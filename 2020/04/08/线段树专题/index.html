

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="琉璃糖">
  <meta name="keywords" content="">
  
    <meta name="description" content="浅析：线段树（Segment Tree）">
<meta property="og:type" content="article">
<meta property="og:title" content="线段树专题">
<meta property="og:url" content="http://example.com/2020/04/08/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%93%E9%A2%98/index.html">
<meta property="og:site_name" content="BlablaWu&#39;s Blog">
<meta property="og:description" content="浅析：线段树（Segment Tree）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/04/11/FxuW6sfL45dbBkz.png">
<meta property="og:image" content="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/20190511125552180.png">
<meta property="og:image" content="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/20190511130727560.png">
<meta property="article:published_time" content="2020-04-08T14:44:43.000Z">
<meta property="article:modified_time" content="2022-10-03T15:40:13.795Z">
<meta property="article:author" content="琉璃糖">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="分块">
<meta property="article:tag" content="线段树">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://i.loli.net/2020/04/11/FxuW6sfL45dbBkz.png">
  
  
  <title>线段树专题 - BlablaWu&#39;s Blog</title>

  <link  rel="stylesheet" href="https://fastly.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://fastly.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://fastly.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://fastly.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":50,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>BlablaWu の Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/index_bg.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="线段树专题">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-04-08 22:44" pubdate>
        2020年4月8日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      29k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      245 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">线段树专题</h1>
            
            <div class="markdown-body">
              <h2 id="浅析：线段树（Segment-Tree）"><a href="#浅析：线段树（Segment-Tree）" class="headerlink" title="浅析：线段树（Segment Tree）"></a><center>浅析：线段树（Segment Tree）</center></h2><span id="more"></span>
<ul>
<li>可能我终于算是算法入门了，终于学到了线段树了，加油加油</li>
</ul>
<h2 id="线段树简介"><a href="#线段树简介" class="headerlink" title="线段树简介"></a>线段树简介</h2><p>说到线段树嘛，他就是形如下面这样的一颗<strong>二叉树</strong>，它一般用来<strong>维护对于一个序列的各种操作（比如让区间每个数加上一个数 等等）</strong>其中每个节点可以维护一段区间的某些值（比如最值、区间和、区间乘积、异或和 等等<strong>满足结合律的操作</strong>。。。），而<strong>每个叶子节点都是一个长度为1的区间</strong>，也就代表了序列本身对应下标的值</p>
<p><img src="https://i.loli.net/2020/04/11/FxuW6sfL45dbBkz.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>线段树操作的复杂度：</p>
<p>建树：$O(nlogn)$</p>
<p>一次区间操作：通常为$O(logn)$</p>
<h2 id="常规线段树"><a href="#常规线段树" class="headerlink" title="常规线段树"></a>常规线段树</h2><p>参考blog：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jason2003/p/9676729.html">线段树从入门到进阶</a></li>
</ul>
<h3 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h3><p>对于一般的线段树，我通常会开一个<strong>结构体</strong>来存储树的各种信息</p>
<p>注意事项：</p>
<ul>
<li><p><code>i&lt;&lt;1和1&lt;&lt;1|1</code>分别表示<strong>左儿子和右儿子</strong>，位运算能够加快速度，真香</p>
</li>
<li><p>对于区间加减之类的操作（其实乘除、开根号也要），我们都需要一个<strong>懒惰标记</strong>（lazy tag），这个稍后解释</p>
</li>
<li>需要开<strong>4倍空间</strong>，因为线段树不是一个满二叉树，但我们需要把它开满，防止溢出</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Stree</span>&#123;<br>    <span class="hljs-type">int</span> l,r,sum,lz;<span class="hljs-comment">//lz为懒惰标记</span><br>&#125;tr[N&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-comment">//</span><br></code></pre></div></td></tr></table></figure>
<p>那么开始建树</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    tr[i].l=l,tr[i].r=r,tr[i].lz=<span class="hljs-number">0</span>;<span class="hljs-comment">//加法的懒惰标记初始化为0</span><br>    <span class="hljs-keyword">if</span>(l==r)&#123;<span class="hljs-comment">//如果递归到了叶子节点</span><br>        tr[i].sum=a[l];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(i&lt;&lt;<span class="hljs-number">1</span>,l,mid);<span class="hljs-comment">//递归建左子树</span><br>    <span class="hljs-built_in">build</span>(i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-comment">//递归建右子树</span><br>    tr[i].sum=tr[i&lt;&lt;<span class="hljs-number">1</span>].sum+tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum;<span class="hljs-comment">//从叶子往根部更新区间和</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h3><p><del>是树状数组不香了吗？</del></p>
<p>这个就很简单了，直接像二分一样去找到这个下标所在的节点就好啦！</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">//下标位k的数+x</span><br>    <span class="hljs-keyword">if</span>(tr[i].l==tr[i].r)&#123;<br>        tr[i].sum+=x;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(tr[i&lt;&lt;<span class="hljs-number">1</span>].r&gt;=k) <span class="hljs-built_in">modify</span>(i&lt;&lt;<span class="hljs-number">1</span>,k,x);<span class="hljs-comment">//往哪跑？</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,k,x);<br>    tr[i].sum=tr[i&lt;&lt;<span class="hljs-number">1</span>].sum+tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum;<span class="hljs-comment">//记得改完了要更新</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="区间加法（减法）"><a href="#区间加法（减法）" class="headerlink" title="区间加法（减法）"></a>区间加法（减法）</h3><p>对于一个序列，我们需要让<code>[l,r]</code>区间内所有数+k，那么怎么操作呢？</p>
<p>显然如果我们执行（r-l+1）次单点修改的话，时间绝对会炸，因此我们需要更聪明的办法，这个办法就是之前提到的<strong>懒惰标记</strong></p>
<p>当我们需要给一个区间的数都加上k时，如果线段树的当前节点包含在这个区间里面，那么我们肯定是要先把这个节点维护的区间和加上<code>（区间长度）*k</code>的值，这是毫无疑问的，但他的儿子区间都要改啊，这太麻烦了，反正现在也不用求答案，倒不如先不对这个区间的儿子进行操作了，先给它打上一个“+k”的标记，我们之后要是要求求和再把这个标记<strong>下放</strong>到儿子们的区间，那时候再操作也不迟~</p>
<p>这个方法好聪明啊！因此我们在区间修改和查询的时候都需要<strong>把懒惰标记下放</strong>，同时要让父亲的懒惰标记清零</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[i].l&gt;=l&amp;&amp;tr[i].r&lt;=r)&#123;<br>        tr[i].sum+=(tr[i].r-tr[i].l+<span class="hljs-number">1</span>)*k;<span class="hljs-comment">//区间和需要对应加上k*(区间长度)</span><br>        tr[i].lz+=k;<span class="hljs-comment">//懒惰标记也要加k</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">push_down</span>(i); <span class="hljs-comment">//核心：下放操作</span><br>    <span class="hljs-keyword">if</span>(tr[i&lt;&lt;<span class="hljs-number">1</span>].r&gt;=l) <span class="hljs-built_in">add</span>(i&lt;&lt;<span class="hljs-number">1</span>,l,r,k);<br>    <span class="hljs-keyword">if</span>(tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].l&lt;=r) <span class="hljs-built_in">add</span>(i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r,k);<br>    tr[i].sum=tr[i&lt;&lt;<span class="hljs-number">1</span>].sum+tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum;<span class="hljs-comment">//维护区间和</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>那么这个<strong>下放操作</strong>怎么写呢？</p>
<p>对于最简单的<strong>区间加法</strong>，下放操作就是把加法标记下放给他儿子，同时更新它儿子所维护的区间和就行了</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[i].lz==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    tr[i&lt;&lt;<span class="hljs-number">1</span>].lz+=tr[i].lz;<br>    tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].lz+=tr[i].lz;<br>    tr[i&lt;&lt;<span class="hljs-number">1</span>].sum+=(tr[i&lt;&lt;<span class="hljs-number">1</span>].r-tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].l+<span class="hljs-number">1</span>)*tr[i].lz;<br>    tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum+=(tr[i&lt;&lt;<span class="hljs-number">1</span>].r-tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].l+<span class="hljs-number">1</span>)*tr[i].lz;<br>    tr[i].lz=<span class="hljs-number">0</span>;<span class="hljs-comment">//这一步别忘了，不然会死的很惨</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="询问区间和"><a href="#询问区间和" class="headerlink" title="询问区间和"></a>询问区间和</h3><p>对于询问区间和操作，其实就很简单了，如果线段树当前节点对应区间被包含在了询问的区间里，那么直接返回该节点对应的sum即可，否则，就递归地去找左子树和右子树，更新答案（对了，别忘记下放标记，因为这个标记很懒，你不手动下放他是不会动的，哈哈哈~）</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[i].l&gt;=l&amp;&amp;tr[i].r&lt;=r) <span class="hljs-keyword">return</span> tr[i].sum;<br>    <span class="hljs-built_in">push_down</span>(i);<span class="hljs-comment">//切记！！！</span><br>    ll res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(tr[i&lt;&lt;<span class="hljs-number">1</span>].r&gt;=l) res+=<span class="hljs-built_in">getsum</span>(i&lt;&lt;<span class="hljs-number">1</span>,l,r);<br>    <span class="hljs-keyword">if</span>(tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].l&lt;=r) res+=<span class="hljs-built_in">getsum</span>(i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="维护区间最值"><a href="#维护区间最值" class="headerlink" title="维护区间最值"></a>维护区间最值</h3><p>对于这个操作，我们可以像维护区间和一样维护，而修改和下放操作也需要加上对应的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<span class="hljs-comment">//建树时需要维护</span><br>    ...<br>    tr[i].mx=<span class="hljs-built_in">max</span>(tr[i&lt;&lt;<span class="hljs-number">1</span>].mx,tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].mx);<br>    tr[i].mn=<span class="hljs-built_in">min</span>(tr[i&lt;&lt;<span class="hljs-number">1</span>].mn,tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].mn);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//各种修改的时候也需要维护</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<span class="hljs-comment">//下放时需要维护</span><br>    ...<br>    tr[i&lt;&lt;<span class="hljs-number">1</span>].mx+=tr[i].lz;<br>    tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].mx+=tr[i].lz;<br>    tr[i&lt;&lt;<span class="hljs-number">1</span>].mn+=tr[i].lz;<br>    tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].mn+=tr[i].lz;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="区间乘法-加法（减法）"><a href="#区间乘法-加法（减法）" class="headerlink" title="区间乘法+加法（减法）"></a>区间乘法+加法（减法）</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3373">模板题 线段树2</a></p>
<p>单独一个区间乘法就很简单了，只需要把上面的懒惰标记改成乘，加号都改为乘号就行了，十分简单，但是如果是<strong>乘法和加法</strong>同时出现的话，就没这么简单了</p>
<p>因为，我们需要考虑到，对于懒惰标记的操作，到底是<strong>先乘再加 还是 先加再乘？</strong></p>
<p>事实表明，<strong>先乘再加</strong>是最好的解法，我们需要维护两个标记（加法标记and乘法标记），在下放标记的时候，只需要将乘法标记直接下放，而加法标记需要<strong>先乘以乘法标记再加上下放的加法标记</strong>，然后更新一下儿子们维护的区间和（同上）就行了</p>
<p>下放操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<span class="hljs-comment">//区间加乘的下放操作</span><br>    <span class="hljs-type">int</span> k1=tr[i].plz,k2=tr[i].mlz;<span class="hljs-comment">//plz:加法标记，mlz:乘法标记</span><br>    tr[i&lt;&lt;<span class="hljs-number">1</span>].sum=(tr[i&lt;&lt;<span class="hljs-number">1</span>].sum*k2+k1*(tr[i&lt;&lt;<span class="hljs-number">1</span>].r-tr[i&lt;&lt;<span class="hljs-number">1</span>].l+<span class="hljs-number">1</span>))%p;<br>    tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum=(tr[i&lt;&lt;<span class="hljs-number">1</span>].sum*k2+k1*(tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].r-tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].l+<span class="hljs-number">1</span>))%p;<span class="hljs-comment">//先乘再加</span><br>    tr[i&lt;&lt;<span class="hljs-number">1</span>].plz=(tr[i&lt;&lt;<span class="hljs-number">1</span>].plz*k2+k1)%p;<br>    tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].plz=(tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].plz*k2+k1)%p;<br>    tr[i&lt;&lt;<span class="hljs-number">1</span>].mlz=(tr[i&lt;&lt;<span class="hljs-number">1</span>].mlz*k2)%p;<br>    tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].mlz=(tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].mlz*k2)%p;<br>    tr[i].mlz=<span class="hljs-number">1</span>;<span class="hljs-comment">//乘法标记初始化一定是1</span><br>    tr[i].plz=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>对于区间修改操作，区间加法我们可以无脑直接加，而区间乘法则需要<strong>同时把加法标记乘以这个数k</strong></p>
<p>修改操作：（<code>[l,r]</code>内每个数加上、乘以k）</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<span class="hljs-comment">//区间加法</span><br>    <span class="hljs-keyword">if</span>(tr[i].l&gt;=l&amp;&amp;tr[i].r&lt;=r)&#123;<br>        tr[i].sum=(tr[i].sum+k*(tr[i].r-tr[i].l+<span class="hljs-number">1</span>))%p;<br>        tr[i].plz=(tr[i].plz+k)%p;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    ...<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<span class="hljs-comment">//区间乘法</span><br>    <span class="hljs-keyword">if</span>(tr[i].l&gt;=l&amp;&amp;tr[i].r&lt;=r)&#123;<br>        tr[i].sum=(tr[i].sum*k)%p;<br>        tr[i].plz=(tr[i].plz*k)%p;<span class="hljs-comment">//加法标记一定要要对应*k</span><br>        tr[i].mlz=(tr[i].mlz*k)%p;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="区间除法-amp-区间开根号"><a href="#区间除法-amp-区间开根号" class="headerlink" title="区间除法&amp;区间开根号"></a>区间除法&amp;区间开根号</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4145">区间开根号模板题：花神游历各国</a></p>
<p>对于这两种操作，显然他们<strong>不满足结合律</strong>，但是，这样我们就不能线段树了吗？</p>
<p>大错特错！我们来考虑除法与开根号这些运算的特性：他们都会使得一堆元素（整数）不断地减小，并且趋于一个值（除法趋于0，开根号趋于1）</p>
<p>针对除法来说：对于一个区间的所有元素而言，如果这个<strong>区间内元素最大值与他除以除数所得商的差值 等于 最小值与他除以除数所得商的差值</strong>，那么这个区间内的所有元素除以除数都会减去同一个数，于是就可以给这个区间的<strong>加法标记</strong>做一点操作，就可以把区间除法转换成区间减法啦！</p>
<p>同理，如果这个区间的<strong>最大值与它开根号的差值</strong> 等于 <strong>最小值与它开根号的差值</strong>，那么这个区间内的所有元素开根号都会减去同一个数，我们就能把开根号转换为减法啦！</p>
<p>所以说，对于区间除法和区间开根号操作，他们都可以<strong>转化为区间减法</strong>操作来优化复杂度（这十分重要，否则就是一个单纯的暴力了呀~）</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Sqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<span class="hljs-comment">//区间开根号</span><br>    <span class="hljs-keyword">if</span>(tr[i].l&gt;=l&amp;&amp;tr[i].r&lt;=r)&#123;<br>        <span class="hljs-type">int</span> k1=tr[i].mx-<span class="hljs-built_in">floor</span>(<span class="hljs-built_in">sqrt</span>(tr[i].mx));<span class="hljs-comment">//核心，转换为减法</span><br>        <span class="hljs-type">int</span> k2=tr[i].mn-<span class="hljs-built_in">floor</span>(<span class="hljs-built_in">sqrt</span>(tr[i].mn));<br>        <span class="hljs-keyword">if</span>(k1==k2)&#123;<span class="hljs-comment">//判断是否可以对整个区间操作</span><br>            tr[i].lz-=k1;<br>            tr[i].sum-=k1*(tr[i].r-tr[i].l+<span class="hljs-number">1</span>);<br>            tr[i].mx-=k1;<br>            tr[i].mn-=k1;<br>            <span class="hljs-keyword">return</span>;<span class="hljs-comment">//这个return要写在里面</span><br>        &#125;<br>    &#125;<br>	...<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<span class="hljs-comment">//区间除法</span><br>    ...<br>    <span class="hljs-keyword">if</span>(tr[i].l&gt;=l&amp;&amp;tr[i].r&lt;=r)&#123;<br>        <span class="hljs-type">int</span> k1=tr[i].mx-tr[i].mx/k;<span class="hljs-comment">//核心</span><br>        <span class="hljs-type">int</span> k2=tr[i].mn-tr[i].mn/k;<br>        <span class="hljs-keyword">if</span>(k1==k2)&#123;<br>            tr[i].sum-=k1*(tr[i].r-tr[i].l+<span class="hljs-number">1</span>);<br>            tr[i].lz-=k1;<br>            tr[i].mx-=k1;<br>            tr[i].mn-=k1;<br>        &#125;<br>    &#125;<br>    ...<span class="hljs-comment">//其他都一样</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>然而，对于区间开根号操作，还有更好的办法：对于一个很大的数，我们只要不断对其开根号，用不了几次它就会变成1，那么我们可以通过<strong>维护区间最大值是否小于等于1来判断这个区间是否有必要操作</strong>，这样就可以大大优化时间复杂度</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Sqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[i].l==tr[i].r)&#123;<br>        tr[i].sum=tr[i].mx=<span class="hljs-built_in">sqrt</span>(tr[i].sum);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">push_down</span>(i);<br>    <span class="hljs-comment">//判断是否有必要对这个区间开根号</span><br>    <span class="hljs-keyword">if</span>(tr[i&lt;&lt;<span class="hljs-number">1</span>].r&gt;=l&amp;&amp;tr[i&lt;&lt;<span class="hljs-number">1</span>].mx&gt;<span class="hljs-number">1</span>) <span class="hljs-built_in">Sqrt</span>(i&lt;&lt;<span class="hljs-number">1</span>,l,r);<br>    <span class="hljs-keyword">if</span>(tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].l&lt;=r&amp;&amp;tr[i&lt;&lt;<span class="hljs-number">1</span>|].mx&gt;<span class="hljs-number">1</span>) <span class="hljs-built_in">Sqrt</span>(i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r);<br>    tr[i].sum=tr[i&lt;&lt;<span class="hljs-number">1</span>].sum+tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum;<br>    tr[i].mx=<span class="hljs-built_in">max</span>(tr[i&lt;&lt;<span class="hljs-number">1</span>].mx,tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].mx);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>UPD 2020.6.8</p>
<p>这几天学校训练做了一道类似的题<a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/6015/C">USST训练赛9 时间管理</a>，题意大概是<strong>区间gcd修改+区间求和</strong>，对于区间gcd，可以同样用线段数（或分块）维护区间的值是否相同，若相同，直接$O(1)$修改该区间和即可，因为gcd操作和开根号操作一样，总是让一段区间趋于1的</p>
<details>
<summary>线段树</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">ll a[maxn],n,m;<br><span class="hljs-comment">/* Normal Segment Tree */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegmentTree</span><br>&#123;	<br>	<span class="hljs-meta">#<span class="hljs-keyword">define</span> ls i&lt;&lt;1</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">define</span> rs i&lt;&lt;1|1</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tree</span>&#123;<br>		<span class="hljs-type">int</span> l,r;<br>		ll sum,ptg,minh,maxh;<br>	&#125;tr[maxn&lt;&lt;<span class="hljs-number">2</span>];<br><br>	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>		tr[i].sum=tr[ls].sum+tr[rs].sum;<br>		tr[i].minh=<span class="hljs-built_in">min</span>(tr[ls].minh,tr[rs].minh);<br>		tr[i].maxh=<span class="hljs-built_in">max</span>(tr[ls].maxh,tr[rs].maxh);<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>		<span class="hljs-keyword">if</span>(tr[i].ptg==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>		ll k=tr[i].ptg;<br>		tr[ls].sum+=k*(tr[ls].r-tr[ls].l+<span class="hljs-number">1</span>);<br>		tr[rs].sum+=k*(tr[rs].r-tr[rs].l+<span class="hljs-number">1</span>);<br>		tr[ls].minh+=k;<br>		tr[ls].maxh+=k;<br>		tr[rs].minh+=k;<br>		tr[rs].maxh+=k;<br>		tr[ls].ptg+=k;<br>		tr[rs].ptg+=k;<br>		tr[i].ptg=<span class="hljs-number">0</span>;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>		tr[i].l=l,tr[i].r=r;<br>		tr[i].ptg=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">if</span>(tr[i].l==tr[i].r)&#123;<br>			tr[i].sum=a[l];<br>			tr[i].minh=a[l];<br>			tr[i].maxh=a[l];<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>		<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>		<span class="hljs-built_in">build</span>(ls,l,mid);<br>		<span class="hljs-built_in">build</span>(rs,mid+<span class="hljs-number">1</span>,r);<br>		<span class="hljs-built_in">push_up</span>(i);<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,ll k)</span></span>&#123;<br>		<span class="hljs-keyword">if</span>(tr[i].l&gt;=l&amp;&amp;tr[i].r&lt;=r)&#123;<br>			<span class="hljs-keyword">if</span>(tr[i].minh==tr[i].maxh)&#123;<br>				ll tp=<span class="hljs-built_in">gcd</span>(tr[i].minh,k)-tr[i].minh;<br>				tr[i].sum+=tp*(tr[i].r-tr[i].l+<span class="hljs-number">1</span>);<br>				tr[i].ptg+=tp;<br>				tr[i].minh+=tp;<br>				tr[i].maxh+=tp;<br>				<span class="hljs-keyword">return</span>;<br>			&#125;<br>		&#125;<br>		<span class="hljs-built_in">push_down</span>(i);<br>		<span class="hljs-keyword">if</span>(tr[ls].r&gt;=l) <span class="hljs-built_in">change</span>(ls,l,r,k);<br>		<span class="hljs-keyword">if</span>(tr[rs].l&lt;=r) <span class="hljs-built_in">change</span>(rs,l,r,k);<br>		<span class="hljs-built_in">push_up</span>(i);<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>		<span class="hljs-keyword">if</span>(tr[i].l&gt;=l&amp;&amp;tr[i].r&lt;=r)<br>			<span class="hljs-keyword">return</span> tr[i].sum;<br>		<span class="hljs-built_in">push_down</span>(i);<br>		ll res=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">if</span>(tr[ls].r&gt;=l) res+=<span class="hljs-built_in">getsum</span>(ls,l,r);<br>		<span class="hljs-keyword">if</span>(tr[rs].l&lt;=r) res+=<span class="hljs-built_in">getsum</span>(rs,l,r);<br>		<span class="hljs-keyword">return</span> res;<br>	&#125;<br>&#125;T;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">read</span>(n),<span class="hljs-built_in">read</span>(m);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">read</span>(a[i]);<br>	T.<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br>	<span class="hljs-type">int</span> op,l,r,x;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m)&#123;<br>		<span class="hljs-built_in">read</span>(op),<span class="hljs-built_in">read</span>(l),<span class="hljs-built_in">read</span>(r);<br>		<span class="hljs-keyword">if</span>(op&amp;<span class="hljs-number">1</span>)&#123;<br>			<span class="hljs-built_in">read</span>(x);<br>			T.<span class="hljs-built_in">change</span>(<span class="hljs-number">1</span>,l,r,x);<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,T.<span class="hljs-built_in">getsum</span>(<span class="hljs-number">1</span>,l,r));<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<details>
    <summary>分块</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><br>ll a[maxn],n,m,blk,bel[maxn],sz[maxn],st[maxn],en[maxn],tg[maxn];<br>ll minh[maxn],maxh[maxn];<br>ll sum[maxn];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init_blk</span><span class="hljs-params">()</span></span>&#123;<br>	blk=<span class="hljs-built_in">sqrt</span>(n);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,blk)&#123;<br>		st[i]=n/blk*(i<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>;<br>		en[i]=n/blk*i;<br>		minh[i]=inf;<br>		maxh[i]=-inf;<br>	&#125;<br>	en[blk]=n;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,blk)&#123;<br>		sz[i]=en[i]-st[i]+<span class="hljs-number">1</span>;<br>		<span class="hljs-built_in">rep</span>(j,st[i],en[i])&#123;<br>			bel[j]=i;<br>			minh[i]=<span class="hljs-built_in">min</span>(minh[i],a[j]);<br>			maxh[i]=<span class="hljs-built_in">max</span>(maxh[i],a[j]);<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(ll l,ll r,ll x)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(bel[l]==bel[r])&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r;i++)&#123;<br>			a[i]=<span class="hljs-built_in">gcd</span>(a[i]+tg[bel[l]],x);<br>		&#125;<br>		minh[bel[l]]=inf,maxh[bel[l]]=-inf;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=st[bel[l]];i&lt;=en[bel[l]];i++)&#123;<br>			<span class="hljs-keyword">if</span>(i&lt;l||i&gt;r) a[i]+=tg[bel[l]];<br>			minh[bel[l]]=<span class="hljs-built_in">min</span>(minh[bel[l]],a[i]),<br>			maxh[bel[l]]=<span class="hljs-built_in">max</span>(maxh[bel[l]],a[i]);<br>		&#125;<br>		tg[bel[l]]=<span class="hljs-number">0</span>;<br>	&#125;<span class="hljs-keyword">else</span>&#123;<br>		<span class="hljs-comment">// left blk</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=en[bel[l]];i++)&#123;<br>			a[i]=<span class="hljs-built_in">gcd</span>(a[i]+tg[bel[l]],x);<br>		&#125;<br>		minh[bel[l]]=inf,maxh[bel[l]]=-inf;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=st[bel[l]];i&lt;=en[bel[l]];i++)&#123;<br>			<span class="hljs-keyword">if</span>(i&lt;l) a[i]+=tg[bel[l]];<br>			minh[bel[l]]=<span class="hljs-built_in">min</span>(minh[bel[l]],a[i]),<br>			maxh[bel[l]]=<span class="hljs-built_in">max</span>(maxh[bel[l]],a[i]);<br>		&#125;<br>		tg[bel[l]]=<span class="hljs-number">0</span>;<br>		<span class="hljs-comment">// right blk</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=st[bel[r]];i&lt;=r;i++)&#123;<br>			a[i]=<span class="hljs-built_in">gcd</span>(a[i]+tg[bel[r]],x);<br>		&#125;<br>		minh[bel[r]]=inf,maxh[bel[r]]=-inf;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=st[bel[r]];i&lt;=en[bel[r]];i++)&#123;<br>			<span class="hljs-keyword">if</span>(i&gt;r) a[i]+=tg[bel[r]];<br>			minh[bel[r]]=<span class="hljs-built_in">min</span>(minh[bel[r]],a[i]),<br>			maxh[bel[r]]=<span class="hljs-built_in">max</span>(maxh[bel[r]],a[i]);<br>		&#125;<br>		tg[bel[r]]=<span class="hljs-number">0</span>;<br>		<span class="hljs-comment">// middle whole blk</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=bel[l]+<span class="hljs-number">1</span>;i&lt;=bel[r]<span class="hljs-number">-1</span>;i++)&#123;<br>			<span class="hljs-keyword">if</span>(minh[i]==maxh[i])&#123;<br>				<span class="hljs-type">int</span> tp=<span class="hljs-built_in">gcd</span>(minh[i],x);<br>				tg[i]+=tp-minh[i];<br>				minh[i]=maxh[i]=tp;<br>			&#125;<span class="hljs-keyword">else</span>&#123;<br>				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=st[i];j&lt;=en[i];j++)&#123;<br>					a[j]=<span class="hljs-built_in">gcd</span>(a[j]+tg[i],x);<br>				&#125;<br>				minh[i]=inf,maxh[i]=-inf;<br>				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=st[i];j&lt;=en[i];j++)&#123;<br>					minh[i]=<span class="hljs-built_in">min</span>(minh[i],a[j]),<br>					maxh[i]=<span class="hljs-built_in">max</span>(maxh[i],a[j]);<br>				&#125;<br>				tg[i]=<span class="hljs-number">0</span>;<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">getsum</span><span class="hljs-params">(ll l,ll r)</span></span>&#123;<br>	ll res=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">if</span>(bel[l]==bel[r])&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r;i++)&#123;<br>			res+=(a[i]+tg[bel[l]]);<br>		&#125;<br>	&#125;<span class="hljs-keyword">else</span>&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=en[bel[l]];i++)&#123;<br>			res+=(a[i]+tg[bel[l]]);<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=st[bel[r]];i&lt;=r;i++)&#123;<br>			res+=(a[i]+tg[bel[r]]);<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=bel[l]+<span class="hljs-number">1</span>;i&lt;=bel[r]<span class="hljs-number">-1</span>;i++)&#123;<br>			<span class="hljs-keyword">if</span>(minh[i]==maxh[i])&#123;<br>				res+=(sz[i]*minh[i]);<br>			&#125;<span class="hljs-keyword">else</span>&#123;<br>				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=st[i];j&lt;=en[i];j++)&#123;<br>					res+=(a[j]+tg[i]);<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">read</span>(n),<span class="hljs-built_in">read</span>(m);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">read</span>(a[i]);<br>	<span class="hljs-built_in">init_blk</span>();<br>	<span class="hljs-type">int</span> op,l,r,x;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m)&#123;<br>		<span class="hljs-built_in">read</span>(op),<span class="hljs-built_in">read</span>(l),<span class="hljs-built_in">read</span>(r);<br>		<span class="hljs-keyword">if</span>(op&amp;<span class="hljs-number">1</span>)&#123;<br>			<span class="hljs-built_in">read</span>(x);<br>			<span class="hljs-built_in">change</span>(l,r,x);<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">getsum</span>(l,r));<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="Lazy-Tag的用途"><a href="#Lazy-Tag的用途" class="headerlink" title="Lazy Tag的用途"></a>Lazy Tag的用途</h3><p>来源于这道典型例题：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/UVA10587">Mayor’s posters</a>（线段树+离散化）</p>
<p>就像铺地毯一样，我们不停地在某些区间上铺一些地毯，最后问能在整个区间看到多少种颜色的地毯？</p>
<p>这题我们离线做<del>（动态开点目前没学orz）</del>，首先离散化三部曲（排序 去重 二分插入，否则你会MLE）我就不多说了，那么这个题怎么用Lzay Tag来维护呢，我们很容易想到整个区间的种类数比较好求，只要开一个vis数组记录就行了，而这个离线的区间更新怎么做呢？我们思考区间求和的懒惰标记是维护的求和的加数，但是我们这是维护一个颜色（即种类），如果一个区间的子区间的颜色在后来被修改了，那么我们就需要把这个区间的lazytag下放，直到给到那个被修改的子区间，然后把那个修改的子区间的颜色改成要修改成的颜色，这样一来，维护了这个区间其他子区间颜色没变，而只改变了这一个区间的颜色，非常巧妙</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br>ll t,n,tot,l,r,vis[N],b[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>	ll l,r;<br>&#125;a[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Stree</span>&#123;<br>	ll l,r,col;<br>&#125;tree[N&lt;&lt;<span class="hljs-number">2</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">memset</span>(b,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(b));<br>	<span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<br>	ll temp=<span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;n);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;a[i].l,&amp;a[i].r);<br>		b[++temp]=a[i].l,b[++temp]=a[i].r;<br>	&#125;<br>	<span class="hljs-built_in">sort</span>(b+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>+temp);<br>	tot=<span class="hljs-built_in">unique</span>(b+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>+temp)-b<span class="hljs-number">-1</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		a[i].l=<span class="hljs-built_in">lower_bound</span>(b+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>+tot,a[i].l)-b;<br>		a[i].r=<span class="hljs-built_in">lower_bound</span>(b+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>+tot,a[i].r)-b;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(ll i,ll l,ll r)</span></span>&#123;<br>	tree[i].l=l,tree[i].r=r,tree[i].col=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">if</span>(l==r)&#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	ll mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>	<span class="hljs-built_in">build</span>(i&lt;&lt;<span class="hljs-number">1</span>,l,mid);<br>	<span class="hljs-built_in">build</span>(i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br>	<span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(ll i)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(tree[i].col==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>	tree[i&lt;&lt;<span class="hljs-number">1</span>].col=tree[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].col=tree[i].col;<br>	tree[i].col=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(ll i,ll l,ll r,ll col)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(tree[i].l&gt;=l&amp;&amp;tree[i].r&lt;=r)&#123;<br>		tree[i].col=col;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-built_in">push_down</span>(i);<br>	<span class="hljs-keyword">if</span>(tree[i&lt;&lt;<span class="hljs-number">1</span>].r&gt;=l) <span class="hljs-built_in">update</span>(i&lt;&lt;<span class="hljs-number">1</span>,l,r,col);<br>	<span class="hljs-keyword">if</span>(tree[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].l&lt;=r) <span class="hljs-built_in">update</span>(i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r,col);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">search</span><span class="hljs-params">(ll i,ll l,ll r,ll &amp;ans)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(tree[i].col)&#123;<br>		<span class="hljs-keyword">if</span>(!vis[tree[i].col])&#123;<br>			vis[tree[i].col]=<span class="hljs-number">1</span>;<br>			ans++;<br>		&#125;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-built_in">search</span>(i&lt;&lt;<span class="hljs-number">1</span>,l,r,ans);<br>	<span class="hljs-built_in">search</span>(i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r,ans);<br>	<span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">ask</span><span class="hljs-params">(ll l,ll r)</span></span>&#123;<br>	ll ans=<span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">search</span>(<span class="hljs-number">1</span>,l,r,ans);<br>	<span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;t);<br>    <span class="hljs-keyword">while</span>(t--)&#123;<br>    	<span class="hljs-built_in">init</span>();<br>	    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,tot);<br>	    ll col=<span class="hljs-number">0</span>;<br>	    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>	    	<span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>,a[i].l,a[i].r,++col);<br>		&#125;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">ask</span>(<span class="hljs-number">1</span>,tot));<br>	&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h2 id="权值线段树"><a href="#权值线段树" class="headerlink" title="权值线段树"></a>权值线段树</h2><p>例题：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1801">洛谷 P1801 黑匣子</a>（离散化+权值线段树）</p>
<p>与一般的线段树有一点区别：权值线段树的每个叶子节点就<strong>代表了数列中一个具体的值</strong>（我们称之为<strong>权值</strong>），而每个叶子节点<strong>维护的是这个具体的值在整个数列中出现的次数</strong>，每一个父亲节点<strong>维护了一段区间的值出现的总次数</strong>，这样一来，权值线段树的意义就很明朗了</p>
<p>权值线段树的一个重要应用：<strong>求整个数列中第k大（第k小）的数</strong>（注意是整个数列）</p>
<p>算法：权值线段树的基本操作和普通线段树几乎相同，需要注意的是以下几点：</p>
<ul>
<li><p>每个节点维护的不再是权值or区间和，而是<strong>该节点代表数字出现的次数</strong></p>
<p>比如我们可以开一个结构体存储</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Stree</span>&#123;<br>    <span class="hljs-type">int</span> l,r;<span class="hljs-comment">//维护该子树对应的左右区间端点</span><br>    <span class="hljs-type">int</span> v;<span class="hljs-comment">//维护数的出现次数</span><br>&#125;tr[N&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-comment">//照样开4倍大</span><br></code></pre></div></td></tr></table></figure>
</li>
<li><p>更新操作（比如插入了一个数），就是递归找到该数对应的叶子节点，给节点维护的次数+1</p>
</li>
<li><p>询问操作（以询问第k小为例），递归地找，如果左子树内有大于等于k个数字，那么就递归进入左子树找第k小，否则就递归进入右子树找第<code>k-tr[rs].v</code>小</p>
</li>
</ul>
<p>例题代码：</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ls (i&lt;&lt;1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs (i&lt;&lt;1|1)</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n,m,b[N],c[N],cnt=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>	<span class="hljs-type">int</span> val,id;<br>&#125;a[N];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node x1,node x2)</span></span>&#123;<br>	<span class="hljs-keyword">return</span> x1.val&lt;x2.val;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Stree</span>&#123;<br>	<span class="hljs-type">int</span> l,r,v;<br>&#125;tr[N&lt;&lt;<span class="hljs-number">2</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<span class="hljs-comment">//建树</span><br>	tr[i].l=l,tr[i].r=r;<br>	<span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span>;<br>	<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>	<span class="hljs-built_in">build</span>(ls,l,mid);<br>	<span class="hljs-built_in">build</span>(rs,mid+<span class="hljs-number">1</span>,r);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">//插入并更新</span><br>	<span class="hljs-keyword">if</span>(tr[i].l==tr[i].r)&#123;<br>		tr[i].v++;<span class="hljs-comment">//次数+1</span><br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-keyword">if</span>(tr[ls].r&gt;=x) <span class="hljs-built_in">update</span>(ls,x);<span class="hljs-comment">//找到位置</span><br>	<span class="hljs-keyword">else</span> <span class="hljs-built_in">update</span>(rs,x);<br>	tr[i].v=tr[ls].v+tr[rs].v;<span class="hljs-comment">//push_up</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getval</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> k)</span></span>&#123;<span class="hljs-comment">//获得对应权值</span><br>	<span class="hljs-keyword">if</span>(tr[i].l==tr[i].r)&#123;<br>		<span class="hljs-keyword">return</span> tr[i].l;<br>	&#125;<br>	<span class="hljs-keyword">if</span>(tr[ls].v&gt;=k) <span class="hljs-keyword">return</span> <span class="hljs-built_in">getval</span>(ls,k);<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">getval</span>(rs,k-tr[ls].v);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i].val),a[i].id=i;<br>    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">1</span>+n,cmp);<span class="hljs-comment">//离散化排序</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) c[a[i].id]=i;<span class="hljs-comment">//找出每个点的相对大小位置</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;b[i]);<br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    	<span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>,c[i]);<span class="hljs-comment">//插入操作</span><br>    	<span class="hljs-keyword">while</span>(b[cnt]==i)&#123;<br>    		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,a[<span class="hljs-built_in">getval</span>(<span class="hljs-number">1</span>,cnt)].val); <br>    		cnt++;<br>		&#125;<br>	&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h2 id="动态开点线段树"><a href="#动态开点线段树" class="headerlink" title="动态开点线段树"></a>动态开点线段树</h2><p>参考blog：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/light-house/p/11756048.html">[线段树系列]动态开点线段树</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://doc.okbase.net/GuZhenYin/archive/259026.html">动态开点线段树</a></p>
</li>
</ul>
<p>这东西就比较神了，它是线段树的<del>（阉割）</del>简化版，原理就是：我们不会在询问出现之前就利用build函数建立一颗完整的<strong>满二叉树</strong>结构的线段树（因为这样可能会有很多节点的空间没有用上，浪费了空间），而是采用<strong>边询问边建树</strong>的方式<strong>动态开点</strong>，这样以来，不用的节点我们不开，用的节点我们用的时候再开，可以很高效地处理<strong>值域较大（1e9），但是操作次数较少（1e5）</strong>的操作，或是需要<strong>建立多棵独立的线段树</strong>的时候</p>
<p>通常情况下，我们为动态开点线段树开<strong>（修改次数*40）</strong>的空间（类似主席树），然后根据RE和MLE来修改空间，其余特征和普通线段树无差异（pushdown下放，pushup更新）</p>
<p>注意事项：</p>
<ul>
<li>我们不再开结构体（可以但没必要）存树，因为它不再满足儿子节点为根节点编号的两倍和两倍加一原则（不是满二叉树），而是利用一个<strong>时间戳编号</strong>来存储节点编号</li>
<li>也不需要存储每个节点所对应的区间左右端点值（其实普通线段树也没必要存）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> ls[N*<span class="hljs-number">40</span>],rs[N*<span class="hljs-number">40</span>],tg[N*<span class="hljs-number">40</span>],rt,ncnt;<br>ll sum[N*<span class="hljs-number">40</span>];<br><span class="hljs-comment">//rt为根节点编号，ncnt为节点数（时间戳），动态开点时用到</span><br></code></pre></div></td></tr></table></figure>
<p>下面放<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3372">线段树1</a>的动态开点形式：</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n,m,op,x,y,k,ls[N*<span class="hljs-number">40</span>],rs[N*<span class="hljs-number">40</span>],tg[N*<span class="hljs-number">40</span>],rt,ncnt;<br>ll sum[N*<span class="hljs-number">40</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> o)</span></span>&#123;<br>	sum[o]=sum[ls[o]]+sum[rs[o]];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;o,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> k)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(!o) o=++ncnt;<br>	<span class="hljs-keyword">if</span>(l==r)&#123;<br>		sum[o]+=<span class="hljs-number">1ll</span>*k;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span>(mid&gt;=x) <span class="hljs-built_in">init</span>(ls[o],l,mid,x,k);<br>	<span class="hljs-keyword">else</span> <span class="hljs-built_in">init</span>(rs[o],mid+<span class="hljs-number">1</span>,r,x,k);<br>	<span class="hljs-built_in">pushup</span>(o);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-type">int</span> o,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(!tg[o]) <span class="hljs-keyword">return</span>;<br>	<span class="hljs-keyword">if</span>(!ls[o]) ls[o]=++ncnt;<br>	<span class="hljs-keyword">if</span>(!rs[o]) rs[o]=++ncnt;<br>	<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>	sum[ls[o]]+=tg[o]*(mid-l+<span class="hljs-number">1</span>);<br>	sum[rs[o]]+=tg[o]*(r-mid);<br>	tg[ls[o]]+=tg[o];<br>	tg[rs[o]]+=tg[o];<br>	tg[o]=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;o,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> k)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(!o) o=++ncnt;<br>	<span class="hljs-keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;<br>		sum[o]+=<span class="hljs-number">1ll</span>*k*(r-l+<span class="hljs-number">1</span>);<br>		tg[o]+=k;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-built_in">push_down</span>(o,l,r);<br>	<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span>(mid&gt;=L) <span class="hljs-built_in">update</span>(ls[o],l,mid,L,R,k);<br>	<span class="hljs-keyword">if</span>(mid+<span class="hljs-number">1</span>&lt;=R) <span class="hljs-built_in">update</span>(rs[o],mid+<span class="hljs-number">1</span>,r,L,R,k);<br>	<span class="hljs-built_in">pushup</span>(o);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;o,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(!o) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R) <span class="hljs-keyword">return</span> sum[o];<br>	<span class="hljs-built_in">push_down</span>(o,l,r);<br>	ll res=<span class="hljs-number">0</span>;<br>	<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span>(mid&gt;=L) res+=<span class="hljs-built_in">getsum</span>(ls[o],l,mid,L,R);<br>	<span class="hljs-keyword">if</span>(mid+<span class="hljs-number">1</span>&lt;=R) res+=<span class="hljs-built_in">getsum</span>(rs[o],mid+<span class="hljs-number">1</span>,r,L,R);<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>    	<span class="hljs-built_in">init</span>(rt,<span class="hljs-number">1</span>,n,i,x);<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;op,&amp;x,&amp;y);<br>		<span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)&#123;<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;k);<br>			<span class="hljs-built_in">update</span>(rt,<span class="hljs-number">1</span>,n,x,y,k);<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">getsum</span>(rt,<span class="hljs-number">1</span>,n,x,y));<br>		&#125;<br>	&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h2 id="可持久化线段树（主席树）"><a href="#可持久化线段树（主席树）" class="headerlink" title="可持久化线段树（主席树）"></a>可持久化线段树（主席树）</h2><p>题目链接：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3834">P3834 【模板】可持久化线段树 1（主席树）</a></p>
<p>参考blog：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ModestCoder_/article/details/90107874">【学习笔记】主席树</a></li>
</ul>
<p>题意：给定$n$个整数构成的序列，将对于指定的闭区间查询其区间内的第$k$小值</p>
<p>经典得不能再经典的区间$Kth$问题，即（强制在线的）询问若干区间内的 $k$大/$k$小 值，对于这类问题，当然可以使用暴力$O(nq)$，但是你会T得很惨，于是便又出现了一种神仙数据结构——<strong>可持久化线段树</strong>（或 主席树，据说是因为发明人的名字缩写叫hjt）</p>
<p>其实<strong>主席树</strong>并不是什么新的数据结构，本质上它其实是<strong>权值线段树+前缀和思想</strong>应用的结合，原理描述起来也十分简单，即：开$n$棵权值线段树，第$i$棵维护序列的前$i$个数的出现次数，对于每一次$[l,r]$的询问，用第$r$棵线段树减去第$l-1$棵线段树，得出的新线段树就是维护了$[l,r]$区间的每个数的出现次数的权值线段树，然后在这棵树上二分求解$Kth$就行了，但是，仅仅这样做会使得空间特别大导致RE，因此需要优化，优化过后的这些树就是主席树啦，那么如何进行空间优化呢？</p>
<p>我们发现，对于每一次插入新的序列中的值时，都构建出一颗完整的权值线段树是不值得的，因为有很多的点早就已经在之前构建的权值线段树中出现过了，且没有发生改变，这些点没必要再重新新建，直接利用之前构建好的点就行了，因此，<strong>单次的更新只需要新建$log(n)$个新节点即可</strong>，空间大大缩减</p>
<p>举个栗子：4 3 2 3 6 1</p>
<p>初始时，只有一棵空的线段树，所有节点对应的出现次数为0，当加入区间$[1,1]$时，即 将4的出现次数+1，此时，只需要将与4节点有关的节点维护的次数值+1即可，剩余的节点不需要改变，直接连回去即可</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/20190511125552180.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>插入$[1,3]$区间后得到的线段树如下图所示：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/20190511130727560.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<ul>
<li><p>时间复杂度：建树$O(nlogn)$，单次询问$O(logn)$</p>
</li>
<li><p>空间复杂度：通常情况$O(nlog^2n)$</p>
</li>
</ul>
<p>接下来是代码实现</p>
<h3 id="一些变量"><a href="#一些变量" class="headerlink" title="一些变量"></a>一些变量</h3><p><code>T[maxn*50]</code>：存储每棵线段树的根节点</p>
<p><code>ls[maxn*50]</code>：存储左儿子编号</p>
<p><code>rs[maxn*50]</code>：存储右儿子编号</p>
<p><code>ci[maxn*50]</code>：记录节点对应权值（出现次数）</p>
<p><code>tcnt</code>：节点个数</p>
<h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p>通常情况下，如果要求$Kth$，给出的数值一般都比$n$大很多，所以需要离散化，否者会炸空间RE哦</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">read</span>(a[i]),b[i]=a[i];<br><span class="hljs-built_in">sort</span>(b+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>+n);<br><span class="hljs-type">int</span> len=<span class="hljs-built_in">unique</span>(b+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>+n)-b<span class="hljs-number">-1</span>;<br></code></pre></div></td></tr></table></figure>
<h3 id="Build建树函数"><a href="#Build建树函数" class="headerlink" title="Build建树函数"></a>Build建树函数</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;rt,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    rt=++tcnt,ci[rt]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(ls[rt],<span class="hljs-number">1</span>,mid);<br>    <span class="hljs-built_in">build</span>(rs[rt],mid+<span class="hljs-number">1</span>,r);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="Update更新函数"><a href="#Update更新函数" class="headerlink" title="Update更新函数"></a>Update更新函数</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> o,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> val)</span></span>&#123;<br>    <span class="hljs-type">int</span> oo=++tcnt;<br>    <span class="hljs-comment">//新节点的左右儿子与原节点相同</span><br>    ls[oo]=ls[o],rs[oo]=rs[o],ci[oo]=ci[o]+<span class="hljs-number">1</span>;<span class="hljs-comment">//在之前的节点基础上+1</span><br>    <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> oo;<span class="hljs-comment">//如果到叶子了，返回新节点标号</span><br>    <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(mid&gt;=val) ls[oo]=<span class="hljs-built_in">update</span>(ls[oo],l,mid,val);<span class="hljs-comment">//递归求左右节点新标号</span><br>    <span class="hljs-keyword">else</span> rs[oo]=<span class="hljs-built_in">update</span>(rs[oo],mid+<span class="hljs-number">1</span>,r);<br>    <span class="hljs-keyword">return</span> oo;<span class="hljs-comment">//返回新节点序号</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="Query询问函数"><a href="#Query询问函数" class="headerlink" title="Query询问函数"></a>Query询问函数</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<br>    <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> x=ci[ls[R]]-ci[ls[L]];<span class="hljs-comment">//x为区间[l,r]中数的出现次数之和</span><br>    <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> l;<br>    <span class="hljs-keyword">if</span>(x&gt;=k) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(ls[L],ls[R],l,mid,k);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(rs[L],rs[R],mid+<span class="hljs-number">1</span>,r,k-x);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="完整模板题代码"><a href="#完整模板题代码" class="headerlink" title="完整模板题代码"></a>完整模板题代码</h3><p>通常情况下，主席树的空间需要开32~50倍的序列长度大小，总之，能开多大开多大吧</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,a,b) for(register int i=a;i&lt;=b;i++)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> All(x) (x).begin(),(x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mp make_pair</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">double</span> db;<br><span class="hljs-keyword">typedef</span> vector&lt;<span class="hljs-type">int</span>&gt; VI;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI=<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps=<span class="hljs-number">1e-6</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">0x7fffffff</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">200005</span>;<br><span class="hljs-function">ll <span class="hljs-title">qpow</span><span class="hljs-params">(ll x,ll y,ll Mod)</span> </span>&#123;ll ans=<span class="hljs-number">1</span>,base=x%Mod; <span class="hljs-keyword">while</span>(y)&#123;<span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>)ans=(ans*base)%Mod;base=(base*base)%Mod;y&gt;&gt;=<span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">return</span> ans;&#125;<br><span class="hljs-function">ll <span class="hljs-title">gcd</span><span class="hljs-params">(ll a,ll b)</span> </span>&#123;<span class="hljs-keyword">return</span> b?<span class="hljs-built_in">gcd</span>(b,a%b):a;&#125;<br><br><span class="hljs-comment">// fast read</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(T &amp;x)</span> </span>&#123;<br>	x=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> f=<span class="hljs-number">0</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br>	<span class="hljs-keyword">while</span>(ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;f|=(ch==<span class="hljs-string">&#x27;-&#x27;</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<br>	<span class="hljs-keyword">while</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<br>	x=f?-x:x;<br>	<span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">int</span> n,m,type,a[maxn],b[maxn],ans;<br><span class="hljs-type">int</span> T[maxn*<span class="hljs-number">40</span>],ls[maxn*<span class="hljs-number">40</span>],rs[maxn*<span class="hljs-number">40</span>],ci[maxn*<span class="hljs-number">40</span>],tcnt;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;rt,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>	rt=++tcnt,ci[rt]=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span>;<br>	<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>	<span class="hljs-built_in">build</span>(ls[rt],l,mid);<br>	<span class="hljs-built_in">build</span>(rs[rt],mid+<span class="hljs-number">1</span>,r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> ort,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> val)</span></span>&#123;<br>	<span class="hljs-type">int</span> nrt=++tcnt;<br>	ls[nrt]=ls[ort],rs[nrt]=rs[ort],ci[nrt]=ci[ort]+<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> nrt;<br>	<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span>(mid&gt;=val) ls[nrt]=<span class="hljs-built_in">update</span>(ls[nrt],l,mid,val);<br>	<span class="hljs-keyword">else</span> rs[nrt]=<span class="hljs-built_in">update</span>(rs[nrt],mid+<span class="hljs-number">1</span>,r,val);<br>	<span class="hljs-keyword">return</span> nrt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> lt,<span class="hljs-type">int</span> rt,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> l;<br>	<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>,x=ci[ls[rt]]-ci[ls[lt]];<br>	<span class="hljs-keyword">if</span>(x&gt;=k) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(ls[lt],ls[rt],l,mid,k);<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(rs[lt],rs[rt],mid+<span class="hljs-number">1</span>,r,k-x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">read</span>(n),<span class="hljs-built_in">read</span>(m);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">read</span>(a[i]),b[i]=a[i];<br>	<span class="hljs-built_in">sort</span>(b+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>+n);<br>	<span class="hljs-type">int</span> len=<span class="hljs-built_in">unique</span>(b+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>+n)-b<span class="hljs-number">-1</span>;<br>	<span class="hljs-built_in">build</span>(T[<span class="hljs-number">0</span>],<span class="hljs-number">1</span>,len);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n)&#123;<br>		<span class="hljs-type">int</span> x=<span class="hljs-built_in">lower_bound</span>(b+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>+len,a[i])-b;<br>		T[i]=<span class="hljs-built_in">update</span>(T[i<span class="hljs-number">-1</span>],<span class="hljs-number">1</span>,len,x);<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,x,y,k;i&lt;m;i++)&#123;<br>		<span class="hljs-built_in">read</span>(x),<span class="hljs-built_in">read</span>(y),<span class="hljs-built_in">read</span>(k);<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,b[<span class="hljs-built_in">query</span>(T[x<span class="hljs-number">-1</span>],T[y],<span class="hljs-number">1</span>,len,k)]);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3834">P3834 【模板】可持久化线段树 1（主席树）</a></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3567">P3567 [POI2014]KUR-Couriers</a>（动态询问区间是否存在出现次数大于一半的数）</p>
<hr>
<p>UPD：2022.10.3</p>
<p>时光荏苒，一转眼两年半过去了，现在再回过头来看之前学习的算法和数据结构，代码风格实在是不敢苟同（我为什么当时能写得出这么OI风格的代码？？）如今加深了对语言和算法的认识，现在重新拾起旧知识的时候，有了很多自己的想法和思考。接下来介绍一下线段树常用小技巧 之 <strong>线段树合并</strong>。</p>
<h2 id="线段树合并"><a href="#线段树合并" class="headerlink" title="线段树合并"></a>线段树合并</h2><p>参考blog：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/styx-ferryman/xian-duan-shu-ge-bing-zong-ru-men-dao-fang-qi#blog-comments">线段树合并：从入门到放弃 - Styx 的博客 - 洛谷博客 (luogu.com.cn)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Plozia/p/16156757.html">数据结构专题-学习笔记：线段树合并 - Plozia - 博客园 (cnblogs.com)</a></li>
</ul>
<hr>
<p>首先我们先规定一下线段树的节点结构体：存储了需要维护的值<code>val</code>、左儿子下标<code>LS</code>、右儿子下标<code>RS</code>。</p>
<p>这棵树是由一个<code>vector&lt;Node&gt;</code>来维护的。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    T val;<br>    <span class="hljs-type">int</span> LS, RS;<br>    <span class="hljs-built_in">Node</span>(): <span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>) &#123;<br>        LS = <span class="hljs-number">0</span>, RS = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br><br>vector&lt;Node&gt; tr;<br></code></pre></div></td></tr></table></figure>
<p>动态开点线段树合并，简称线段树合并，顾名思义，就是将两棵线段树的节点值合并，注意这里的合并是指维护的信息合并，例如：区间和的合并，就是将两个节点的区间和相加。线段树合并的代码十分简单：</p>
<ul>
<li>如果两棵树对应节点任意一个没有被开辟，则返回另一个节点</li>
<li>如果是叶子节点，将信息合并</li>
<li>递归左右子树</li>
</ul>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 线段树合并：将b为根的树合并到a为根的树上</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!a) <span class="hljs-keyword">return</span> b;<br>    <span class="hljs-keyword">if</span>(!b) <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">if</span>(l == r)&#123;<br>        <span class="hljs-comment">/* 合并信息操作 */</span><br>        <span class="hljs-comment">// 例如：tr[a].val += tr[b].val;</span><br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    tr[a].LS = <span class="hljs-built_in">merge</span>(tr[a].LS, tr[b].LS, l, mid);<br>    tr[a].RS = <span class="hljs-built_in">merge</span>(tr[a].RS, tr[b].RS, mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-built_in">push_up</span>(a);<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>线段树合并的时间复杂度与树中插入的节点个数有关，如果我们需要加入$k$个点，则会向树中会插入$k \log k$个节点，每次合并两棵线段树同位置的点，就会少掉一个点，这个复杂度是$O(1)$的，因此线段树合并的总复杂度为$O(k\log k)$，具体证明可以参考上方blog。</p>
<hr>
<h3 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3605">P3605 USACO17JAN Promotion Counting P</a></p>
<p>题意：一棵有根树，求每个子树中严格大于当前节点值的节点个数</p>
<p>题解：对每个节点维护一棵动态开点线段树，线段树维护区间和，然后直接dfs + 线段树合并</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    https://www.luogu.com.cn/problem/P3605</span><br><span class="hljs-comment">    线段树合并模板题</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    一棵有根树，求每个子树中严格大于当前节点值的节点个数</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> pii = pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;;<br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DYNAMIC <span class="hljs-comment">// 是否开启动态开点</span></span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SegTree</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> T T_MIN = numeric_limits&lt;T&gt;::<span class="hljs-built_in">lowest</span>();<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> T T_MAX = numeric_limits&lt;T&gt;::<span class="hljs-built_in">max</span>();<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>        T val;<br>        <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DYNAMIC</span><br>            <span class="hljs-type">int</span> LS, RS;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        <span class="hljs-built_in">Node</span>(): <span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DYNAMIC</span><br>                LS = <span class="hljs-number">0</span>, RS = <span class="hljs-number">0</span>;<br>            <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DYNAMIC</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">define</span> ls (tr[i].LS)</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">define</span> rs (tr[i].RS)</span><br>        <span class="hljs-type">int</span> tcnt; <span class="hljs-comment">// 动态节点数</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        <span class="hljs-meta">#<span class="hljs-keyword">define</span> ls (i&lt;&lt;1)</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">define</span> rs (i&lt;&lt;1|1)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    vector&lt;Node&gt; tr;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DYNAMIC</span><br>            <span class="hljs-keyword">if</span>(!ls) ls = ++tcnt, tr.<span class="hljs-built_in">emplace_back</span>(Node&#123;&#125;);<br>            <span class="hljs-keyword">if</span>(!rs) rs = ++tcnt, tr.<span class="hljs-built_in">emplace_back</span>(Node&#123;&#125;);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>        tr[i].val = tr[ls].val + tr[rs].val;<br>    &#125;<br><br><br>    <span class="hljs-comment">/* 构造与初始化 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DYNAMIC</span><br>        <span class="hljs-built_in">SegTree</span>(): <span class="hljs-built_in">tcnt</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">tr</span>(<span class="hljs-number">2</span>) &#123;&#125;<br>        <span class="hljs-comment">// 开N棵动态开点线段树，根节点分别为 1 ~ N（用于线段树合并）</span><br>        <span class="hljs-built_in">SegTree</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;N): <span class="hljs-built_in">tcnt</span>(N), <span class="hljs-built_in">tr</span>(N+<span class="hljs-number">1</span>) &#123;&#125;<br><br>        <span class="hljs-comment">// 线段树合并：将b为根的树合并到a为根的树上</span><br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(!a) <span class="hljs-keyword">return</span> b;<br>            <span class="hljs-keyword">if</span>(!b) <span class="hljs-keyword">return</span> a;<br>            <span class="hljs-keyword">if</span>(l == r)&#123;<br>                <span class="hljs-comment">/* 合并信息操作 */</span><br>                tr[a].val += tr[b].val;<br>                <span class="hljs-keyword">return</span> a;<br>            &#125;<br>            <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            tr[a].LS = <span class="hljs-built_in">merge</span>(tr[a].LS, tr[b].LS, l, mid);<br>            tr[a].RS = <span class="hljs-built_in">merge</span>(tr[a].RS, tr[b].RS, mid + <span class="hljs-number">1</span>, r);<br>            <span class="hljs-built_in">push_up</span>(a);<br>            <span class="hljs-keyword">return</span> a;<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        <span class="hljs-comment">// 初值初始化</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">const</span> vector&lt;T&gt; &amp;a)</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(l==r)&#123;<br>                tr[i].val = a[l];<br>                tr[i].maxh = a[l];<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">build</span>(ls, l, mid, a);<br>            <span class="hljs-built_in">build</span>(rs, mid+<span class="hljs-number">1</span>, r, a);<br>            <span class="hljs-built_in">push_up</span>(i);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RESIZE</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;N)</span> </span>&#123; tr.<span class="hljs-built_in">resize</span>(N&lt;&lt;<span class="hljs-number">2</span>); &#125;<br>        <span class="hljs-built_in">SegTree</span>() = <span class="hljs-keyword">default</span>;<br>        <span class="hljs-built_in">SegTree</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;N): <span class="hljs-built_in">tr</span>(N&lt;&lt;<span class="hljs-number">2</span>) &#123;&#125;<br>        <span class="hljs-built_in">SegTree</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;N, <span class="hljs-type">const</span> vector&lt;T&gt; &amp;a): <span class="hljs-built_in">tr</span>(N&lt;&lt;<span class="hljs-number">2</span>) &#123; <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, N, a); &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-comment">/* 构造与初始化 */</span><br><br><br>    <span class="hljs-comment">// 单点修改</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_point</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos, T k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r) &#123;<br>            tr[i].val += k;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">push_down</span>(i, l, r);<br>        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (pos &lt;= mid) <span class="hljs-built_in">add_point</span>(ls, l, mid, pos, k);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">add_point</span>(rs, mid+<span class="hljs-number">1</span>, r, pos, k);<br>        <span class="hljs-built_in">push_up</span>(i);<br>    &#125;<br><br>    <span class="hljs-comment">// 区间求和</span><br>    <span class="hljs-function">T <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= L &amp;&amp; r &lt;= R) <span class="hljs-keyword">return</span> tr[i].val;<br>        <span class="hljs-built_in">push_down</span>(i, l, r);<br>        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        T ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (mid &gt;= L) ret += <span class="hljs-built_in">getsum</span>(ls, l, mid, L, R);<br>        <span class="hljs-keyword">if</span> (mid+<span class="hljs-number">1</span> &lt;= R) ret += <span class="hljs-built_in">getsum</span>(rs, mid+<span class="hljs-number">1</span>, r, L, R);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br><br>&#125;;<br><span class="hljs-comment">////////////////////////////////////////////////////////</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">e</span>(n+<span class="hljs-number">1</span>);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin &gt;&gt; a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fa,i=<span class="hljs-number">2</span>;i&lt;=n;++i)&#123;<br>        cin &gt;&gt; fa;<br>        e[i].<span class="hljs-built_in">emplace_back</span>(fa);<br>        e[fa].<span class="hljs-built_in">emplace_back</span>(i);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">SegTree&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">seg</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">auto</span> dfs = [&amp;](<span class="hljs-keyword">auto</span> &amp;&amp;self, <span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fath) -&gt; <span class="hljs-type">void</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;&amp;v: e[u])&#123;<br>            <span class="hljs-keyword">if</span>(v == fath) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">self</span>(self, v, u);<br>            seg.<span class="hljs-built_in">merge</span>(u, v, <span class="hljs-number">1</span>, <span class="hljs-number">1e9</span>);<br>        &#125;<br>        ans[u] = seg.<span class="hljs-built_in">getsum</span>(u, <span class="hljs-number">1</span>, <span class="hljs-number">1e9</span>, a[u]+<span class="hljs-number">1</span>, <span class="hljs-number">1e9</span>);<br>        seg.<span class="hljs-built_in">add_point</span>(u, <span class="hljs-number">1</span>, <span class="hljs-number">1e9</span>, a[u], <span class="hljs-number">1</span>);<br>    &#125;;<br>    <span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>)-&gt;<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <br>    <span class="hljs-type">int</span> _ = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// cin&gt;&gt;_;</span><br>    <span class="hljs-keyword">while</span>(_--)&#123;<br>        <br>        <span class="hljs-built_in">solve</span>();<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4556">P4556 Vani有约会  雨天的尾巴 /【模板】线段树合并</a></p>
<p>题意：一棵有根树，m次操作，每次给[x,y]路径上所有点发放z类型的食物，问所有操作后，每个点存放的最多的是哪种食物？</p>
<p>题解：首先，[x,y]路径操作可以转化成树上差分，即<code>x+1, y+1, LCA(x,y)-1, fa[LCA(x,y)]-1</code>。对每个节点维护一棵动态开点线段树，线段树维护该点的每种食物的出现次数 和 出现次数最大的食物下标。先树上差分将所有修改处理好，然后dfs + 线段树合并，注意合并时需要保证合并好所有信息。（易错点：可能会出现<strong>每种食物的出现次数=0</strong>，但<strong>出现次数最大的食物下标≠0</strong>的情况，这里需要特判使得ans = 0）</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> pii = pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;;<br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DYNAMIC <span class="hljs-comment">// 是否开启动态开点</span></span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SegTree</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> T T_MIN = numeric_limits&lt;T&gt;::<span class="hljs-built_in">lowest</span>();<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> T T_MAX = numeric_limits&lt;T&gt;::<span class="hljs-built_in">max</span>();<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>        T maxh, maxidx;<br>        <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DYNAMIC</span><br>            <span class="hljs-type">int</span> LS, RS;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        <span class="hljs-built_in">Node</span>(): <span class="hljs-built_in">maxh</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">maxidx</span>(<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DYNAMIC</span><br>                LS = <span class="hljs-number">0</span>, RS = <span class="hljs-number">0</span>;<br>            <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DYNAMIC</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">define</span> ls (tr[i].LS)</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">define</span> rs (tr[i].RS)</span><br>        <span class="hljs-type">int</span> tcnt; <span class="hljs-comment">// 动态节点数</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        <span class="hljs-meta">#<span class="hljs-keyword">define</span> ls (i&lt;&lt;1)</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">define</span> rs (i&lt;&lt;1|1)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    vector&lt;Node&gt; tr;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DYNAMIC</span><br>            <span class="hljs-keyword">if</span>(!ls) ls = ++tcnt, tr.<span class="hljs-built_in">emplace_back</span>(Node&#123;&#125;);<br>            <span class="hljs-keyword">if</span>(!rs) rs = ++tcnt, tr.<span class="hljs-built_in">emplace_back</span>(Node&#123;&#125;);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(tr[ls].maxh &gt;= tr[rs].maxh) tr[i].maxh = tr[ls].maxh, tr[i].maxidx = tr[ls].maxidx;<br>        <span class="hljs-keyword">else</span> tr[i].maxh = tr[rs].maxh, tr[i].maxidx = tr[rs].maxidx;<br>    &#125;<br><br>    <span class="hljs-comment">/* 构造函数 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DYNAMIC</span><br><br>        <span class="hljs-built_in">SegTree</span>(): <span class="hljs-built_in">tcnt</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">tr</span>(<span class="hljs-number">2</span>) &#123;&#125;<br>        <span class="hljs-comment">// 开N棵动态开点线段树，根节点分别为 1 ~ N（一般用于线段树合并）</span><br>        <span class="hljs-built_in">SegTree</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;N): <span class="hljs-built_in">tcnt</span>(N), <span class="hljs-built_in">tr</span>(N+<span class="hljs-number">1</span>) &#123;&#125;<br><br>        <span class="hljs-comment">// 线段树合并：将b为根的树合并到a为根的树上</span><br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(!a) <span class="hljs-keyword">return</span> b;<br>            <span class="hljs-keyword">if</span>(!b) <span class="hljs-keyword">return</span> a;<br>            <span class="hljs-keyword">if</span>(l == r)&#123;<br>                tr[a].maxh += tr[b].maxh;<br>                tr[a].maxidx = l;<br>                <span class="hljs-keyword">return</span> a;<br>            &#125;<br>            <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            tr[a].LS = <span class="hljs-built_in">merge</span>(tr[a].LS, tr[b].LS, l, mid);<br>            tr[a].RS = <span class="hljs-built_in">merge</span>(tr[a].RS, tr[b].RS, mid + <span class="hljs-number">1</span>, r);<br>            <span class="hljs-built_in">push_up</span>(a);<br>            <span class="hljs-keyword">return</span> a;<br>        &#125;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><br>        <span class="hljs-comment">// 初值初始化</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">const</span> vector&lt;T&gt; &amp;a)</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(l==r)&#123;<br>                tr[i].val = tr[i].maxh = a[l];<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">build</span>(ls, l, mid, a);<br>            <span class="hljs-built_in">build</span>(rs, mid+<span class="hljs-number">1</span>, r, a);<br>            <span class="hljs-built_in">push_up</span>(i);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RESIZE</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;N)</span> </span>&#123; tr.<span class="hljs-built_in">resize</span>(N&lt;&lt;<span class="hljs-number">2</span>); &#125;<br>        <span class="hljs-built_in">SegTree</span>() = <span class="hljs-keyword">default</span>;<br>        <span class="hljs-built_in">SegTree</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;N): <span class="hljs-built_in">tr</span>(N&lt;&lt;<span class="hljs-number">2</span>) &#123;&#125;<br>        <span class="hljs-built_in">SegTree</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;N, <span class="hljs-type">const</span> vector&lt;T&gt; &amp;a): <span class="hljs-built_in">tr</span>(N&lt;&lt;<span class="hljs-number">2</span>) &#123; <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, N, a); &#125;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">// 单点修改</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_point</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos, T k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r) &#123;<br>            tr[i].maxh += k;<br>            tr[i].maxidx = l;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">push_down</span>(i, l, r);<br>        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (pos &lt;= mid) <span class="hljs-built_in">add_point</span>(ls, l, mid, pos, k);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">add_point</span>(rs, mid+<span class="hljs-number">1</span>, r, pos, k);<br>        <span class="hljs-built_in">push_up</span>(i);<br>    &#125;<br><br>&#125;;<br><span class="hljs-comment">////////////////////////////////////////////////////////</span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n,m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">e</span>(n+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x,y,i=<span class="hljs-number">1</span>;i&lt;n;++i)&#123;<br>        cin &gt;&gt; x &gt;&gt; y;<br>        e[x].<span class="hljs-built_in">emplace_back</span>(y);<br>        e[y].<span class="hljs-built_in">emplace_back</span>(x);<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">	    倍增LCA</span><br><span class="hljs-comment">    */</span><br>    vector&lt;array&lt;<span class="hljs-type">int</span>,22&gt;&gt; <span class="hljs-built_in">bfa</span>(n+<span class="hljs-number">1</span>);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">deep</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">auto</span> init_beizeng = [&amp;](<span class="hljs-type">int</span> root)&#123;<br>        <span class="hljs-comment">// init dfs</span><br>        <span class="hljs-keyword">auto</span> dfs = [&amp;](<span class="hljs-keyword">auto</span> &amp;&amp;self, <span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa,<span class="hljs-type">int</span> dep)-&gt;<span class="hljs-type">void</span>&#123;<br>            deep[u] = dep;<br>            bfa[u][<span class="hljs-number">0</span>] = fa;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;&amp;v:e[u])&#123;<br>                <span class="hljs-keyword">if</span>(v == fa) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-built_in">self</span>(self, v, u, dep+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-built_in">dfs</span>(dfs, root, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// dp</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;(<span class="hljs-number">1</span>&lt;&lt;i)&lt;=n;++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)&#123;<br>                bfa[j][i]=bfa[bfa[j][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-built_in">init_beizeng</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// LCA</span><br>    <span class="hljs-keyword">auto</span> LCA = [&amp;](<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)&#123;<br>        <span class="hljs-keyword">if</span>(deep[x] &lt; deep[y]) <span class="hljs-built_in">swap</span>(x,y);<br>        <span class="hljs-keyword">while</span>(deep[x] &gt; deep[y])&#123;<br>            x=bfa[x][<span class="hljs-built_in">int</span>(<span class="hljs-built_in">log2</span>(deep[x]-deep[y]))];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> x;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">log2</span>(deep[x]); i&gt;=<span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">if</span>(bfa[x][i]!=bfa[y][i])&#123;<br>                x=bfa[x][i],y=bfa[y][i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> bfa[x][<span class="hljs-number">0</span>];<br>    &#125;;<br><br>    <span class="hljs-function">SegTree&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">seg</span><span class="hljs-params">(n)</span></span>; <span class="hljs-comment">// n 个动态开点线段树</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100000</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x,y,z,i=<span class="hljs-number">1</span>;i&lt;=m;++i)&#123;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;<br>        seg.<span class="hljs-built_in">add_point</span>(x, <span class="hljs-number">1</span>, N, z, <span class="hljs-number">1</span>);<br>        seg.<span class="hljs-built_in">add_point</span>(y, <span class="hljs-number">1</span>, N, z, <span class="hljs-number">1</span>);<br>        seg.<span class="hljs-built_in">add_point</span>(<span class="hljs-built_in">LCA</span>(x,y), <span class="hljs-number">1</span>, N, z, <span class="hljs-number">-1</span>);<br>        seg.<span class="hljs-built_in">add_point</span>(bfa[<span class="hljs-built_in">LCA</span>(x,y)][<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, N, z, <span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br><br>    <span class="hljs-keyword">auto</span> dfs = [&amp;](<span class="hljs-keyword">auto</span> &amp;&amp;self, <span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fath) -&gt; <span class="hljs-type">void</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;&amp;v: e[u])&#123;<br>            <span class="hljs-keyword">if</span>(v == fath) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">self</span>(self, v, u);<br>            seg.<span class="hljs-built_in">merge</span>(u, v, <span class="hljs-number">1</span>, N);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(seg.tr[u].maxh == <span class="hljs-number">0</span>) ans[u] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> ans[u] = seg.tr[u].maxidx;<br>    &#125;;<br><br>    <span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>)-&gt;<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <br>    <span class="hljs-type">int</span> _ = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// cin&gt;&gt;_;</span><br>    <span class="hljs-keyword">while</span>(_--)&#123;<br>        <br>        <span class="hljs-built_in">solve</span>();<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%88%86%E5%9D%97/">分块</a>
                    
                      <a class="hover-with-bg" href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/">线段树</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/04/10/%E5%88%86%E5%9D%97%E4%B8%93%E9%A2%98/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">分块专题</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/03/30/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-BIT-%E4%B8%93%E9%A2%98/">
                        <span class="hidden-mobile">树状数组(BIT)专题</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://fastly.jsdelivr.net/npm/valine@1/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"8WpS33YNRGD4IQNVQgVCmHQy-gzGzoHsz","appKey":"jed4H3219MxS5igBfmfTU81w","path":"window.location.pathname","placeholder":"write something here","avatar":"retro","meta":["nick","mail","link"],"requiredFields":["nick"],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":true},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          Fluid.plugins.initFancyBox('#valine .vcontent img:not(.vemoji)');
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://fastly.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://fastly.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://fastly.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://fastly.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://fastly.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://fastly.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://fastly.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://fastly.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://fastly.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://fastly.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->


</body>
</html>
