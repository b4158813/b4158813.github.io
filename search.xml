<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>01背包前k优解方案</title>
    <url>/2020/01/17/01%E8%83%8C%E5%8C%85%E5%89%8Dk%E4%BC%98%E8%A7%A3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="刷题记录-洛谷P1858-多人背包"><a href="#刷题记录-洛谷P1858-多人背包" class="headerlink" title="[刷题记录]洛谷P1858 多人背包"></a><center>[刷题记录]洛谷P1858 多人背包</center></h2><span id="more"></span>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1858">P1858多人背包</a></p>
<hr>
<h2 id="题意解释"><a href="#题意解释" class="headerlink" title="题意解释"></a>题意解释</h2><ul>
<li><p>传统的01背包问题：有一堆物品和一个固定容量的背包，每个物品有自己的体积和价值，要求求出能装入背包的所有物品对应的最大总价值；</p>
</li>
<li><p>这道题又多出了一个k值，表示有k个背包，意思是要求你求出上述问题的前k优解的总和；</p>
</li>
<li><p>当然，题目里还有一个要注意的地方就是：<strong>要求背包恰好装满</strong>，因此需要在初始化的时候做点手脚就可以了，具体一点的可以参考<a href="https://www.kancloud.cn/kancloud/pack/70124">背包九讲</a>。</p>
</li>
</ul>
<h2 id="算法解释与实现"><a href="#算法解释与实现" class="headerlink" title="算法解释与实现"></a>算法解释与实现</h2><p>传统的01背包问题，大致的实现过程如下（时间复杂度：$O(NV)$）：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1.</span>..N)&#123;<br>	<span class="hljs-keyword">for</span>(j=V...v[i])&#123;<br>		dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j-v[i]]+w[i]);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>我们知道这是求<strong>最优解</strong>的方法，那么<strong>前k优解</strong>怎么求呢？</p>
<p><del>貌似不太好想，</del>我们来捋一下传统方法的具体实现思路，看看能不能找到点灵感：</p>
<p>背包问题的解法中，状态$dp[i][j]$是由状态$dp[i-1][j]$和$dp[i-1][j-v[i]]+w[i]$这两个状态转移得到的，那么前k优解的状态转移方程，我们便可以定义为：$dp[i][j][k]$，表示装入前$i$件物品容量最大为$j$时的第$k$大的总价值。</p>
<p><del>然后正常转移就好了</del></p>
<p>好吧，具体来说，这里转移状态需要用到<strong>归并排序</strong>的合并思想：比较$dp[i-1][j]$和$dp[i-1][j-v[i]]+w[i]$，设置一个新数组$num[i]$,利用归并排序合并数组的思想，定义两个变量t1和t2分别指向上述两状态对应的最优值，每次比较将两者中的最优值存入num数组（也即使把这两个状态合并，保证存入num数组的是整个背包的前k优的值 ），随后该值对应状态的t++，，最后再从头到尾把num数组赋给dp数组，因为还需要下一轮状态转移。</p>
<p>那有人会问了：为什么这样就正确呢？我们知道，一个动态规划问题的正确性取决于其是否考虑到了所有状态，对于普通的背包问题，其实就是k==1的情形，而max函数的使用其实就是上述数组合并过程的简化写法，真正的本质还在于这个状态数组合并过程啊！</p>
<p>噢差点忘了，还有就是初始化过程的问题，由于是要求<strong>恰好装满背包</strong>，因此dp数组的在容量为0的时候的值为0（表示什么都不装，或者说被0装满，是合理的），但其他情形都需要定义为-INF（即不合法状态，因为只要背包有容量了，还必须得全部装满，但初始状态是没有物品给你装的，因此不合法）就行了，这里还是需要消化一下的。</p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> k,v,n,vo[<span class="hljs-number">205</span>],va[<span class="hljs-number">205</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">5005</span>][<span class="hljs-number">55</span>];<br><span class="hljs-type">int</span> num[<span class="hljs-number">55</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;k&gt;&gt;v&gt;&gt;n;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		cin&gt;&gt;vo[i]&gt;&gt;va[i];<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=v;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=k;j++)&#123;<br>			dp[i][j]=<span class="hljs-number">-9999999</span>;<br>		&#125;<br>	&#125;<br>	dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=v;j&gt;=vo[i];j--)&#123;<br>			<span class="hljs-type">int</span> t1=<span class="hljs-number">1</span>,t2=<span class="hljs-number">1</span>;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> m=<span class="hljs-number">1</span>;m&lt;=k;m++)&#123;<br>				<span class="hljs-keyword">if</span>(dp[j][t1]&gt;dp[j-vo[i]][t2]+va[i])&#123;<br>					num[m]=dp[j][t1];<br>					t1++;<br>				&#125;<span class="hljs-keyword">else</span>&#123;<br>					num[m]=dp[j-vo[i]][t2]+va[i];<br>					t2++;<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> o=<span class="hljs-number">1</span>;o&lt;=k;o++)&#123;<br>				dp[j][o]=num[o];<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;i++)&#123;<br>		<span class="hljs-keyword">if</span>(dp[v][i]&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>		sum+=dp[v][i];<br>	&#125;<br>	cout&lt;&lt;sum&lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<hr>
<ul>
<li>以上就是01背包问题的前k优解的个人理解</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>背包问题</tag>
        <tag>刷题</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Atcoder Beginner Contest 169 题解</title>
    <url>/2020/06/01/Atcoder-Beginner-Contest-169/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://atcoder.jp/contests/abc169">Atcoder Beginner Contest 169</a>，被B和C的精度搞得惨不忍睹，最后没时间想E和F了。。。<br><span id="more"></span></p>
<h4 id="A-大水题"><a href="#A-大水题" class="headerlink" title="A. 大水题"></a>A. 大水题</h4><h4 id="B-Multiplication-2"><a href="#B-Multiplication-2" class="headerlink" title="B. Multiplication 2"></a>B. Multiplication 2</h4><p>给出一个序列，求这些值练成的结果，如果结果大于$10^{18}$，输出<code>-1</code></p>
<p>发现是会爆<code>long long</code>的，所以<code>__int128</code>一发水过</p>
<h4 id="C-Multiplication-3"><a href="#C-Multiplication-3" class="headerlink" title="C. Multiplication 3"></a>C. Multiplication 3</h4><p>求整数A乘以小数点后有两位的浮点数B的结果，结果去掉小数部分</p>
<p>发现<code>double</code>的精度不够，所以<code>long double</code>一发水过</p>
<h4 id="D-Div-Game"><a href="#D-Div-Game" class="headerlink" title="D. Div Game"></a>D. Div Game</h4><p>问能将一个数N拆分成多少个质数的幂次的乘积，这些质数的幂次都互不相同</p>
<p>简单数论，直接分解质因数，然后对于N的一个质因数p，假设它的幂次为$p^e$，则表示成$p^1\cdot p^2\cdot p^3 … p^x$，且$\sum_{i=1}^{x}i\le e$，是能将p分解成最多个不同幂次的方案，暴力一下就行了</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">ll n,cnt,ans;<br>pair&lt;ll,<span class="hljs-type">int</span>&gt; yin[maxn];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">read</span>(n);<br>	<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">2</span>;i*i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)&#123;<br>			yin[++cnt].first=i;<br>			<span class="hljs-keyword">while</span>(n%i==<span class="hljs-number">0</span>) n/=i,yin[cnt].second++;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">if</span>(n!=<span class="hljs-number">1</span>) yin[++cnt].first=n,yin[cnt].second++;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;i++)&#123;<br>		<span class="hljs-type">int</span> dd=<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=yin[i].second;j+=++dd)&#123;<br>			ans++;<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="E-Count-Median"><a href="#E-Count-Median" class="headerlink" title="E. Count Median"></a>E. Count Median</h4><p>给出n个闭区间，每个区间为$[A_i,B_i]$，问从这些区间里选n个数，这n个数的中位数有多少种不同的取值？</p>
<p>结论：设$A_i$的中位数为$x$，$B_i$的中位数为$y$，则当$n$为奇数时，答案为$y-x+1$，当$n$为偶数时，答案为$2y-2x+1$</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;<br>ll a[maxn],b[maxn],zuo,you,sum[maxn];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">read</span>(n);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n)&#123;<br>		<span class="hljs-built_in">read</span>(a[i]),<span class="hljs-built_in">read</span>(b[i]);<br>	&#125;<br>	<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">1</span>+n);<br>	<span class="hljs-built_in">sort</span>(b+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>+n);<br>	<span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,b[n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]-a[n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(b[n/<span class="hljs-number">2</span>]+b[n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>])-(a[n/<span class="hljs-number">2</span>]+a[n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>])+<span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="F-Knapsack-for-All-Subsets"><a href="#F-Knapsack-for-All-Subsets" class="headerlink" title="F. Knapsack for All Subsets"></a>F. Knapsack for All Subsets</h4><p>题意：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200601110845372.png" alt="image-20200601110845372"></p>
<p>题解：后来看别人题解才明白，这是一道典型的背包题，可以定义状态$dp[i][j]$：前$i$个数子集至少有一个为$j$的方案数，则对于转移来说，考虑第$i$个数，有两种决策，取或不取：</p>
<p>不取：$dp[i][j]+=dp[i-1][j]$</p>
<p>取：$dp[i][j]+=dp[i-1][j]+((j&gt;=a[i])?dp[i-1][j-a[i]]:0)$</p>
<p>化简得到：</p>
<p>$dp[i][j]+=2\cdot d[i-1][j]+((j&gt;=a[i])?dp[i-1][j-a[i]]:0)$</p>
<p>初始化：$dp[0][0]=1$，答案为：$dp[n][s]$</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n,s,a[maxn];<br>ll dp[<span class="hljs-number">3005</span>][<span class="hljs-number">3005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">read</span>(n),<span class="hljs-built_in">read</span>(s);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">read</span>(a[i]);<br>	dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n)&#123;<br>		<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,s)&#123;<br>			dp[i][j]=(dp[i][j]+dp[i<span class="hljs-number">-1</span>][j]*<span class="hljs-number">2</span>+((j&gt;=a[i])?dp[i<span class="hljs-number">-1</span>][j-a[i]]:<span class="hljs-number">0</span>))%mod;<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,dp[n][s]%mod);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>[CFD笔记2] 偏微分方程分类</title>
    <url>/2020/02/10/CFD%E7%AC%94%E8%AE%B0-%E5%81%8F%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="《计算流体力学基础及其应用》第三章笔记"><a href="#《计算流体力学基础及其应用》第三章笔记" class="headerlink" title="《计算流体力学基础及其应用》第三章笔记"></a><center>《计算流体力学基础及其应用》第三章笔记</center></h2><span id="more"></span>
<ul>
<li>这一章也比较硬核，下面我用比较简洁的语言总结一下知识点。</li>
</ul>
<hr>
<h2 id="拟线性偏微分方程分类"><a href="#拟线性偏微分方程分类" class="headerlink" title="拟线性偏微分方程分类"></a>拟线性偏微分方程分类</h2><h3 id="方法1：克莱姆法则"><a href="#方法1：克莱姆法则" class="headerlink" title="方法1：克莱姆法则"></a>方法1：克莱姆法则</h3><p>考虑如下的<strong>拟线性偏微分方程组</strong>：</p>
<script type="math/tex; mode=display">
a_1\frac{\partial u}{\partial x}+b_1\frac{\partial u}{\partial y}+c_1\frac{\partial v}{\partial x}+d_1\frac{\partial v}{\partial y}=f_1\\a_2\frac{\partial u}{\partial x}+b_2\frac{\partial u}{\partial y}+c_2\frac{\partial v}{\partial x}+d_2\frac{\partial v}{\partial y}=f_2\\</script><p>矩阵形式：</p>
<script type="math/tex; mode=display">
\begin{pmatrix} a_{1} & b_{1} & c_{1} & d_{1} \\ a_{2} & b_{2} & c_{2} & d_{2} \\ dx & dy & 0 & 0 \\ 0 & 0 & dx & dy \end{pmatrix}\begin{pmatrix}\frac{\partial u}{\partial x}\\\frac{\partial u}{\partial y}\\\frac{\partial v}{\partial x}\\\frac{\partial v}{\partial y}\end{pmatrix}=\begin{pmatrix}f_1\\f_2\\du\\dv\end{pmatrix}</script><p>令<strong>系数矩阵</strong></p>
<script type="math/tex; mode=display">
[A]=\begin{pmatrix} a_{1} & b_{1} & c_{1} & d_{1} \\ a_{2} & b_{2} & c_{2} & d_{2} \\ dx & dy & 0 & 0 \\ 0 & 0 & dx & dy \end{pmatrix}</script><script type="math/tex; mode=display">
[B]=\begin{pmatrix} f_{1} & b_{1} & c_{1} & d_{1} \\ f_{2} & b_{2} & c_{2} & d_{2} \\ du & dy & 0 & 0 \\ dv & 0 & dx & dy \end{pmatrix}</script><p>则利用<strong>克莱姆法则</strong>解得：</p>
<script type="math/tex; mode=display">
\frac{\partial u}{\partial x}=\frac{|B|}{|A|}</script><p>同理可解出其他解</p>
<ul>
<li><p>现在我们需要在$xy$平面内找到一条曲线，使得$u$和$v$的导数都是不确定的，而且跨过这条曲线时，这些导数还是不连续的，我们称这样的曲线为<strong>特征线</strong></p>
</li>
<li><p>显然当$|A|=0$该导数不确定，通过数学推导可以得出以下结论：</p>
<script type="math/tex; mode=display">
D=b^2-4ac\begin{cases} >0 \ \ 平面上每一点都有两条不同的实特征线\rightarrow双曲型方程组\\ =0\ \ 只有一条特征线\rightarrow抛物型方程组\\ <0\ \ 虚特征线\rightarrow椭圆型方程组\end{cases}\\</script><p>其中</p>
<script type="math/tex; mode=display">
\begin{aligned}a&=(a_1c_2-a_2c_1)\\b&=-(a_1d_2-a_2d_1+b_1c_2-b_2c_1)\\c&=(b_1d_2-b_2d_1)\end{aligned}</script></li>
</ul>
<h3 id="方法2：特征值法"><a href="#方法2：特征值法" class="headerlink" title="方法2：特征值法"></a>方法2：特征值法</h3><p>将上述方程组写为如下形式：</p>
<script type="math/tex; mode=display">
W=\begin{pmatrix}u\\v\end{pmatrix}\\\begin{pmatrix}a_1&c_1\\a_2&c_2\end{pmatrix}\frac{\partial W}{\partial x}+\begin{pmatrix}b_1&d_1\\b_2&d_2\end{pmatrix}\frac{\partial W}{\partial y}=0</script><p>或</p>
<script type="math/tex; mode=display">
[K]\frac{\partial W}{\partial x}+[M]\frac{\partial W}{\partial y}=0</script><p>变形得：</p>
<script type="math/tex; mode=display">
\begin{aligned}&\frac{\partial W}{\partial x}+[K]^{-1}[M]\frac{\partial W}{\partial y}=0\\&\rightarrow \frac{\partial W}{\partial x}+[N]\frac{\partial W}{\partial y}=0\end{aligned}</script><p>求出$[N]$的特征值$\lambda$，即可判断方程组类型：</p>
<script type="math/tex; mode=display">
\lambda均为实数：双曲型\\\lambda均为复数：椭圆型\\\lambda有实有虚：混合型</script><h2 id="不同类型偏微分方程性质"><a href="#不同类型偏微分方程性质" class="headerlink" title="不同类型偏微分方程性质"></a>不同类型偏微分方程性质</h2><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>以下术语均针对$xy$平面上一点$P$而言：</p>
<ul>
<li>左行特征曲线：站在点$P$上，面对$x$轴正向，必须向左转头才能看见的特征曲线</li>
<li><p>右行特征曲线：同上，向右转头才能看见的特征曲线</p>
</li>
<li><p>影响区域：沿$x$轴正向夹在两条特征曲线之间的区域（受点$P$扰动影响的区域）</p>
</li>
<li>依赖区域：影响点$P$的区域</li>
</ul>
<h3 id="双曲型"><a href="#双曲型" class="headerlink" title="双曲型"></a>双曲型</h3><ul>
<li>有两条特征曲线</li>
<li>可以利用<strong>“推进”</strong>求解（给定初始条件和边界条件，从前往后一步步求解）</li>
</ul>
<h4 id="举例1-定常无粘超声速流动"><a href="#举例1-定常无粘超声速流动" class="headerlink" title="举例1. 定常无粘超声速流动"></a>举例1. 定常无粘超声速流动</h4><ul>
<li>注意：任何定常的局部<strong>亚声速</strong>流动都是<strong>椭圆型方程</strong>决定的，因此不可以“推进”求解</li>
</ul>
<h4 id="举例2-非定常无粘流动"><a href="#举例2-非定常无粘流动" class="headerlink" title="举例2. 非定常无粘流动"></a>举例2. 非定常无粘流动</h4><ul>
<li><p>对<strong>时间是双曲型</strong>的，如：一维管道内波的运动、绕过振荡翼型的二维非定常流动</p>
</li>
<li><p>无论是<strong>亚声速</strong>还是<strong>超声速</strong>都是<strong>双曲型</strong>方程决定，因此都可以“推进”求解</p>
</li>
<li>通过对非定常流动的长时间“推进”求解，可以得到最终的<strong>定常流场</strong>的解</li>
</ul>
<h3 id="抛物型"><a href="#抛物型" class="headerlink" title="抛物型"></a>抛物型</h3><ul>
<li>只有一条铅垂的特征线</li>
<li>可以利用<strong>“推进”</strong>求解</li>
</ul>
<h4 id="举例1-定常边界层流动"><a href="#举例1-定常边界层流动" class="headerlink" title="举例1. 定常边界层流动"></a>举例1. 定常边界层流动</h4><ul>
<li><p>适用于雷诺数很大时，简化的$NS$方程——<strong>边界层方程</strong></p>
</li>
<li><p><strong>边界层方程是抛物型的</strong></p>
</li>
</ul>
<h4 id="举例2-“抛物化”粘性流动"><a href="#举例2-“抛物化”粘性流动" class="headerlink" title="举例2. “抛物化”粘性流动"></a>举例2. “抛物化”粘性流动</h4><ul>
<li>当雷诺数很小时，对于尖头物体，激波和流场都可能是粘性的</li>
<li>对$NS$方程做另一种简化，将包含流向导数的粘性项忽略，而且流动定常，从而导出——<strong>抛物化$NS$方程（$PNS$）</strong></li>
<li>$PNS$可以通过<strong>推进求解</strong></li>
</ul>
<h4 id="举例3-非定常热传导"><a href="#举例3-非定常热传导" class="headerlink" title="举例3. 非定常热传导"></a>举例3. 非定常热传导</h4><p>导热微分方程如下：</p>
<script type="math/tex; mode=display">
\rho\frac{\partial e}{\partial t}=\rho \dot q +\frac{\partial}{\partial x}\left(k\frac{\partial T}{\partial x}\right)+\frac{\partial}{\partial y}\left(k\frac{\partial T}{\partial y}\right)+\frac{\partial}{\partial z}\left(k\frac{\partial T}{\partial z}\right)</script><p>若<strong>无内热源</strong>且内能$e=c_vT$，则上述方程化简为：</p>
<script type="math/tex; mode=display">
\frac{\partial T}{\partial t}=\frac{1}{\rho c_v}\left[\frac{\partial}{\partial x}\left(k\frac{\partial T}{\partial x}\right)+\frac{\partial}{\partial y}\left(k\frac{\partial T}{\partial y}\right)+\frac{\partial}{\partial z}\left(k\frac{\partial T}{\partial z}\right)\right]</script><p>若$k$为常数，则进一步化简为：</p>
<script type="math/tex; mode=display">
\frac{\partial T}{\partial t}=\alpha \nabla^2T\\热扩散系数：\alpha=\frac{k}{\rho c_v}</script><h3 id="椭圆型"><a href="#椭圆型" class="headerlink" title="椭圆型"></a>椭圆型</h3><ul>
<li>没有限制的影响区域和依赖区域，信息可以向任何方向传播到任何地方</li>
<li><p>“陪审团”问题，无法通过“推进”求解，需要对流场中所有点同时求解</p>
</li>
<li><p>必须给定边界条件：</p>
<ul>
<li>在边界上指定未知函数$u$和$v$：$Dirichlet$条件</li>
<li>在边界上指定未知函数的导数,如$\frac{\partial u}{\partial x}$：$Neumann$条件</li>
<li>上述两种条件的混合条件</li>
</ul>
</li>
</ul>
<h4 id="举例1-定常亚声速无粘流动"><a href="#举例1-定常亚声速无粘流动" class="headerlink" title="举例1. 定常亚声速无粘流动"></a>举例1. 定常亚声速无粘流动</h4><ul>
<li>如：绕翼型的亚声速流动</li>
<li>由于翼型的存在所造成的扰动将会传遍整个流场，包括上游</li>
</ul>
<h4 id="举例2-不可压无粘流动"><a href="#举例2-不可压无粘流动" class="headerlink" title="举例2. 不可压无粘流动"></a>举例2. 不可压无粘流动</h4><ul>
<li>是马赫数趋于零时的亚声速流动的极限情况</li>
</ul>
<h3 id="定解问题的适定性"><a href="#定解问题的适定性" class="headerlink" title="定解问题的适定性"></a>定解问题的适定性</h3><ul>
<li>适定性：如果一个偏微分方程的解存在并且是唯一的，同时，解连续地依赖于初始条件和边界条件，那么这个问题就是<strong>适定的</strong></li>
</ul>
]]></content>
      <categories>
        <category>物理</category>
      </categories>
      <tags>
        <tag>流体力学</tag>
        <tag>CFD</tag>
      </tags>
  </entry>
  <entry>
    <title>[CFD笔记1] 流体力学控制方程组</title>
    <url>/2020/02/05/CFD%E7%AC%94%E8%AE%B0-%E6%B5%81%E4%BD%93%E5%8A%9B%E5%AD%A6%E6%8E%A7%E5%88%B6%E6%96%B9%E7%A8%8B%E7%BB%84/</url>
    <content><![CDATA[<h2 id="《计算流体力学基础及其应用》第二章笔记"><a href="#《计算流体力学基础及其应用》第二章笔记" class="headerlink" title="《计算流体力学基础及其应用》第二章笔记"></a><center>《计算流体力学基础及其应用》第二章笔记</center></h2><span id="more"></span>
<ul>
<li>最近开始学CFD了，先入个门，看的书是<a href="https://book.douban.com/subject/2180067/">《计算流体力学基础及其应用》</a>，通俗易懂，今天看完了<strong>第二章</strong>，做个记录；</li>
<li>包含了一些核心知识点和<del>简陋的</del>推导过程（自我理解），便于自己复习。</li>
</ul>
<hr>
<h2 id="流体力学的控制方程组"><a href="#流体力学的控制方程组" class="headerlink" title="流体力学的控制方程组"></a>流体力学的控制方程组</h2><h3 id="两个概念"><a href="#两个概念" class="headerlink" title="两个概念"></a>两个概念</h3><h4 id="1-物质导数"><a href="#1-物质导数" class="headerlink" title="1. 物质导数"></a>1. 物质导数</h4><p>假设一<strong>运动的流体微团</strong>在<strong>笛卡尔坐标系</strong>下的某一个状态$(x<em>{1},y</em>{1},z<em>{1},t</em>{1})$，速度满足</p>
<script type="math/tex; mode=display">
\overrightarrow{V}=u\overrightarrow{i}+v\overrightarrow{j}+w\overrightarrow{k}</script><p>密度满足</p>
<script type="math/tex; mode=display">
\rho_{1} = \rho\left(x_1,y_1,z_1,t_1\right)</script><p>则在另一个状态$(x<em>{2},y</em>{2},z<em>{2},t</em>{2})$下，有：</p>
<script type="math/tex; mode=display">
\rho_{2} = \rho\left(x_2,y_2,z_2,t_2\right)</script><p>在$1$处使用<strong>泰勒展开</strong>，得到：</p>
<script type="math/tex; mode=display">
\rho_2-\rho_1=\frac{\partial \rho}{\partial t}(t_2-t_1)+\frac{\partial \rho}{\partial x}(x_2-x_1)+\frac{\partial \rho}{\partial y}(y_2-y_1)+\frac{\partial \rho}{\partial z}(z_2-z_1)</script><p>两边同时除以$(t_2-t_1)$，得到：</p>
<script type="math/tex; mode=display">
\frac{\rho_2-\rho_1}{t_2-t_1}=\frac{\partial \rho}{\partial t}+\frac{\partial \rho}{\partial x}\frac{(x_2-x_1)}{t_2-t_1}+\frac{\partial \rho}{\partial y}\frac{(y_2-y_1)}{t_2-t_1}+\frac{\partial \rho}{\partial z}\frac{(z_2-z_1)}{t_2-t_1}</script><p>当$t_2\rightarrow t_1$时，化简上式，得到：</p>
<script type="math/tex; mode=display">
\frac{D\rho}{Dt}=\frac{\partial\rho}{\partial t}+u\frac{\partial\rho}{\partial x}+v\frac{\partial\rho}{\partial y}+w\frac{\partial\rho}{\partial z}</script><p>其中$\frac{D\rho}{Dt}$为密度的<strong>物质导数</strong>，它等于密度的<strong>当地导数</strong>$\frac{\partial\rho}{\partial t}$和<strong>迁移导数</strong>$u\frac{\partial\rho}{\partial x}+v\frac{\partial\rho}{\partial y}+w\frac{\partial\rho}{\partial z}$（即$\overrightarrow{V}\cdot \overrightarrow{\nabla \rho}$）之和。</p>
<p>因此规定<strong>物质导数</strong>为$\frac{D}{Dt}$，<strong>当地导数</strong>为$\frac{\partial}{\partial t}$，<strong>迁移导数</strong>为$\overrightarrow{V}\cdot \overrightarrow{\nabla}$</p>
<p>有：</p>
<script type="math/tex; mode=display">
\frac{D}{Dt}=\frac{\partial}{\partial t}+\overrightarrow{V}\cdot \overrightarrow{\nabla}</script><ul>
<li><p><strong>当地导数的物理意义</strong>：流体微团在<strong>空间静止（不运动）</strong>时所对应的物理量的时间变化率，在数学上就表示为该物理量对时间$t$的偏导数；</p>
</li>
<li><p><strong>迁移导数的物理意义</strong>：流体微团由于处于<strong>运动的状态</strong>（流畅空间的不均匀性）所导致的对应物理量的时间变化率。</p>
</li>
</ul>
<h4 id="2-速度散度"><a href="#2-速度散度" class="headerlink" title="2. 速度散度"></a>2. 速度散度</h4><p>场论里面，我们学过散度$div$或直接使用$\overrightarrow \nabla$算子点乘，而速度散度即</p>
<script type="math/tex; mode=display">
\overrightarrow{\nabla}\cdot\overrightarrow{V}=\frac{\partial u}{\partial x}+\frac{\partial v}{\partial y}+\frac{\partial w}{\partial z}</script><p>考虑使用<strong>随流体运动的流体微团</strong>模型的性质（<strong>质量恒定</strong>），导出如下关系式：</p>
<script type="math/tex; mode=display">
\overrightarrow{\nabla}\cdot\overrightarrow{V}=\frac{1}{\delta\mathscr{V}}\frac{D(\delta\mathscr{V})}{Dt}</script><p>此式为速度散度赋予了<strong>物理意义</strong>：<strong>单位体积运动着的流体微团，体积变化的时间变化率</strong>。</p>
<h3 id="质量守恒方程（连续性方程）"><a href="#质量守恒方程（连续性方程）" class="headerlink" title="质量守恒方程（连续性方程）"></a>质量守恒方程（连续性方程）</h3><h4 id="模型1：空间位置固定的有限控制体模型"><a href="#模型1：空间位置固定的有限控制体模型" class="headerlink" title="模型1：空间位置固定的有限控制体模型"></a>模型1：空间位置固定的有限控制体模型</h4><ul>
<li><p>核心原理：流体流入（出）控制体的净质量流量 = 流体质量的增加（减少）率</p>
</li>
<li><p>方程（积分形式/守恒形式）：</p>
</li>
</ul>
<script type="math/tex; mode=display">
\frac{\partial}{\partial t}\iiint_{\mathscr{V}}\rho d\mathscr{V}+\iint_S\rho \overrightarrow{V}\cdot d\overrightarrow{S}=0</script><h4 id="模型2：随流体流动的有限控制体模型"><a href="#模型2：随流体流动的有限控制体模型" class="headerlink" title="模型2：随流体流动的有限控制体模型"></a>模型2：随流体流动的有限控制体模型</h4><ul>
<li>核心原理：控制体质量恒定</li>
<li>方程（积分形式/非守恒形式）：</li>
</ul>
<script type="math/tex; mode=display">
\frac{D}{Dt}\iiint_{\mathscr{V}}\rho d\mathscr{V}=0</script><h4 id="模型3：空间位置固定的无穷小微团模型"><a href="#模型3：空间位置固定的无穷小微团模型" class="headerlink" title="模型3：空间位置固定的无穷小微团模型"></a>模型3：空间位置固定的无穷小微团模型</h4><ul>
<li>核心原理：流体流入（出）流体微团的净质量流量 = 流体质量的增加（减少）率</li>
<li>方程（微分形式/守恒形式）：</li>
</ul>
<script type="math/tex; mode=display">
\frac{\partial \rho}{\partial t}+\overrightarrow{\nabla}\cdot (\rho \overrightarrow{V})=0</script><h4 id="模型4：随流体流动的无穷小微团模型"><a href="#模型4：随流体流动的无穷小微团模型" class="headerlink" title="模型4：随流体流动的无穷小微团模型"></a>模型4：随流体流动的无穷小微团模型</h4><ul>
<li>核心原理：控制体质量恒定</li>
<li>推导过程中使用了<strong>速度散度物理意义</strong>的公式</li>
<li>方程（微分形式/非守恒形式）：</li>
</ul>
<script type="math/tex; mode=display">
\frac{D\rho}{Dt}+\rho\overrightarrow{\nabla}\cdot\overrightarrow{V}=0</script><h4 id="四种模型的转换"><a href="#四种模型的转换" class="headerlink" title="四种模型的转换"></a>四种模型的转换</h4><ul>
<li><p>首先只需要掌握两个公式（场论课都学过）：</p>
<ol>
<li><p>散度定理：</p>
<script type="math/tex; mode=display">
\begin{aligned}\iint_{S}\overrightarrow{V}\cdot d\overrightarrow{S}=\iiint_{\Omega}\left(\overrightarrow{\nabla}\cdot \overrightarrow{V}\right)d{\Omega}\end{aligned}</script></li>
<li><p>向量恒等式：</p>
<script type="math/tex; mode=display">
\overrightarrow{\nabla}\cdot\left(\rho \overrightarrow{V}\right)=\rho \overrightarrow{\nabla}\cdot \overrightarrow{V}+\overrightarrow{V}\cdot \overrightarrow{\nabla}\rho</script></li>
</ol>
</li>
</ul>
<ul>
<li>对于<strong>积分守恒形式</strong>方程，控制体空间位置固定，有</li>
</ul>
<script type="math/tex; mode=display">
\begin{aligned}&\frac{\partial}{\partial t}\iiint_{\mathscr{V}}\rho d\mathscr{V}+\iint_S\rho \overrightarrow{V}\cdot d\overrightarrow{S}\\&=\iiint_{\mathscr{V}}\frac{\partial\rho}{\partial t} d\mathscr{V}+\iiint_\mathscr{V}\overrightarrow{\nabla}\cdot(\rho\overrightarrow{V}) d{\mathscr{V}}\\&=\iiint_\mathscr{V}\left(\frac{\partial\rho}{\partial t}+\overrightarrow{\nabla}\cdot(\rho\overrightarrow{V})\right)d\mathscr{V}\\&=0\end{aligned}</script><p>由于控制体是任取的，所以被积函数恒为零，导出<strong>微分守恒形式</strong>方程：</p>
<script type="math/tex; mode=display">
\frac{\partial \rho}{\partial t}+\overrightarrow{\nabla}\cdot (\rho \overrightarrow{V})=0</script><ul>
<li>对于<strong>微分守恒形式</strong>方程，可通过如下方式导出<strong>微分非守恒形式</strong>方程：</li>
</ul>
<script type="math/tex; mode=display">
\begin{aligned}
&\frac{\partial \rho}{\partial t}+\overrightarrow{\nabla}\cdot (\rho \overrightarrow{V})\\&=\frac{\partial \rho}{\partial t}+\rho\overrightarrow{\nabla}\cdot \overrightarrow{V}+\overrightarrow{V}\cdot\overrightarrow{\nabla}\rho\\
&=\left(\frac{\partial \rho}{\partial t}+\overrightarrow{V}\cdot\overrightarrow{\nabla}\rho\right)+\rho\overrightarrow{\nabla}\cdot \overrightarrow{V}\\
&=\frac{D\rho}{Dt}+\rho\overrightarrow{\nabla}\cdot \overrightarrow{V}
\end{aligned}</script><ul>
<li>对于<strong>积分非守恒形式</strong>方程，可通过如下方法导出<strong>积分守恒形式</strong>方程</li>
</ul>
<script type="math/tex; mode=display">
\begin{aligned}\frac{D}{Dt}\iiint_{\mathscr{V}}\rho d\mathscr{V}&=\iiint_{\mathscr{V}}\frac{D\left(\rho d\mathscr{V}\right)}{Dt}\\&=\iiint_{\mathscr{V}}\left[\rho\frac{D(d\mathscr{V})}{Dt}+d\mathscr{V}\frac{D\rho}{Dt}\right]\\&=\iiint_{\mathscr{V}}\rho\frac{D(d\mathscr{V})}{Dt}\frac{1}{d\mathscr{V}}d\mathscr{V}+\iiint_{\mathscr{V}}\frac{D\rho}{Dt}d\mathscr{V}\\&=\iiint_{\mathscr{V}}\left(\rho\overrightarrow{\nabla}\cdot \overrightarrow{V}\right)d\mathscr{V}+\iiint_{\mathscr{V}}\left(\frac{\partial \rho}{\partial t}+\overrightarrow{V}\cdot \overrightarrow{\nabla}\rho\right)d\mathscr{V}\\&=\iiint_{\mathscr{V}}\left(\rho\overrightarrow{\nabla}\cdot \overrightarrow{V}+\overrightarrow{V}\cdot \overrightarrow{\nabla}\rho\right)d\mathscr{V}+\iiint_{\mathscr{V}}\frac{\partial \rho}{\partial t}d\mathscr{V}\\&=\iiint_{\mathscr{V}}\frac{\partial \rho}{\partial t}d\mathscr{V}+\iiint_\mathscr{V}\overrightarrow{\nabla}\cdot(\rho\overrightarrow{V}) d{\mathscr{V}}\\&=\frac{\partial}{\partial t}\iiint_{\mathscr{V}}d{\mathscr{V}}+\iint_{S}\rho \overrightarrow{V}\cdot d\overrightarrow{S}\end{aligned}</script><ul>
<li>至此，所有四种模型的方程（积分/微分/守恒/非守恒 形式）可以<strong>互相转换</strong>，所以他们本质上就是<strong>一个方程：质量守恒方程</strong></li>
</ul>
<h3 id="动量方程"><a href="#动量方程" class="headerlink" title="动量方程"></a>动量方程</h3><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><ul>
<li><p>采用<strong>模型4：随流体运动的无穷小微团</strong>，利用牛顿第二定律：</p>
<script type="math/tex; mode=display">
\overrightarrow{F}=m\overrightarrow{a}</script></li>
<li><p>此处略去推导过程，只记录公式</p>
</li>
</ul>
<h4 id="动量方程式"><a href="#动量方程式" class="headerlink" title="动量方程式"></a>动量方程式</h4><ul>
<li>非守恒形式 $x、y、z$方向：</li>
</ul>
<script type="math/tex; mode=display">
\begin{aligned}
  \rho\frac{Du}{Dt}&=-\frac{\partial p}{\partial x}+\frac{\partial \tau_{xx}}{\partial x}+\frac{\partial \tau_{yx}}{\partial y}+\frac{\partial \tau_{zx}}{\partial z}+\rho f_x\\
  \rho\frac{Dv}{Dt}&=-\frac{\partial p}{\partial y}+\frac{\partial \tau_{xy}}{\partial x}+\frac{\partial \tau_{yy}}{\partial y}+\frac{\partial \tau_{zy}}{\partial z}+\rho f_y\\
  \rho\frac{Dw}{Dt}&=-\frac{\partial p}{\partial z}+\frac{\partial \tau_{xz}}{\partial x}+\frac{\partial \tau_{yz}}{\partial y}+\frac{\partial \tau_{zz}}{\partial z}+\rho f_z
  \end{aligned}</script><ul>
<li><p>守恒形式 $x、y、z$方向：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\partial(\rho u)}{\partial t}+\overrightarrow{\nabla}\cdot\left(\rho u \overrightarrow{V}\right)&=-\frac{\partial p}{\partial x}+\frac{\partial \tau_{xx}}{\partial x}+\frac{\partial \tau_{yx}}{\partial y}+\frac{\partial \tau_{zx}}{\partial z}+\rho f_x\\
\frac{\partial(\rho v)}{\partial t}+\overrightarrow{\nabla}\cdot\left(\rho v \overrightarrow{V}\right)&=-\frac{\partial p}{\partial y}+\frac{\partial \tau_{xy}}{\partial x}+\frac{\partial \tau_{yy}}{\partial y}+\frac{\partial \tau_{zy}}{\partial z}+\rho f_y\\
\frac{\partial(\rho w)}{\partial t}+\overrightarrow{\nabla}\cdot\left(\rho w \overrightarrow{V}\right)&=-\frac{\partial p}{\partial z}+\frac{\partial \tau_{xz}}{\partial x}+\frac{\partial \tau_{yz}}{\partial y}+\frac{\partial \tau_{zz}}{\partial z}+\rho f_z
\end{aligned}</script></li>
<li><p>注：关注到等号右边的几项，分别代表了流体微团所受的力，它包含：</p>
<ul>
<li><strong>表面力</strong>：压力 + 粘性力（正应力+切应力）</li>
<li><strong>体积力</strong></li>
</ul>
</li>
</ul>
<h3 id="能量守恒方程"><a href="#能量守恒方程" class="headerlink" title="能量守恒方程"></a>能量守恒方程</h3><h4 id="模型-1"><a href="#模型-1" class="headerlink" title="模型"></a>模型</h4><ul>
<li><p>采用<strong>模型4：随流体运动的无穷小微团</strong>，利用<strong>热力学第一定律</strong>：</p>
<p><strong>微团总能量的变化率 = 流入的净热流率 + 体积力和表面力对微团做功的功率</strong></p>
</li>
<li><p>注：此处<strong>总能量</strong>包括了分子和原子的<strong>所有能量</strong>（内能+动能），前者对于原子来说有<strong>平动能</strong>和<strong>电子能</strong>，对于分子（双原子及以上）来说又多出了<strong>转动能</strong>和<strong>振动能</strong></p>
</li>
<li><p>此处略去推导过程，只记录公式</p>
</li>
</ul>
<h4 id="能量守恒方程式"><a href="#能量守恒方程式" class="headerlink" title="能量守恒方程式"></a>能量守恒方程式</h4><ul>
<li><p>非守恒形式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\rho \frac{D}{Dt}\left(e+\frac{V^2}{2}\right)&=\rho\dot{q}+\frac{\partial}{\partial x}\left(k\frac{\partial T}{\partial x}\right)+\frac{\partial}{\partial y}\left(k\frac{\partial T}{\partial y}\right)+\frac{\partial}{\partial z}\left(k\frac{\partial T}{\partial z}\right)\\
&-\frac{\partial (up)}{\partial x}-\frac{\partial (vp)}{\partial y}-\frac{\partial (wp)}{\partial z}\\
&+\frac{\partial (u\tau_{xx})}{\partial x}+\frac{\partial (u\tau_{yx})}{\partial y}+\frac{\partial (u\tau_{zx})}{\partial z}\\
&+\frac{\partial (v\tau_{xy})}{\partial x}+\frac{\partial (v\tau_{yy})}{\partial y}+\frac{\partial (v\tau_{zy})}{\partial z}\\
&+\frac{\partial (w\tau_{xz})}{\partial x}+\frac{\partial (w\tau_{yz})}{\partial y}+\frac{\partial (w\tau_{zz})}{\partial z}\\
&+\rho\overrightarrow{f}\cdot\overrightarrow{V}
\end{aligned}</script></li>
<li><p>守恒形式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\frac{\partial}{\partial t}\left[\rho\left(e+\frac{V^2}{2}\right)\right]+\overrightarrow{\nabla}\cdot\left[\rho\left(e+\frac{V^2}{2}\right)\overrightarrow{V}\right]
\\
&=\rho\dot{q}+\frac{\partial}{\partial x}\left(k\frac{\partial T}{\partial x}\right)+\frac{\partial}{\partial y}\left(k\frac{\partial T}{\partial y}\right)+\frac{\partial}{\partial z}\left(k\frac{\partial T}{\partial z}\right)\\
&-\frac{\partial (up)}{\partial x}-\frac{\partial (vp)}{\partial y}-\frac{\partial (wp)}{\partial z}\\
&+\frac{\partial (u\tau_{xx})}{\partial x}+\frac{\partial (u\tau_{yx})}{\partial y}+\frac{\partial (u\tau_{zx})}{\partial z}\\
&+\frac{\partial (v\tau_{xy})}{\partial x}+\frac{\partial (v\tau_{yy})}{\partial y}+\frac{\partial (v\tau_{zy})}{\partial z}\\
&+\frac{\partial (w\tau_{xz})}{\partial x}+\frac{\partial (w\tau_{yz})}{\partial y}+\frac{\partial (w\tau_{zz})}{\partial z}\\
&+\rho\overrightarrow{f}\cdot\overrightarrow{V}
\end{aligned}</script></li>
<li><p>可以发现，能量方程和动量方程（守恒和非守恒形式）的等号左边各式的形式是一致的，而从非守恒形式转化到守恒形式时之后，仅仅是等号左边有变化而已。其转化的核心步骤如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\rho \frac{Du}{Dt}&=\rho \frac{\partial u}{\partial t}+\rho\overrightarrow{V}\cdot \overrightarrow{\nabla}u\\
&=\frac{\partial (up)}{\partial t}-u\frac{\partial \rho}{\partial t}+\overrightarrow{\nabla}(\rho u\overrightarrow{V})-u\overrightarrow{\nabla}\cdot(\rho\overrightarrow{V})\\
&=\frac{\partial(\rho u)}{\partial t}+\overrightarrow{\nabla}(\rho u \overrightarrow{V})-\left[u\frac{\partial \rho}{\partial t}+u\overrightarrow{\nabla}\cdot(\rho\overrightarrow{V})\right]
\end{aligned}</script><p>注意到中括号内为<strong>空间位置固定的流体微团模型</strong>的质量守恒方程，故有：</p>
<script type="math/tex; mode=display">
\rho \frac{Du}{Dt}=\frac{\partial(\rho u)}{\partial t}+\overrightarrow{\nabla}(\rho u \overrightarrow{V})</script><p>同样的，能量方程的守恒和非守恒式之间的关系也可由此导出。</p>
</li>
</ul>
<h3 id="无粘流的欧拉方程（Euler-Equation）"><a href="#无粘流的欧拉方程（Euler-Equation）" class="headerlink" title="无粘流的欧拉方程（Euler Equation）"></a>无粘流的欧拉方程（Euler Equation）</h3><h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><ul>
<li>忽略了<strong>耗散、粘性输运、质量扩散以及热传导</strong>的流动</li>
</ul>
<h4 id="方程式"><a href="#方程式" class="headerlink" title="方程式"></a>方程式</h4><ul>
<li><p>连续性方程</p>
<p>非守恒式：</p>
<script type="math/tex; mode=display">
\frac{D\rho}{Dt}+\rho\overrightarrow{\nabla}\cdot\overrightarrow{V}=0</script><p>守恒式：</p>
<script type="math/tex; mode=display">
\frac{\partial \rho}{\partial t}+\overrightarrow{\nabla}\cdot (\rho \overrightarrow{V})=0</script></li>
<li><p>动量方程</p>
<p>非守恒式：</p>
<script type="math/tex; mode=display">
\rho\frac{Du/v/w}{Dt}=-\frac{\partial p}{\partial x/y/z}+\rho f_{x/y/z}</script><p>守恒式：</p>
<script type="math/tex; mode=display">
\frac{\partial(\rho u/v/w)}{\partial t}+\overrightarrow{\nabla}\cdot\left(\rho u/v/w \overrightarrow{V}\right)=-\frac{\partial p}{\partial x/y/z}+\rho f_{x/y/z}\\</script></li>
<li><p>能量方程</p>
<p>非守恒式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\rho \frac{D}{Dt}\left(e+\frac{V^2}{2}\right)=\rho\dot{q}
-\frac{\partial (up)}{\partial x}-\frac{\partial (vp)}{\partial y}-\frac{\partial (wp)}{\partial z}+\rho\overrightarrow{f}\cdot\overrightarrow{V}
\end{aligned}</script><p>守恒形式：</p>
<script type="math/tex; mode=display">
\frac{\partial}{\partial t}\left[\rho\left(e+\frac{V^2}{2}\right)\right]+\overrightarrow{\nabla}\cdot\left[\rho\left(e+\frac{V^2}{2}\right)\overrightarrow{V}\right]
\\=\rho\dot{q}
-\frac{\partial (up)}{\partial x}-\frac{\partial (vp)}{\partial y}-\frac{\partial (wp)}{\partial z}+\rho\overrightarrow{f}\cdot\overrightarrow{V}</script></li>
</ul>
<h3 id="附加方程"><a href="#附加方程" class="headerlink" title="附加方程"></a>附加方程</h3><ul>
<li><p>我们发现，无论是$NS$方程还是$Euler$方程，都只有<strong>5个方程式</strong>（质量守恒1个、动量守恒3个、能量守恒1个），而其中却有<strong>6个未知数</strong>（$p、u、v、w、\rho、e$）</p>
</li>
<li><p>因此，我们需要补充方程，在空气动力学中，假设气体是<strong>完全气体</strong>（理想气体），则有状态方程：</p>
<script type="math/tex; mode=display">
p=\rho RT</script><p>但此方程又引入了新变量$T$，因此还需要补充状态参量间的热力学关系（<strong>量热状态方程</strong>），比如对定比热容的完全气体，有：</p>
<script type="math/tex; mode=display">
e=c_vT</script><p>其中$c_v$是比定容热容。</p>
</li>
</ul>
<h3 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h3><ul>
<li>对于任意特定的流动情况，其控制方程是相同的，而决定他们之间不同的因素便是<strong>边界条件</strong>（包括<strong>初始条件</strong>）</li>
</ul>
<h4 id="适合粘性流动的边界条件"><a href="#适合粘性流动的边界条件" class="headerlink" title="适合粘性流动的边界条件"></a>适合粘性流动的边界条件</h4><ul>
<li><p>无滑移条件</p>
<p>在物面处，有：</p>
<script type="math/tex; mode=display">
u=v=w=0</script><p>若壁面温度已知，则有：</p>
<script type="math/tex; mode=display">
T=T_w</script><p>若未知，由傅里叶导热定律，有：</p>
<script type="math/tex; mode=display">
\dot{q_w}=-\left(k\frac{\partial T}{\partial n}\right)_w</script><p>若为绝热壁面，有：</p>
<script type="math/tex; mode=display">
\left(\frac{\partial T}{\partial n}\right)_w=0</script></li>
<li><p>等等……</p>
</li>
</ul>
<h4 id="适合无粘流动的边界条件"><a href="#适合无粘流动的边界条件" class="headerlink" title="适合无粘流动的边界条件"></a>适合无粘流动的边界条件</h4><ul>
<li><p>无滑移条件</p>
<p>在物面处，有：</p>
<script type="math/tex; mode=display">
\overrightarrow{V}\cdot\overrightarrow{n}=0</script></li>
<li><p>等等……</p>
</li>
</ul>
<h3 id="适合CFD的控制方程"><a href="#适合CFD的控制方程" class="headerlink" title="适合CFD的控制方程"></a>适合CFD的控制方程</h3><ul>
<li><p>那必须是<strong>守恒式</strong>，其实理论上控制方程的<strong>守恒式</strong>与<strong>非守恒式</strong>是无差别的，但由于CFD的出现，导致这两者出现了区分，<strong>非守恒式</strong>所求出的解往往不尽如人意（会出现震荡or跑偏），而守恒式得出的解则较为合理。</p>
</li>
<li><p>观察$NS$方程，发现五个方程有共通的地方，可以归结为如下形式：</p>
<script type="math/tex; mode=display">
\frac{\partial U}{\partial t}+\frac{\partial F}{\partial x}+\frac{\partial G}{\partial y}+\frac{\partial H}{\partial z}=J</script><p>而其中的$U、F、G、H、J$可以从$NS$方程中得出并以<strong>列向量</strong>的形式给出</p>
</li>
<li><p>通常情况采用<strong>时间推进算法</strong>解方程（后面会学到）</p>
</li>
<li><p>通常我们把$U$命名为<strong>解向量</strong>，因为该项的分量通常就是每一时间步中直接被求解的未知函数，而$F G H$为<strong>通量项</strong>，当然我们也可以自己指定解向量</p>
</li>
</ul>
<h4 id="弱守恒-amp-强守恒"><a href="#弱守恒-amp-强守恒" class="headerlink" title="弱守恒&amp;强守恒"></a>弱守恒&amp;强守恒</h4><ul>
<li>强守恒：所有东西都写进了导数里面，没有任何流动变量单独留在导数之外（如上式）</li>
<li>弱守恒：出现了有流动变量单独留在导数之外的情形</li>
</ul>
<h4 id="激波装配法-amp-激波捕捉法"><a href="#激波装配法-amp-激波捕捉法" class="headerlink" title="激波装配法&amp;激波捕捉法"></a>激波装配法&amp;激波捕捉法</h4><ul>
<li><p>激波捕捉法：将激波作为CFD方程的计算结果，直接计算出激波的流场</p>
<p>优点：不需要事先知道激波位置，以及激波的边界条件</p>
<p>缺点：可能会与真实情况相差甚远，误差起伏大</p>
</li>
<li><p>激波装配法：利用<em>兰金-许贡钮</em>关系式，将激波人为引入到流场解中，而流动控制方程只用来解除激波之外的解</p>
<p>优点：与真实情况接近，激波位置确定</p>
<p>缺点：需要事先知道激波位置，并利用斜激波关系式引入</p>
</li>
</ul>
<hr>
<ul>
<li>心得：orz这一章的东西真TM硬核啊，看了一整天，算是把大二下的工流没弄明白的东西全给整明白了，<del>我吐了</del>。</li>
</ul>
]]></content>
      <categories>
        <category>物理</category>
      </categories>
      <tags>
        <tag>流体力学</tag>
        <tag>CFD</tag>
      </tags>
  </entry>
  <entry>
    <title>[CFD笔记3] 离散化方法</title>
    <url>/2020/02/15/CFD%E7%AC%94%E8%AE%B03-%E7%A6%BB%E6%95%A3%E5%8C%96%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="《计算流体力学基础及其应用》第四章笔记"><a href="#《计算流体力学基础及其应用》第四章笔记" class="headerlink" title="《计算流体力学基础及其应用》第四章笔记"></a><center>《计算流体力学基础及其应用》第四章笔记</center></h2><span id="more"></span>
<h3 id="有限差分法"><a href="#有限差分法" class="headerlink" title="有限差分法"></a>有限差分法</h3><p>大多数都是传热学课第四章的内容</p>
<p>差分方式：</p>
<ul>
<li><p>一阶导的向前/向后差分（一阶精度）</p>
</li>
<li><p>一阶导的中心差分（二阶精度）</p>
</li>
<li><p>二阶（混合）导的中心差分（二阶精度）</p>
</li>
<li><p>边界通过多项式方式差分（可证明为二阶精度）</p>
</li>
</ul>
<h3 id="隐式方法-amp-显式方法"><a href="#隐式方法-amp-显式方法" class="headerlink" title="隐式方法&amp;显式方法"></a>隐式方法&amp;显式方法</h3><h4 id="显式方法"><a href="#显式方法" class="headerlink" title="显式方法"></a>显式方法</h4><p>优点：编程简单，方程简单</p>
<p>缺点：需要满足稳定性条件，通常时间推进求解的时间步要很小，因此计算时间复杂度增加</p>
<h4 id="隐式方法"><a href="#隐式方法" class="headerlink" title="隐式方法"></a>隐式方法</h4><p>优点：可以使用比显式方法大很多的时间步也能保持稳定，计算时间大大缩短</p>
<p>缺点：方程和方法建立较为复杂，需要运用大型矩阵运算方法，每一步的计算时间会比显式的长（总体则不一定），编程难度大</p>
<h3 id="误差与稳定性"><a href="#误差与稳定性" class="headerlink" title="误差与稳定性"></a>误差与稳定性</h3><p><strong>离散误差</strong>： 微分方程精确解与差分方程精确解的差别</p>
<p><strong>舍入误差$\varepsilon$</strong>： 差分方程精确解与实际计算机求得解的差别（计算机有浮点数误差，C++中double通常有效位数为15位左右，但其实可以实现高精，例如Python的Decimal库高精浮点能达到很高精度）</p>
<p>显然计算机解得的解 = 舍入误差 + 差分方程精确解，那么容易得出舍入误差满足差分方程</p>
<p>对于舍入误差，需要满足时间推进过程中不能增加，因此$|\frac{\varepsilon_i^{n+1}}{\varepsilon_i^n}|\le 1$，作出误差在边界范围内的图像后，发现他类似于随机分布的函数信号（边界处误差为0，因为条件已知），考虑对误差进行<strong>傅里叶展开</strong>，得到</p>
<script type="math/tex; mode=display">
\varepsilon(x) = \sum_{m=1}^{\frac{N}{2}} A_me^{ik_mx}</script><p>考虑对于每个时间步都有此误差，所以误差也是时间$t$的函数，将振幅$A$视作指数函数增长/衰减，那么误差表示为：</p>
<script type="math/tex; mode=display">
\varepsilon(x,t) = \sum_{m=1}^{\frac{N}{2}} e^{at}e^{ik_mx}</script><p>由于误差为线性的，且级数每一项的变化趋势和级数本身相同，所以讨论这个误差函数的情况可以通过只研究其中一项的情况得到，从而可以只研究</p>
<script type="math/tex; mode=display">
\varepsilon_m(x) = e^{at}e^{ik_mx}</script><p>最后，将误差代入<strong>一阶导热</strong>的差分方程，通过一顿操作和推导（过程中用到了欧拉公式和三角函数降幂公式），得到了稳定性条件：</p>
<script type="math/tex; mode=display">
\frac{\alpha \Delta t}{(\Delta x)^2}\le \frac{1}{2}</script><p>可见，时间步$\Delta t$需要特别的小才能满足该条件</p>
<p>以上的分析法称为<strong>冯·诺依曼稳定性方法</strong>，通过此方法，可以得到一阶、二阶波动方程的稳定性条件：<strong>柯朗数小于等于1</strong>，这个条件被称为<strong>CFL准则</strong></p>
<p>一/二阶波动方程为：</p>
<script type="math/tex; mode=display">
\frac{\partial u}{\partial t} + c\frac{\partial u}{\partial x} = 0\\
\frac{\partial^2 u}{\partial^2 t} = c^2 \frac{\partial^2 u}{\partial^2 x}</script><p>他们的稳定性条件都是：</p>
<script type="math/tex; mode=display">
C = |c|\frac{\Delta t}{\Delta x}\le1</script><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>数值稳定性并不是说如果有一台无误差的计算机就不存在不稳定的现象，实际上可以广义地将数值解展开为傅里叶级数，然后用同样的冯诺依曼稳定性分析法得到对应的条件</p>
]]></content>
      <categories>
        <category>物理</category>
      </categories>
      <tags>
        <tag>流体力学</tag>
        <tag>CFD</tag>
      </tags>
  </entry>
  <entry>
    <title>DP优化策略</title>
    <url>/2022/05/16/DP%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h2 id="一些常用的DP优化套路（待更……）"><a href="#一些常用的DP优化套路（待更……）" class="headerlink" title="一些常用的DP优化套路（待更……）"></a><center>一些常用的DP优化套路（待更……）</center></h2><span id="more"></span>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>FFT(快速傅里叶变换)及优化</title>
    <url>/2020/06/30/FFT-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2-%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>最近夏令营投递结束了，抽空来学习一波FFT，其中核心内容包括了DFT（离散傅里叶变换）和IDFT（离散傅里叶逆变换），但他们的复杂度都是$O(n^2)$的，我们通过引入单位根及其相关性质将DFT和IDFT优化为FFT和IFFT，实现$O(nlogn)$的复杂度求解多项式卷积系数及相关问题。<br><span id="more"></span></p>
<p>参考blog：</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/solution/P3803">洛谷P3803 【模板】多项式乘法（FFT）</a> 的所有题解</li>
</ul>
<h2 id="前置姿势"><a href="#前置姿势" class="headerlink" title="前置姿势"></a>前置姿势</h2><h3 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h3><script type="math/tex; mode=display">
e^{ix}=\cos{x}+i\cdot \sin{x}</script><h3 id="单位根"><a href="#单位根" class="headerlink" title="单位根"></a>单位根</h3><p>满足$w^n=1$的复数$w$的<strong>集合</strong>称为$n$次单位根，通常写作$w_n$</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/23925.png" alt="23925" style="zoom:67%;" /></p>
<p>根据欧拉公式，令$x=2\pi$，得到$e^{2\pi i}=1=w_n^n$，得到$w_n=e^{\frac{2\pi i}{n}}$，称为<strong>本原单位根</strong>，显然</p>
<script type="math/tex; mode=display">
w_n=e^{\frac{2\pi i}{n}}=\cos{\frac{2\pi}{n}}+i\cdot \sin{\frac{2\pi}{n}}</script><h4 id="单位根的一些性质（可以用欧拉公式轻松证得）"><a href="#单位根的一些性质（可以用欧拉公式轻松证得）" class="headerlink" title="单位根的一些性质（可以用欧拉公式轻松证得）"></a>单位根的一些性质（可以用欧拉公式轻松证得）</h4><ul>
<li><p>$w<em>n^k=w</em>{2n}^{2k}$</p>
</li>
<li><p>$w_n^{n+k}=w_n^k$</p>
</li>
<li><p>$w_n^{k+\frac{n}{2}}=-w_n^k$</p>
</li>
<li><p>$w_n^{\frac{n}{2}}=-1$</p>
</li>
<li><p>$w_n^0=w_n^n=1$</p>
</li>
</ul>
<h3 id="多项式的系数表达法"><a href="#多项式的系数表达法" class="headerlink" title="多项式的系数表达法"></a>多项式的系数表达法</h3><p>通常情况下，通过多项式方程来表示多项式的方法就是系数表达法，可以直观的看到每项的系数，如$f(x)=3x^3+2x+5$，但如果要通过系数表达法求解两多项式的卷积，显然需要$O(n^2)$的复杂度，不能接受，因此需要考虑换一种方式求解</p>
<h3 id="多项式的点值表达法"><a href="#多项式的点值表达法" class="headerlink" title="多项式的点值表达法"></a>多项式的点值表达法</h3><p>众所周知，一个$n$次多项式可以用$n-1$个互不相同的点的坐标来表示，这就是点值表达法，它没有系数表达法那么直观，但显然，如果我们知道两个多项式的系数表达法$(x_0,y0),(x_1,y_1),…$和$(x_0,y_0’),(x_1,y_1’),…$，则可以在$O(n)$的时间内求出$(x_0,y_0y_0’),(x_1,y_1y_1’),…$，即他们卷积的点值表达法</p>
<p>因此，FFT就是通过将多项式的系数表达法转化为点值表达法（DFT），再通过点值表达法求解卷积，再转换回系数表达法（IDFT）的一个计算过程，这个过程乍一看是$o(n^2)$的，因为找出多项式的$n$个点就已经需要$O(n^2)$的时间了（找n个点$O(n)$，计算对应函数值$O(n)$），因此就出现了著名的$FFT$算法</p>
<h2 id="FFT（Fast-Fourier-Transform）"><a href="#FFT（Fast-Fourier-Transform）" class="headerlink" title="FFT（Fast Fourier Transform）"></a>FFT（Fast Fourier Transform）</h2><p>设$n-1$次多项式$A(x)$的系数为</p>
<script type="math/tex; mode=display">
(a_0,a_1,a_2,...,a_{n-1})\\即
A(x)=a_0+a_1x+a_2x^2+...+a_{n-1}x^{n-1}</script><p>将下标按照奇偶性分类，得到</p>
<script type="math/tex; mode=display">
A(x)=(a_0+a_2x^2+a_4x^4+...+a_{n-2}x^{n-2})\\
+(a_1+a_3x^3+a_5x^5+...+a_{n-1}x^{n-1})</script><p>设</p>
<script type="math/tex; mode=display">
A_1(x)=(a_0+a_2x+a_4x^2+...+a_{n-2}x^{\frac{n}{2}-1})\\
A_2(x)=(a_1+a_3x+a_5x^2+...+a_{n-1}x^{\frac{n}{2}-1})</script><p>显然可以得到</p>
<script type="math/tex; mode=display">
A(x)=A_1(x^2)+xA_2(x^2)</script><p>此时，将单位根$w_n^k(k&lt;\frac{n}{2})$代入得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
A(w_n^k)&=A_1(w_n^{2k})+w_n^kA_2(w_n^{2k})\\
&=A_1(w_{\frac{n}{2}}^{k})+w_n^kA_2(w_{\frac{n}{2}}^{k})
\end{aligned}</script><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200630204330210.png" alt="image-20200630204330210"></p>
<p>可以惊奇地发现这两个式子就只差了中间一个负号，并且表达式中的$A_1,A_2$规模为$A$的一半，且计算方法相同，因此可以递归<strong>分治</strong>计算这个式子，递归边界就是仅剩一个项的时候，此时直接返回即可</p>
<p>关于逆变换，先抛出结论：<strong>一个多项式在反分治的过程中乘上单位根的共轭复数，分治完的每一项 $/n$即为原多项式的每一项系数</strong></p>
<p>复杂度：$O(nlogn)$，但由于需要递归动态开数组，因此常数较大，但时间复杂度正确</p>
<h3 id="代码（递归版）"><a href="#代码（递归版）" class="headerlink" title="代码（递归版）"></a>代码（递归版）</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n,m;<br>complex&lt;<span class="hljs-type">double</span>&gt; f[maxn],g[maxn],ans[maxn];<br><br><span class="hljs-comment">// 递归FFT，type = 1 : DFT ; type = -1 : IDFT</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FFT</span><span class="hljs-params">(complex&lt;<span class="hljs-type">double</span>&gt; *a,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> type)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>	<span class="hljs-type">int</span> mid=n&gt;&gt;<span class="hljs-number">1</span>;<br>	complex&lt;<span class="hljs-type">double</span>&gt; a1[mid],a2[mid];<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;mid;i++)<br>		a1[i]=a[i&lt;&lt;<span class="hljs-number">1</span>],a2[i]=a[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>];<br>	<span class="hljs-built_in">FFT</span>(a1,mid,type),<span class="hljs-built_in">FFT</span>(a2,mid,type);<br>	<span class="hljs-function">complex&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">w1</span><span class="hljs-params">(cos(PI/mid),type*sin(PI/mid))</span>,<span class="hljs-title">w</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span>,x</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;mid;i++)&#123;<br>		x=w*a2[i];<br>		a[i]=a1[i]+x;<br>		a[i+mid]=a1[i]-x;<br>		w*=w1;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">read</span>(n),<span class="hljs-built_in">read</span>(m);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,x;i&lt;=n;i++) <span class="hljs-built_in">read</span>(x),f[i]=x;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,x;i&lt;=m;i++) <span class="hljs-built_in">read</span>(x),g[i]=x;<br>	<span class="hljs-type">int</span> tot=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">while</span>(tot&lt;=n+m) tot&lt;&lt;=<span class="hljs-number">1</span>;<br>	<span class="hljs-built_in">FFT</span>(f,tot,<span class="hljs-number">1</span>),<span class="hljs-built_in">FFT</span>(g,tot,<span class="hljs-number">1</span>);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,tot) ans[i]=f[i]*g[i];<br>	<span class="hljs-built_in">FFT</span>(ans,tot,<span class="hljs-number">-1</span>);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,n+m) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,(<span class="hljs-type">int</span>)(ans[i].<span class="hljs-built_in">real</span>()/tot+<span class="hljs-number">0.5</span>));<span class="hljs-comment">//记得除以tot</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="优化为迭代版本"><a href="#优化为迭代版本" class="headerlink" title="优化为迭代版本"></a>优化为迭代版本</h3><p>到洛谷模板一交，由于它时限定在了2s，因此可以通过（最慢的点要1.8s左右），但是我们能够做得更优，为了解决常数较大的问题，我们需要把<strong>递归写法改为迭代写法</strong></p>
<p>我们通过将奇偶分治的最终序列手写出来，可以发现一个规律：<strong>原序列和分治到最后的序列的对应二进制表示数互为翻转关系</strong>，这样一来，从最终分治的结果，我们先计算$a_0/a_2;a_4/a_6;a_1/a_3;a_5/a_7$，然后计算$a_0/a_1;a_2/a_3;a_4/a_5;a_6/a_7$，得到最终结果</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/1101696-20180212074250859-1560811086.png" alt="1101696-20180212074250859-1560811086" style="zoom:67%;" /></p>
<p>对于二进制翻转的操作，可以使用如下的方法获得，即 得到原序列中的数$i$在翻转序列中的位置$rev[i]$</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;tot;i++)<br>		rev[i]=(rev[i&gt;&gt;<span class="hljs-number">1</span>]&gt;&gt;<span class="hljs-number">1</span>)|((i&amp;<span class="hljs-number">1</span>)&lt;&lt;(bi<span class="hljs-number">-1</span>));<br>\*<br>基本原理：<br>    原数组的第i位为第i/<span class="hljs-number">2</span>位左移得到，则翻转数组就为右移得到<br>    奇数情况下，原数组+<span class="hljs-number">1</span>，翻转数组需要倒着+<span class="hljs-number">1</span><br>*\<br></code></pre></div></td></tr></table></figure>
<p>而求出这个$rev[]$数组还不够，我们还需要将原数组重新排列成为翻转序列的顺序，操作如下</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>		<span class="hljs-keyword">if</span>(i&lt;rev[i]) <span class="hljs-built_in">swap</span>(a[i],a[rev[i]]);<br></code></pre></div></td></tr></table></figure>
<p>这样一来，我们就可以通过枚举递归分治的区间大小，再枚举区间个数，再枚举区间中每一个数来实现迭代版的FFT</p>
<h3 id="代码（迭代版）"><a href="#代码（迭代版）" class="headerlink" title="代码（迭代版）"></a>代码（迭代版）</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> bi,rev[maxn];<br>complex&lt;<span class="hljs-type">double</span>&gt; f[maxn],g[maxn],ans[maxn];<br><br><span class="hljs-comment">// 迭代FFT，type = 1 : DFT ; type = -1 : IDFT</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FFT</span><span class="hljs-params">(complex&lt;<span class="hljs-type">double</span>&gt; *a,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> type)</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>		<span class="hljs-keyword">if</span>(i&lt;rev[i]) <span class="hljs-built_in">swap</span>(a[i],a[rev[i]]);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len=<span class="hljs-number">1</span>;len&lt;=(n&gt;&gt;<span class="hljs-number">1</span>);len&lt;&lt;=<span class="hljs-number">1</span>)&#123;<br>		<span class="hljs-function">complex&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">w1</span><span class="hljs-params">(cos(PI/len),type*sin(PI/len))</span></span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n-(len&lt;&lt;<span class="hljs-number">1</span>);i+=len&lt;&lt;<span class="hljs-number">1</span>)&#123;<br>			<span class="hljs-function">complex&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">w</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span>,x,y</span>;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;len;j++)&#123;<br>				x=a[i+j],y=w*a[i+j+len];<br>				a[i+j]=x+y,a[i+j+len]=x-y;<br>				w*=w1;<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">read</span>(n),<span class="hljs-built_in">read</span>(m);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,x;i&lt;=n;i++) <span class="hljs-built_in">read</span>(x),f[i]=x;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,x;i&lt;=m;i++) <span class="hljs-built_in">read</span>(x),g[i]=x;<br>	<span class="hljs-type">int</span> tot=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">while</span>(tot&lt;=n+m) tot&lt;&lt;=<span class="hljs-number">1</span>,bi++;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;tot;i++)<br>		rev[i]=(rev[i&gt;&gt;<span class="hljs-number">1</span>]&gt;&gt;<span class="hljs-number">1</span>)|((i&amp;<span class="hljs-number">1</span>)&lt;&lt;(bi<span class="hljs-number">-1</span>));<br>	<span class="hljs-built_in">FFT</span>(f,tot,<span class="hljs-number">1</span>),<span class="hljs-built_in">FFT</span>(g,tot,<span class="hljs-number">1</span>);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,tot) ans[i]=f[i]*g[i];<br>	<span class="hljs-built_in">FFT</span>(ans,tot,<span class="hljs-number">-1</span>);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,n+m) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,(<span class="hljs-type">int</span>)(ans[i].<span class="hljs-built_in">real</span>()/tot+<span class="hljs-number">0.5</span>));<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexoの换电脑部署操作</title>
    <url>/2020/05/08/Hexo%E3%81%AE%E6%8D%A2%E7%94%B5%E8%84%91%E9%83%A8%E7%BD%B2%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>最近小电脑用的不舒服了（屏幕小，分辨率低），于是搞了一波Hexo移植操作，整了我一下午，最后几近崩溃的时候终于成功了，特此记录。<br><span id="more"></span></p>
<p>参考教程&amp;blog：</p>
<ul>
<li><p><a href="https://www.jianshu.com/p/ca87dd7b9e00">简书-hexo换电脑</a>（很详细了，但还是少说了点坑）</p>
</li>
<li><p><a href="https://www.jianshu.com/p/af83fc73e525">【完美解决】Hexo博客出现“Cannot GET/xxx”错误</a>（最大的坑，感谢大佬）</p>
</li>
</ul>
<h3 id="第一步：拷贝原文件"><a href="#第一步：拷贝原文件" class="headerlink" title="第一步：拷贝原文件"></a>第一步：拷贝原文件</h3><p>首先可以考虑那一个U盘将原始的blog文件夹下的如下文件拷进U盘里（当然也可以传到网盘里，反正能移动到另一个电脑里就行）</p>
<p>PS：这些个东西请自己备份好</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/5312266-451b411d0373de14.jpg" alt="img"></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/5312266-b91ea07dad00ff2d.jpg" alt="img"></p>
<h3 id="第二步：在新电脑上安装配置Hexo"><a href="#第二步：在新电脑上安装配置Hexo" class="headerlink" title="第二步：在新电脑上安装配置Hexo"></a>第二步：在新电脑上安装配置Hexo</h3><p>需要先安装<code>Node.js</code>，见 <a href="https://nodejs.org/zh-cn/">Node.js官网</a>，以及<code>Git</code>环境，见 <a href="https://git-scm.com/">Git官网</a></p>
<p>然后在你想放置blog的地方新建一个文件夹，进入文件夹，右键选择<code>git bash here</code></p>
<p>输入：<code>npm install -g hexo</code> 安装hexo</p>
<p>然后输入<code>hexo init</code>初始化hexo（这里可能会一直卡着，是不正常的，可以考虑重开几次，应该一分钟内就能完成），初始化完成后，输入<code>npm install</code>安装依赖的各种包（中途可能会卡顿，这次卡属于正常现象，毕竟要安装很多包，然而我重开了好几次，可能是等不及了，最后还是选择等待，果然就好了）</p>
<p>以上步骤都完成了以后，就可以将<strong>第一步</strong>中拷贝的几个文件夹<strong>替换掉</strong>新电脑中的同名文件夹，然后记得把<code>.ssh</code>文件也替换了（或者你不嫌麻烦的话，去重新生成一个ssh，具体步骤百度吧）</p>
<h3 id="第三步：补充配置-amp-一些坑"><a href="#第三步：补充配置-amp-一些坑" class="headerlink" title="第三步：补充配置&amp;一些坑"></a>第三步：补充配置&amp;一些坑</h3><p>上一步已经基本完成了主要的换机操作，现在列出几个比较关键的补充点</p>
<p>进入到新电脑的blog文件夹内，打开<code>git bash here</code>，输入</p>
<p><code>git init</code>，初始化本地仓库</p>
<p><code>npm install hexo-deployer-git --save</code>，安装上传插件</p>
<p><code>npm i --save hexo-wordcount</code>，字数统计、阅读时长插件</p>
<p><code>npm install hexo-generator-serchdb --save</code>，搜索插件</p>
<p>最最关键的，如果此时你输入<code>hexo clean &amp;&amp; hexo g</code>，很可能在<code>public</code>文件夹下无法生成<code>index.html</code>的文件，此刻你如果<code>hexo s</code>，然后去本地服务器端口查看的话，会发现界面是个白屏，而且第一行显示<code>Cannot GET /blog/</code>，这是因为缺少插件的缘故</p>
<p>经过我的反复查询试错，最终发现了是缺少了<code>hexo-generator-index</code>插件，于是<code>npm install hexo-generator-index</code>就好了</p>
<h3 id="第四步：愉快地享用"><a href="#第四步：愉快地享用" class="headerlink" title="第四步：愉快地享用"></a>第四步：愉快地享用</h3><p>然后你就可以愉快地享用新新电脑下的hexo操作啦：<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP字符串匹配算法</title>
    <url>/2020/02/21/KMP%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="KMP-算法浅析"><a href="#KMP-算法浅析" class="headerlink" title="$KMP$算法浅析"></a><center>$KMP$算法浅析</center></h2><span id="more"></span>
<h3 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h3><ul>
<li>该算法是由$D.E.Knuth$、$J.H.Morris$、$V.R.Pratt$三位神犇提出的，因此人们称它为<strong>克努特-莫里斯-普拉特操作</strong>，简称<strong>$KMP$算法</strong></li>
<li>该算法是一种字<strong>符串匹配算法</strong>，用于寻找模式串在文本串中出现的位置（下标）、次数 等，相较于传统的暴力解法，复杂度由$O(nm)$减小到了$O(n+m)$，是速度极快的一种字符串匹配算法</li>
</ul>
<h3 id="算法思想-amp-流程"><a href="#算法思想-amp-流程" class="headerlink" title="算法思想&amp;流程"></a>算法思想&amp;流程</h3><p>举个例子</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">文本串：<span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c<br>模式串：<span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c<br></code></pre></div></td></tr></table></figure>
<p>如果使用暴力解法，在模式串指针指向<code>c</code>时，发现文本串不匹配，于是模式串指针要<strong>退回到初始位置</strong>，而文本串指针只前进一步，形成这样一个局面</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">文本串：<span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c<br>模式串：  <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c<br></code></pre></div></td></tr></table></figure>
<p>而接下来一次匹配完全是不可能匹配出答案的（无用的匹配），我们可以发现，完全可以在前一步结束后，<strong>让文本串的指针前进两步</strong>，成为下面这个形式</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">文本串：<span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c<br>模式串：    <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c<br></code></pre></div></td></tr></table></figure>
<p>换句话说，就是<strong>让模式串的指针退回两步</strong>，将模式串分割成为两个<strong>具有相同前缀</strong>的子串</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">模式串：a b | a b c <br></code></pre></div></td></tr></table></figure>
<p>这里就是出现了两个一模一样的<code>ab</code>子串，那么接下来就可以从前一个具有相同前缀的子串末尾开始继续匹配了</p>
<p>那么问题来了，这样一个操作具体如何实施呢？</p>
<p>这里定义文本串数组为<code>a</code>，模式串数组为<code>b</code></p>
<p><strong>我们定义一个数组<code>kmp[j]</code></strong><del>（很多地方next，老子就不用）</del><strong>：表示当匹配到<code>b</code>的第<code>j</code>个字母而第<code>j+1</code>个字母无法匹配的时候，新的<code>j</code>最大值是多少</strong></p>
<p>这也就是我们每次无法匹配时需要做的<strong>回退操作</strong>的核心数组，其中<code>kmp[j]</code>应该是所有满足<code>b[1...kmp[j]]==b[j-kmp[j]+1...j]</code>的最大值</p>
<p>我们需要明确的一点是：<strong>kmp数组只和模式串本身有关</strong>，我们在做kmp算法时，是先利用模式串数组来预处理好kmp数组，再利用这个处理好的kmp数组去匹配文本串数组</p>
<p><strong>而这个预处理的过程，就是模式串自己匹配自己的过程</strong><del>（我搞我自己）</del></p>
<p>因此kmp算法的大致框架就是两次匹配：一次用模式串来构造kmp数组，另一次用kmp数组来匹配文本串</p>
<p>而具体的实行方法，还是看代码吧（原谅我蒻我讲不清楚）</p>
<p>PS：一开始会觉得这个算法很神奇，而且想不明白<del>（反正蒟蒻本蒻是想了一个多小时才想明白）</del></p>
<h3 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h3><p>代码加了一点输出内容，见题目链接：<a href="https://www.luogu.com.cn/problem/P3375">洛谷 P3375 [模板]KMP字符串匹配</a></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> kmp[<span class="hljs-number">1000005</span>]; <span class="hljs-comment">//相当于next数组</span><br><span class="hljs-type">char</span> a[<span class="hljs-number">1000005</span>],b[<span class="hljs-number">1000005</span>]; <span class="hljs-comment">//a文本串 b模式串</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;a+<span class="hljs-number">1</span>; <span class="hljs-comment">//注意读取从第1位开始</span><br>	cin&gt;&gt;b+<span class="hljs-number">1</span>;<br>	<span class="hljs-type">int</span> lena=<span class="hljs-built_in">strlen</span>(a+<span class="hljs-number">1</span>),lenb=<span class="hljs-built_in">strlen</span>(b+<span class="hljs-number">1</span>); <span class="hljs-comment">//长度也需要真实长度</span><br>	<span class="hljs-comment">// 下面是构造kmp数组的过程</span><br>    <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; <span class="hljs-comment">// 模式串的指针，一开始指向模式串的最初位置，表示不能再回退了</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=lenb;i++)&#123; <span class="hljs-comment">//模式串自己匹配自己，从第2位开始</span><br>        <span class="hljs-comment">// 如果无法匹配，则回退直到可以匹配，到j=0为止（因为不能再退了）</span><br>		<span class="hljs-keyword">while</span>(j&amp;&amp;b[j+<span class="hljs-number">1</span>]!=b[i]) j=kmp[j];<br>		<span class="hljs-keyword">if</span>(b[j+<span class="hljs-number">1</span>]==b[i]) j++; <span class="hljs-comment">//如果匹配了，指针前进一步</span><br>        <br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        这一步最难理解</span><br><span class="hljs-comment">        可以把匹配过程想象成一个dp过程</span><br><span class="hljs-comment">        在达到这一步的时候已经满足了 &lt;i 的都找到了退回的答案（因为是从i=2开始）</span><br><span class="hljs-comment">        那么过完这一遍之后，kmp数组就已经成型了</span><br><span class="hljs-comment">        对于任何一位都有对应的回退之路</span><br><span class="hljs-comment">        */</span><br>		kmp[i]=j; <br>	&#125;<br>    <span class="hljs-comment">// 下面是用kmp数组去匹配文本串的过程</span><br>	j=<span class="hljs-number">0</span>; <span class="hljs-comment">// 重置指向模式串的指针</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=lena;i++)&#123; <span class="hljs-comment">// 开始匹配文本串</span><br>		<span class="hljs-keyword">while</span>(j&amp;&amp;b[j+<span class="hljs-number">1</span>]!=a[i]) j=kmp[j]; <span class="hljs-comment">//同上，只不过改成了a[i]</span><br>		<span class="hljs-keyword">if</span>(b[j+<span class="hljs-number">1</span>]==a[i]) j++; <span class="hljs-comment">//同上</span><br>		<span class="hljs-keyword">if</span>(j==lenb)&#123; <span class="hljs-comment">// 如果匹配成功了，就可以输出啦</span><br>			cout&lt;&lt;i-lenb+<span class="hljs-number">1</span>&lt;&lt;endl; <span class="hljs-comment">// 记得+1</span><br>            <span class="hljs-comment">// 如果要继续往下找就回退，实际上这里就是j=0，因为已经匹配到最后一位了，要从第一位开始重新匹配</span><br>			j=kmp[j]; <br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=lenb;i++)&#123; <span class="hljs-comment">//题目还要求输出模式串每一位的前缀下标</span><br>		cout&lt;&lt;kmp[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<hr>
<ul>
<li>太神奇了，这么美的算法居然这么早就有人提出来来了，也太强了叭Orz</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串处理</tag>
      </tags>
  </entry>
  <entry>
    <title>LSTM(Long Short-Term Memory)浅析</title>
    <url>/2020/02/17/LSTM-Long-Short-Term-Memory-%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h2 id="个人对于LSTM的原理解释"><a href="#个人对于LSTM的原理解释" class="headerlink" title="个人对于LSTM的原理解释"></a><center>个人对于LSTM的原理解释</center></h2><span id="more"></span>
<p>个人对LSTM的理解和浅析</p>
<hr>
<h2 id="LSTM（长短期记忆网络）"><a href="#LSTM（长短期记忆网络）" class="headerlink" title="LSTM（长短期记忆网络）"></a>LSTM（长短期记忆网络）</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>为了解决RNN中梯度消失的问题，即RNN无法记住时间间隔很长的信息，因此出现了LSTM网络，它的基础框架也是建立在RNN框架上的，但设计上却避免了长期依赖的问题，因为LSTM具有独特的<strong>“门”结构</strong>以帮助记住长期的信息</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>传统的RNN在每个神经元内仅通过激活函数来传递信息，实现重复学习，如下图所示<img src="https://i.loli.net/2020/02/18/PEFu6NhxOJ5l8MY.png" alt="image.png"></p>
<p>而LSTM的神经元内部却包含了诸多信息，如下图</p>
<p><img src="https://i.loli.net/2020/02/18/U7e96iCxLDR4SpX.png" alt="image.png"></p>
<p>其中粉红色圆圈代表运算操作，黄色矩阵代表学习得到的神经网络层，黑色箭头代表向量传输，所以整体看来，不仅仅是h在随时间流动，细胞状态c也在随着时间流动，实际上<strong>细胞状态c代表长期记忆</strong></p>
<h3 id="门结构"><a href="#门结构" class="headerlink" title="门结构"></a>门结构</h3><p>我们来细细分析每个神经元内部的过程（“门”结构），这是一种让信息选择通过的方法，包括一个$sigmoid$神经网络层和一个$pointwise$乘法操作</p>
<p><img src="https://i.loli.net/2020/02/18/KI61bmZzfxAj9p5.png" alt="image.png" style="zoom:67%;" /></p>
<h4 id="第一阶段：遗忘门"><a href="#第一阶段：遗忘门" class="headerlink" title="第一阶段：遗忘门"></a>第一阶段：遗忘门</h4><ul>
<li><p>决定哪些信息需要从细胞状态中被遗忘<img src="https://i.loli.net/2020/02/18/GsQp8bESeU1524F.png" alt="image.png"></p>
</li>
<li><p>它以上一层的输出$h_{t-1}$和本层的输入$x_t$作为输入，通过一个$sigmoid$激活函数的到输出$f_t$，表示上一层细胞状态被遗忘的概率</p>
</li>
</ul>
<h4 id="第二阶段：输入门"><a href="#第二阶段：输入门" class="headerlink" title="第二阶段：输入门"></a>第二阶段：输入门</h4><ul>
<li><p>决定哪些信息能够被存放到细胞状态中<img src="https://i.loli.net/2020/02/18/JO247TUzIZdYlRf.png" alt="image.png"></p>
</li>
<li><p>包含两个部分：</p>
<ol>
<li>使用$sigmoid$激活函数，输出为$i_t$</li>
<li>使用$tanh$激活函数，输出为$C_t$</li>
</ol>
</li>
</ul>
<p>其中$C_t$可表示原RNN网络中本层的输出，$i_t$表示$C_t$中的信息被保留的程度，因此$i_t*C_t$表示该层被保留的新信息</p>
<p>到目前为止，遗忘门决定$C_{t-1}$被遗忘的程度，输入门决定多少信息被保留，基于此就可以更新此刻的细胞状态了</p>
<p><img src="https://i.loli.net/2020/02/18/BTDNCbLmGcMQA6Z.png" alt="image.png"></p>
<h4 id="第三阶段：输出门"><a href="#第三阶段：输出门" class="headerlink" title="第三阶段：输出门"></a>第三阶段：输出门</h4><ul>
<li>控制盖层的细胞状态有多少被过滤</li>
</ul>
<p><img src="https://i.loli.net/2020/02/18/utRO8BSzJWU9Ga4.png" alt="image.png"></p>
<ul>
<li>先使用$sigmoid$激活函数的到一个[0,1]区间的取值$o_t$，然后将前两步得出的细胞状态$C_t$通过$tanh$激活函数处理后与$o_t$相乘，即得本层输出$h_t$</li>
</ul>
<h3 id="变形：双向LSTM"><a href="#变形：双向LSTM" class="headerlink" title="变形：双向LSTM"></a>变形：双向LSTM</h3><ul>
<li>如同双向RNN一样（同时利用过去和未来的信息），双向LSTM也能同时利用过去和未来的信息，而且通常情况会比单向LSTM预测得更加准确<img src="https://i.loli.net/2020/02/18/DlEvJKysbHSuQVg.png" alt="image.png"></li>
</ul>
<h3 id="变形：GRU（Gated-Recurrent-Unit）"><a href="#变形：GRU（Gated-Recurrent-Unit）" class="headerlink" title="变形：GRU（Gated Recurrent Unit）"></a>变形：GRU（Gated Recurrent Unit）</h3><p><img src="https://i.loli.net/2020/02/18/T86cA9QUkewXjPv.png" alt="image.png"></p>
<h4 id="门结构1：重置门-r-t"><a href="#门结构1：重置门-r-t" class="headerlink" title="门结构1：重置门$r_t$"></a>门结构1：重置门$r_t$</h4><ul>
<li>使用$sigmoid$激活函数</li>
<li>候选隐含状态$\widehat{h}_t$使用重置门$r_t$来控制$t-1$时刻信息的输入，如果$r_t$结果为0，那么上一个隐含状态的输出信息将被丢弃</li>
<li>决定过去多少信息被遗忘</li>
</ul>
<h4 id="门结构2：更新门-z-t"><a href="#门结构2：更新门-z-t" class="headerlink" title="门结构2：更新门$z_t$"></a>门结构2：更新门$z_t$</h4><ul>
<li>使用$sigmoid$函数</li>
<li>控制过去隐含状态在当前时刻的重要性，如果$z_t$趋于1，则$t$时刻之前的隐含状态将保存下来并传递到$t$时刻</li>
<li>有助于捕捉时序数据中中长期的依赖关系</li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络编程</title>
    <url>/2022/09/18/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>一些Linux网络编程的操作和姿势</p>
<span id="more"></span>
<hr>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>OJ搭建过程记录</title>
    <url>/2020/04/22/OJ%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="QDUOJ的搭建过程"><a href="#QDUOJ的搭建过程" class="headerlink" title="QDUOJ的搭建过程"></a><center>QDUOJ的搭建过程</center></h2><span id="more"></span>
<p>首先附上<a href="https://github.com/QingdaoU/OnlineJudge">QDUOJ链接</a>，不得不说，这个OJ做得太良心了（除了不能很快地导入第三方题库之外），下面记录一下过程，因为一开始用虚拟机的，没办法一直开着，因此下面主要介绍如何在Ubuntu操作系统的服务器上搭建这样一个OJ</p>
<hr>
<p>首先，你需要租一个云服务器，我选择腾讯云（学生优惠，一个ID号只能买一个，我枯了），租完之后它会发初始用户名和密码到你的邮箱里（这一步我一开始居然没看到，坑死了），然后到控制台去远程连接，进入到命令行</p>
<p>随后，就可以按照<a href="https://github.com/QingdaoU/OnlineJudgeDeploy/tree/2.0">Installation</a>的操作步骤来安装了，一步到位，十分简单</p>
<p>最后就可以在外网用服务器的IP地址访问OJ页面了，简直良心，题目和用户管理都十分方便（有GUI界面操作不就是傻瓜式操作嘛），改名出题出比赛什么的很方便</p>
<p>然后，就没了。。。</p>
]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>MergeSort理解</title>
    <url>/2020/01/19/Mergesort%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="【复习】-归并排序原理（MergeSort）"><a href="#【复习】-归并排序原理（MergeSort）" class="headerlink" title="【复习】 归并排序原理（MergeSort）"></a><center>【复习】 归并排序原理（MergeSort）</center></h2><span id="more"></span>
<ul>
<li>经典排序算法之一：归并排序（MergeSort），时间复杂度为$nlogn$，这里复习一遍。</li>
<li>以我目前所学知识而言，归并排序最常用的还是用来解决<strong><a href="https://www.luogu.com.cn/problem/P1908">逆序对</a></strong>的问题，以及其<strong>合并数组</strong>的思想可以用来解决许多难题，如<a href="https://www.luogu.com.cn/problem/P1858">多人背包</a>中合并dp数组的方法就利用了归并排序的思想。</li>
</ul>
<hr>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="原理解释"><a href="#原理解释" class="headerlink" title="原理解释"></a>原理解释</h3><p><strong>核心步骤</strong>：</p>
<ol>
<li><p>我们先开一个数组<strong>合并空间</strong>，用来存储<strong>每次排好序</strong>的序列；</p>
</li>
<li><p>对于一个无序序列，我们不断将其<strong>二分</strong>为若干组，直到每一组只剩下一个元素为止（此刻也即是每一组都是有序的了）；</p>
</li>
<li><p>设定两个指针，最初位置分别为两个<strong>已经排好序</strong>的序列的起始位置；</p>
</li>
<li><p>（递归地）从最后两个组分逐步向前，比较两串<strong>已经排好序的序列</strong>的各个元素（一顿排序工作,<u>这个时候可以发现逆序对！</u>），将较小的元素先放入<strong>合并空间</strong>，并同时移动指针，完成一轮排序；</p>
</li>
<li><p>将上步骤中两组剩余的（未放入合并空间的or指针还未指向尾部的）元素继续放入合并空间；</p>
</li>
<li><p>将排序好的<strong>合并序列</strong>赋值给左边的序列，以便下一轮递归使用；</p>
</li>
<li><p>重复3、4、5、6操作，直至整个序列有序。</p>
</li>
</ol>
<h3 id="帮助理解的图"><a href="#帮助理解的图" class="headerlink" title="帮助理解的图"></a>帮助理解的图</h3><p><img src="https://i.loli.net/2020/01/19/dEPSXwk3nmRTYlK.png" alt="帮助理解的图1"></p>
<hr>
<p><img src="https://i.loli.net/2020/01/19/N4FEKHC2w5USgBi.gif" alt="meregsort.gif"></p>
<h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> s[maxn],p[maxn];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">msort</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span>;<br>	<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>	<span class="hljs-built_in">msort</span>(l,mid);<span class="hljs-built_in">msort</span>(mid+<span class="hljs-number">1</span>,r); <span class="hljs-comment">//不断二分</span><br>    <span class="hljs-type">int</span> i=l,j=mid+<span class="hljs-number">1</span>,t=l; <br>	<span class="hljs-keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;<br>		<span class="hljs-keyword">if</span>(s[i]&gt;s[j]) p[t++]=s[i++];<br>        p[t++]=s[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid) p[t++]=s[i++];<br>    <span class="hljs-keyword">while</span>(j&lt;=r) p[t++]=s[j++];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=l;k&lt;=r;k++) s[k]=p[k];<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="模板代码（逆序对版本）"><a href="#模板代码（逆序对版本）" class="headerlink" title="模板代码（逆序对版本）"></a>模板代码（逆序对版本）</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">10000005</span>;<br><span class="hljs-type">int</span> s[maxn],p[maxn];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans; <span class="hljs-comment">//逆序对个数</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">msort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>	<span class="hljs-type">int</span> mid = (l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span>;<br>	<span class="hljs-built_in">msort</span>(l,mid);<span class="hljs-built_in">msort</span>(mid+<span class="hljs-number">1</span>,r);<br>	<span class="hljs-type">int</span> i = l, j=mid+<span class="hljs-number">1</span>,t=l;<br>	<span class="hljs-keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;<br>		<span class="hljs-keyword">if</span>(s[i]&gt;s[j])&#123;<br>			ans += mid-i+<span class="hljs-number">1</span>; <span class="hljs-comment">//出现逆序对，开始计数</span><br>			p[t++] = s[j++];<br>		&#125;<br>		<span class="hljs-keyword">else</span> p[t++] = s[i++];<br>	&#125;<br>	<span class="hljs-keyword">while</span>(i&lt;=mid) p[t++]=s[i++];<br>	<span class="hljs-keyword">while</span>(j&lt;=r) p[t++]=s[j++];<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=l;k&lt;=r;k++) s[k]=p[k];<br>	<span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> n;<br>	cin&gt;&gt;n;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>		cin&gt;&gt;s[i];<br>	<span class="hljs-built_in">msort</span>(<span class="hljs-number">1</span>,n);<br>	cout&lt;&lt;ans&lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>排序</tag>
        <tag>算法模板</tag>
      </tags>
  </entry>
  <entry>
    <title>QuickSort理解</title>
    <url>/2020/01/19/QuickSort%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="【复习】-快速排序原理（QuickSort）"><a href="#【复习】-快速排序原理（QuickSort）" class="headerlink" title="【复习】 快速排序原理（QuickSort）"></a><center>【复习】 快速排序原理（QuickSort）</center></h2><span id="more"></span>
<p><a href="https://www.luogu.com.cn/problem/P1177">题目链接</a></p>
<ul>
<li>最最常用的经典排序算法之一：快速排序（QuickSort），时间复杂度为$nlogn$，这里复习一遍。</li>
</ul>
<hr>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="原理解释"><a href="#原理解释" class="headerlink" title="原理解释"></a>原理解释</h3><p><strong>核心步骤</strong>：</p>
<ol>
<li><p>对于一个无序序列，我们首先<strong>随便</strong>选取（其实<strong>随机选取</strong>是最优的，但通常我们都选开头结尾或中间）一个<strong>key元素</strong>；</p>
</li>
<li><p>经过一顿排序，将序列中小于<strong>key元素</strong>的元素都置于其左边，大于<strong>key元素</strong>的元素，都置于其右边；</p>
</li>
<li><p>分别对<strong>key元素</strong>左右两侧的序列（也是无序的）重复1、2步骤（可以<strong>递归</strong>实现），直至整个序列有序。</p>
</li>
</ol>
<h3 id="帮助理解的图"><a href="#帮助理解的图" class="headerlink" title="帮助理解的图"></a>帮助理解的图</h3><p><img src="https://i.loli.net/2020/01/19/IFei4fSqKEZ7zQV.gif" alt="1940317-3bf6002ba2c0b90b.gif"></p>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight processing"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs processing"><span class="hljs-keyword">void</span> <span class="hljs-title function_">qsort</span>(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)&#123;<br>	<span class="hljs-type">int</span> i=l,j=r;<br>	确定<span class="hljs-built_in">key</span>;<br>	将小于<span class="hljs-built_in">key</span>的都放到<span class="hljs-built_in">key</span>左边，大于<span class="hljs-built_in">key</span>的都放到<span class="hljs-built_in">key</span>右边；<br>	<span class="hljs-keyword">if</span>(l&lt;j) <span class="hljs-title function_">qsort</span>(l,j);<br>	<span class="hljs-keyword">if</span>(r&gt;i) <span class="hljs-title function_">qsort</span>(i,r);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="模板代码（含注释）"><a href="#模板代码（含注释）" class="headerlink" title="模板代码（含注释）"></a>模板代码（含注释）</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">100000005</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">qsort</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123; <span class="hljs-comment">//quick sort function</span><br>	<span class="hljs-type">int</span> i=l,j=r,key=(l+r)&gt;&gt;<span class="hljs-number">1</span>; <span class="hljs-comment">// 中间元素定位key</span><br>	<span class="hljs-keyword">do</span>&#123; <span class="hljs-comment">//do while循环</span><br>		<span class="hljs-keyword">while</span>(a[i]&lt;a[key]) i++; <span class="hljs-comment">//从左往右找到第一个大于key的元素</span><br>		<span class="hljs-keyword">while</span>(a[j]&gt;a[key]) j--; <span class="hljs-comment">//从右往左找到第一个小于key的元素</span><br>		<span class="hljs-keyword">if</span>(i&lt;=j)&#123;<br>			<span class="hljs-built_in">swap</span>(a[i],a[j]); <span class="hljs-comment">// 交换他们俩</span><br>			i++;j--; <span class="hljs-comment">//别漏了这个</span><br>		&#125;<br>	&#125;<span class="hljs-keyword">while</span>(i&lt;=j);<br>	<span class="hljs-keyword">if</span>(l&lt;j) <span class="hljs-built_in">qsort</span>(l,j); <span class="hljs-comment">//递归 分而治之</span><br>	<span class="hljs-keyword">if</span>(r&gt;i) <span class="hljs-built_in">qsort</span>(i,r); <span class="hljs-comment">//同上</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> n;<br>	cin&gt;&gt;n;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		cin&gt;&gt;a[i]; <span class="hljs-comment">//input</span><br>	&#125;<br>	<span class="hljs-built_in">qsort</span>(<span class="hljs-number">1</span>,n); <span class="hljs-comment">//quick sort</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">//output</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>排序</tag>
        <tag>算法模板</tag>
      </tags>
  </entry>
  <entry>
    <title>My Algorithm Template</title>
    <url>/2020/05/13/My-Algorithm-Template/</url>
    <content><![CDATA[<center>Competetive Programming Code Template in C/C++</center>

<span id="more"></span>
<h3 id="杂活"><a href="#杂活" class="headerlink" title="杂活"></a>杂活</h3><h4 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bitset&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cassert&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cctype&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-comment">// #include&lt;bits/stdc++.h&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,a,b) for(register int i=a;i&lt;=b;i++)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> All(x) (x).begin(),(x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mp make_pair</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">double</span> db;<br><span class="hljs-keyword">typedef</span> vector&lt;<span class="hljs-type">int</span>&gt; VI;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI=<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps=<span class="hljs-number">1e-6</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">2147483647</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">100005</span>;<br><span class="hljs-function">ll <span class="hljs-title">qpow</span><span class="hljs-params">(ll x,ll y,ll Mod)</span> </span>&#123;ll ans=<span class="hljs-number">1</span>,base=x%Mod; <span class="hljs-keyword">while</span>(y)&#123;<span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>)ans=(ans*base)%Mod;base=(base*base)%Mod;y&gt;&gt;=<span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">return</span> ans;&#125;<br><span class="hljs-function">ll <span class="hljs-title">gcd</span><span class="hljs-params">(ll a,ll b)</span> </span>&#123;<span class="hljs-keyword">return</span> b?<span class="hljs-built_in">gcd</span>(b,a%b):a;&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="O1快速乘"><a href="#O1快速乘" class="headerlink" title="O1快速乘"></a>O1快速乘</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// O1快速乘</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">multi</span><span class="hljs-params">(ll x,ll y,ll Mod)</span></span>&#123;<br>	ll tmp=(x*y-(ll)((<span class="hljs-type">long</span> <span class="hljs-type">double</span>)x/Mod*y+<span class="hljs-number">1.0e-8</span>)*Mod);<br>	<span class="hljs-keyword">return</span> tmp&lt;<span class="hljs-number">0</span> ? tmp+Mod : tmp;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="快读-amp-快写"><a href="#快读-amp-快写" class="headerlink" title="快读&amp;快写"></a>快读&amp;快写</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// fread</span><br><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span> _nc()&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> buf[<span class="hljs-number">100000</span>],*L=buf,*R=buf;<br>    <span class="hljs-keyword">return</span> L==R&amp;&amp;(R=(L=buf)+<span class="hljs-built_in">fread</span>(buf,<span class="hljs-number">1</span>,<span class="hljs-number">100000</span>,stdin),L==R)?EOF:*L++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(T &amp;x)</span> </span>&#123;<br>	x=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> f=<span class="hljs-number">0</span>;<span class="hljs-type">char</span> ch=_nc();<br>	<span class="hljs-keyword">while</span>(ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;f|=(ch==<span class="hljs-string">&#x27;-&#x27;</span>);ch=_nc();&#125;<br>	<span class="hljs-keyword">while</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+(ch^<span class="hljs-number">48</span>);ch=_nc();&#125;<br>	x=f?-x:x;<br>	<span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// fast read</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(T &amp;x)</span> </span>&#123;<br>	x=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> f=<span class="hljs-number">0</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br>	<span class="hljs-keyword">while</span>(ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;f|=(ch==<span class="hljs-string">&#x27;-&#x27;</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<br>	<span class="hljs-keyword">while</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<br>	x=f?-x:x;<br>	<span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//fast write</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ll x)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>)<span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;<br>    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>)<span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">	KMP(文本串，模式串)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> kmp[maxn];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">KMP</span><span class="hljs-params">(<span class="hljs-type">char</span> *a,<span class="hljs-type">char</span> *b)</span></span>&#123;<br>	<span class="hljs-type">int</span> lena=<span class="hljs-built_in">strlen</span>(a+<span class="hljs-number">1</span>),lenb=<span class="hljs-built_in">strlen</span>(b+<span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>,j=<span class="hljs-number">0</span>;i&lt;=lenb;i++)&#123;<br>		<span class="hljs-keyword">while</span>(j&amp;&amp;b[j+<span class="hljs-number">1</span>]!=b[i]) j=kmp[j];<br>		<span class="hljs-keyword">if</span>(b[j+<span class="hljs-number">1</span>]==b[i]) j++;<br>		kmp[i]=j;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;i&lt;=lena;i++)&#123;<br>		<span class="hljs-keyword">while</span>(j&amp;&amp;b[j+<span class="hljs-number">1</span>]!=a[i]) j=kmp[j];<br>		<span class="hljs-keyword">if</span>(b[j+<span class="hljs-number">1</span>]==a[i]) j++;<br>		<span class="hljs-keyword">if</span>(j==lenb)&#123;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,i-j+<span class="hljs-number">1</span>);<br>			j=kmp[j];<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,a+<span class="hljs-number">1</span>);<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,b+<span class="hljs-number">1</span>);<br>	<span class="hljs-built_in">KMP</span>(a,b);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h3><h4 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> f[maxn],prime[maxn],phi[maxn],cnt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span></span>&#123;<br>	phi[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//欧拉函数：小于等于n的与n互质的正整数个数</span><br>	f[<span class="hljs-number">0</span>]=f[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//0：素数，1：合数</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=N;i++)&#123;<br>		<span class="hljs-keyword">if</span>(f[i]==<span class="hljs-number">0</span>)&#123;<br>			prime[++cnt]=i;<br>			phi[i]=i<span class="hljs-number">-1</span>;<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=N;j++)&#123;<br>			f[i*prime[j]]=<span class="hljs-number">1</span>;<br>			<span class="hljs-keyword">if</span>(i%prime[j]==<span class="hljs-number">0</span>)&#123;<br>				phi[i*prime[j]]=phi[i]*prime[j];<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<span class="hljs-keyword">else</span> phi[i*prime[j]]=phi[i]*phi[prime[j]];<span class="hljs-comment">//积性函数</span><br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">ll <span class="hljs-title">exgcd</span><span class="hljs-params">(ll a,ll b,ll &amp;x,ll &amp;y)</span></span>&#123;<span class="hljs-comment">//return gcd(a,b)</span><br>	<span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)&#123;<br>		x=<span class="hljs-number">1</span>,y=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">return</span> a;<br>	&#125;<br>	ll res=<span class="hljs-built_in">exgcd</span>(b,a%b,x,y);<br>	ll tx=x;<br>	x=y;<br>	y=tx-a/b*y;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* Matrix quick power */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">M</span><br>&#123;<br>	ll mat[<span class="hljs-number">15</span>][<span class="hljs-number">15</span>];<br>&#125;;<br><br>M <span class="hljs-keyword">operator</span> *(M x1,M x2)&#123;<br>	M res;<br>	<span class="hljs-built_in">memset</span>(res.mat,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(res.mat));<br>	<span class="hljs-comment">// n: transition matrix dimension</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;<br>				res.mat[i][j]+=(x1.mat[i][k]%mod*x2.mat[k][j]%mod)%mod;<br>				res.mat[i][j]%=mod;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// res*move^y</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> M <span class="hljs-title">mqpow</span><span class="hljs-params">(M res,M move,ll y)</span></span>&#123;<br>	<span class="hljs-keyword">while</span>(y)&#123;<br>		<span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) res=res*move;<br>		move=move*move;<br>		y&gt;&gt;=<span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></div></td></tr></table></figure>
<h3 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h3><h4 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> u,v,w,next;<br>&#125;e[maxn&lt;&lt;<span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> gcnt,head[maxn];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init_graph</span><span class="hljs-params">()</span></span>&#123;<br>	gcnt=<span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w=<span class="hljs-number">0</span>)</span></span>&#123;<br>	e[gcnt]=Edge&#123;u,v,w,head[u]&#125;;<br>	head[u]=gcnt++;<br>&#125;<br><br></code></pre></div></td></tr></table></figure>
<h4 id="并査集"><a href="#并査集" class="headerlink" title="并査集"></a>并査集</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n,k,ran[maxn],fa[maxn];<br><span class="hljs-comment">// ran:集合大小</span><br><span class="hljs-comment">// fa:父亲</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		fa[i]=i;<br>		ran[i]=<span class="hljs-number">1</span>;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>	<span class="hljs-keyword">return</span> x==fa[x]?x:fa[x]=<span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>	x=<span class="hljs-built_in">find</span>(x);<br>	y=<span class="hljs-built_in">find</span>(y);<br>	<span class="hljs-keyword">if</span>(x!=y)&#123;<br>		fa[x]=y;<br>		ran[y]+=ran[x];<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="Johnson全源最短路"><a href="#Johnson全源最短路" class="headerlink" title="Johnson全源最短路"></a>Johnson全源最短路</h4><p>包含了SPFA+负环、Dijkstra算法</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">3005</span>;<br><span class="hljs-type">int</span> n,m,ring[maxn],vis[maxn];<br>ll dis[maxn],hh[maxn];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span><br>&#123;<br>	<span class="hljs-type">int</span> u,v,w,next;<br>&#125;e[maxn&lt;&lt;<span class="hljs-number">1</span>];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br>	<span class="hljs-type">int</span> u;<br>	ll dis;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> node&amp;rhs)<span class="hljs-type">const</span>&#123;<br>		<span class="hljs-keyword">return</span> dis&gt;rhs.dis;<br>	&#125;<br>&#125;;<br><span class="hljs-type">int</span> cnt,head[maxn&lt;&lt;<span class="hljs-number">1</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w=<span class="hljs-number">0</span>)</span></span>&#123;<br>	e[cnt]=Edge&#123;u,v,w,head[u]&#125;;<br>	head[u]=cnt++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init_graph</span><span class="hljs-params">()</span></span>&#123;<br>	cnt=<span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">dij</span><span class="hljs-params">(<span class="hljs-type">int</span> st)</span></span>&#123;<span class="hljs-comment">//裸dijkstra最短路</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) dis[i]=<span class="hljs-number">1e9</span>;<br>	priority_queue&lt;node&gt; q;<br>	q.<span class="hljs-built_in">push</span>(node&#123;st,<span class="hljs-number">0</span>&#125;);<br>	dis[st]=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>		node q1=q.<span class="hljs-built_in">top</span>();<br>		q.<span class="hljs-built_in">pop</span>();<br>		<span class="hljs-type">int</span> u=q1.u;<br>		ll d=q1.dis;<br>		<span class="hljs-keyword">if</span>(d&gt;dis[u]) <span class="hljs-keyword">continue</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>			<span class="hljs-type">int</span> v=e[i].v;<br>			ll w=e[i].w;<br>			<span class="hljs-keyword">if</span>(dis[v]&gt;dis[u]+w)&#123;<br>				dis[v]=dis[u]+w;<br>				q.<span class="hljs-built_in">push</span>(node&#123;v,dis[v]&#125;);<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> st)</span></span>&#123;<span class="hljs-comment">//SPFA判负环 + 求势</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) hh[i]=<span class="hljs-number">1e9</span>;<br>	queue&lt;<span class="hljs-type">int</span>&gt; q;<br>	q.<span class="hljs-built_in">push</span>(st);<br>	hh[st]=<span class="hljs-number">0</span>;<br>	vis[st]=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>		<span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>();<br>		q.<span class="hljs-built_in">pop</span>();<br>		vis[u]=<span class="hljs-number">0</span>;<br>		ring[u]++;<br>		<span class="hljs-keyword">if</span>(ring[u]&gt;n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>			<span class="hljs-type">int</span> v=e[i].v;<br>			ll w=e[i].w;<br>			<span class="hljs-keyword">if</span>(hh[v]&gt;hh[u]+w)&#123;<br>				hh[v]=hh[u]+w;<br>				<span class="hljs-keyword">if</span>(!vis[v])&#123;<br>					vis[v]=<span class="hljs-number">1</span>;<br>					q.<span class="hljs-built_in">push</span>(v);<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>	<span class="hljs-built_in">init_graph</span>();<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>		<span class="hljs-type">int</span> u,v,w;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);<br>		<span class="hljs-built_in">addedge</span>(u,v,w);<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//从n+1向所有点连边</span><br>		<span class="hljs-built_in">addedge</span>(n+<span class="hljs-number">1</span>,i,<span class="hljs-number">0</span>);<br>	&#125;<br>	<span class="hljs-keyword">if</span>(<span class="hljs-built_in">spfa</span>(n+<span class="hljs-number">1</span>))&#123;<span class="hljs-comment">//如果有负环，返回-1</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>),<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u=<span class="hljs-number">1</span>;u&lt;=n;u++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>			e[i].w+=hh[u]-hh[e[i].v];<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-built_in">dij</span>(i);<br>		ll ans=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>			<span class="hljs-keyword">if</span>(dis[j]==<span class="hljs-number">1e9</span>)&#123;<br>				ans+=j*<span class="hljs-number">1e9</span>;<br>			&#125;<span class="hljs-keyword">else</span> ans+=j*(dis[j]+hh[j]-hh[i]);<br>		&#125;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="二分图匹配（匈牙利算法）"><a href="#二分图匹配（匈牙利算法）" class="headerlink" title="二分图匹配（匈牙利算法）"></a>二分图匹配（匈牙利算法）</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><br><span class="hljs-comment">// 匈牙利算法</span><br><span class="hljs-type">int</span> idx,have[maxn],used[maxn];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">Hungary</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(used[v]!=idx)&#123;<br>			used[v]=idx;<br>			<span class="hljs-keyword">if</span>(!have[v]||<span class="hljs-built_in">Hungary</span>(have[v]))&#123;<br>				have[v]=u;<br>				<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 二分图判定</span><br><span class="hljs-type">int</span> colr[maxn];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">isbg</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> col)</span></span>&#123;<br>	colr[u]=col;;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(colr[u]==colr[v]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!colr[v]&amp;&amp;!<span class="hljs-built_in">isbg</span>(v,<span class="hljs-number">3</span>-col)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="二分图最大权匹配（KM算法）"><a href="#二分图最大权匹配（KM算法）" class="headerlink" title="二分图最大权匹配（KM算法）"></a>二分图最大权匹配（KM算法）</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mxn=<span class="hljs-number">411</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(ch&lt;<span class="hljs-string">&#x27;0&#x27;</span> || ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<br>    <span class="hljs-keyword">while</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">&#x27;0&#x27;</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<br>    <span class="hljs-keyword">return</span> x*f;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(LL x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>)<span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">mini</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<span class="hljs-keyword">return</span> a&lt;b?a:b;&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">maxi</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<span class="hljs-keyword">return</span> a&gt;b?a:b;&#125;<br><span class="hljs-type">int</span> nL,nR,bl,br,m;<br><span class="hljs-type">int</span> visL[mxn],visR[mxn];<br><span class="hljs-type">int</span> exL[mxn],exR[mxn];<br><span class="hljs-type">int</span> link[mxn],pre[mxn],lx[mxn];<br><span class="hljs-type">int</span> slack[mxn];<br><span class="hljs-type">int</span> mp[mxn][mxn];<br><span class="hljs-comment">//</span><br>LL ans=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> a[mxn];<br><span class="hljs-type">int</span> dtime=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> q[mxn&lt;&lt;<span class="hljs-number">1</span>],hd,tl;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Aug</span><span class="hljs-params">(<span class="hljs-type">int</span> rt)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!rt)<span class="hljs-keyword">return</span>;<br>    link[rt]=pre[rt];<br>    <span class="hljs-built_in">Aug</span>(lx[pre[rt]]);<br>    lx[pre[rt]]=rt;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-type">int</span> S)</span></span>&#123;<br>    <span class="hljs-type">int</span> i,j,tmp;++dtime;<br>    <span class="hljs-built_in">memset</span>(slack,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> slack);<br>    hd=tl=<span class="hljs-number">1</span>;q[tl]=S;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">while</span>(hd&lt;=tl)&#123;<br>            <span class="hljs-type">int</span> u=q[hd];++hd;<br>            visL[u]=dtime;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=nR;i++)&#123;<br>                <span class="hljs-keyword">if</span>(visR[i]^dtime)&#123;<br>                    tmp=exL[u]+exR[i]-mp[u][i];<br>                    <span class="hljs-keyword">if</span>(!tmp)&#123;<br>                        visR[i]=dtime;pre[i]=u;<br>                        <span class="hljs-keyword">if</span>(!link[i])&#123;<br>                            <span class="hljs-built_in">Aug</span>(i);<br>                            <span class="hljs-keyword">return</span>;<br>                        &#125;<br>                        q[++tl]=link[i];<br>                        <span class="hljs-comment">//</span><br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tmp&lt;slack[i])slack[i]=tmp,pre[i]=u;<br>                &#125;<br>            &#125;<br>        &#125;<br>        tmp=INF;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=nR;i++)<span class="hljs-keyword">if</span>(visR[i]^dtime)tmp=<span class="hljs-built_in">mini</span>(tmp,slack[i]);<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=nL;i++)&#123;<br>            <span class="hljs-keyword">if</span>(visL[i]==dtime)exL[i]-=tmp;<br>            <span class="hljs-keyword">if</span>(visR[i]==dtime)exR[i]+=tmp;<br>            <span class="hljs-keyword">else</span> slack[i]-=tmp;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=nR;i++)&#123;<br>            <span class="hljs-keyword">if</span>(visR[i]^dtime &amp;&amp; !slack[i])&#123;<br>                visR[i]=dtime;<br>                <span class="hljs-keyword">if</span>(!link[i])&#123;<br><span class="hljs-comment">//                    link[i]=pre[i];</span><br>                    <span class="hljs-built_in">Aug</span>(i);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                q[++tl]=link[i];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">KM</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=nL;i++)&#123;<br>        exL[i]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=nR;j++)<br>            exL[i]=<span class="hljs-built_in">max</span>(exL[i],mp[i][j]);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=nL;i++) <span class="hljs-built_in">BFS</span>(i);<br>    ans=<span class="hljs-number">0</span>;<br>    nL=bl;nR=br;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=nR;i++)&#123;<br>        <span class="hljs-keyword">if</span>(mp[link[i]][i])&#123;<br>            a[link[i]]=i;<br>            ans+=mp[link[i]][i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=nL;i++)&#123;<br>        <span class="hljs-built_in">write</span>(a[i]);<br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> i,j;<br>    nL=<span class="hljs-built_in">read</span>();<br>    nR=<span class="hljs-built_in">read</span>();<br>    bl=nL;br=nR;<br>    nL=<span class="hljs-built_in">max</span>(nL,nR);<br>    nR=nL;<br>    m=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-type">int</span> u,v,w;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        u=<span class="hljs-built_in">read</span>();v=<span class="hljs-built_in">read</span>();w=<span class="hljs-built_in">read</span>();<br>        mp[u][v]=w;<br>    &#125;<br>    <span class="hljs-built_in">KM</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="树论"><a href="#树论" class="headerlink" title="树论"></a>树论</h3><h4 id="倍增LCA"><a href="#倍增LCA" class="headerlink" title="倍增LCA"></a>倍增LCA</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> bfa[maxn][<span class="hljs-number">21</span>],bdep[maxn];<br><span class="hljs-comment">// int bsum[maxn][21],bmax[maxn][21];</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init_beizeng</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">21</span>;++i)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>			bfa[j][i]=bfa[bfa[j][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<br>			<span class="hljs-comment">// bsum[j][i]=bsum[j][i-1]+bsum[bfa[j][i-1]][i-1];</span><br>			<span class="hljs-comment">// bmax[j][i]=max(bmax[j][i-1],bmax[bfa[j][i-1]][i-1]);</span><br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// init dfs</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">bdfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fath,<span class="hljs-type">int</span> depth)</span></span>&#123;<br>	bdep[u]=depth;<br>	bfa[u][<span class="hljs-number">0</span>]=fath;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(v!=fath)&#123;<br>			<span class="hljs-comment">// bsum[v][0]=e[i].w;</span><br>			<span class="hljs-comment">// bmax[v][0]=e[i].w;</span><br>			<span class="hljs-built_in">bdfs</span>(v,u,depth+<span class="hljs-number">1</span>);<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// LCA</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">LCA</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(bdep[x]&lt;bdep[y]) <span class="hljs-built_in">swap</span>(x,y);<br>	<span class="hljs-comment">// int Sum=0,Max=-1;</span><br>	<span class="hljs-keyword">while</span>(bdep[x]&gt;bdep[y])&#123;<br>		<span class="hljs-comment">// Sum+=bsum[x][int(log2(bdep[x]-bdep[y]))];</span><br>		<span class="hljs-comment">// Max=max(Max,bmax[x][int(log2(bdep[x]-bdep[y]))]);</span><br>		x=bfa[x][<span class="hljs-built_in">int</span>(<span class="hljs-built_in">log2</span>(bdep[x]-bdep[y]))];<br>	&#125;<br>	<span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> x;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">log2</span>(bdep[x]);i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>		<span class="hljs-keyword">if</span>(bfa[x][i]!=bfa[y][i])&#123;<br>			x=bfa[x][i],y=bfa[y][i];<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> bfa[x][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* Heavy Path Decomposition */</span><br><span class="hljs-comment">// dfs序、深度、子树大小、父节点、重儿子、链顶</span><br><span class="hljs-type">int</span> dfsx,csid[maxn],csdep[maxn],cssize[maxn],csfa[maxn],csson[maxn],cstop[maxn];<br><span class="hljs-comment">// value need to maintain</span><br><span class="hljs-type">int</span> csw[maxn];<br><br><span class="hljs-comment">// first dfs</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">csdfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fath,<span class="hljs-type">int</span> depth)</span></span>&#123;<br>	csfa[u]=fath;<br>	csdep[u]=depth;<br>	cssize[u]=<span class="hljs-number">1</span>;<br>	<span class="hljs-comment">/* long path dec */</span><br>	<span class="hljs-comment">// cssize[u]=csdep[u];</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(v!=fath)&#123;<br>			<span class="hljs-comment">/* edge to point */</span><br>			<span class="hljs-comment">// w[v]=e[i].w;</span><br>			<span class="hljs-comment">// wdep[v]+=w[v];</span><br>			<span class="hljs-built_in">csdfs1</span>(v,u,depth+<span class="hljs-number">1</span>);<br>			cssize[u]+=cssize[v];<br>			<span class="hljs-comment">/* long path dec */</span><br>			<span class="hljs-comment">// cssize[u]=max(cssize[u],cssize[v]);</span><br>			<span class="hljs-keyword">if</span>(cssize[v]&gt;cssize[csson[u]])<br>				csson[u]=v;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">//second dfs</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">csdfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> topf)</span></span>&#123;<br>	csid[u]=++dfsx;<br>	<span class="hljs-comment">/* value need to maintain */</span><br>	<span class="hljs-comment">// csw[dfsx]=u;</span><br>	cstop[u]=topf;<br>	<span class="hljs-keyword">if</span>(!csson[u]) <span class="hljs-keyword">return</span>;<br>	<span class="hljs-built_in">csdfs2</span>(csson[u],topf);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(v!=csfa[u]&amp;&amp;v!=csson[u])<br>			<span class="hljs-built_in">csdfs2</span>(v,v);<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">/*--------------------------------------*/</span><br><br><span class="hljs-comment">// get LCA</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">LCA</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>	<span class="hljs-keyword">while</span>(cstop[x]!=cstop[y])&#123;<br>		<span class="hljs-keyword">if</span>(csdep[cstop[x]]&lt;csdep[cstop[y]])<br>			<span class="hljs-built_in">swap</span>(x,y);<br>		x=csfa[cstop[x]];<br>	&#125;<br>	<span class="hljs-keyword">return</span> csdep[x]&lt;csdep[y]?x:y;<br>&#125;<br><br><span class="hljs-comment">// [x,y] + k</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addroute</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> k)</span></span>&#123;<br>	<span class="hljs-keyword">while</span>(cstop[x]!=cstop[y])&#123;<br>		<span class="hljs-keyword">if</span>(csdep[cstop[x]]&lt;csdep[cstop[y]])<br>			<span class="hljs-built_in">swap</span>(x,y);<br>		<span class="hljs-comment">// Segment Tree: add(i,l,r,k)</span><br>		<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,csid[cstop[x]],csid[x],k);<br>		x=csfa[cstop[x]];<br>	&#125;<br>	<span class="hljs-keyword">if</span>(csdep[x]&gt;csdep[y]) <span class="hljs-built_in">swap</span>(x,y);<br>	<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,csid[x],csid[y],k);<br>&#125;<br><br><span class="hljs-comment">// get [x,y] sum</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">getroutesum</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>	ll res=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(cstop[x]!=cstop[y])&#123;<br>		<span class="hljs-keyword">if</span>(csdep[cstop[x]]&lt;csdep[cstop[y]])<br>			<span class="hljs-built_in">swap</span>(x,y);<br>		<span class="hljs-comment">// Segment Tree: getsum(i,l,r)</span><br>		res+=<span class="hljs-built_in">getsum</span>(<span class="hljs-number">1</span>,csid[cstop[x]],csid[x],k);<br>		x=csfa[cstop[x]];<br>	&#125;<br>	<span class="hljs-keyword">if</span>(csdep[x]&gt;csdep[y]) <span class="hljs-built_in">swap</span>(x,y);<br>	res+=<span class="hljs-built_in">getsum</span>(<span class="hljs-number">1</span>,csid[x],csid[y],k);<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="区间操作-amp-RMQ"><a href="#区间操作-amp-RMQ" class="headerlink" title="区间操作&amp;RMQ"></a>区间操作&amp;RMQ</h3><h4 id="ST表"><a href="#ST表" class="headerlink" title="ST表"></a>ST表</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// Sparse Table</span><br><span class="hljs-type">int</span> n,m,a[maxn],ST[maxn][<span class="hljs-number">23</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init_st</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//st init</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) ST[i][<span class="hljs-number">0</span>]=a[i];<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;(<span class="hljs-number">1</span>&lt;&lt;j)&lt;=n;j++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))<span class="hljs-number">-1</span>&lt;=n;i++)&#123;<br>			ST[i][j]=<span class="hljs-built_in">max</span>(ST[i][j<span class="hljs-number">-1</span>],ST[i+(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))][j<span class="hljs-number">-1</span>]);<br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123; <span class="hljs-comment">//查询l,r最值</span><br>	<span class="hljs-type">int</span> len=<span class="hljs-built_in">log2</span>(r-l+<span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(ST[l][len],ST[r-(<span class="hljs-number">1</span>&lt;&lt;len)+<span class="hljs-number">1</span>][len]);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">ll c[maxn];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> x&amp;-x;&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i,ll k)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(i&lt;=n) c[i]+=k,i+=<span class="hljs-built_in">lowbit</span>(i);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>    ll res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">0</span>) res+=c[pos],i-=<span class="hljs-built_in">lowbit</span>(i);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="普通线段树"><a href="#普通线段树" class="headerlink" title="普通线段树"></a>普通线段树</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* Normal Segment Tree */</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegmentTree</span><br>&#123;	<br>	<span class="hljs-meta">#<span class="hljs-keyword">define</span> ls i&lt;&lt;1</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">define</span> rs i&lt;&lt;1|1</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tree</span>&#123;<br>		<span class="hljs-type">int</span> l,r;<br>		ll sum,ptg;<br>	&#125;tr[maxn&lt;&lt;<span class="hljs-number">2</span>];<br><br>	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>		tr[i].sum=(tr[ls].sum+tr[rs].sum)%mod;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>		<span class="hljs-keyword">if</span>(tr[i].ptg==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>		ll k=tr[i].ptg%mod;<br>		tr[ls].sum=(tr[ls].sum+k*(tr[ls].r-tr[ls].l+<span class="hljs-number">1</span>)%mod)%mod;<br>		tr[rs].sum=(tr[rs].sum+k*(tr[rs].r-tr[rs].l+<span class="hljs-number">1</span>)%mod)%mod;<br>		tr[ls].ptg=(tr[ls].ptg+k)%mod;<br>		tr[rs].ptg=(tr[rs].ptg+k)%mod;<br>		tr[i].ptg=<span class="hljs-number">0</span>;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>		tr[i].l=l,tr[i].r=r;<br>		tr[i].ptg=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">if</span>(tr[i].l==tr[i].r)&#123;<br>			tr[i].sum=a[l]%mod;<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>		<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>		<span class="hljs-built_in">build</span>(ls,l,mid);<br>		<span class="hljs-built_in">build</span>(rs,mid+<span class="hljs-number">1</span>,r);<br>		<span class="hljs-built_in">push_up</span>(i);<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">changepoint</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> pos,ll k)</span></span>&#123;<br>		<span class="hljs-keyword">if</span>(tr[i].l==tr[i].r)&#123;<br>			tr[i].sum=k%mod;<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>		<span class="hljs-built_in">push_down</span>(i);<br>		<span class="hljs-keyword">if</span>(tr[ls].r&gt;=pos) <span class="hljs-built_in">changepoint</span>(ls,pos,k);<br>		<span class="hljs-keyword">else</span> <span class="hljs-built_in">changepoint</span>(rs,pos,k);<br>		<span class="hljs-built_in">push_up</span>(i);<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addinterval</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,ll k)</span></span>&#123;<br>		<span class="hljs-keyword">if</span>(tr[i].l&gt;=l&amp;&amp;tr[i].r&lt;=r)&#123;<br>			tr[i].sum=(tr[i].sum+k*(tr[i].r-tr[i].l+<span class="hljs-number">1</span>)%mod)%mod;<br>			tr[i].ptg=(tr[i].ptg+k)%mod;<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>		<span class="hljs-built_in">push_down</span>(i);<br>		<span class="hljs-keyword">if</span>(tr[ls].r&gt;=l) <span class="hljs-built_in">addinterval</span>(ls,l,r,k);<br>		<span class="hljs-keyword">if</span>(tr[rs].l&lt;=r) <span class="hljs-built_in">addinterval</span>(rs,l,r,k);<br>		<span class="hljs-built_in">push_up</span>(i);<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>		<span class="hljs-keyword">if</span>(tr[i].l&gt;=l&amp;&amp;tr[i].r&lt;=r)<br>			<span class="hljs-keyword">return</span> tr[i].sum;<br>		<span class="hljs-built_in">push_down</span>(i);<br>		ll res=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">if</span>(tr[ls].r&gt;=l) res=(res+<span class="hljs-built_in">getsum</span>(ls,l,r))%mod;<br>		<span class="hljs-keyword">if</span>(tr[rs].l&lt;=r) res=(res+<span class="hljs-built_in">getsum</span>(rs,l,r))%mod;<br>		<span class="hljs-keyword">return</span> res;<br>	&#125;<br>&#125;T;<br></code></pre></div></td></tr></table></figure>
<h4 id="珂朵莉树ODT"><a href="#珂朵莉树ODT" class="headerlink" title="珂朵莉树ODT"></a>珂朵莉树ODT</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IT set<span class="hljs-string">&lt;odtnode&gt;</span>::iterator</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">odtnode</span><br>&#123;<br>	<span class="hljs-type">int</span> l,r;<br>	<span class="hljs-keyword">mutable</span> ll v;<br>	<span class="hljs-built_in">odtnode</span>(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R=<span class="hljs-number">-1</span>,ll V=<span class="hljs-number">0</span>):<span class="hljs-built_in">l</span>(L),<span class="hljs-built_in">r</span>(R),<span class="hljs-built_in">v</span>(V)&#123;&#125;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> odtnode&amp; rhs)<span class="hljs-type">const</span>&#123;<br>		<span class="hljs-keyword">return</span> l&lt;rhs.l;<br>	&#125;<br>&#125;;<br>set&lt;odtnode&gt; odt;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> IT <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span></span>&#123;<br>	IT it=odt.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-built_in">odtnode</span>(pos));<br>	<span class="hljs-keyword">if</span>(it!=odt.<span class="hljs-built_in">end</span>()&amp;&amp;it-&gt;l==pos) <span class="hljs-keyword">return</span> it;<br>	it--;<br>	<span class="hljs-type">int</span> l=it-&gt;l,r=it-&gt;r;<br>	ll v=it-&gt;v;<br>	odt.<span class="hljs-built_in">erase</span>(it);<br>	odt.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">odtnode</span>(l,pos<span class="hljs-number">-1</span>,v));<br>	<span class="hljs-keyword">return</span> odt.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">odtnode</span>(pos,r,v)).first;<br>&#125;<br><br><span class="hljs-comment">// Assign to same value</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,ll k)</span></span>&#123;<br>	IT itr=<span class="hljs-built_in">split</span>(r+<span class="hljs-number">1</span>),itl=<span class="hljs-built_in">split</span>(l);<br>	odt.<span class="hljs-built_in">erase</span>(itl,itr);<br>	odt.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">odtnode</span>(l,r,k));<br>&#125;<br><br><br><span class="hljs-comment">// [l,r] + k</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,ll k)</span></span>&#123;<br>	IT itr=<span class="hljs-built_in">split</span>(r+<span class="hljs-number">1</span>),itl=<span class="hljs-built_in">split</span>(l);<br>	<span class="hljs-keyword">for</span>(;itl!=itr;itl++) itl-&gt;v+=k;<br>&#125;<br><br><span class="hljs-comment">// kth small</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">kths</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<br>	IT itr=<span class="hljs-built_in">split</span>(r+<span class="hljs-number">1</span>),itl=<span class="hljs-built_in">split</span>(l);<br>	vector&lt;pair&lt;ll,<span class="hljs-type">int</span>&gt;&gt; vec;<br>	vec.<span class="hljs-built_in">clear</span>();<br>	<span class="hljs-keyword">for</span>(;itl!=itr;itl++)&#123;<br>		vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pair</span>&lt;ll,<span class="hljs-type">int</span>&gt;(itl-&gt;v,itl-&gt;r-itl-&gt;l+<span class="hljs-number">1</span>));<br>	&#125;<br>	<span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(),vec.<span class="hljs-built_in">end</span>());<br>	<span class="hljs-keyword">for</span>(vector&lt;pair&lt;ll,<span class="hljs-type">int</span>&gt;&gt;::iterator it=vec.<span class="hljs-built_in">begin</span>();it!=vec.<span class="hljs-built_in">end</span>();it++)&#123;<br>		k-=it-&gt;second;<br>		<span class="hljs-keyword">if</span>(k&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> it-&gt;first;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">-1ll</span>;<br>&#125;<br><br><span class="hljs-comment">// x pow sum mod y</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">xpowsum</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,ll x,ll y)</span></span>&#123;<br>	IT itr=<span class="hljs-built_in">split</span>(r+<span class="hljs-number">1</span>),itl=<span class="hljs-built_in">split</span>(l);<br>	ll res=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(;itl!=itr;itl++)&#123;<br>		res=((res+(itl-&gt;r-itl-&gt;l+<span class="hljs-number">1</span>)*<span class="hljs-built_in">qpow</span>(itl-&gt;v,x,y)%y)%y+y)%y;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h3><h4 id="判断两线段是否相交"><a href="#判断两线段是否相交" class="headerlink" title="判断两线段是否相交"></a>判断两线段是否相交</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 点结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span><br>&#123;<br>    <span class="hljs-type">double</span> x,y;<br>&#125;;<br><span class="hljs-comment">// 线段结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Line</span><br>&#123;<br>    Point ps,pe;<br>&#125;;<br><br><span class="hljs-comment">// 求叉积：CA x CB</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">mult</span><span class="hljs-params">(Point c,Point a,Point b)</span></span>&#123;<span class="hljs-keyword">return</span> (a.x-c.x)*(b.y-c.y)-(b.x-c.x)*(a.y-c.y);&#125;<br><br><span class="hljs-comment">// 判断 AB和CD 是否有交点</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">intersect</span><span class="hljs-params">(Point a,Point b,Point c,Point d)</span></span>&#123;<br>    <span class="hljs-comment">//判投影</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">max</span>(a.x,b.x)&lt;<span class="hljs-built_in">min</span>(c.x,d.x)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">max</span>(a.y,b.y)&lt;<span class="hljs-built_in">min</span>(c.y,d.y)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">max</span>(c.x,d.x)&lt;<span class="hljs-built_in">min</span>(a.x,b.x)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">max</span>(c.y,d.y)&lt;<span class="hljs-built_in">min</span>(a.y,b.y)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//判叉积</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">mult</span>(a,c,b)*<span class="hljs-built_in">mult</span>(a,b,d)&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">mult</span>(c,a,d)*<span class="hljs-built_in">mult</span>(c,d,b)&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>代码模板</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析Note</title>
    <url>/2022/08/16/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90Note/</url>
    <content><![CDATA[<p>侯捷老师的《STL源码剖析》阅读笔记（个人理解向）<br><span id="more"></span></p>
<h2 id="第2章-空间配置器（allocator）"><a href="#第2章-空间配置器（allocator）" class="headerlink" title="第2章 空间配置器（allocator）"></a>第2章 空间配置器（allocator）</h2><ul>
<li>SGI STL实现了一种具有次层配置（sub-allocation）能力的特殊空间配置器</li>
</ul>
<h3 id="SGI标准的空间配置器：std-allocator"><a href="#SGI标准的空间配置器：std-allocator" class="headerlink" title="SGI标准的空间配置器：std::allocator"></a>SGI标准的空间配置器：<code>std::allocator</code></h3><p>效率低下，仅仅是把<code>::operator new, ::operator delete</code>做了一层封装而已</p>
<h3 id="SGI特殊的空间配置器：std-alloc"><a href="#SGI特殊的空间配置器：std-alloc" class="headerlink" title="SGI特殊的空间配置器：std::alloc"></a>SGI特殊的空间配置器：<code>std::alloc</code></h3><ul>
<li><p><code>new</code>的过程：先调用<code>::operator new</code>分配内存，再调用<code>::construct()</code>构造对象</p>
</li>
<li><p><code>delete</code>的过程：先调用<code>::destroy()</code>调用对象的析构函数，再调用<code>::operator delete</code>释放内存</p>
</li>
</ul>
<p>在实现上，对象的构造析构 与 内存的分配释放分开实现，<code>alloc::allocate()</code>和<code>alloc::deallocate()</code>负责内存分配和释放，<code>::construct()</code>和<code>::destroy()</code>负责构造析构。</p>
<h4 id="构造和析构"><a href="#构造和析构" class="headerlink" title="构造和析构"></a>构造和析构</h4><p><code>::construct()</code>：使用<code>&lt;new.h&gt;</code>中的<code>placement new</code>运算子在特定指针所指空间上构造对象（注意与<code>new</code>区分）</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220816145905378.png" alt="construct" style="zoom:67%;" /></p>
<p><code>::destroy()</code>：直接调用析构函数（另外需要考虑是否具有trivial destructor，如果有就什么也不做，否则遍历整个范围一个个释放）</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220816150152073.png" alt="destroy" style="zoom:67%;" /></p>
<h4 id="内存分配与释放"><a href="#内存分配与释放" class="headerlink" title="内存分配与释放"></a>内存分配与释放</h4><p>特点：<strong>双层级配置器</strong>，第一层直接使用<code>malloc(), free()</code>，第二层（STL默认使用的）采用内存池（memory pool）和第一层结合的方式。简单来说，第二层是为了减小多次分配和释放内存的开销（因为malloc会附带一些额外的占空间的cookie和内存）而设计的。具体地，在第二层维护一个长度为<strong>16</strong>（default）的数组，数组元素是一个链表，因此叫他<strong>自由链表</strong>（free lists，类似块状链表，不过是反过来的），负责16种内存大小的次配置能力（每个元素负责<strong>8的倍数个byte</strong>的内存大小的区块）。如下所示，因此最多是<strong>128bytes</strong>，超过这个值得内存分配就会直接调用第一层的配置器。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gherkin">|<span class="hljs-string">       </span>|<span class="hljs-string">        </span>|<span class="hljs-string">     </span>|<span class="hljs-string">           </span>|<br>|<span class="hljs-string"> [0,8) </span>|<span class="hljs-string"> [8,16) </span>|<span class="hljs-string"> ... </span>|<span class="hljs-string"> [120,128) </span>|<br>|<span class="hljs-string">       </span>|<span class="hljs-string">        </span>|<span class="hljs-string">     </span>|<span class="hljs-string">           </span>|<br></code></pre></div></td></tr></table></figure>
<p>在这个数据结构的实现上，采用了<code>union</code>结构以节省内存开销，也就是说，这个数组中的每个元素既能指向另一个相同类型元素，又能指向实际区块。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">union</span> <span class="hljs-title class_">obj</span>&#123;<br>    <span class="hljs-keyword">union</span> <span class="hljs-title class_">obj</span> *free_list_link;<br>    <span class="hljs-type">char</span> client_data[<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><code>allocate()和deallocate()</code>函数的实现就如上方所讲，首先找到符合的内存对应的自由链表位置，然后分配和释放内存。</p>
<p><code>refill()</code>函数的作用：重新填充free list的空间（默认值20个新区块），新空间取自内存池（由<code>chunk_alloc()</code>完成）</p>
<p><code>chunk_alloc()</code>函数作用：从内存池取空间给free lists，具体实现如下：</p>
<ul>
<li>如果内存池剩余空间完全满足需求量：取空间分配给free lists</li>
<li><p>如果内存池剩余空间不能完全满足需求量（但满足&gt;=1个）：取上限量分配给free lists</p>
</li>
<li><p>如果内存池空：如果内存池还有零头可用，则先编入，再调用<code>malloc()</code>从heap空间申请（两倍+附加量）的内存</p>
</li>
</ul>
<h3 id="内存基本处理工具"><a href="#内存基本处理工具" class="headerlink" title="内存基本处理工具"></a>内存基本处理工具</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">construct</span>();<br><span class="hljs-built_in">destroy</span>();<br><span class="hljs-built_in">uninitialized_copy</span>();<br><span class="hljs-built_in">uninitialized_fill</span>();<br><span class="hljs-built_in">uninitialized_fill_n</span>();<br></code></pre></div></td></tr></table></figure>
<h2 id="第3章-迭代器（iterators）与traits编程技法"><a href="#第3章-迭代器（iterators）与traits编程技法" class="headerlink" title="第3章 迭代器（iterators）与traits编程技法"></a>第3章 迭代器（iterators）与traits编程技法</h2><h3 id="迭代器所指对象型别的实现——traits与偏特化"><a href="#迭代器所指对象型别的实现——traits与偏特化" class="headerlink" title="迭代器所指对象型别的实现——traits与偏特化"></a>迭代器所指对象型别的实现——traits与偏特化</h3><p>采用一个迭代器traits来“萃取”迭代器特性：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220816184424217.png" alt="traits技法" style="zoom:67%;" /></p>
<p>如果类<code>I</code>定义了自己的value type（类似的，还有difference type, pointer, reference, iterator category），那么就可以直接获取。如果<code>I</code>是原生指针或常量指针，则可以通过<strong>类模板偏特化</strong>自己实现：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220816184656436.png" alt="偏特化指针类型" style="zoom:67%;" /></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220816184714316.png" alt="偏特化常量指针" style="zoom:67%;" /></p>
<p>类似地，以下迭代器型别都需要针对原生指针定义偏特化版本：</p>
<p><code>value_type</code>：迭代器所指对象的型别</p>
<p><code>difference_type</code>：表示两个迭代器之间的距离</p>
<p><code>reference_type</code>：(*迭代器)的型别</p>
<p><code>piointer_type</code>：一个地址，指向迭代器所指的量</p>
<p><code>iterator_category</code>：迭代器的类别（5种）</p>
<p>对于<code>iterator_category</code>，在偏特化的时候，只需偏特化定义<code>random_access_iterator_tag</code>即可，因为：</p>
<blockquote>
<p>任何一个迭代器，其类型永远应该落在“该迭代器所隶属之各种类型中，最强化的那个”。</p>
</blockquote>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220816201433359.png" alt="random_access_iterator_tag" style="zoom: 67%;" /></p>
<p>但是，在定义STL算法的时候，函数可以接受各种类型的迭代器，因此：</p>
<blockquote>
<p>以算法所能接受之最低阶迭代器类型，来为其迭代器型别参数命名。</p>
</blockquote>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220816201051787.png" alt="advance方法" style="zoom: 67%;" /></p>
<p>任何迭代器都应该提供这五个内嵌型别，因此为了统一定义，STL提供iterator class，每个新设计的迭代器都继承自它：（注意到后三个参数都有默认值）</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220816212710761.png" alt="iterator class" style="zoom: 67%;" /></p>
<h3 id="type-traits"><a href="#type-traits" class="headerlink" title="__type_traits"></a>__type_traits</h3><p>除了iterator可以有traits技法之外，SGI-STL将其扩展为用于萃取型别的特性的<code>__type_traits</code></p>
<p>此举允许针对不同的型别属性，在编译时期就完成函数派送决定（例如，如果一个型别具备trivial_default_constructor等等，就可以不用constructor等，而是直接采用内存处理操作，比如<code>malloc(),memecpy()</code>)</p>
<p>在定义<code>__type_traits</code>类时，初始将所有内嵌型别都默认为<code>__false_type</code>，随后再针对所有标量型别进行特化，这样就可以实现这一功能。</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220818211117731.png" alt="__type_traits定义" style="zoom:50%;" /></p>
<p>注意在定义<code>__true_type, __false_type</code>时直接定义了一个类，以满足函数传参的自动推导：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220818211151078.png" alt="__true_type, __false_type定义" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>ST表浅析</title>
    <url>/2020/03/16/ST%E8%A1%A8/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<h2 id="ST表（稀疏表Sparse-Table）"><a href="#ST表（稀疏表Sparse-Table）" class="headerlink" title="ST表（稀疏表Sparse Table）"></a>ST表（稀疏表Sparse Table）</h2><p>参考<a href="https://www.cnblogs.com/zwfymqz/p/8581995.html">一位神犇的博客</a></p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>解决<a href="https://baike.baidu.com/item/rmq/1797559?fr=aladdin">RMQ(Range Minimun/Maximun Query)</a>问题的利器（当然也有别的更牛逼的方法，比如 树状数组or线段树）</p>
<p>复杂度：</p>
<ul>
<li><p>预处理：$O(nlogn)$</p>
</li>
<li><p>查询：$O(1)$</p>
</li>
</ul>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>ST表利用的是<strong>倍增</strong>的思想（就是c++里面vector实现用的思想）</p>
<p>拿最大值来说，我们用$Max[i][j]$表示<strong>从$i$位置开始的$2^j$个数中的最大值</strong>，注意，这里的<code>i</code>代表区间左端点，而<code>j</code>代表<code>2^j</code>的区间长度，即$[i,i+2^j-1]$这个区间的最大值</p>
<p>ST表的构建类似一个<strong>区间dp</strong>的过程，首先枚举区间长度，再枚举区间左端点，最后进行状态转移，而转移过程如下：</p>
<p><img src="https://images2018.cnblogs.com/blog/1101696/201803/1101696-20180317093105594-446018365.png" alt="6663"></p>
<p>它将每个区间分为两段，分别比较两段的最大值更新到当前区间的最大值</p>
<p>查询时，只需计算出$log_2(区间长度)$，然后根据左右端点分别查询一次取最大值即可，至于为什么要查询两次比较取最值，是因为$l+2^k-1$很有可能不是右端点（因为长度取对数取整了），同理$r-2^k+1$也可能不是左端点，但$[l,l+2^k-1]$he$[r-2^k+1,r]$这两个区间一定会有交集（如下图）</p>
<p><img src="https://images2018.cnblogs.com/blog/1101696/201803/1101696-20180317094520949-961365919.png" alt="123"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>注意事项：</p>
<ul>
<li><p>预处理第一步<strong>切记要初始化</strong>：把$ST[i][0]$（从<code>i</code>位开始区间长为1，也就是序列本身）都设置为对应序列的原始值</p>
</li>
<li><p><strong>区间长度的枚举范围</strong>（即ST表第二维的大小）取决于<strong>题目查询数据的范围</strong>，取$log2(查询范围)$就够用了</p>
</li>
<li><p>预处理时内层循环需要<strong>控制边界</strong>，右端点不能越界</p>
</li>
</ul>
<p>预处理：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) ST[i][<span class="hljs-number">0</span>]=a[i]; <span class="hljs-comment">// 初始化</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;(<span class="hljs-number">1</span>&lt;&lt;j)&lt;=n;j++)&#123; <span class="hljs-comment">//枚举区间长度</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))<span class="hljs-number">-1</span>&lt;=n;j++)&#123; <span class="hljs-comment">//枚举左端点</span><br>        ST[i][j]=max/<span class="hljs-built_in">min</span>(ST[i][j<span class="hljs-number">-1</span>],ST[i+(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))][j<span class="hljs-number">-1</span>]);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>查询：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-type">int</span> len=<span class="hljs-built_in">log2</span>(r-l+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> max/<span class="hljs-built_in">min</span>(ST[i][len],ST[r-(<span class="hljs-number">1</span>&lt;&lt;len)+<span class="hljs-number">1</span>][len]);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><a href="https://www.luogu.com.cn/problem/P3865">【模板】ST表</a>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100005</span><br><span class="hljs-type">int</span> n,m,a[N],ST[N][<span class="hljs-number">23</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> len=<span class="hljs-built_in">log2</span>(N);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=len;j++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))<span class="hljs-number">-1</span>&lt;=n;i++)&#123;<br>			ST[i][j]=<span class="hljs-built_in">max</span>(ST[i][j<span class="hljs-number">-1</span>],ST[i+(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))][j<span class="hljs-number">-1</span>]);<br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>	<span class="hljs-type">int</span> len=<span class="hljs-built_in">log2</span>(r-l+<span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(ST[l][len],ST[r-(<span class="hljs-number">1</span>&lt;&lt;len)+<span class="hljs-number">1</span>][len]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]),ST[i][<span class="hljs-number">0</span>]=a[i];<br>	<span class="hljs-built_in">init</span>();<br>	<span class="hljs-type">int</span> l,r;<br>	<span class="hljs-keyword">while</span>(m--)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">query</span>(l,r));<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux与操作系统</title>
    <url>/2022/08/27/Linux%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>一些OS和Linux的前置姿势</p>
<span id="more"></span>
<hr>
<h1 id="Linux-amp-OS"><a href="#Linux-amp-OS" class="headerlink" title="Linux &amp; OS"></a>Linux &amp; OS</h1><h2 id="静态库和动态库"><a href="#静态库和动态库" class="headerlink" title="静态库和动态库"></a>静态库和动态库</h2><ul>
<li><p>静态库：链接时将静态库内容复制到程序中，与程序一起打包成可执行文件</p>
<ul>
<li>优点：加载速度快；发布时无需提供静态库，移植方便</li>
<li>缺点：消耗内存；更新部署发布麻烦</li>
</ul>
</li>
<li><p>动态库（共享库）：链接时将动态库相关信息与程序链接，真正使用函数api是直到运行时才动态载入</p>
<ul>
<li>优点：进程间资源共享；更新部署发布简单；可以控制何时加载动态库</li>
<li>缺点：加载速度较静态库慢；发布时需要提供依赖库</li>
</ul>
</li>
</ul>
<h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><p>steps for build a static link library:</p>
<ol>
<li><p><code>gcc -c a.c b.c xxx.c ...</code></p>
</li>
<li><p><code>ar rcs libxxx.a a.o b.o ... -I ./include_dir</code></p>
</li>
<li><p>complie the main code (don’t forget to add -I and -L <code>-L ./lib_dir -lxxx</code>)</p>
</li>
</ol>
<h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><p>steps for build a dynamic link library:</p>
<ol>
<li><p><code>gcc -c -fpic a.c b.c xxx.c ...</code>（-fpic代表生成与位置无关的代码）</p>
</li>
<li><p><code>gcc -shared a.o b.o ... -o libxxx.so</code></p>
</li>
<li><p>complie the main code (don’t forget to add -I and -L)</p>
</li>
<li><p>add lib path to env:</p>
</li>
</ol>
<ul>
<li><p><strong>user</strong>: add <code>LD_LIBRARY_PATH=$LD_LIBRARY_PATH:absolute_lib_path</code> to <code>~/.bashrc</code> and then <code>source ~/.bashrc</code></p>
</li>
<li><p><strong>root</strong>: add <code>LD_LIBRARY_PATH=$LD_LIBRARY_PATH:absolute_lib_path</code> to <code>/etc/profile</code> and then <code>source /etc/profile</code></p>
</li>
</ul>
<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220827202151243.png" alt="makefile操作" style="zoom: 33%;" /></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220827210707392.png" alt="变量" style="zoom: 33%;" /></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220827211304690.png" alt="通配符匹配" style="zoom: 50%;" /></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220827232047838.png" alt="wildcard函数（用于返回满足匹配的文件名列表）"></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220827232152888.png" alt="patsubst（用于replacement）"></p>
<p><strong><code>.PHONY:</code></strong> 后跟的名称为<strong>伪文件</strong>（即：不是一个文件），用于防止和自己定义的文件名冲突而使规则无效化（一直显示最新）</p>
<p>Makefile的特点：</p>
<ul>
<li><p>执行make前，先检查依赖是否存在，若不存在，则向下检查是否有生成该规则的依赖并执行</p>
</li>
<li><p>检测更新：如果依赖文件比目标文件的时间晚，则会重新生成目标</p>
</li>
</ul>
<p>举例：一个文件树如下，其中<code>a.c, b.c</code>定义了头文件<code>head.h</code>声明的函数，而<code>main.c</code>使用了<code>a.c, b.c</code>定义的函数。此处我想把<code>a.c, b.c</code>打包成静态库，并编译<code>main.c</code></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220827231306247.png" alt="work tree" style="zoom: 50%;" /></p>
<figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile">LIB_DIR=./lib<br>LIB_NAME=calc<br>INCLUDE_DIR=./<span class="hljs-keyword">include</span><br>SRC_DIR=./src<br>TARGET=app<br>MAIN=main.c<br>DEPENDENCE=<span class="hljs-variable">$(MAIN)</span> <span class="hljs-variable">$(LIB_DIR)</span>/lib<span class="hljs-variable">$(LIB_NAME)</span>.a <span class="hljs-variable">$(INCLUDE_DIR)</span><br>DEP_C=<span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> ./src/*.c)</span><br>DEP_O=<span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c, %.o, <span class="hljs-variable">$(DEP_C)</span>)</span> <br><br><span class="hljs-variable">$(TARGET)</span>: <span class="hljs-variable">$(DEPENDENCE)</span><br>	<span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(MAIN)</span> -o <span class="hljs-variable">$@</span> -I <span class="hljs-variable">$(INCLUDE_DIR)</span> -L <span class="hljs-variable">$(LIB_DIR)</span> -l<span class="hljs-variable">$(LIB_NAME)</span><br><br><span class="hljs-variable">$(LIB_DIR)</span>/lib<span class="hljs-variable">$(LIB_NAME)</span>.a: <span class="hljs-variable">$(DEP_O)</span> <br>	ar rcs <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span><br><br><span class="hljs-variable">$(SRC_DIR)</span>/%.o: <span class="hljs-variable">$(SRC_DIR)</span>/%.c <span class="hljs-variable">$(INCLUDE_DIR)</span><br>	<span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span> -I <span class="hljs-variable">$(INCLUDE_DIR)</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean</span><br><span class="hljs-section">clean:</span><br>	rm -f <span class="hljs-variable">$(DEP_O)</span><br><br></code></pre></div></td></tr></table></figure>
<h2 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">list/l   <span class="hljs-comment"># 显示代码</span><br>list/l 函数名: 行数<br>list/l 文件名: 行数<br>show list/listsize  <span class="hljs-comment"># 显示默认显示行数</span><br><span class="hljs-built_in">set</span> list/listsize  <span class="hljs-comment"># 设置默认显示行数</span><br><br><span class="hljs-comment"># 打断点</span><br><span class="hljs-built_in">break</span>/b 文件名: 行号<br><span class="hljs-built_in">break</span>/b 文件名: 函数名<br>info/i b/break  <span class="hljs-comment"># 查看断点</span><br>delete/d <span class="hljs-built_in">id</span>  <span class="hljs-comment"># 删除断点（编号）</span><br><span class="hljs-built_in">disable</span>/enable <span class="hljs-built_in">id</span>  <span class="hljs-comment"># 无效化/有效化断点（编号）</span><br><span class="hljs-built_in">break</span> 行号 <span class="hljs-keyword">if</span> i==5  <span class="hljs-comment"># 条件断点</span><br><br><span class="hljs-comment"># 调试命令</span><br>start <span class="hljs-comment"># 程序停在main第一行</span><br>run <span class="hljs-comment"># 程序停在第一个断点处</span><br>c/continue <span class="hljs-comment"># 继续运行，到下一个断点停</span><br>n/next <span class="hljs-comment"># 向下执行一行（不会进入函数）</span><br>s/step <span class="hljs-comment"># 单步调试（会进入函数）</span><br>finish <span class="hljs-comment"># 跳出函数体</span><br>until <span class="hljs-comment"># 跳出循环</span><br>p/print 变量名 <span class="hljs-comment"># 打印变量值</span><br>ptype 变量名 <span class="hljs-comment"># 打印变量类型</span><br>display 变量名 <span class="hljs-comment"># 设置自动变量</span><br>i/info display<br>undisplay <span class="hljs-built_in">id</span><br><span class="hljs-built_in">set</span> var 变量名=变量值<br><br><span class="hljs-comment">#进程调试</span><br><span class="hljs-built_in">set</span> follow-fork-mode prent/child <span class="hljs-comment"># 设置调试父/子进程</span><br><span class="hljs-built_in">set</span> detach-on-fork on/off <span class="hljs-comment"># 设置debug时是否运行其他进程</span><br>info inferiors <span class="hljs-comment"># 查看调试的进程</span><br>inferior <span class="hljs-built_in">id</span> <span class="hljs-comment"># 切换当前调试进程</span><br>detach inferiors <span class="hljs-built_in">id</span> <span class="hljs-comment"># 使进程脱离GDB调试</span><br></code></pre></div></td></tr></table></figure>
<h2 id="虚拟地址空间与文件IO"><a href="#虚拟地址空间与文件IO" class="headerlink" title="虚拟地址空间与文件IO"></a>虚拟地址空间与文件IO</h2><p>32位机：3G用户态，1G内核态</p>
<p>64位机：281T（$2^{48}$）用户态，基本可认为无穷大</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220828230914461.png" alt="虚拟地址空间示意图"></p>
<p>文件描述符：保存在内核区PCB（进程控制块）</p>
<p>文件描述符表：一个数组（默认大小1024），保存每个打开的文件描述符信息</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220828231928856.png" alt="文件描述符在内核中的位置"></p>
<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="open和close"><a href="#open和close" class="headerlink" title="open和close"></a>open和close</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-comment">// 打开一个已经存在的文件</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span>;<br>    参数：<br>        - pathname: 要打开的文件路径<br>        - flags: 对文件的操作权限和其他设置<br>            O_RDONLY, O_WRONLY, ORDWR<br>        返回值: 一个新的文件描述符，若失败则返回<span class="hljs-number">-1</span><br><br>    errno: 属于Linux系统函数库的全局变量，记录最近的错误号<br><br><br><span class="hljs-comment">// 输出错误</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">perror</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span>;<br>s参数: 用户描述，比如hello，最终输出的是 hello: xxx(实际的错误描述)<br><br><br><span class="hljs-comment">// 创建一个新的文件</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span>;<br>    参数：<br>        - pathname<br>        - flags(<span class="hljs-type">int</span> <span class="hljs-number">4</span>个字节，<span class="hljs-number">32</span>位标志位，支持按位或)<br>            - 必选: O_RDONLY, O_WRONLY, O_RDWR<br>            - 可选: ..., O_CREAT 文件不存在，创建新文件<br>        - mode: <span class="hljs-number">8</span>进制数，表示创建出的新文件的操作权限<br>        最终的权限是：mode &amp; ~umask<br>        例如： <span class="hljs-number">0777</span><br>          &amp; (~<span class="hljs-number">0022</span>)<br>          -------------<br>              <span class="hljs-number">0777</span> -&gt; <span class="hljs-number">0</span> <span class="hljs-number">111</span> <span class="hljs-number">111</span> <span class="hljs-number">111</span><br>          &amp;   <span class="hljs-number">0755</span> -&gt; <span class="hljs-number">0</span> <span class="hljs-number">111</span> <span class="hljs-number">101</span> <span class="hljs-number">101</span><br>          --------------------------<br>              <span class="hljs-number">0755</span> &lt;- <span class="hljs-number">0</span> <span class="hljs-number">111</span> <span class="hljs-number">101</span> <span class="hljs-number">101</span><br>        umask的作用就是抹去某些权限<br><br><span class="hljs-comment">// 关闭文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fildes)</span>;<br></code></pre></div></td></tr></table></figure>
<details>
    <summary>open和close</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span> <span class="hljs-comment">// close</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span> <span class="hljs-comment">// perror</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-comment">// 创建一个新文件</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;create.txt&quot;</span>, O_RDWR | O_CREAT, <span class="hljs-number">0777</span>);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 关闭</span><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h3 id="read和write"><a href="#read和write" class="headerlink" title="read和write"></a>read和write</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span>;<br>    参数：<br>        - fd：文件描述符，open得到，通过fd操作某文件<br>        - buf：需要读取数据存放的地方，数组的地址<br>        - count：指定数组的大小<br>    返回值：<br>        - 成功：<br>            &gt;<span class="hljs-number">0</span>: 返回实际的读取到的字节数<br>            =<span class="hljs-number">0</span>: 文件已经读取完了<br>        - 失败：<br>            <span class="hljs-number">-1</span>，并设置errno<br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> write(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count);<br>    参数：<br>        - fd：文件描述符<br>        - buf：往磁盘写入的数据，数组<br>        - count：要写入的数据的实际大小<br>    返回值：<br>        - 成功：返回实际写入的字节数<br>        - 失败：返回<span class="hljs-number">-1</span>，并设置errno<br></code></pre></div></td></tr></table></figure>
<details>
    <summary>read和write</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-comment">// 通过open打开english.txt</span><br>    <span class="hljs-type">int</span> srcfd = open(<span class="hljs-string">&quot;english.txt&quot;</span>, O_RDONLY);<br>    <span class="hljs-keyword">if</span>(srcfd == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建一个新文件（拷贝文件）</span><br>    <span class="hljs-type">int</span> destfd = open(<span class="hljs-string">&quot;cpy.txt&quot;</span>, O_WRONLY | O_CREAT, <span class="hljs-number">0664</span>);<br>    <span class="hljs-keyword">if</span>(destfd == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 频繁的读写操作</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>((len = read(srcfd, buf, <span class="hljs-keyword">sizeof</span> buf))&gt;<span class="hljs-number">0</span>)&#123;<br>        write(destfd, buf, len);<br>    &#125;<br><br>    <span class="hljs-comment">// 关闭文件</span><br>    close(destfd);<br>    close(srcfd);<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h3 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">标准C库fseek<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fseek</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> whence)</span>;<br><br><br>Linux系统函数<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">off_t</span> <span class="hljs-title function_">lseek</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset, <span class="hljs-type">int</span> whence)</span>;<br>    参数：<br>        - fd：文件描述符<br>        - offset：偏移量<br>        - whence：<br>        SEEK_SET<br>            设置文件指针偏移量<br>        SEEK_CUR<br>            设置偏移量：当前位置 + offset值<br>        SEEK_END<br>            设置偏移量：文件大小 + offset值<br>    返回值：<br>        返回文件指针的位置<br><br>    作用：<br>        <span class="hljs-number">1.</span> 移动文件指针到文件头<br>            lseek(fd, <span class="hljs-number">0</span>, SEEK_SET);<br>        <span class="hljs-number">2.</span> 获取当前文件指针的位置<br>            lseek(fd, <span class="hljs-number">0</span>, SEEK_CUR);<br>        <span class="hljs-number">3.</span> 获取文件长度<br>            lseek(fd, <span class="hljs-number">0</span>, SEEK_END);<br>        <span class="hljs-number">4.</span> 扩展文件的长度（当前文件 <span class="hljs-number">10B</span> -&gt; <span class="hljs-number">110B</span>）<br>            lseek(fd, <span class="hljs-number">100</span>, SEEK_END);<br></code></pre></div></td></tr></table></figure>
<details>
    <summary>lseek</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;hello.txt&quot;</span>, O_RDWR);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 扩展文件长度</span><br>    <span class="hljs-type">int</span> ret = lseek(fd, <span class="hljs-number">100</span>, SEEK_END);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;lseek&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">//写入一个空数据</span><br>    write(fd, <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//关闭文件</span><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h3 id="stat和lstat"><a href="#stat和lstat" class="headerlink" title="stat和lstat"></a>stat和lstat</h3><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220830112036721.png" alt="struct stat结构体信息" style="zoom: 33%;" /></p>
<ul>
<li><p>获取文件指定的权限：将st_mode和对应宏进行<strong>按位与</strong></p>
</li>
<li><p>获取文件类型：将st_mode和对应掩码（S_IFMT)进行按位与，结果与宏值对应判断</p>
</li>
</ul>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220830110757259.png" alt="mode_t类型" style="zoom: 25%;" /></p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-keyword">struct</span> stat *statbuf)</span>;<br>    作用：获取一个文件相关的一些信息（如果是软链接则获取链接对象的信息）<br>    参数：<br>        - pathname: 文件路径<br>        - statbuf: 结构体变量，传出参数，用于保存获取到的文件信息<br>    返回值：<br>        成功：返回<span class="hljs-number">0</span><br>        失败：返回<span class="hljs-number">-1</span>，并设置errno<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">lstat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-keyword">struct</span> stat *statbuf)</span>;<br>    作用：获取一个文件相关的一些信息（可以获取软链接文件本身信息）<br>    其他同上<br></code></pre></div></td></tr></table></figure>
<details>
    <summary>stat和lstat</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">statbuf</span>;</span><br><br>    <span class="hljs-type">int</span> ret = stat(<span class="hljs-string">&quot;a.txt&quot;</span>, &amp;statbuf);<br><br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;stat&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;size: %ld\n&quot;</span>, statbuf.st_size);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<details>
    <summary>Linux C语言实现`ls -l`</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 模拟实现 ls -l 指令</span><br><span class="hljs-comment">// -rw-r--r-- 1 root root 12 Aug 30 11:02 a.txt</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pwd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;grp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span>&#123;<br><br>    <span class="hljs-comment">// 判断输入参数是否正确</span><br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s filename\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 通过stat函数获取用户传入文件的信息</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br>    <span class="hljs-type">int</span> ret = stat(argv[<span class="hljs-number">1</span>], &amp;st);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;stat&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 获取文件类型和文件权限</span><br>    <span class="hljs-type">char</span> perms[<span class="hljs-number">11</span>] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 用于保存文件类型和文件权限的字符串</span><br>    <span class="hljs-keyword">switch</span>(st.st_mode &amp; S_IFMT)&#123;<br>        <span class="hljs-keyword">case</span> S_IFLNK:<br>            perms[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;l&#x27;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> S_IFDIR:<br>            perms[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;d&#x27;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> S_IFREG:<br>            perms[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;-&#x27;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> S_IFBLK:<br>            perms[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;b&#x27;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> S_IFCHR:<br>            perms[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;c&#x27;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> S_IFSOCK:<br>            perms[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;s&#x27;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> S_IFIFO:<br>            perms[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;p&#x27;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            perms[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;?&#x27;</span>;<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断文件访问权限</span><br>    <span class="hljs-comment">// 这里我自己小优化了一下，位运算经典操作</span><br>    <span class="hljs-type">char</span> tab[<span class="hljs-number">3</span>] = &#123;<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;++i)<br>        perms[<span class="hljs-number">9</span>-i] = ((st.st_mode&gt;&gt;i)&amp;<span class="hljs-number">1</span>) ? tab[i%<span class="hljs-number">3</span>] : <span class="hljs-string">&#x27;-&#x27;</span>;<br>    perms[<span class="hljs-number">10</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-comment">// printf(&quot;%s\n&quot;, perms);</span><br><br>    <span class="hljs-comment">// 硬链接数</span><br>    <span class="hljs-type">int</span> linkNum = st.st_nlink;<br><br>    <span class="hljs-comment">// 判断文件所有者</span><br>    <span class="hljs-type">char</span> *fileUser = getpwuid(st.st_uid)-&gt;pw_name;<br><br>    <span class="hljs-comment">// 文件所在组</span><br>    <span class="hljs-type">char</span> *fileGrp = getgrgid(st.st_gid)-&gt;gr_name;<br><br>    <span class="hljs-comment">// 文件大小</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">int</span> fileSize = st.st_size;<br><br>    <span class="hljs-comment">// 获取修改时间</span><br>    <span class="hljs-type">char</span> *time = ctime(&amp;st.st_mtime);<br>    <span class="hljs-type">char</span> mtime[<span class="hljs-number">512</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-built_in">strncpy</span>(mtime, time, <span class="hljs-built_in">strlen</span>(time)<span class="hljs-number">-1</span>);<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;%s %d %s %s %ld %s %s&quot;</span>, perms, linkNum, fileUser, fileGrp, fileSize, mtime, argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<p>最终效果：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220830115700934.png" alt="模拟实现ls -l a.txt最终效果" style="zoom: 50%;" /></p>
<hr>
<h3 id="文件属性操作函数-access-chmod-chown-truncate"><a href="#文件属性操作函数-access-chmod-chown-truncate" class="headerlink" title="文件属性操作函数(access, chmod, chown, truncate)"></a>文件属性操作函数(access, chmod, chown, truncate)</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">access</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> mode)</span>;<br>    作用：判断某文件是否有某种权限，或是否存在<br>    参数：<br>        pathname：文件名<br>        mode:<br>            R_OK: 是否有读权限<br>            W_OK: 判断是否有写权限<br>            X_OK: 判断是否有执行权限<br>            F_OK: 判断是否存在<br>    返回值：<br>        成功返回<span class="hljs-number">0</span>， 失败返回<span class="hljs-number">-1</span><br></code></pre></div></td></tr></table></figure>
<details>
    <summary>access</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-type">int</span> ret = access(<span class="hljs-string">&quot;a.txt&quot;</span>, F_OK);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;access&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;File exists!!!\n&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">chmod</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span>;<br>    作用：修改文件权限<br>    参数：<br>        - pathname：文件路径<br>        - mode：需要修改的权限，<span class="hljs-number">8</span>进制数<br>    返回值：成功<span class="hljs-number">0</span>，失败<span class="hljs-number">-1</span><br></code></pre></div></td></tr></table></figure>
<details>
    <summary>chmod</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-type">int</span> ret = chmod(<span class="hljs-string">&quot;a.txt&quot;</span>, <span class="hljs-number">0644</span>);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;chmod&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<details>
    <summary>chown</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br><span class="hljs-comment">int chown(const char *pathname, uid_t owner, gid_t group);</span><br><span class="hljs-comment">	作用：改变文件所有者</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">truncate</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">off_t</span> length)</span>;<br>    作用：所见或扩展文件尺寸至指定大小<br>    参数：<br>        - path：需要修改的文件路径<br>        - length：需要的最终文件变成的大小<br>    返回值：<br>        成功返回<span class="hljs-number">0</span>，失败<span class="hljs-number">-1</span><br></code></pre></div></td></tr></table></figure>
<details>
    <summary>truncate</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-type">int</span> ret = truncate(<span class="hljs-string">&quot;a.txt&quot;</span>, <span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;truncate&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h3 id="目录操作函数-mkdir-rmdir-rename-chdir-getcwd"><a href="#目录操作函数-mkdir-rmdir-rename-chdir-getcwd" class="headerlink" title="目录操作函数(mkdir, rmdir, rename, chdir, getcwd)"></a>目录操作函数(mkdir, rmdir, rename, chdir, getcwd)</h3><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220830131528737.png" alt="目录操作函数"  /></p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">chdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span>;<br>    作用：修改进程的工作目录<br>        比如在/home/wlx 启动了一个可执行程序a.out，进程的工作目录/home/wlx<br>    参数：<br>        - path：需要修改的工目录路径<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">getcwd</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size)</span>;<br>    作用：获取当前工作目录<br>    参数：<br>        - buf：存储的路径，指向的是一个数组（传出参数）<br>        - size：数组的大小<br>    返回值：<br>        返回的是指向的buf的首地址<br></code></pre></div></td></tr></table></figure>
<details>
    <summary>目录操作</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-comment">// 获取当前的工作目录</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">128</span>];<br>    getcwd(buf, <span class="hljs-keyword">sizeof</span> buf);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;当前的工作目录是：%s\n&quot;</span>, buf);<br>    <br>    <span class="hljs-comment">//修改工作目录</span><br>    <span class="hljs-type">int</span> ret = chdir(<span class="hljs-string">&quot;/root/linux_learn/dir_operation/ddd&quot;</span>);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-type">int</span> res = mkdir(<span class="hljs-string">&quot;ddd&quot;</span>, <span class="hljs-number">0664</span>);<br>        <span class="hljs-keyword">if</span>(res == <span class="hljs-number">-1</span>)&#123;<br>            perror(<span class="hljs-string">&quot;mkdir&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        chdir(<span class="hljs-string">&quot;/root/linux_learn/dir_operation/ddd&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 创建一个新文件</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;chdir.txt&quot;</span>, O_CREAT | O_RDWR, <span class="hljs-number">0664</span>);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    close(fd);<br>    <br>    <span class="hljs-comment">// 获取当前的工作目录</span><br>    <span class="hljs-type">char</span> buf1[<span class="hljs-number">128</span>];<br>    getcwd(buf1, <span class="hljs-keyword">sizeof</span> buf1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;当前的工作目录是：%s\n&quot;</span>, buf1);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h3 id="目录遍历函数-opendir-readdir"><a href="#目录遍历函数-opendir-readdir" class="headerlink" title="目录遍历函数(opendir, readdir)"></a>目录遍历函数(opendir, readdir)</h3><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220830134357664.png" alt="struct dirent结构体"  /></p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 打开指定目录</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br>DIR *<span class="hljs-title function_">opendir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br>    参数：<br>        - name：需要打开的目录名称<br>    返回值：<br>        - DIR * 类型：理解为目录流<br>        错误返回<span class="hljs-literal">NULL</span><br><span class="hljs-comment">// 读取目录中的数据</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><span class="hljs-keyword">struct</span> dirent *<span class="hljs-title function_">readdir</span><span class="hljs-params">(DIR *dirp)</span>;<br>    参数：<br>        - dirp：通过opendir返回的结果<br>        返回值：<br>                - <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span>：代表读取到的文件信息</span><br><span class="hljs-class">                        读取到了末尾或者失败，返回<span class="hljs-title">NULL</span></span><br><span class="hljs-class"></span><br><span class="hljs-class">// 关闭目录</span><br><span class="hljs-class">#<span class="hljs-title">include</span> &lt;</span>sys/types.h&gt;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">closedir</span><span class="hljs-params">(DIR *dirp)</span>;<br></code></pre></div></td></tr></table></figure>
<details>
    <summary>获取指定目录下的所有普通文件的个数（递归处理）</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">// 用于获取目录下所有普通文件的个数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getFileNum</span><span class="hljs-params">(<span class="hljs-type">char</span> *path)</span>&#123;<br><br>    <span class="hljs-comment">// 1. 打开目录</span><br>    DIR *dir = opendir(path);<br>    <span class="hljs-keyword">if</span>(dir == <span class="hljs-literal">NULL</span>)&#123;<br>        perror(<span class="hljs-string">&quot;opendir&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// 返回值（普通文件的数目）</span><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> *<span class="hljs-title">ptr</span>;</span><br>    <span class="hljs-comment">// 排除 . 和 ..</span><br>    <span class="hljs-keyword">while</span>((ptr = readdir(dir)) != <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-type">char</span> *dname = ptr-&gt;d_name;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(dname, <span class="hljs-string">&quot;.&quot;</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(dname, <span class="hljs-string">&quot;..&quot;</span>) == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 判断是普通文件还是目录</span><br>        <span class="hljs-keyword">if</span>(ptr-&gt;d_type == DT_DIR)&#123;<br>            <span class="hljs-comment">// 目录，需要继续读取整个目录</span><br>            <span class="hljs-type">char</span> newpath[<span class="hljs-number">256</span>];<br>            <span class="hljs-built_in">sprintf</span>(newpath, <span class="hljs-string">&quot;%s/%s&quot;</span>, path, dname);<br>            res += getFileNum(newpath);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(ptr-&gt;d_type == DT_REG)&#123;<br>            res ++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 关闭目录</span><br>    closedir(dir);<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-comment">// 读取某个目录下所有普通文件的个数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span>&#123;<br><br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s path\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> num = getFileNum(argv[<span class="hljs-number">1</span>]);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;普通文件的个数为：%d\n&quot;</span>, num);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h3 id="文件复制操作-dup-dup2"><a href="#文件复制操作-dup-dup2" class="headerlink" title="文件复制操作(dup, dup2)"></a>文件复制操作(dup, dup2)</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd)</span>;<br>    作用：复制一个新的文件描述符<br>    fd=<span class="hljs-number">3</span>, <span class="hljs-type">int</span> fd1 = dup(fd);<br>    fd指向的是a.txt, fd1也指向a.txt<br>    从空闲的文件描述符表中找一个最小的，作为新的拷贝的文件描述符<br></code></pre></div></td></tr></table></figure>
<details>
    <summary>dup</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;a.txt&quot;</span>, O_RDWR | O_CREAT, <span class="hljs-number">0664</span>);<br><br>    <span class="hljs-type">int</span> fd1 = dup(fd);<br>    <span class="hljs-keyword">if</span>(fd1 == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;dup&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd: %d, fd1: %d\n&quot;</span>, fd, fd1);<br>    close(fd);<br><br>    <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;hello, world&quot;</span>;<br>    <span class="hljs-type">int</span> ret = write(fd1, str, <span class="hljs-built_in">strlen</span>(str));<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;write&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    close(fd1);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd, <span class="hljs-type">int</span> newfd)</span>;<br>    作用：重定向文件描述符<br>    old 指向 a.txt, newfd 指向 b.txt<br>    调用函数成功后：newfd 和 b.txt 做close，newfd 指向了 a.txt<br>    等价于: close(newfd), newfd = dup(oldfd);<br>    oldfd 必须是一个有效的文件描述符<br>    oldfd 和 newfd 值相同时，相当于无事发生<br></code></pre></div></td></tr></table></figure>
<details>
    <summary>dup2</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;1.txt&quot;</span>, O_RDWR | O_CREAT, <span class="hljs-number">0664</span>);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> fd1 = open(<span class="hljs-string">&quot;2.txt&quot;</span>, O_RDWR | O_CREAT, <span class="hljs-number">0664</span>);<br>    <span class="hljs-keyword">if</span>(fd1 == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd: %d, fd1: %d\n&quot;</span>, fd, fd1);<br><br>    <span class="hljs-type">int</span> fd2 = dup2(fd, fd1);<br>    <span class="hljs-keyword">if</span>(fd2 == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;dup2&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 通过fd1去写数据，实际操作的是1.txt</span><br>    <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;hello, dup2&quot;</span>;<br>    <span class="hljs-type">int</span> len = write(fd1, str, <span class="hljs-built_in">strlen</span>(str));<br>    <span class="hljs-keyword">if</span>(len == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;write&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd: %d, fd1: %d, fd2: %d\n&quot;</span>, fd, fd1, fd2);<br><br>    close(fd);<br>    close(fd1);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h3 id="控制文件状态-fcntl"><a href="#控制文件状态-fcntl" class="headerlink" title="控制文件状态(fcntl)"></a>控制文件状态(fcntl)</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, ... )</span>;<br>    参数：<br>        - fd：需要操作的文件描述符<br>        - cmd：表示对文件描述符进行如何操作<br>            - F_DUPFD: 复制文件描述符，复制fd，返回一个新的描述符<br>                <span class="hljs-type">int</span> ret = fcntl(fd, F_DUPFD);<br>            <br>            - F_GETFL: 获取文件状态flag<br>                获取的flag和open函数传递的flag相同<br>            <br>            - F_SETFL: 设置文件描述符状态flag<br>                O_RDONLY, O_WRONLY, O_RDWR, O_CREAT 等不可以被修改<br>                O_APPEND, O_NONBLOCK 等可修改<br>                    O_APPEND 表示追加数据<br>                    O_NONBLOCK 设置成非阻塞<br><br>阻塞和非阻塞：描述的是函数调用行为<br></code></pre></div></td></tr></table></figure>
<details>
    <summary>fcntl</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-comment">// 1. 复制文件描述符</span><br>    <span class="hljs-comment">// int fd = open(&quot;1.txt&quot;, O_RDONLY);</span><br>    <span class="hljs-comment">// int ret = fcntl(fd, F_DUPFD);</span><br><br>    <span class="hljs-comment">// 2. 修改或获取文件状态flag</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;1.txt&quot;</span>, O_RDWR);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取文件描述符的状态flag</span><br>    <span class="hljs-type">int</span> flag = fcntl(fd, F_GETFL);<br>    <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;fcntl&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 修改文件描述符状态flag，给flag加入O_APPEND标记</span><br>    <span class="hljs-type">int</span> ret = fcntl(fd, F_SETFL, flag | O_APPEND);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;fcntl&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 追加字符串到文件末尾</span><br>    <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;nihao&quot;</span>;<br>    write(fd, str, <span class="hljs-built_in">strlen</span>(str));<br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h2 id="多进程开发"><a href="#多进程开发" class="headerlink" title="多进程开发"></a>多进程开发</h2><p>并行与并发的区别：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220830211033398.png" alt="并行（左）与并发（右）的区别"></p>
<p>进程状态：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220830223357874.png" alt="进程状态示意图"></p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ps aux / ajx<br>a: 显示终端上所有进程，包括其他用户进程<br>u: 显示进程详细信息<br>x: 显示没有控制终端的进程<br>j: 列出与作业控制相关的信息<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">杀死进程</span><br>kill pid<br>kill -9 pid # 强制杀死<br></code></pre></div></td></tr></table></figure>
<hr>
<h3 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> **environ;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ... (<span class="hljs-type">char</span>  *) <span class="hljs-literal">NULL</span> )</span>;<br>    参数：<br>        - path：需要指定的执行的文件的路径或名称<br>        - arg：可执行文件的参数列表<br>            第一个参数一般没什么作用，通常写的时可执行程序名称<br>            第二个参数开始往后，时程序执行所需要的参数列表<br>            参数最后需要以<span class="hljs-literal">NULL</span>结束（哨兵）<br>    返回值：<br>        只有当调用失败，才会有返回值，返回<span class="hljs-number">-1</span>，并设置errno<br>        如果调用成功，没有返回值。<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">execlp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ... (<span class="hljs-type">char</span>  *) <span class="hljs-literal">NULL</span> )</span>;<br>    与上一个区别：会到环境变量中查找可执行文件并执行<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">execle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ..., (<span class="hljs-type">char</span> *) <span class="hljs-literal">NULL</span>, <span class="hljs-type">char</span> * <span class="hljs-type">const</span> envp[] )</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execvp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execvpe</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[], <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span>;<br><br>l(<span class="hljs-built_in">list</span>): 参数地址列表，以空指针结尾<br>v(<span class="hljs-built_in">vector</span>): 存有各参数地址的指针数组的地址<br>p(path): 按PATH环境变量指定的目录搜索可执行文件<br>e(environment): 存有环境变量字符地址的指针数组的地址<br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">execve</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[], <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span>;<br></code></pre></div></td></tr></table></figure>
<details>
    <summary>exec函数族</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> **environ;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-comment">// 创建一个子进程，在子进程中执行exec函数族中的函数</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// parent</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am parent process, pid: %d\n&quot;</span>, getpid());<br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">// child</span><br>        <span class="hljs-comment">// execl(&quot;hello&quot;, &quot;hello&quot;, NULL);</span><br>        <span class="hljs-comment">// execl(&quot;/bin/ps&quot;, &quot;ps&quot;, &quot;aux&quot;, NULL);</span><br>        execlp(<span class="hljs-string">&quot;ps&quot;</span>, <span class="hljs-string">&quot;ps&quot;</span>, <span class="hljs-string">&quot;aux&quot;</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am child process, pid: %d\n&quot;</span>, getpid());<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++ i)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %d, pid = %d\n&quot;</span>, i, getpid());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h3 id="fork-和execve-的原理"><a href="#fork-和execve-的原理" class="headerlink" title="fork()和execve()的原理"></a><code>fork()</code>和<code>execve()</code>的原理</h3><ul>
<li><p><code>fork()</code>函数原理：</p>
<ul>
<li>被当前进程调用时，内核为新进程创建数据结构，并分配一个唯一的pid</li>
<li>创建虚拟内存：创建mm_struct，区域结构和页表的<strong>原样副本</strong></li>
<li>将两个进程的页表都标记为<strong>只读</strong></li>
<li>将两个进程的每个区域结构标记为<strong>私有的写时复制</strong>（只要有一个进程试图写私有区域的某个页面，则触发保护故障，在物理内存中页面的新副本，更新页表条目指向新副本，恢复可写权限）</li>
</ul>
</li>
<li><p><code>execve()</code>函数原理：（例如，在当前进程执行<code>execve(&quot;a.out&quot;, NULL, NULL)</code></p>
<ul>
<li>删除已存在的用户区域</li>
<li>映射私有区域：为新程序的代码、数据、bss和栈区创建新的区域结构，这些新区域都是<strong>私有的写时复制的</strong>（其中代码和数据被映射到<code>.text, .data</code></li>
<li>映射共享区域：如果<code>a.out</code>与共享对象链接（例如 动态链接库<code>libxxx.so</code>），则映射到虚拟地址空间中，这些区域是共享的</li>
<li>设置程序计数器（PC）：使之指向代码区域入口</li>
</ul>
</li>
</ul>
<hr>
<h3 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span>;<br>	<span class="hljs-comment">// 调用退出处理函数</span><br>	<span class="hljs-comment">// 刷新I/O缓冲，关闭文件描述符</span><br>	<span class="hljs-comment">// 调用_exit()系统调用</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">void</span> _exit(<span class="hljs-type">int</span> status);<br>	<span class="hljs-comment">// 终止进程</span><br><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello\nworld&quot;</span>);<br>_exit(<span class="hljs-number">0</span>); <span class="hljs-comment">// 未刷新缓冲区，world无法输出</span><br></code></pre></div></td></tr></table></figure>
<hr>
<h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><ul>
<li>父进程运行结束，但子进程未结束，就变成孤儿进程。</li>
<li>每当出现一个孤儿进程，<strong>内核就把它的父进程设置为<code>init</code>，而<code>init</code>进程会循环地<code>wait()</code>它的已经退出的子进程</strong>，作为善后。</li>
<li>孤儿进程<strong>没什么危害</strong>。</li>
</ul>
<hr>
<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><ul>
<li>每个进程结束之后，都会释放自己地址空间中的用户区数据，<strong>内核区的 PCB没有办法自己释放掉</strong>，需要父进程去释放。</li>
<li>进程终止时， 父进程尚未回收，子进程残留资源(PCB）存放于内核中，变成僵尸(zombie)进程。</li>
<li>僵尸进程<strong>不能被 <code>kill -9</code> 杀死</strong>。</li>
<li>这样就会导致一个问题，如果父进程<strong>不调用<code>wait()</code>或<code>waitpid ()</code></strong>的话，那么保留的那段信息就不会释放，<strong>其进程号就会一直被占用</strong>，但是系统所能使用的进程号是有限的， 如果大量的产生僵户进程，将因为没有可用的进程号而导致系统不能产生新的进程, 此即为<strong>僵尸进程的危害，应当避免</strong>。</li>
</ul>
<hr>
<h3 id="进程回收-wait-和-waitpid"><a href="#进程回收-wait-和-waitpid" class="headerlink" title="进程回收(wait 和 waitpid)"></a>进程回收(wait 和 waitpid)</h3><ul>
<li>父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。</li>
<li><code>wait()</code>和<code>waitpid()</code>函数的功能一样，区别在于, <code>wait()</code>函数会<strong>阻塞</strong>，<code>waitpid()</code>可以<strong>设置不阻塞</strong>, <code>waitpid()</code>还可以<strong>指定等待哪个子进程结束</strong>。</li>
<li>注意: 一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。</li>
</ul>
<hr>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">int</span> *wstatus)</span>;<br>    功能：等待任意一个子进程结束，如果有一个子进程结束，则回收资源<br>    参数：<span class="hljs-type">int</span> *wstatus<br>        进程退出时的状态信息，传出参数<br>    返回值：<br>        - 成功：返回被回收的子进程的pid<br>        - 失败：返回 <span class="hljs-number">-1</span>（所有子进程都结束，或调用函数失败）<br><br>    调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或收到一个不能被忽略的信号才能被唤醒（相当于继续执行）<br>    如果没有子进程，则立刻返回<span class="hljs-number">-1</span><br>    如果子进程都已结束，则立刻返回<span class="hljs-number">-1</span><br></code></pre></div></td></tr></table></figure>
<details>
    <summary>wait</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <br>    <span class="hljs-comment">// 有一个父进程，创建5个子进程（兄弟）</span><br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++ i)&#123;<br>        pid = fork();<br>        <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// parent</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent, pid = %d\n&quot;</span>, getpid());<br>            <span class="hljs-type">int</span> st;<br>            <span class="hljs-type">int</span> ret = wait(&amp;st);<br>            <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">if</span>(WIFEXITED(st))&#123;<br>                <span class="hljs-comment">// 是不是正常退出</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;退出状态码：%d\n&quot;</span>, WEXITSTATUS(st));<br>            &#125;<br>            <span class="hljs-keyword">if</span>(WIFSIGNALED(st))&#123;<br>                <span class="hljs-comment">// 是不是异常退出</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;被哪个信号干掉了：%d\n&quot;</span>, WTERMSIG(st));<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child die, pid = %d\n&quot;</span>, ret);<br><br>            sleep(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// child</span><br>        <span class="hljs-comment">// while(1)&#123;</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child, pid = %d\n&quot;</span>, getpid());<br>            sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">waitpid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> *wstatus, <span class="hljs-type">int</span> options)</span>;<br>    功能：回收指定进程号的子进程，可以设置是否阻塞<br>    参数：<br>        - pid:<br>            pid &gt; <span class="hljs-number">0</span>: 某个子进程的pid<br>            pid == <span class="hljs-number">0</span>: 回收当前进程组的任意子进程<br>            pid == <span class="hljs-number">-1</span>: 回收任意子进程，相当于 wait()（最常用）<br>            pid &lt; <span class="hljs-number">-1</span>: 回收在|pid|组内的任意子进程<br>        - options: 设置阻塞或非阻塞<br>            <span class="hljs-number">0</span>: 阻塞<br>            WNOHANG: 非阻塞<br>    返回值：<br>        &gt; <span class="hljs-number">0</span>: 返回子进程id<br>        == <span class="hljs-number">0</span>: options=WNOHANG， 表示还有子进程活着<br>        == <span class="hljs-number">-1</span>: 错误，或者没有子进程活着了<br></code></pre></div></td></tr></table></figure>
<details>
    <summary>waitpid</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-comment">// 有一个父进程，创建5个子进程（兄弟）</span><br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++ i)&#123;<br>        pid = fork();<br>        <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// parent</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent, pid = %d\n&quot;</span>, <span class="hljs-built_in">getpid</span>());<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>            <span class="hljs-type">int</span> st;<br>            <span class="hljs-comment">// int ret = waitpid(-1, &amp;st, 0);</span><br>            <span class="hljs-type">int</span> ret = <span class="hljs-built_in">waitpid</span>(<span class="hljs-number">-1</span>, &amp;st, WNOHANG);<br>            <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">// 说明还有子进程存在</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">WIFEXITED</span>(st))&#123;<br>                    <span class="hljs-comment">// 是不是正常退出</span><br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;退出状态： %d\n&quot;</span>, <span class="hljs-built_in">WEXITSTATUS</span>(st));<br>                &#125;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">WIFSIGNALED</span>(st))&#123;<br>                    <span class="hljs-comment">// 是不是异常退出</span><br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;被哪个信号干掉了：%d\n&quot;</span>, <span class="hljs-built_in">WTERMSIG</span>(st));<br>                &#125;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child die, pid = %d\n&quot;</span>, ret);<br>            &#125;<br><br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// child</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child, pid = %d\n&quot;</span>, <span class="hljs-built_in">getpid</span>());<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h3 id="进程间通信（IPC）"><a href="#进程间通信（IPC）" class="headerlink" title="进程间通信（IPC）"></a>进程间通信（IPC）</h3><p>目的：数据传输、通知事件、资源共享、进程控制</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220902200443609.png" alt="进程间通信方式"></p>
<h4 id="（匿名）管道"><a href="#（匿名）管道" class="headerlink" title="（匿名）管道"></a>（匿名）管道</h4><ul>
<li>管道其实是一个在内核内存中维护的缓冲器，这个缓冲器的存储能力是有限的，不同的操作系统大小不一定相同。</li>
<li>管道拥有文件的特质：读操作、写操作，匿名管道<strong>没有文件实体</strong>，有名管道有文件实体，但不存储数据。可以按照操作文件的方式对管道进行操作。</li>
<li>一个管道是一个<strong>字节流</strong>，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少。</li>
<li>通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的。</li>
<li>在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，管道是半双工的。</li>
<li>从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据，在管道中无法使用lseek ()来随机的访问数据。</li>
<li><strong>匿名管道只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用。</strong></li>
</ul>
<p>为什么可以使用管道进行进程间通信？因为fork()后两个进程<strong>共享文件描述符表</strong></p>
<p>管道的数据结构：<strong>环形队列（循环队列）</strong><a href="https://leetcode.cn/problems/design-circular-queue/">622. 设计循环队列 - 力扣（LeetCode）</a></p>
<p><strong>管道读写特点：</strong></p>
<ul>
<li>如果所有指向管道写端的fd关闭（管道写端引用计数<strong>为0</strong>），则管道中剩余数据读完后，read会返回0（就像EOF）</li>
<li>如果有指向管道写端的fd没有关闭（管道写端引用计数<strong>大于0</strong>），而持有管道写端的进程也没有往管道写数据，此时读数据，则<strong>剩余数据被读完后，再次read会阻塞</strong>，直到管道中有数据了才可读并返回</li>
<li>如果所有指向管道读端的fd都被关闭（管道读端引用计数为0），这个时候有进程向管道中写数据，那么该进程会收到一个信号SIGPIPE，通常会导致进程异常终止</li>
<li>如果有指向管道读端的fd没有关闭（管道读端引用计数<strong>大于0</strong>），而持有管道读端的进程也没有从管道中读数据，此时写数据，则<strong>在管道被写满后，再次write会阻塞</strong>，直到管道中有空位置才可写并返回</li>
</ul>
<p>总结：</p>
<ul>
<li><p>读管道：</p>
<ul>
<li><p>管道中有数据：read返回实际读到的字节数</p>
</li>
<li><p>管道中无数据：</p>
<ul>
<li>写端全关：read返回0（相当于EOF）</li>
<li>写端未全关：read阻塞</li>
</ul>
</li>
</ul>
</li>
<li><p>写管道：</p>
<ul>
<li>管道读端全关：进程异常终止（进程收到SIGPIPE）</li>
<li>管道读端未全关：<ul>
<li>管道已满：write阻塞</li>
<li>管道没有满：write将数据写入并返回实际写入字节数</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pipe</span><span class="hljs-params">(<span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>])</span>;<br>    功能：创建一个匿名管道，用来进程间通信<br>    参数：<br>        - <span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>] 这个数组是一个传出参数<br>        pipefd[<span class="hljs-number">0</span>] 读端<br>        pipefd[<span class="hljs-number">1</span>] 写端<br>    返回值：<br>        成功<span class="hljs-number">0</span>，失败<span class="hljs-number">-1</span><br><br>    管道默认阻塞，如果管道中没有数据，read阻塞，如果满了，write阻塞<br>    注意：匿名管道只能用于具有关系进程之间通信（父子、兄弟 等）<br></code></pre></div></td></tr></table></figure>
<details>
    <summary>pipe 阻塞版</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-comment">// 在fork之前创建管道</span><br>    <span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> ret = pipe(pipefd);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;pipe&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// 创建子进程</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// parent</span><br>        <span class="hljs-comment">// 从管道读取端读取数据，同时发送数据</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am parent process, pid = %d\n&quot;</span>, getpid());<br>        <span class="hljs-comment">// 关闭写端</span><br>        close(pipefd[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-type">int</span> len = read(pipefd[<span class="hljs-number">0</span>], buf, <span class="hljs-keyword">sizeof</span> buf);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent rcv: %s, pid: %d\n&quot;</span>, buf, getpid());<br><br>            <span class="hljs-comment">// char *str = &quot;hello, i am parent\n&quot;;</span><br>            <span class="hljs-comment">// write(pipefd[1], str, strlen(str));</span><br>            <span class="hljs-comment">// sleep(1);</span><br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// child</span><br>        <span class="hljs-comment">// 向管道中写入数据，同时接受数据</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am child process, pid = %d\n&quot;</span>, getpid());<br>        <span class="hljs-comment">// 关闭读端</span><br>        close(pipefd[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;hello, i am child&quot;</span>;<br>            write(pipefd[<span class="hljs-number">1</span>], str, <span class="hljs-built_in">strlen</span>(str));<br>            <span class="hljs-comment">// sleep(1);</span><br>            <span class="hljs-comment">// 注意！这里可能会出现自己读自己写的数据的情况！</span><br><br>            <span class="hljs-comment">// int len = read(pipefd[0], buf, sizeof buf);</span><br>            <span class="hljs-comment">// printf(&quot;child rcv: %s, pid: %d\n&quot;, buf, getpid());</span><br>            <span class="hljs-comment">// bzero(buf, 1024);</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">设置管道非阻塞<br><span class="hljs-type">int</span> flags = fcntl(fd[<span class="hljs-number">0</span>], F_GETFL); <span class="hljs-comment">// 获取原来的flag</span><br>flags |= O_NONBLOCK;               <span class="hljs-comment">// 修改flag的值</span><br>fcntl(fd[<span class="hljs-number">0</span>], F_SETFL, flags);      <span class="hljs-comment">// 设置flag</span><br></code></pre></div></td></tr></table></figure>
<details>
    <summary>pipe 非阻塞版</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-comment">// 在fork之前创建管道</span><br>    <span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> ret = pipe(pipefd);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;pipe&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// 创建子进程</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// parent</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am parent process, pid = %d\n&quot;</span>, getpid());<br><br>        <span class="hljs-comment">// 关闭写端</span><br>        close(pipefd[<span class="hljs-number">1</span>]);<br><br>        <span class="hljs-type">int</span> flags = fcntl(pipefd[<span class="hljs-number">0</span>], F_GETFL); <span class="hljs-comment">// 获取原来的flag</span><br>        flags |= O_NONBLOCK;               <span class="hljs-comment">// 修改flag的值</span><br>        fcntl(pipefd[<span class="hljs-number">0</span>], F_SETFL, flags);      <span class="hljs-comment">// 设置flag</span><br><br>        <span class="hljs-comment">// 从管道读取端读取数据</span><br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-type">int</span> len = read(pipefd[<span class="hljs-number">0</span>], buf, <span class="hljs-keyword">sizeof</span> buf);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;len = %d\n&quot;</span>, len);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent rcv: %s, pid: %d\n&quot;</span>, buf, getpid());<br>            <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> buf);<br>            sleep(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// child</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am child process, pid = %d\n&quot;</span>, getpid());<br><br>        <span class="hljs-comment">// 关闭读端</span><br>        close(pipefd[<span class="hljs-number">0</span>]);<br><br>        <span class="hljs-comment">// 向管道中写入数据</span><br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;hello, i am child&quot;</span>;<br>            write(pipefd[<span class="hljs-number">1</span>], str, <span class="hljs-built_in">strlen</span>(str));<br>            sleep(<span class="hljs-number">5</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 获取管道大小</span><br><span class="hljs-type">long</span> size = fpathconf(pipefd[<span class="hljs-number">0</span>], _PC_PIPE_BUF);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pipe size = %d\n&quot;</span>, size);<br></code></pre></div></td></tr></table></figure>
<hr>
<details>
    <summary>实现ps aux 并过滤</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    实现 ps aud | grep xxx 父子进程间通信</span><br><span class="hljs-comment">    子进程：ps aux, 子进程结束后，将数据发送给父进程</span><br><span class="hljs-comment">    父进程：获取到数据，过滤</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    pipe()</span><br><span class="hljs-comment">    execlp()</span><br><span class="hljs-comment">    子进程将标准输出stdout_fileno重定向到管道写端：dup2()</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wait.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-comment">// 创建一个管道</span><br>    <span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> ret = pipe(fd);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;pipe&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 创建子进程</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// parent</span><br>        <span class="hljs-comment">// 关闭写端</span><br>        close(fd[<span class="hljs-number">1</span>]);<br>        <span class="hljs-comment">// 从管道中读取</span><br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> len = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>((len = read(fd[<span class="hljs-number">0</span>], buf, <span class="hljs-keyword">sizeof</span> buf)))&#123;<br>            <span class="hljs-comment">// 过滤数据输出</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buf);<br>            <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> buf);<br>        &#125;<br>        wait(<span class="hljs-literal">NULL</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// child</span><br>        <span class="hljs-comment">// 关闭读端</span><br>        close(fd[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// 文件描述符重定向: stdout_fileno -&gt; fd[1]</span><br>        dup2(fd[<span class="hljs-number">1</span>], STDOUT_FILENO);<br>        <span class="hljs-comment">// 执行 ps aux</span><br>        execlp(<span class="hljs-string">&quot;ps&quot;</span>, <span class="hljs-string">&quot;ps&quot;</span>, <span class="hljs-string">&quot;aux&quot;</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">while</span>((ret = execlp(<span class="hljs-string">&quot;ps&quot;</span>, <span class="hljs-string">&quot;ps&quot;</span>, <span class="hljs-string">&quot;aux&quot;</span>, <span class="hljs-literal">NULL</span>)) != <span class="hljs-number">-1</span>) &#123;&#125;<br>        perror(<span class="hljs-string">&quot;execlp&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h4 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h4><ul>
<li>有名管道(FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联，以<strong>FIFO的文件形式</strong>存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过FIFO相互通信，因此，通过FIFO 不相关的进程也能交换数据。</li>
<li>一旦打开了FIFO，其他操作同pipe。</li>
</ul>
<p>FIFO特性：</p>
<ul>
<li>FIFO在文件系统中作为一个特殊文件存在，但FIFO中的内容却存放在内存中。</li>
<li>当使用FIFO的进程退出后， FIFO文件将继续保存在文件系统中以便以后使用。</li>
</ul>
<hr>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">创建fifo文件<br>    <span class="hljs-number">1.</span> 通过命令：mkfifo 名字<br>    <span class="hljs-number">2.</span> 通过函数：<span class="hljs-type">int</span> <span class="hljs-title function_">mkfifo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mkfifo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span>;<br>参数：<br>    - pathname：管道名称的路径<br>    - mode：文件的权限，和open相同（mode &amp; ~umask）<br>    返回值：<br>    成功<span class="hljs-number">0</span>，失败<span class="hljs-number">-1</span><br></code></pre></div></td></tr></table></figure>
<details>
    <summary>mkfifo</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-type">int</span> ret = access(<span class="hljs-string">&quot;fifo1&quot;</span>, F_OK);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;管道不存在，创建管道\n&quot;</span>);<br><br>        ret = mkfifo(<span class="hljs-string">&quot;fifo1&quot;</span>, <span class="hljs-number">0664</span>);<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>            perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<p>fifo实现进程间通信（read读数据，write写数据）</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">有名管道注意事项：<br>    <span class="hljs-number">1.</span> 一个为只读打开一个管道的进程会阻塞，直到另一个进程为只写打卡管道<br>    <span class="hljs-number">2.</span> 一个为只写打开一个管道的进程会阻塞，直到另一个进程为只读打卡管道<br><br>    读管道：<br>    管道中有数据，read返回实际读到的字节数<br>    管道中无数据：<br>    写端全关，read返回<span class="hljs-number">0</span>（相当于EOF）<br>    写端未全关，read阻塞等待<br><br>    写管道：<br>    管道读端全关，进程异常终止（收到一个SIGPIPE信号）<br>    管道读端未全关：<br>    管道已满，write阻塞<br>    管道未满，write写入数据，并返回实际写入字节数<br></code></pre></div></td></tr></table></figure>
<details>
    <summary>write</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-comment">// 1. 判断文件是否存在</span><br>    <span class="hljs-type">int</span> ret = access(<span class="hljs-string">&quot;test&quot;</span>, F_OK);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;管道不存在，创建管道\n&quot;</span>);<br><br>        <span class="hljs-comment">// 2. 创建管道文件</span><br>        ret = mkfifo(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-number">0664</span>);<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>            perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 3. 以只写方式打开管道</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;test&quot;</span>, O_WRONLY);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 4. 写数据</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++ i)&#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>        <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;hello, %d\n&quot;</span>, i);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write data : %s\n&quot;</span>, buf);<br>        write(fd, buf, <span class="hljs-built_in">strlen</span>(buf));<br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure>

</details>

<details>
    <summary>read</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-comment">// 1. 打开管道文件</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;test&quot;</span>, O_RDONLY);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 2. 读数据</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> len = read(fd, buf, <span class="hljs-keyword">sizeof</span> buf);<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;写端断开连接...\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv buf : %s\n&quot;</span>, buf);<br>    &#125;<br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h5 id="使用-父子进程-FIFO-实现聊天功能"><a href="#使用-父子进程-FIFO-实现聊天功能" class="headerlink" title="使用 父子进程 + FIFO 实现聊天功能"></a>使用 父子进程 + FIFO 实现聊天功能</h5><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220902234150377.png" alt="有名管道实现聊天功能基本思路"></p>
<p>注意，如果仅使用单进程实现A和B，则<strong>如果一方连续发送多条消息，会导致阻塞</strong>。因此应当采用两个进程，<strong>一个进程负责写，另一个负责读</strong>。</p>
<details>
    <summary>chatA(父进程写管道1，子进程读管道2)</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">create_fifo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span>&#123;<br>    <span class="hljs-type">int</span> ret = access(str, F_OK);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s 不存在，创建 %s\n&quot;</span>, str, str);<br>        ret = mkfifo(str, <span class="hljs-number">0664</span>);<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>            perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-comment">// 创建fifo管道</span><br>    create_fifo(<span class="hljs-string">&quot;fifo1&quot;</span>);<br>    create_fifo(<span class="hljs-string">&quot;fifo2&quot;</span>);<br><br>    <span class="hljs-comment">// fork出一个子进程</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-type">int</span> fd1, fd2;<br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 父进程以只写方式打开1</span><br>        fd1 = open(<span class="hljs-string">&quot;fifo1&quot;</span>, O_WRONLY);<br>        <span class="hljs-keyword">if</span>(fd1 == <span class="hljs-number">-1</span>)&#123;<br>            perror(<span class="hljs-string">&quot;open&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打开fifo1成功，等待读取...\n&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 子进程以只读方式打开2</span><br>        fd2 = open(<span class="hljs-string">&quot;fifo2&quot;</span>, O_RDONLY);<br>        <span class="hljs-keyword">if</span>(fd2 == <span class="hljs-number">-1</span>)&#123;<br>            perror(<span class="hljs-string">&quot;open&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打开fifo2成功，等待读取...\n&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">128</span>];<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// 父进程循环向fifo1写入数据</span><br>            <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> buf);<br>            fgets(buf, <span class="hljs-number">128</span>, <span class="hljs-built_in">stdin</span>);<br>            ret = write(fd1, buf, <span class="hljs-built_in">strlen</span>(buf));<br>            <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>                perror(<span class="hljs-string">&quot;write&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// 子进程循环读fifo2</span><br>            <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> buf);<br>            ret = read(fd2, buf, <span class="hljs-number">127</span>);<br>            <span class="hljs-keyword">if</span>(ret &lt;= <span class="hljs-number">0</span>)&#123;<br>                perror(<span class="hljs-string">&quot;read&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;buf: %s\n&quot;</span>, buf);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) close(fd1);<br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) close(fd2);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<details>
    <summary>chatB(父进程读管道1，子进程写管道2)</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">create_fifo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span>&#123;<br>    <span class="hljs-type">int</span> ret = access(str, F_OK);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s 不存在，创建 %s\n&quot;</span>, str, str);<br>        ret = mkfifo(str, <span class="hljs-number">0664</span>);<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>            perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-comment">// 创建fifo管道</span><br>    create_fifo(<span class="hljs-string">&quot;fifo1&quot;</span>);<br>    create_fifo(<span class="hljs-string">&quot;fifo2&quot;</span>);<br><br>    <span class="hljs-comment">// fork出一个子进程</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-type">int</span> fd1, fd2;<br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 父进程以只读方式打开1</span><br>        fd1 = open(<span class="hljs-string">&quot;fifo1&quot;</span>, O_RDONLY);<br>        <span class="hljs-keyword">if</span>(fd1 == <span class="hljs-number">-1</span>)&#123;<br>            perror(<span class="hljs-string">&quot;open&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打开fifo1成功，等待读取...\n&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 子进程以只写方式打开2</span><br>        fd2 = open(<span class="hljs-string">&quot;fifo2&quot;</span>, O_WRONLY);<br>        <span class="hljs-keyword">if</span>(fd2 == <span class="hljs-number">-1</span>)&#123;<br>            perror(<span class="hljs-string">&quot;open&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打开fifo2成功，等待读取...\n&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">128</span>];<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// 父进程循环读fifo1</span><br>            <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> buf);<br>            ret = read(fd1, buf, <span class="hljs-number">127</span>);<br>            <span class="hljs-keyword">if</span>(ret &lt;= <span class="hljs-number">0</span>)&#123;<br>                perror(<span class="hljs-string">&quot;read&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;buf: %s\n&quot;</span>, buf);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// 子进程循环写fifo2</span><br>            <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> buf);<br>            fgets(buf, <span class="hljs-number">128</span>, <span class="hljs-built_in">stdin</span>);<br>            ret = write(fd2, buf, <span class="hljs-built_in">strlen</span>(buf));<br>            <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>                perror(<span class="hljs-string">&quot;write&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) close(fd1);<br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) close(fd2);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h4 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h4><p>内存映射将磁盘文件数据映射到内存，用户通过修改内存就能修改磁盘文件（效率高）。</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220903110129753.png" alt="内存映射"></p>
<hr>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset)</span>;<br>    - 功能：将一个文件或者设备数据映射到内存中<br>    - 参数：<br>        - <span class="hljs-type">void</span> *addr: <span class="hljs-literal">NULL</span>, 由内核指定<br>        - length: 要映射的数据长度，不能为<span class="hljs-number">0</span>，建议使用文件长度<br>                获取文件长度：stat lseek<br>        - prot: 对申请的内存映射区的操作权限<br>                - PROT_EXEC: 可执行权限<br>                - PROT_READ:读权限<br>                - PROT_WRITE: 写权限<br>                - PROT_NONE: 没有权限<br>                要操作内存映射，必须要有读权限<br>                PROT_READ、PROT_READ|PROT_WRITE<br>        - flags:<br>                - MAP_SHARED: 映射区的数据会自动和磁盘文件进行同步，进程间通信，必须要设置此选项<br>                - MAP_PRIVE: 不同步，内存映射区数据被改变，对原来的文件不修改，会重新创建新文件（写时复制）<br>        - fd: 需要映射的文件的文件描述符<br>                - 通过open得到（一个磁盘文件）<br>                - 注意：文件大小不能为<span class="hljs-number">0</span>，open指定的权限不能和prot参数冲突<br>        - offset：偏移量，一般不用。必须指定<span class="hljs-number">4</span>k的整数倍，<span class="hljs-number">0</span>表示不便宜<br>    返回值：返回创建的内存的首地址<br>        失败返回MAP_FAILED,. (<span class="hljs-type">void</span>*)<span class="hljs-number">-1</span><br>        <br><br><span class="hljs-type">int</span> <span class="hljs-title function_">munmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length)</span>;<br>        功能：释放内存映射<br>        参数：<br>            - addr：要释放的内存的首地址<br>            - length：要释放的内存大小，要和mmap函数中的legnth参数值一样<br><br><br><br>	使用内存映射实现进程间通信：<br>	<span class="hljs-number">1.</span> 有关系的进程（父子进程）<br>		- 还没有子进程的时候<br>			- 通过唯一的父进程，先创建内存映射区<br>		- 有了内存映射区后，创建子进程<br>		- 父子进程共享创建的内存映射区<br><br>	<span class="hljs-number">2.</span> 没有关系的进程间通信<br>		- 准备一个大小不是<span class="hljs-number">0</span>的磁盘文件<br>		- 进程<span class="hljs-number">1</span> 通过磁盘文件创建内存映射区<br>			- 得到一个操作这块内存的指针<br>		- 进程<span class="hljs-number">2</span> 通过磁盘文件创建内存映射区<br>			- 得到一个操作这块内存的指针<br>		- 使用映射区通信<br><br>	注意：内存映射区通信，是非阻塞的<br></code></pre></div></td></tr></table></figure>
<details>
    <summary>mmap / munmap</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wait.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>	<span class="hljs-comment">// 1. 打开一个文件</span><br>	<span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;test.txt&quot;</span>, O_RDWR);<br>	<span class="hljs-type">int</span> size = lseek(fd, <span class="hljs-number">0</span>, SEEK_END);<br><br>	<span class="hljs-comment">// 2. 创建内存映射区</span><br>	<span class="hljs-type">void</span> *ptr = mmap(<span class="hljs-literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">if</span>(ptr == MAP_FAILED)&#123;<br>		perror(<span class="hljs-string">&quot;mmap&quot;</span>);<br>		<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>	&#125;<br><br>	<span class="hljs-comment">// 3. 创建子进程</span><br>	<span class="hljs-type">pid_t</span> pid = fork();<br>	<span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)&#123;<br>		wait(<span class="hljs-literal">NULL</span>);<br>		<span class="hljs-comment">// parent</span><br>		<span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>];<br>		<span class="hljs-built_in">strcpy</span>(buf, (<span class="hljs-type">char</span> *)ptr);<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read data: %s\n&quot;</span>, buf);<br>	&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>		<span class="hljs-comment">// child</span><br>		<span class="hljs-built_in">strcpy</span>((<span class="hljs-type">char</span> *)ptr, <span class="hljs-string">&quot;nihao a, son!!&quot;</span>);<br>	&#125;<br>	<br>	<span class="hljs-comment">// 关闭内存映射区</span><br>	munmap(ptr, size);<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<p>内存映射经典问题：</p>
<ul>
<li>如果对mmap的返回值(ptr)做++操作(ptr++)，munmap能否成功？</li>
</ul>
<blockquote>
<p>可以进行++操作，但是munmap(ptr, len)需要传首地址</p>
</blockquote>
<ul>
<li>如果open时O_RDONLY，mmap时prot指定PROT_READ | PROT_WRITE会怎样？</li>
</ul>
<blockquote>
<p>错误，返回MAP_FAILED。open函数权限建议和prot参数权限保持一致（prot时open权限的子集）</p>
</blockquote>
<ul>
<li>如果文件偏移量为1000会怎样？</li>
</ul>
<blockquote>
<p>偏移量必须是4k的整数倍，否则返回MAP_FAILED</p>
</blockquote>
<ul>
<li>mmap什么情况下会调用失败？</li>
</ul>
<blockquote>
<ul>
<li>第一个参数：length = 0</li>
<li>第三个参数：prot<ul>
<li>只指定了写权限</li>
<li>prot为PROT_READ | PROT_WRITE，而fd为O_RDONLY / O_WRONLY</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>可以open的时候O_CREAT一个新文件来创建映射区吗？</li>
</ul>
<blockquote>
<ul>
<li>可以，但是文件大小不能为0</li>
<li>可以对新文件进行扩展:<ul>
<li>lseek()</li>
<li>truncate()</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>mmap后关闭文件描述符，对mmap映射有没有影响？</li>
</ul>
<blockquote>
<p>int fd = open(“xxx”);<br>mmap(,,,,fd,0);<br>close(fd);<br>映射区还存在，创建映射区的fd关闭，没有任何影响</p>
</blockquote>
<ul>
<li>对ptr越界操作会怎样？</li>
</ul>
<blockquote>
<p>void *ptr = mmap(NULL, 100,,,,,);<br>4K<br>越界操作，操作的是非法内存 -&gt; segmentation fault</p>
</blockquote>
<hr>
<details>
    <summary>使用文件映射实现文件拷贝功能（通常不会用）</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 使用文件映射实现文件拷贝功能（通常不会用）</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    思路：</span><br><span class="hljs-comment">        1. 对原始文件进行内存映射</span><br><span class="hljs-comment">        2. 创建新文件（扩展）</span><br><span class="hljs-comment">        3. 把新文件数据映射到内存中</span><br><span class="hljs-comment">        4. 通过内存映射将第一个文件的内存数据拷贝到新文件中</span><br><span class="hljs-comment">        5. 释放数据</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-comment">// 1. 对原始文件进行内存映射</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;english.txt&quot;</span>, O_RDWR);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取原始文件的大小</span><br>    <span class="hljs-type">int</span> len = lseek(fd, <span class="hljs-number">0</span>, SEEK_END);<br><br>    <span class="hljs-comment">// 2. 创建新文件（扩展）</span><br>    <span class="hljs-type">int</span> fd1 = open(<span class="hljs-string">&quot;cpy.txt&quot;</span>, O_RDWR | O_CREAT, <span class="hljs-number">0664</span>);<br>    <span class="hljs-keyword">if</span>(fd1 == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 对新文件进行扩展</span><br>    truncate(<span class="hljs-string">&quot;cpy.txt&quot;</span>, len);<br>    write(fd1, <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 3. 分别做内存映射</span><br>    <span class="hljs-type">void</span> *ptr = mmap(<span class="hljs-literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);<br>    <span class="hljs-type">void</span> *ptr1 = mmap(<span class="hljs-literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd1, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(ptr == MAP_FAILED || ptr1 == MAP_FAILED)&#123;<br>        perror(<span class="hljs-string">&quot;mmap&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 4. 通过内存映射将第一个文件的内存数据拷贝到新文件中</span><br>    <span class="hljs-built_in">memcpy</span>(ptr1, ptr, len);<br><br>    <span class="hljs-comment">// 5. 释放资源</span><br>    munmap(ptr1, len);<br>    munmap(ptr, len);<br>    close(fd1);<br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h5 id="匿名映射"><a href="#匿名映射" class="headerlink" title="匿名映射"></a>匿名映射</h5><details>
    <summary>匿名映射（父子进程通信）</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    匿名映射：不需要文件实体的内存映射</span><br><span class="hljs-comment">    用于父子间进程通信</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-comment">// 1. 创建匿名内存映射区</span><br>    <span class="hljs-type">int</span> len = <span class="hljs-number">4096</span>;<br>    <span class="hljs-type">void</span> *ptr = mmap(<span class="hljs-literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(ptr == MAP_FAILED)&#123;<br>        perror(<span class="hljs-string">&quot;mmap&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// 2. 父子进程间通信</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// parent</span><br>        <span class="hljs-built_in">strcpy</span>((<span class="hljs-type">char</span> *)ptr, <span class="hljs-string">&quot;hello world&quot;</span>);<br>        wait(<span class="hljs-literal">NULL</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// child</span><br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, (<span class="hljs-type">char</span> *)ptr);<br>    &#125;<br><br>    <span class="hljs-comment">// 3. 释放内存映射区</span><br>    <span class="hljs-type">int</span> ret = munmap(ptr, len);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;munmap&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><p>又称为<strong>软件中断</strong>，时一种<strong>异步</strong>通信的方式，发往进程的诸多信号通常都源于<strong>内核</strong>，其事件如下：</p>
<ul>
<li>对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入<code>Ctrl+C</code>通常会给进程发送一个中断信号。</li>
<li>硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令，诸如被0除，或者引用了无法访问的内存区域。</li>
<li>系统状态变化，比如alarm定时器到期将引起SIGALRM信号，进程执行的CPU时间超限，或者该进程的某个子进程退出。</li>
<li>运行kill 命令或调用kill 函数。</li>
</ul>
<p>使用信号的两个主要<strong>目的</strong>是:</p>
<ul>
<li>让进程知道已经发生了一个特定的事情。</li>
<li>强迫进程执行它自己代码中的信号处理程序。</li>
</ul>
<p>信号的特点:</p>
<ul>
<li>简单</li>
<li>不能携带大量信息</li>
<li>满足某个特定条件才发送<strong>优先级比较高</strong></li>
<li>查看系统定义的信号列表: <code>kill -l</code></li>
<li>前31个信号为常规信号，其余为实时信号。</li>
</ul>
<p>可以通过 <code>man 7 signal</code>查看文档</p>
<p>五种默认处理动作：Term, Ign, Core, Stop, Cont</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220906234027583.png" alt="常用信号1"></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220906234318205.png" alt="常用信号2"></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220906234353581.png" alt="常用信号3"></p>
<hr>
<h5 id="kill-raise-abort"><a href="#kill-raise-abort" class="headerlink" title="kill, raise, abort"></a>kill, raise, abort</h5><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">kill</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> sig)</span>;<br>    功能：给某个进程或进程组id发送某个信号sig<br>    参数：<br>        - pid：<br>            &gt; <span class="hljs-number">0</span>：发送给指定进程<br>            = <span class="hljs-number">0</span>：发送给进程组所有进程<br>            = <span class="hljs-number">-1</span>： 发送给每一个有权限接受这个信号的进程<br>            &lt; <span class="hljs-number">-1</span>：这个pid=某个进程组的ID取反<br>        - sig：需要发送的信号编号或宏值（建议用宏值）<br>    <br>    kill(getppid(), <span class="hljs-number">9</span>);<br>    kill(getpid(), <span class="hljs-number">9</span>);<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">raise</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span>;<br>    功能：给当前进程发送信号<br>    参数：<br>        - sig：需要发送的信号<br>    返回值：<br>        - 成功：<span class="hljs-number">0</span><br>        - 失败：非<span class="hljs-number">0</span><br>    等同于 kill(getpid(), sig);<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">abort</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br>    - 功能：发送SIGABRT信号给当前进程，杀死当前进程<br>    kill(getpid(), SIGABRT);<br></code></pre></div></td></tr></table></figure>
<details>
    <summary>kill</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent\n&quot;</span>);<br>        sleep(<span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;kill child process now\n&quot;</span>);<br>        kill(pid, SIGINT);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child\n&quot;</span>);<br>            sleep(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h5 id="alarm"><a href="#alarm" class="headerlink" title="alarm"></a>alarm</h5><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">alarm</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> seconds)</span>;<br>    功能：设置定时器（闹钟），函数调用开始倒计时，当倒计时为<span class="hljs-number">0</span>时，函数会给当前进程发送SIGALARM信号<br>    参数：<br>        - seconds：倒计时时长，单位：秒，如果参数为<span class="hljs-number">0</span>，则使alarm无效<br>            	   取消一个定时器，通过 alarm(<span class="hljs-number">0</span>)<br>    返回值：<br>        - 之前没有定时器：返回<span class="hljs-number">0</span><br>        - 之前有定时器：返回剩余时间<br><br>SIGALARM：默认终止当前的进程，每一个进程都有且只有一个唯一的定时器<br>    alarm(<span class="hljs-number">10</span>); -&gt; 返回<span class="hljs-number">0</span><br>    过了<span class="hljs-number">1</span>秒<br>    alarm(<span class="hljs-number">5</span>); -&gt; 返回<span class="hljs-number">9</span><br><br>alarm是非阻塞的<br>实际的时间 = 内核时间 + 用户时间 + 消耗的时间<br>进行文件IO操作的时候比较浪费时间<br>定时器：与进程的状态无关（自然定时法），无论进程处于什么状态，alarm都会计时<br></code></pre></div></td></tr></table></figure>
<details>
    <summary>alarm</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-type">int</span> seconds = alarm(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;seconds = %d\n&quot;</span>, seconds); <span class="hljs-comment">// 0</span><br>    <br>    sleep(<span class="hljs-number">2</span>);<br>    seconds = alarm(<span class="hljs-number">2</span>); <span class="hljs-comment">// 不阻塞</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;seconds = %d\n&quot;</span>, seconds); <span class="hljs-comment">// 3</span><br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<details>
    <summary>1s 电脑能数多少个数？</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 1s 电脑能数多少个数？</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-type">int</span> seconds = alarm(<span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%i\n&quot;</span>, i++);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h5 id="setitimer-signal"><a href="#setitimer-signal" class="headerlink" title="setitimer, signal"></a>setitimer, signal</h5><p>注意：尽量避免使用<code>signal</code>，因为它属于ANSI C标准，建议使用<code>sigaction</code></p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">setitimer</span><span class="hljs-params">(<span class="hljs-type">int</span> which, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> itimerval *new_value, <span class="hljs-keyword">struct</span> itimerval *old_value)</span>;<br>    功能：设定定时器（闹钟），可以替代alarm，精度微秒us， 可以实现周期<br>    参数：<br>        - which：定时器以什么时间计时<br>            ITIMER_REAL：真实时间，时间到达发送SIGALRM（常用）<br>            ITIMER_VIRTUAL：用户态时间，时间到达发送SIGVTALRM<br>            ITIMER_PROF：用户态+内核态时间，时间到达发送SIGPROF<br><br>        - new_value：设置定时器的属性<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">itimerval</span> &#123;</span>       <span class="hljs-comment">// 定时器结构体</span><br>               <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">it_interval</span>;</span> <span class="hljs-comment">// 每个阶段的时间，间隔时间</span><br>               <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">it_value</span>;</span>    <span class="hljs-comment">// 延迟多长时间执行定时器</span><br>           &#125;;<br><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> &#123;</span>         <span class="hljs-comment">// 时间的结构体</span><br>            <span class="hljs-type">time_t</span>      tv_sec;  <span class="hljs-comment">// 秒数</span><br>            <span class="hljs-type">suseconds_t</span> tv_usec; <span class="hljs-comment">// 微秒</span><br>        &#125;;<br>        <br>        - old_value：记录上一次定时的时间参数，一般不使用，指定<span class="hljs-literal">NULL</span><br>    返回值：<br>        - 成功：<span class="hljs-number">0</span><br>        - 失败：<span class="hljs-number">-1</span>，并设置errno<br>            <br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*<span class="hljs-type">sighandler_t</span>)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">sighandler_t</span> <span class="hljs-title function_">signal</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">sighandler_t</span> handler)</span>;<br>    功能：设置某个信号的捕捉行为<br>    参数：<br>        - signum：要捕捉的信号<br>        - handler：捕捉到信号如何处理<br>            - SIG_IGN：忽略信号<br>            - SIG_DFL：使用信号默认行为<br>            - 回调函数：由内核调用，程序员只负责写，捕捉到信号后如何处理信号<br>            回调函数：<br>                - 需要程序员实现，提前准备好，函数类型根据实际需求，看函数指针定义<br>                - 不是程序员调用，而是当信号产生由内核调用<br>                - 函数指针是实现回调的手段，函数实现后，将函数名放到函数指针的位置即可<br>    返回值：<br>        成功：返回上一次注册的信号处理函数的地址，第一次调用返回<span class="hljs-literal">NULL</span><br>        失败：返回SIG_ERR，设置错误号<br><br><br>SIGSTOP SIGSTOP 不能被捕捉，不能被忽略<br></code></pre></div></td></tr></table></figure>
<details>
    <summary>setitimer + signal 实现定时信号捕捉</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-comment">// 过3s后，每隔2s定时一次</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">myalarm</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123; <span class="hljs-comment">// 自定义回调函数</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;捕捉到的信号编号是: %d\n&quot;</span>, num);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xxxxxxxx\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-comment">// 注册信号捕捉</span><br>    <span class="hljs-comment">// signal(SIGALRM, SIG_IGN);</span><br>    <span class="hljs-comment">// signal(SIGALRM, SIG_DFL);</span><br>    <span class="hljs-comment">// void (*sighandler_t)(int); 函数指针，int类型参数表叔捕捉到的信号的值</span><br>    signal(SIGALRM, myalarm);<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">itimerval</span> <span class="hljs-title">new_value</span>;</span><br>    <span class="hljs-comment">// 设置间隔时间</span><br>    new_value.it_interval.tv_sec = <span class="hljs-number">2</span>;<br>    new_value.it_interval.tv_usec = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 设置延迟时间，3s后第一次发送信号，然后每隔2s发送一次</span><br>    new_value.it_value.tv_sec = <span class="hljs-number">3</span>;<br>    new_value.it_value.tv_usec = <span class="hljs-number">0</span>;<br><br><br>    <span class="hljs-type">int</span> ret = setitimer(ITIMER_REAL, &amp;new_value, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;定时器开始了。。。\n&quot;</span>);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;setitimer&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    getchar();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h5 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h5><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220907143348114.png" alt="阻塞信号集和未决信号集"></p>
<ol>
<li>用户通过键盘Ctrl + C，产生2号信号SIGINT（信号被创建）</li>
<li>信号产生但是没被处理（未决）<ul>
<li>在内核中将所有的没有被处理的信号存储在一个集合中（未决信号集）</li>
<li>SIGINT信号状态被存储在第二个标志位上<ul>
<li>该标志位为0：不是未决状态</li>
<li>该标志位为1：是未决状态</li>
</ul>
</li>
</ul>
</li>
<li>这个未决状态的信号需要被处理，处理前需要与阻塞信号集对应标志位比较<ul>
<li>如果没有阻塞，该信号被处理</li>
<li>如果阻塞，该信号处于未决状态，直到阻塞解除该信号才被处理</li>
</ul>
</li>
</ol>
<ul>
<li>阻塞信号集默认不阻塞任何信号</li>
<li>如果想要阻塞某些信号，需要用户调用系统API</li>
</ul>
<hr>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br>**以下函数均对自定义信号集操作**<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigemptyset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>;<br>    功能：清空信号集中的数据，将信号集中的所有标志位置<span class="hljs-number">0</span><br>    参数：<br>        - <span class="hljs-built_in">set</span>：传出参数，需要操作的信号集<br>    返回值：成功<span class="hljs-number">0</span>，失败<span class="hljs-number">-1</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigfillset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>;<br>    功能：将信号集中的所有标志位置<span class="hljs-number">1</span><br>    其余同上<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigaddset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>;<br>    功能：设置信号集中的某一个信号对应的标志位为<span class="hljs-number">1</span>，表示阻塞该信号<br>    参数：<br>        - <span class="hljs-built_in">set</span>：传出参数，需要操作的信号集<br>        - signum：需要设置阻塞的信号<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigdelset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>;<br>    功能：设置信号集中的某一个信号对应的标志位为<span class="hljs-number">0</span>，表示不阻塞该信号<br>    其余同上<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigismember</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>;<br>    功能：判断某个信号是否阻塞<br>    参数：<br>        - <span class="hljs-built_in">set</span>：需要操作的信号集<br>        - signum：需要判断的信号<br>    返回值：<br>        <span class="hljs-number">1</span>: signum被阻塞<br>        <span class="hljs-number">0</span>: signum不阻塞<br>        <span class="hljs-number">-1</span>: 调用失败<br></code></pre></div></td></tr></table></figure>
<details>
    <summary>操作自定义信号集</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-comment">// 创建一个信号集</span><br>    <span class="hljs-type">sigset_t</span> <span class="hljs-built_in">set</span>;<br><br>    <span class="hljs-comment">// 清空信号集的内容</span><br>    sigemptyset(&amp;<span class="hljs-built_in">set</span>);<br><br>    <span class="hljs-comment">// 判断 SIGINT 是否在信号集 set 里面</span><br>    <span class="hljs-type">int</span> ret = sigismember(&amp;<span class="hljs-built_in">set</span>, SIGINT);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SIGINT 不阻塞\n&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SIGINT 阻塞\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 添加几个信号到信号集中</span><br>    sigaddset(&amp;<span class="hljs-built_in">set</span>, SIGINT);<br>    sigaddset(&amp;<span class="hljs-built_in">set</span>, SIGQUIT);<br><br>    <span class="hljs-comment">// 判断 SIGINT 是否在信号集中</span><br>    ret = sigismember(&amp;<span class="hljs-built_in">set</span>, SIGINT);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SIGINT 不阻塞\n&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SIGINT 阻塞\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 判断 SIGQUIT 是否在信号集中</span><br>    ret = sigismember(&amp;<span class="hljs-built_in">set</span>, SIGQUIT);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SIGQUIT 不阻塞\n&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SIGQUIT 阻塞\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 从信号集中删除一个信号</span><br>    sigdelset(&amp;<span class="hljs-built_in">set</span>, SIGQUIT);<br><br>    <span class="hljs-comment">// 判断 SIGQUIT 是否在信号集中</span><br>    ret = sigismember(&amp;<span class="hljs-built_in">set</span>, SIGQUIT);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SIGQUIT 不阻塞\n&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SIGQUIT 阻塞\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigprocmask</span><span class="hljs-params">(<span class="hljs-type">int</span> how, <span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">sigset_t</span> *oldset)</span>;<br>    功能：将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）<br>    参数：<br>        - how：如何对内核阻塞信号集进行处理<br>            SIG_BLOCK：将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变<br>            SIG_UNBLOCK：根据用户设置的数据，对内核中的数据进行接触阻塞<br>                <span class="hljs-built_in">set</span> &amp;= ~mask<br>            SIG_SETMASK：覆盖内核中原来的值<br>        - <span class="hljs-built_in">set</span>：已经初始化好的用户自定义的信号集<br>        - oldset：保存设置之前的内核中的阻塞信号集的状态，通常为<span class="hljs-literal">NULL</span><br>    返回值：<br>        - 成功：<span class="hljs-number">0</span><br>        - 失败：<span class="hljs-number">-1</span><br><span class="hljs-type">int</span> sigpending(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>);<br>    功能：获取内核中的未决信号集<br>    参数：<br>        - <span class="hljs-built_in">set</span>：传出参数，保存的是内核中的未决信号集的信息<br></code></pre></div></td></tr></table></figure>
<details>
    <summary>把内核中的常规信号（1-31）的未决状态打印到屏幕</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 编写一个程序，把内核中的常规信号（1-31）的未决状态打印到屏幕</span><br><span class="hljs-comment">// 设置某些信号是阻塞的，通过键盘产生这些信号</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 设置2、3信号阻塞</span><br>    <span class="hljs-type">sigset_t</span> <span class="hljs-built_in">set</span>;<br>    sigemptyset(&amp;<span class="hljs-built_in">set</span>);<br>    <span class="hljs-comment">// 将2、3信号添加到信号集中</span><br>    sigaddset(&amp;<span class="hljs-built_in">set</span>, SIGINT);<br>    sigaddset(&amp;<span class="hljs-built_in">set</span>, SIGQUIT);<br>    <span class="hljs-comment">// 修改内存中的阻塞信号集</span><br>    sigprocmask(SIG_BLOCK, &amp;<span class="hljs-built_in">set</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-comment">// 获取当前的未决信号集的数据</span><br>        <span class="hljs-type">sigset_t</span> pendingset;<br>        sigemptyset(&amp;pendingset);<br>        sigpending(&amp;pendingset);<br>        <span class="hljs-comment">// 遍历前32位</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">32</span>;++i)&#123;<br>            <span class="hljs-keyword">if</span>(sigismember(&amp;pendingset, i) == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sigismember(&amp;pendingset, i) == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                perror(<span class="hljs-string">&quot;sigismenber&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(++num == <span class="hljs-number">10</span>)&#123;<br>            <span class="hljs-comment">// 解除阻塞</span><br>            sigprocmask(SIG_UNBLOCK, &amp;<span class="hljs-built_in">set</span>, <span class="hljs-literal">NULL</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220907195418782.png" alt="信号捕捉时内核与用户态操作流程"></p>
<h5 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h5><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigaction</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sigaction *act, <span class="hljs-keyword">struct</span> sigaction *oldact)</span>;<br>    功能：检查或改变信号的处理。信号捕捉<br>    参数：<br>        - signum：需要捕捉的信号的编号或宏值（信号的名称）<br>        - act：捕捉到信号之后的处理动作<br>        - oldact：上一次对信号捕捉相关的设置，一般不使用，传递<span class="hljs-literal">NULL</span><br>    返回值：<br>        - 成功：<span class="hljs-number">0</span><br>        - 失败：<span class="hljs-number">-1</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> &#123;</span><br>        <span class="hljs-comment">// 函数指针，指向函数就是信号捕捉到之后的处理函数</span><br>        <span class="hljs-type">void</span>     (*sa_handler)(<span class="hljs-type">int</span>);<br>        <span class="hljs-comment">// 不常用</span><br>        <span class="hljs-type">void</span>     (*sa_sigaction)(<span class="hljs-type">int</span>, <span class="hljs-type">siginfo_t</span> *, <span class="hljs-type">void</span> *);<br>        <span class="hljs-comment">// 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号</span><br>        <span class="hljs-type">sigset_t</span>   sa_mask;<br>        <span class="hljs-comment">// 使用哪一个信号处理对捕捉到的信号进行处理</span><br>        <span class="hljs-comment">// 这个值可以是0，表示使用sa_handler，也可以是SA_SIGINFO表示使用sa_sigaction</span><br>        <span class="hljs-type">int</span>        sa_flags;<br>        <span class="hljs-comment">// 已被废弃</span><br>        <span class="hljs-type">void</span>     (*sa_restorer)(<span class="hljs-type">void</span>);<br>    &#125;;<br></code></pre></div></td></tr></table></figure>
<details>
    <summary>sigaction捕捉信号</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-comment">// 过3s后，每隔2s定时一次</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">myalarm</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123; <span class="hljs-comment">// 自定义回调函数</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;捕捉到的信号编号是: %d\n&quot;</span>, num);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xxxxxxxx\n&quot;</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">act</span>;</span><br>    act.sa_flags = <span class="hljs-number">0</span>;<br>    act.sa_handler = myalarm;<br>    sigemptyset(&amp;act.sa_mask); <span class="hljs-comment">// 清空临时阻塞信号集</span><br>    <span class="hljs-comment">// 注册信号捕捉</span><br>    sigaction(SIGALRM, &amp;act, <span class="hljs-literal">NULL</span>);<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">itimerval</span> <span class="hljs-title">new_value</span>;</span><br>    <span class="hljs-comment">// 设置间隔时间</span><br>    new_value.it_interval.tv_sec = <span class="hljs-number">2</span>;<br>    new_value.it_interval.tv_usec = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 设置延迟时间，3s后第一次发送信号，然后每隔2s发送一次</span><br>    new_value.it_value.tv_sec = <span class="hljs-number">3</span>;<br>    new_value.it_value.tv_usec = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> ret = setitimer(ITIMER_REAL, &amp;new_value, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;定时器开始了。。。\n&quot;</span>);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;setitimer&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;&#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h5 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a>SIGCHLD信号</h5><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">SIGCHLD 信号产生的<span class="hljs-number">3</span>个条件：<br>    <span class="hljs-number">1.</span> 子进程结束<br>    <span class="hljs-number">2.</span> 子进程暂停了<br>    <span class="hljs-number">3.</span> 子进程继续运行<br>    都会给父进程发送该信号，父进程默认忽略该信号。<br>使用SIGCHLD信号可以解决僵尸进程的问题。<br></code></pre></div></td></tr></table></figure>
<details>
    <summary>SIGCHILD信号捕获</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">myFun</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;捕捉到的信号：%d\n&quot;</span>, num);<br>    <span class="hljs-comment">// 回收子进程PCB资源</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-type">int</span> ret = waitpid(<span class="hljs-number">-1</span>, <span class="hljs-literal">NULL</span>, WNOHANG);<br>        <span class="hljs-keyword">if</span>(ret &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child die, pid = %d\n&quot;</span>, ret);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// 说明还有子进程活着</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-comment">// 没有子进程</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-comment">// 提前设置好阻塞信号集，阻塞SITCHLD，因为有可能子进程很快结束，父进程还没捕捉到</span><br>    <span class="hljs-type">sigset_t</span> <span class="hljs-built_in">set</span>;<br>    sigemptyset(&amp;<span class="hljs-built_in">set</span>);<br>    sigaddset(&amp;<span class="hljs-built_in">set</span>, SIGCHLD);<br>    sigprocmask(SIG_BLOCK, &amp;<span class="hljs-built_in">set</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; ++i)&#123;<br>        pid = fork();<br>        <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// parent</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">act</span>;</span><br>        act.sa_flags = <span class="hljs-number">0</span>;<br>        act.sa_handler = myFun;<br>        sigaction(SIGCHLD, &amp;act, <span class="hljs-literal">NULL</span>);<br><br>        <span class="hljs-comment">// 注册玩信号捕捉后，解除阻塞</span><br>        sigprocmask(SIG_UNBLOCK, &amp;<span class="hljs-built_in">set</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent process pid: %d\n&quot;</span>, getpid());<br>            sleep(<span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// child</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child process pid: %d\n&quot;</span>, getpid());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><ul>
<li>共享内存允许两个或者多个进程共享物理内存的同一块区域(通常被称为段)。由于一个共享内存段会成为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。</li>
<li>与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比，这种IPC技术的速度更快。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><br>共享内存相关的函数<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmget</span><span class="hljs-params">(<span class="hljs-type">key_t</span> key, <span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> shmflg)</span>;<br>    功能：创建一个新的共享内存段，或者获取一个既有得共享内存段得标识<br>        新创建得内存段中得数据都会被初始化为<span class="hljs-number">0</span><br>    参数：<br>        - key: <span class="hljs-type">key_t</span> 类型是一个整形，通过这个找到或创建一个共享内存<br>                一般使用<span class="hljs-number">16</span>进制表示，非<span class="hljs-number">0</span><br>        - size: 共享内存得大小<br>        - shmflg: 属性<br>            - 访问权限<br>            - 附加属性：创建/判断共享内存是否存在<br>                - 创建：IPC_CREAT<br>                - 判断是否存在：IPC_EXCL，需要和IPC_CREAT一起使用<br>            例如：IPC_CREAT | IPC_EXCL | <span class="hljs-number">0664</span><br>    返回值：<br>        成功：&gt;<span class="hljs-number">0</span> 返回共性内存引用得ID，之后操作共性内存都是通过这个值<br>        失败：<span class="hljs-number">-1</span>，并设置errno<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">shmat</span><span class="hljs-params">(<span class="hljs-type">int</span> shmid, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *shmaddr, <span class="hljs-type">int</span> shmflg)</span>;<br>    功能：和当前的进程进行关联<br>    参数：<br>        - shmid: 共享内存的标识，由shmget返回值获取<br>        - shmaddr: 申请的共享内存的起始地址，指定<span class="hljs-literal">NULL</span>，内核指定<br>        - shmflg: 对共享内存的操作<br>            - 读：SHM_RDONLY，必须要有<br>            - 读写：<span class="hljs-number">0</span><br>    返回值：<br>        成功：返回共享内存的首地址<br>        失败：(<span class="hljs-type">void</span> *) <span class="hljs-number">-1</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmdt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *shmaddr)</span>;<br>    功能：解除当前进程和共享内存的关联<br>    参数：<br>        - shmaddr：共享内存的首地址<br>    返回值：<br>        成功：<span class="hljs-number">0</span><br>        失败：<span class="hljs-number">-1</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmctl</span><span class="hljs-params">(<span class="hljs-type">int</span> shmid, <span class="hljs-type">int</span> cmd, <span class="hljs-keyword">struct</span> shmid_ds *buf)</span>;<br>    功能：对共享内存进行操作，共享内存删除才会消失，创建共享内存的进程被销毁了，对共享内存无影响<br>    参数：<br>        - shmid：共享内存的ID<br>        - cmd：<br>            - IPC_STAT：获取共享内存当前状态<br>            - IPC_SET：设置共享内存状态<br>            - IPC_RMID：标记共享内存被销毁<br>        - buf：需要设置或获取的共享内存的属性信息<br>            - IPC_STAT：buf存储数据<br>            - IPC_SET：buf中需要初始化数据，设置到内存中<br>            - IPC_RMID：没用，<span class="hljs-literal">NULL</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-type">key_t</span> <span class="hljs-title function_">ftok</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> proj_id)</span>;<br>    功能：根据指定的路径名，和<span class="hljs-type">int</span>值，生成一个共享内存的key<br>    参数：<br>        - pathname: 指定一个存在的路径<br>        - proj_id: <span class="hljs-type">int</span>类型，但是这个系统调用只会使用其中的<span class="hljs-number">1</span>个字节<br>            范围: <span class="hljs-number">0</span>~<span class="hljs-number">255</span>, <span class="hljs-string">&#x27;a&#x27;</span><br></code></pre></div></td></tr></table></figure>
<hr>
<p><strong>问题1. 操作系统如何直到一块共享内存被多少个进程关联？</strong></p>
<ul>
<li>共享内存维护了一个结构体struct shmid_ds，这个结构体中的成员shm_nattach记录了关联的进程个数</li>
</ul>
<p><strong>问题2. 可不可以对共享内存进行多次删除？</strong></p>
<ul>
<li>可以，因为shmctl<strong>标记删除</strong>（key设置为0）共享内存，不是直接删除</li>
<li>当和共享内存关联的进程数为0时，真正被删除</li>
</ul>
<p><strong>问题3. 共享内存与内存映射的区别</strong></p>
<ol>
<li>共享内存可以直接创建，内存映射依赖磁盘文件（匿名映射除外）</li>
<li>共享内存效率更高</li>
<li>内存映射：所有进程操作的时同一块共享内存<br>内存映射：每个进程再自己的虚拟地址空间有一个独立的内存</li>
<li>数据安全：<ul>
<li>进程突然退出：<br>  共享内存仍然存在，但内存映射区消失</li>
<li>运行进程的电脑宕机<br>  共享内存中的数据无了，内存映射区的数据由于磁盘文件中的数据还在，所以仍存在</li>
</ul>
</li>
<li>生命周期<br> 内存映射区：进程退出，内存映射区销毁<br> 共享内存：进程退出，共享内存还在，标记删除（所有关联进程数为0），或者关机。如果一个进程退出，会自动和共享内存取消关联</li>
</ol>
<hr>
<p>简单实现共享内存通信：</p>
<details>
    <summary>write.c</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 1. 创建一个共享内存</span><br>    <span class="hljs-type">int</span> shmid = shmget(<span class="hljs-number">100</span>, <span class="hljs-number">4096</span>, IPC_CREAT | <span class="hljs-number">0664</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;shmid : %d\n&quot;</span>, shmid);<br>    <span class="hljs-comment">// 2. 和当前进程进行关联</span><br>    <span class="hljs-type">void</span> *ptr = shmat(shmid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 3. 写数据</span><br>    <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;hello world&quot;</span>;<br>    <span class="hljs-built_in">memcpy</span>(ptr, str, <span class="hljs-built_in">strlen</span>(str)+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;按任意键继续\n&quot;</span>);<br>    getchar();<br>    <span class="hljs-comment">// 4. 解除关联</span><br>    shmdt(ptr);<br>    <span class="hljs-comment">// 5. 删除共享内存</span><br>    shmctl(shmid, IPC_RMID, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<details>
    <summary>read.c</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 1. 获取一个共享内存</span><br>    <span class="hljs-type">int</span> shmid = shmget(<span class="hljs-number">100</span>, <span class="hljs-number">0</span>, IPC_CREAT);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;shmid : %d\n&quot;</span>, shmid);<br>    <span class="hljs-comment">// 2. 和当前进程进行关联</span><br>    <span class="hljs-type">void</span> *ptr = shmat(shmid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 3. 读数据</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, (<span class="hljs-type">char</span> *)ptr);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;按任意键继续\n&quot;</span>);<br>    getchar();<br>    <span class="hljs-comment">// 4. 解除关联</span><br>    shmdt(ptr);<br>    <span class="hljs-comment">// 5. 删除共享内存</span><br>    shmctl(shmid, IPC_RMID, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>即Daemon进程，属于后台服务进程，其具备以下特征：</p>
<ul>
<li>生命周期很长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭。</li>
<li>它在后台运行并且不拥有控制终端。没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号(如SIGINT、SIGQUIT)。</li>
</ul>
<p>典型案例：Internet服务器inetd，Web服务器httpd等。</p>
<p>创建步骤：</p>
<ul>
<li><strong>执行<code>fork()</code>，父进程退出，子进程继续执行</strong></li>
<li><strong>子进程调用<code>setsid()</code>开启一个新会话（以上两步的原因：确保新会话脱离当前控制终端连接，且进程组id不会冲突，通过子进程调用setsid()会以子进程id作为新进程组和会话的id）</strong></li>
<li>清除进程的umask以确保当前守护进程创建文件和目录时拥有所需权限</li>
<li>修改进程的当前工作目录，通常会更改为根目录</li>
<li>关闭守护进程从其父进程继承而来的所有打开着的的文件描述符</li>
<li>在关闭了描述符0、1、2后，守护进程通常会打开/dev/null并使用dup2()使所有这些描述符指向这个设备</li>
<li><strong>核心业务逻辑</strong></li>
</ul>
<hr>
<p>实现一个守护进程，每隔2s获取系统时间，将这个时间写入到磁盘文件中</p>
<details>
    <summary>code</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;<br>    <span class="hljs-comment">// 捕捉到信号后，获取系统时间，写入磁盘文件</span><br>    <span class="hljs-type">time_t</span> tm = time(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> *<span class="hljs-title">loc</span> =</span> localtime(&amp;tm);<br>    <span class="hljs-type">char</span> * str = asctime(loc); <span class="hljs-comment">// 时间格式化为字符串</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;time.txt&quot;</span>, O_RDWR | O_CREAT | O_APPEND, <span class="hljs-number">0664</span>);<br>    write(fd, str, <span class="hljs-built_in">strlen</span>(str));<br>    close(fd);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-comment">// 1. 创建子进程，退出父进程</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// 2. 将子进程重新创建一个会话</span><br>    setsid();<br><br>    <span class="hljs-comment">// 3. 设置掩码</span><br>    umask(<span class="hljs-number">022</span>);<br><br>    <span class="hljs-comment">// 4. 更改工作目录</span><br>    chdir(<span class="hljs-string">&quot;/home/wlx/&quot;</span>);<br><br>    <span class="hljs-comment">// 5. 关闭、重定向文件描述符</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/dev/null&quot;</span>, O_RDWR);<br>    dup2(fd, STDIN_FILENO);<br>    dup2(fd, STDOUT_FILENO);<br>    dup2(fd, STDERR_FILENO);<br><br>    <span class="hljs-comment">// 6. 业务逻辑</span><br><br>    <span class="hljs-comment">// 捕捉定时信号</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">act</span>;</span><br>    act.sa_flags = <span class="hljs-number">0</span>;<br>    act.sa_handler = work;<br>    sigemptyset(&amp;act.sa_mask);<br>    sigaction(SIGALRM, &amp;act, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 创建定时器</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">itimerval</span> <span class="hljs-title">val</span>;</span><br>    val.it_value.tv_sec = <span class="hljs-number">2</span>;<br>    val.it_value.tv_usec = <span class="hljs-number">0</span>;<br>    val.it_interval.tv_sec = <span class="hljs-number">2</span>;<br>    val.it_interval.tv_usec = <span class="hljs-number">0</span>;<br>    setitimer(ITIMER_REAL, &amp;val, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 不让进程结束</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        sleep(<span class="hljs-number">10</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h2 id="多线程开发"><a href="#多线程开发" class="headerlink" title="多线程开发"></a>多线程开发</h2><ul>
<li><p>允许程序并发执行多个任务的一种机制，一个进程可以包含多个线程，同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段、堆内存段。</p>
</li>
<li><p>进程是CPU分配资源的最小单位，线程是操作系统调度执行的最小单位。</p>
</li>
<li><p>线程是轻量级的进程（LWP），在Linux环境下线程的本质仍是进程。</p>
</li>
<li><p>通过<code>ps -Lf pid</code> 获取指定进程的LWP号</p>
</li>
</ul>
<p><strong>为什么要有线程：</strong></p>
<ul>
<li>进程间信息难以共享，必须采用进程间通信方式</li>
<li>调用<code>fork()</code>创建进程代价较高（即使采用写时复制技术，仍需要复制内存页表、文件描述符表等属性）</li>
<li>线程之间能方便快速地共享信息，只需将数据复制到共享（全局或堆）变量中即可</li>
<li>创建线程比创建进程快10倍以上，线程间共享虚拟地址空间，无需采用写时复制技术，无需复制页表</li>
</ul>
<p><strong>线程中共享的资源：</strong></p>
<ul>
<li><p>进程ID和父进程ID</p>
</li>
<li><p>进程组ID和会话ID</p>
</li>
<li>用户ID 和用户组ID</li>
<li>文件描述符表</li>
<li>信号处置<br>文件系统的相关信息:文件权限掩码(umask)、当前工作目录</li>
<li>虚拟地址空间（除栈、.text)</li>
</ul>
<p><strong>线程中不共享的资源：</strong></p>
<ul>
<li>线程ID</li>
<li>信号掩码</li>
<li>线程特有数据</li>
<li>error变量</li>
<li>实时调度策略和优先级</li>
<li>栈，本地变量和函数的调用链接信息</li>
</ul>
<p>查看当前<code>pthred</code>库的版本：<code>getconf GNU_LIBPTHREAD_VERSION</code></p>
<p>注意，在编译具有thread的C程序时，需要添加编译命令 <code>-pthread</code> 用来导入thread静态库</p>
<hr>
<h3 id="pthread库常用函数"><a href="#pthread库常用函数" class="headerlink" title="pthread库常用函数"></a>pthread库常用函数</h3><h4 id="线程创建：pthread-create"><a href="#线程创建：pthread-create" class="headerlink" title="线程创建：pthread_create"></a>线程创建：pthread_create</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">一般情况下，main函数所在线程称为主线程（main线程），其余创建的线程成为子线程<br><br>    程序中默认只有一个进程，fork()函数调用 -&gt; <span class="hljs-number">2</span>个进程<br>    程序中默认只有一个线程，pthread_create()函数调用 -&gt; <span class="hljs-number">2</span>个线程<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_create</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> *thread, <span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span> *attr,</span><br><span class="hljs-params"><span class="hljs-type">void</span> *(*start_routine) (<span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *arg)</span>;<br>    功能：创建一个子线程<br>    参数：<br>        - thread: 传出参数，线程创建成功后，子线程的ID被写到该文档中<br>        - attr: 设置线程属性，一般使用<span class="hljs-literal">NULL</span>默认值<br>        - start_routine: 函数指针，这个函数是子线程需要处理的逻辑代码<br>        - arg: 给start_routine使用，传参<br>    返回值：<br>        成功：<span class="hljs-number">0</span><br>        失败：返回错误号（与errno不同，<span class="hljs-type">char</span> *<span class="hljs-title function_">strerror</span><span class="hljs-params">(<span class="hljs-type">int</span> errnum)</span>;<br></code></pre></div></td></tr></table></figure>
<details>
    <summary>pthread_create</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">callback</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child thread...\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;arg value: %d\n&quot;</span>, *(<span class="hljs-type">int</span> *)arg);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> ret = pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, callback, (<span class="hljs-type">void</span> *)&amp;num);<br>    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">char</span> * errstr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error: %s\n&quot;</span>, errstr);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i);<br>    &#125;<br><br>    sleep(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// exit(0)</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h4 id="线程退出：pthread-exit"><a href="#线程退出：pthread-exit" class="headerlink" title="线程退出：pthread_exit"></a>线程退出：pthread_exit</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">pthread_exit</span><span class="hljs-params">(<span class="hljs-type">void</span> *retval)</span>;<br>    功能：终止当前调用该函数的进程<br>    参数：<br>        - retval：指针作为返回值，可以在pthread_join()中获取到<br><br><span class="hljs-type">pthread_t</span> <span class="hljs-title function_">pthread_self</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br>    功能：获取当前调用线程的id<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_equal</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> t1, <span class="hljs-type">pthread_t</span> t2)</span>;<br>    功能：比较两个线程ID是否相等<br>    不同操作系统的pthread实现不同，大部分是usigned <span class="hljs-type">long</span>，有的是<span class="hljs-class"><span class="hljs-keyword">struct</span></span><br></code></pre></div></td></tr></table></figure>
<details>
    <summary>pthread_exit</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">callback</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child thread id: %ld\n&quot;</span>, pthread_self());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// pthread_exit(NULL);</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-comment">// 创建一个线程</span><br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-type">int</span> ret = pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, callback, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">char</span> *errstr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error: %s\n&quot;</span>, errstr);<br>    &#125;<br><br>    <span class="hljs-comment">// 主线程</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;tid: %ld, main thread id: %ld\n&quot;</span>, tid, pthread_self());<br><br>    <span class="hljs-comment">// 让主线程退出，不会影响其他线程</span><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main thread exit\n&quot;</span>); <span class="hljs-comment">// 不会执行</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h4 id="线程连接：pthread-join"><a href="#线程连接：pthread-join" class="headerlink" title="线程连接：pthread_join"></a>线程连接：pthread_join</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_join</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread, <span class="hljs-type">void</span> **retval)</span>;<br>    功能：和一个已经终止的线程进行连接，用于回收子线程资源<br>        特点：<br>            该函数是阻塞函数，调用一次只能回收一个子线程<br>            一般在主线程中使用<br>    参数：<br>        - thread: 需要回收的子线程的ID<br>        - retval: 接收子线程退出时的返回时<br>    返回值：<br>        成功：<span class="hljs-number">0</span><br>        失败：非零，返回的错误号<br></code></pre></div></td></tr></table></figure>
<details>
    <summary>pthread_join</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">callback</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child thread id: %ld\n&quot;</span>, pthread_self());<br>    sleep(<span class="hljs-number">3</span>);<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> val = <span class="hljs-number">10</span>; <span class="hljs-comment">// 注意一定不能返回局部变量（子线程栈区在结束后就释放了）</span><br>    pthread_exit((<span class="hljs-type">void</span> *)&amp;val); <span class="hljs-comment">// return (void *)&amp;val;</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-comment">// 创建一个子线程</span><br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-type">int</span> ret = pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, callback, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">char</span> *errstr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error: %s\n&quot;</span>, errstr);<br>    &#125;<br><br>    <span class="hljs-comment">// 主线程</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;tid: %ld, main thread id: %ld\n&quot;</span>, tid, pthread_self());<br><br>    <span class="hljs-comment">// 主线程调用pthread_join回收子线程资源</span><br>    <span class="hljs-type">int</span> *thread_retval;<br>    ret = pthread_join(tid, (<span class="hljs-type">void</span> **)&amp;thread_retval);<br>    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">char</span> *errstr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error: %s\n&quot;</span>, errstr);<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exit data: %d\n&quot;</span>, *thread_retval);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;回收子线程资源成功\n&quot;</span>);<br><br>    <span class="hljs-comment">// 让主线程退出，不会影响其他线程</span><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h4 id="线程分离：pthread-detach"><a href="#线程分离：pthread-detach" class="headerlink" title="线程分离：pthread_detach"></a>线程分离：pthread_detach</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_detach</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread)</span>;<br>    功能：分离一个线程，被分离的线程在终止时会自动释放资源返回给系统<br>        <span class="hljs-number">1.</span> 不能多次分离，会产生未定义行为<br>        <span class="hljs-number">2.</span> 不能区连接已经分离的线程，否则报错<br>    参数：<br>        thread：需要分离的线程id<br>    返回值：<br>        成功：<span class="hljs-number">0</span><br>        失败：错误号<br></code></pre></div></td></tr></table></figure>
<details>
    <summary>pthread_detach</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">callback</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child thread id: %ld\n&quot;</span>, pthread_self());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br><br>    <span class="hljs-comment">// 创建一个子线程</span><br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-type">int</span> ret = pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, callback, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">char</span> *errostr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error1: %s\n&quot;</span>, errostr);<br>    &#125;<br><br>    <span class="hljs-comment">// 输出主线程和子线程的ID</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;tid: %ld, main thread id: %d\n&quot;</span>, tid, pthread_self());<br><br>    <span class="hljs-comment">// 设置子线程分离，分离后子线程结束时结束时的资源就不需主线程释放</span><br>    ret = pthread_detach(tid);<br>    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">char</span> *errostr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error2: %s\n&quot;</span>, errostr);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置分离后，对分离的子线程进行连接 pthread_join()</span><br>    ret = pthread_join(tid, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">char</span> *errostr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error3: %s\n&quot;</span>, errostr); <span class="hljs-comment">// 会报错</span><br>    &#125;<br><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h4 id="线程取消：pthread-cancel"><a href="#线程取消：pthread-cancel" class="headerlink" title="线程取消：pthread_cancel"></a>线程取消：pthread_cancel</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cancel</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread)</span>;<br>    功能：取消线程（让线程终止）<br>         取消某个线程，可以终止某个线程的运行<br>         但并不是立刻终止，而是到取消点终止<br><br>         取消点：系统规定好的一些系统调用<br>         可粗略地理解为从用户态到内核态的切换这一点<br></code></pre></div></td></tr></table></figure>
<details>
    <summary>pthread_cancel</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">callback</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child thread id: %ld\n&quot;</span>, pthread_self());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)&#123; <span class="hljs-comment">// 这个循环可能没执行完就被取消了</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child: %d\n&quot;</span>, i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br><br>    <span class="hljs-comment">// 创建一个子线程</span><br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-type">int</span> ret = pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, callback, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">char</span> *errostr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error1: %s\n&quot;</span>, errostr);<br>    &#125;<br><br>    <span class="hljs-comment">// 取消线程</span><br>    pthread_cancel(tid);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent: %d\n&quot;</span>, i);<br>    &#125;<br><br>    <span class="hljs-comment">// 输出主线程和子线程的ID</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;tid: %ld, main thread id: %d\n&quot;</span>, tid, pthread_self());<br><br>    <span class="hljs-comment">// 退出主线程</span><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h4 id="线程属性：pthread-attr"><a href="#线程属性：pthread-attr" class="headerlink" title="线程属性：pthread_attr"></a>线程属性：pthread_attr</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_attr_init</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span> *attr)</span>;<br>    功能：初始化线程属性变量<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_attr_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span> *attr)</span>;<br>    功能：释放线程属性的资源<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_attr_setdetachstate</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span> *attr, <span class="hljs-type">int</span> detachstate)</span>;<br>    功能：获取线程分离的状态属性<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_attr_getdetachstate</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span> *attr, <span class="hljs-type">int</span> *detachstate)</span>;<br>    功能：设置线程分离的状态属性<br><br>...<br></code></pre></div></td></tr></table></figure>
<details>
    <summary>phtread_attr</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">callback</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child thread id: %ld\n&quot;</span>, pthread_self());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-comment">// 创建一个线程属性变量</span><br>    <span class="hljs-type">pthread_attr_t</span> attr;<br>    <span class="hljs-comment">// 初始化属性变量</span><br>    pthread_attr_init(&amp;attr);<br>    <span class="hljs-comment">// 设置属性（此处设置线程分离）</span><br>    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);<br><br>    <span class="hljs-comment">// 获取线程栈大小</span><br>    <span class="hljs-type">size_t</span> size;<br>    pthread_attr_getstacksize(&amp;attr, &amp;size);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread stack size: %ld\n&quot;</span>,size);<br><br>    <span class="hljs-comment">// 创建一个子线程</span><br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-type">int</span> ret = pthread_create(&amp;tid, &amp;attr, callback, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">char</span> *errostr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error1: %s\n&quot;</span>, errostr);<br>    &#125;<br><br>    <span class="hljs-comment">// 输出主线程和子线程的ID</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;tid: %ld, main thread id: %d\n&quot;</span>, tid, pthread_self());<br><br>    <span class="hljs-comment">// 释放线程属性资源</span><br>    pthread_attr_destroy(&amp;attr);<br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

---

### 线程同步

- 线程的主要优势在于，能够通过全局变量来共享信息。不过，这种便捷的共享是有代价的：必须确保多个线程不会同时修改同一变量，或者某一线程不会读取正在由其他线程修改的变量。
- 临界区是指访问某一共享资源的代码片段，并且这段代码的执行应为**原子操作**，也就是同时访问同一共享资源的其他线程不应终端该片段的执行。
- **线程同步**：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处于等待状态。

---

### 互斥锁

- 为避免线程更新共享变量时出现问题，可以使用互斥量(mutual exclusion）来确保同时仅有一个线程可以访问某项共享资源。可以使用互斥量来保证对任意共享资源的原子访问。
- 互斥量有两种状态：已锁定(locked)和未锁定(unlocked)。任何时候，至多只有一个线程可以锁定该互斥量。试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报错失败，具体取决于加锁时使用的方法。
- 一旦线程锁定互斥量，随即成为该互斥量的所有者，只有所有者才能给互斥量解锁。一般情况下，对每一共享资源（可能由多个相关变量组成）会使用不同的互斥量，每一线程在访问同一资源时将采用如下协议:
  - 针对共享资源锁定互斥量
  - 访问共享资源
  - 对互斥量解锁
- 如果多个线程试图执行这一块代码（一个临界区)，事实上只有一个线在能够持有该旦斥量(其他线程将遭到阻塞)，即同时只有一个线程能够进入这段代码区域，如下图所示：

![互斥锁保证线程同步](https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220916155535865.png)

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br>互斥量的类型：<span class="hljs-type">pthread_mutex_t</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_init</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *<span class="hljs-keyword">restrict</span> mutex,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">pthread_mutexattr_t</span> *<span class="hljs-keyword">restrict</span> attr)</span>;<br>功能：初始化互斥量<br>参数：<br>	- mutex: 需要初始化的互斥量变量<br>	- attr: 互斥量相关的属性，<span class="hljs-literal">NULL</span><br>	-<span class="hljs-keyword">restrict</span>: C语言修饰符，被修饰的指针，不能由另一个指针操作<br>	<span class="hljs-type">pthread_mutex_t</span> *<span class="hljs-keyword">restrict</span> mutex = xxx;<br>	<span class="hljs-type">pthread_mutex_t</span> *mutex1 = mutex; <span class="hljs-comment">// 报错</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;<br>功能：释放互斥量资源<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_lock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;<br>功能：加锁（阻塞，如果有一个线程加锁了，其他线程等待）<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_trylock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;<br>功能：尝试加锁（如果加锁失败，会直接返回）<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_unlock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;<br>功能：解锁<br></code></pre></div></td></tr></table></figure>

<details>
    <summary>互斥锁实现多线程买票</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    使用多线程实现买票案例</span><br><span class="hljs-comment">    一共100张票，3个窗口并发卖票</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 全局变量，所有线程共享这一份资源</span><br><span class="hljs-type">int</span> tickets = <span class="hljs-number">100000</span>;<br><br><span class="hljs-comment">// 创建一个互斥量</span><br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">sellticket</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>&#123;<br><br>    <span class="hljs-comment">// 卖票</span><br>    <span class="hljs-keyword">while</span>(tickets)&#123;<br>        <span class="hljs-comment">// 加锁</span><br>        pthread_mutex_lock(&amp;mutex);<br>        <span class="hljs-keyword">if</span>(tickets)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld 正在卖第 %d 张门票\n&quot;</span>, pthread_self(), tickets);<br>            tickets--;<br>        &#125;<br>        <span class="hljs-comment">// 解锁</span><br>        pthread_mutex_unlock(&amp;mutex);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-comment">// 初始化互斥量</span><br>    pthread_mutex_init(&amp;mutex, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 创建3个子线程</span><br>    <span class="hljs-type">pthread_t</span> tid[<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;++i)&#123;<br>        pthread_create(&amp;tid[i], <span class="hljs-literal">NULL</span>, sellticket, <span class="hljs-literal">NULL</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// // 回收子线程的资源，阻塞</span><br>    <span class="hljs-comment">// for(int i=0;i&lt;3;++i)&#123;</span><br>    <span class="hljs-comment">//     pthread_join(tid[i], NULL);</span><br>    <span class="hljs-comment">// &#125;</span><br><br>    <span class="hljs-comment">// 设置线程分离</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;++i)&#123;<br>        pthread_detach(tid[i]);<br>    &#125;<br><br><br>    pthread_exit(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 退出主线程</span><br><br>    <span class="hljs-comment">// 释放互斥量资源</span><br>    pthread_mutex_destroy(&amp;mutex);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li>有时，一个线程需要同时访问两个或更多不同的共享资源，而每个资源又都由不同的互斥量管理。当超过一个线程加锁同一组互斥量时，就有可能发生死锁。</li>
<li>两个或两个以上的进程在执行过程中，因争夺共享资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。</li>
<li>死锁的几种场景：<ul>
<li>忘记释放锁</li>
<li>重复加锁多</li>
<li>线程多锁，抢占锁资源</li>
</ul>
</li>
</ul>
<details>
    <summary>多线程抢占锁资源造成死锁例子</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 创建两个互斥锁</span><br><span class="hljs-type">pthread_mutex_t</span> mutex1, mutex2;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">workA</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>&#123;<br><br>    pthread_mutex_lock(&amp;mutex1);<br>    sleep(<span class="hljs-number">1</span>);<br>    pthread_mutex_lock(&amp;mutex2);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;workA...\n&quot;</span>);<br><br>    pthread_mutex_unlock(&amp;mutex2);<br>    pthread_mutex_unlock(&amp;mutex1);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">workB</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>&#123;<br><br>    pthread_mutex_lock(&amp;mutex2);<br>    pthread_mutex_lock(&amp;mutex1);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;workB...\n&quot;</span>);<br><br>    pthread_mutex_unlock(&amp;mutex1);<br>    pthread_mutex_unlock(&amp;mutex2);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-comment">// 初始化互斥量</span><br>    pthread_mutex_init(&amp;mutex1, <span class="hljs-literal">NULL</span>);<br>    pthread_mutex_init(&amp;mutex2, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 创建两个子线程</span><br>    <span class="hljs-type">pthread_t</span> tid1, tid2;<br>    pthread_create(&amp;tid1, <span class="hljs-literal">NULL</span>, workA, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;tid1, <span class="hljs-literal">NULL</span>, workB, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 回收子线程资源</span><br>    pthread_join(tid1, <span class="hljs-literal">NULL</span>);<br>    pthread_join(tid2, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 释放互斥锁资源</span><br>    pthread_mutex_destroy(&amp;mutex1);<br>    pthread_mutex_destroy(&amp;mutex2);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><ul>
<li>实际上，对共享资源只进行读操作并不会造成线程同步的问题，因此诞生了<strong>读写锁</strong>。</li>
<li>在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应用。为了满足当前能够允许多个读出，但只允许一个写入的需求，线程提供了读写锁来实现。</li>
<li>读写锁的特点：<ul>
<li>如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作。</li>
<li>如果有其它线程写数据，则其它线程都不允许读、写操作。</li>
<li>写是独占的，写的优先级高。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_rwlock_init</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *<span class="hljs-keyword">restrict</span> rwlock, <span class="hljs-type">const</span> <span class="hljs-type">pthread_rwlockattr_t</span> *<span class="hljs-keyword">restrict</span> attr)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_rwlock_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_rwlock_rdlock</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_rwlock_tryrdlock</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_rwlock_wrlock</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_rwlock_trywrlock</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_rwlock_unlock</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span>;<br><br>案例：<span class="hljs-number">8</span>个线程操作同一个全局变量<br><span class="hljs-number">3</span>个线程不定时写这个全局变量，<span class="hljs-number">5</span>个线程不定时读这个全局变量<br></code></pre></div></td></tr></table></figure>
<details>
    <summary>rwlock</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 创建一个共享数据</span><br><span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br><br><span class="hljs-type">pthread_rwlock_t</span> rwlock;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">writeNumber</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>&#123;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        pthread_rwlock_wrlock(&amp;rwlock);<br>        num ++;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;++write, tid: %ld, num: %d\n&quot;</span>, pthread_self(), num);<br>        pthread_rwlock_unlock(&amp;rwlock);<br>        usleep(<span class="hljs-number">100</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">readNumber</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>&#123;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        pthread_rwlock_rdlock(&amp;rwlock);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;===read, tid: %ld, num: %d\n&quot;</span>, pthread_self(), num);<br>        pthread_rwlock_unlock(&amp;rwlock);<br>        usleep(<span class="hljs-number">100</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    pthread_rwlock_init(&amp;rwlock, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 创建3个写线程、5个读线程</span><br>    <span class="hljs-type">pthread_t</span> wtids[<span class="hljs-number">3</span>], rtids[<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;++i)&#123;<br>        pthread_create(&amp;wtids[i], <span class="hljs-literal">NULL</span>, writeNumber, <span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)&#123;<br>        pthread_create(&amp;rtids[i], <span class="hljs-literal">NULL</span>, readNumber, <span class="hljs-literal">NULL</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置线程分离</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;++i)&#123;<br>        pthread_detach(wtids[i]);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)&#123;<br>        pthread_detach(rtids[i]);<br>    &#125;<br><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br><br>    pthread_rwlock_destroy(&amp;rwlock);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_init</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *<span class="hljs-keyword">restrict</span> cond, <span class="hljs-type">const</span> <span class="hljs-type">pthread_condattr_t</span> *<span class="hljs-keyword">restrict</span> attr)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_wait</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *<span class="hljs-keyword">restrict</span> cond, <span class="hljs-type">pthread_mutex_t</span> *<span class="hljs-keyword">restrict</span> mutex)</span>;<br>    - 等待，调用了该函数，线程会阻塞(阻塞时解锁，不阻塞加锁)<br>        <br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_timedwait</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *<span class="hljs-keyword">restrict</span> cond, <span class="hljs-type">pthread_mutex_t</span> *<span class="hljs-keyword">restrict</span> mutex, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> timespec *<span class="hljs-keyword">restrict</span> abstime)</span>;<br>    - 等待多长时间，调用这个函数，线程会阻塞，直到指定时间结束(阻塞时解锁，不阻塞加锁)<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_signal</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond)</span>;<br>    - 唤醒一个或多个等待的线程<br>        <br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_broadcast</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond)</span>;<br>    - 唤醒所有的等待的线程<br></code></pre></div></td></tr></table></figure>
<details>
    <summary>cond + mutex 实现生产者消费者模型</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    生产者消费者模型(简单版)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">// 创建一个互斥锁</span><br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><span class="hljs-comment">// 创建条件变量</span><br><span class="hljs-type">pthread_cond_t</span> cond;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">next</span>;</span><br>&#125;;<br><br><span class="hljs-comment">// 头节点</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">head</span> =</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">producer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>&#123;<br><br>    <span class="hljs-comment">// 不断创建新节点添加到链表中</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        pthread_mutex_lock(&amp;mutex);<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">newNode</span> =</span> (<span class="hljs-keyword">struct</span> Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>        newNode-&gt;next = head;<br>        head = newNode;<br>        newNode-&gt;num = rand() % <span class="hljs-number">1000</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;add node, num: %d, tid: %ld\n&quot;</span>, newNode-&gt;num, pthread_self());<br>        <br>        <span class="hljs-comment">// 只要生产了一个，就通知消费者消费</span><br>        pthread_cond_signal(&amp;cond);<br><br>        pthread_mutex_unlock(&amp;mutex);<br>        usleep(<span class="hljs-number">100</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">customer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>&#123;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        pthread_mutex_lock(&amp;mutex);<br>        <span class="hljs-keyword">if</span>(head != <span class="hljs-literal">NULL</span>)&#123; <span class="hljs-comment">// 有数据</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">temp</span> =</span> head;<br>            head = head-&gt;next;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;del node, num: %d, tid: %ld\n&quot;</span>, temp-&gt;num, pthread_self());<br>            <span class="hljs-built_in">free</span>(temp);<br>            pthread_mutex_unlock(&amp;mutex);<br>            usleep(<span class="hljs-number">100</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 没有数据，需要等待</span><br>            <span class="hljs-comment">// 当该函数调用阻塞时，会对互斥锁解锁，当不阻塞向下继续执行时，会重新加锁</span><br>            pthread_cond_wait(&amp;cond, &amp;mutex);<br>            pthread_mutex_unlock(&amp;mutex);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-comment">// 初始化条件变量</span><br>    pthread_cond_init(&amp;cond, <span class="hljs-literal">NULL</span>);<br>    <br>    <span class="hljs-comment">// 初始化互斥锁</span><br>    pthread_mutex_init(&amp;mutex, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 创建5个生产者线程，5个消费者线程</span><br>    <span class="hljs-type">pthread_t</span> ptids[<span class="hljs-number">5</span>], ctids[<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)&#123;<br>        pthread_create(&amp;ptids[i], <span class="hljs-literal">NULL</span>, producer, <span class="hljs-literal">NULL</span>);<br>        pthread_create(&amp;ctids[i], <span class="hljs-literal">NULL</span>, customer, <span class="hljs-literal">NULL</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)&#123;<br>        pthread_detach(ptids[i]);<br>        pthread_detach(ctids[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 防止提前释放互斥锁</span><br>        sleep(<span class="hljs-number">10</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 释放互斥锁</span><br>    pthread_mutex_destroy(&amp;mutex);<br><br>    <span class="hljs-comment">// 释放条件变量</span><br>    pthread_cond_destroy(&amp;cond);<br><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

---

### 信号量

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_init</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem, <span class="hljs-type">int</span> pshared, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value)</span>;<br>    功能：初始化信号量<br>    参数：<br>        - sem：信号量变量的地址<br>        - pshared：<br>            - <span class="hljs-number">0</span>：用在线程间<br>            - <span class="hljs-number">1</span>：用在进程间<br>        - value：信号量的值<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_destroy</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span>;<br>    - 释放资源<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_wait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span>;<br>    - 对信号量加锁，调用一次对信号量值 - <span class="hljs-number">1</span>，如果值为<span class="hljs-number">0</span>则阻塞<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_trywait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_timedwait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> timespec *abs_timeout)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_post</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span>;<br>    - 对信号量解锁，调用一次对信号量的值 + <span class="hljs-number">1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_getvalue</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem, <span class="hljs-type">int</span> *sval)</span>;<br></code></pre></div></td></tr></table></figure>

<details>
    <summary>semaphore + mutex实现生产者消费者模型</summary>

<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    sem_t psem;</span><br><span class="hljs-comment">    sem_t csem;</span><br><span class="hljs-comment">    init(psem, 0, 8);</span><br><span class="hljs-comment">    init(csem, 0, 0);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    producer()&#123;</span><br><span class="hljs-comment">        sem_wait(&amp;psem);</span><br><span class="hljs-comment">        sem_post(&amp;csem);</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    customer()&#123;</span><br><span class="hljs-comment">        sem_wait(&amp;csem);</span><br><span class="hljs-comment">        sem_post(&amp;psem);</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-comment">// 创建一个互斥锁</span><br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><br><span class="hljs-comment">// 创建两个信号量</span><br><span class="hljs-type">sem_t</span> psem;<br><span class="hljs-type">sem_t</span> csem;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">next</span>;</span><br>&#125;;<br><br><span class="hljs-comment">// 头节点</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">head</span> =</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">producer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>&#123;<br><br>    <span class="hljs-comment">// 不断创建新节点添加到链表中</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        sem_wait(&amp;psem); <span class="hljs-comment">// 注意：这里不能先加锁，否则会死锁</span><br>        pthread_mutex_lock(&amp;mutex);<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">newNode</span> =</span> (<span class="hljs-keyword">struct</span> Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>        newNode-&gt;next = head;<br>        head = newNode;<br>        newNode-&gt;num = rand() % <span class="hljs-number">1000</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;add node, num: %d, tid: %ld\n&quot;</span>, newNode-&gt;num, pthread_self());<br>        pthread_mutex_unlock(&amp;mutex);<br>        sem_post(&amp;csem);<br>        usleep(<span class="hljs-number">100</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">customer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>&#123;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        sem_wait(&amp;csem);<br>        pthread_mutex_lock(&amp;mutex);<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">temp</span> =</span> head;<br>        head = head-&gt;next;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;del node, num: %d, tid: %ld\n&quot;</span>, temp-&gt;num, pthread_self());<br>        <span class="hljs-built_in">free</span>(temp);<br>        pthread_mutex_unlock(&amp;mutex);<br>        sem_post(&amp;psem);<br>        usleep(<span class="hljs-number">100</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-comment">// 初始化信号量</span><br>    sem_init(&amp;psem, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>);<br>    sem_init(&amp;csem, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 初始化互斥锁</span><br>    pthread_mutex_init(&amp;mutex, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 创建5个生产者线程，5个消费者线程</span><br>    <span class="hljs-type">pthread_t</span> ptids[<span class="hljs-number">5</span>], ctids[<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)&#123;<br>        pthread_create(&amp;ptids[i], <span class="hljs-literal">NULL</span>, producer, <span class="hljs-literal">NULL</span>);<br>        pthread_create(&amp;ctids[i], <span class="hljs-literal">NULL</span>, customer, <span class="hljs-literal">NULL</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)&#123;<br>        pthread_detach(ptids[i]);<br>        pthread_detach(ctids[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 防止提前释放互斥锁</span><br>        sleep(<span class="hljs-number">10</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 释放互斥锁</span><br>    pthread_mutex_destroy(&amp;mutex);<br><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>TwIST算法</title>
    <url>/2021/03/01/TwIST%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<h2 id="软阈值-Soft-Thresholding-函数"><a href="#软阈值-Soft-Thresholding-函数" class="headerlink" title="软阈值(Soft Thresholding)函数"></a>软阈值(Soft Thresholding)函数</h2><p>参考资料：</p>
<ul>
<li><a href="https://blog.csdn.net/jbb0523/article/details/52103257">CSDN 软阈值函数解读</a></li>
</ul>
<p>软阈值函数一般写作：</p>
<script type="math/tex; mode=display">
soft(x,T) = \left\{\begin{aligned}x&+T && x\le -T,\\&\ 0 && |x|\le T,\\x&-T && x\ge T.\end{aligned}\right.</script><p>或</p>
<script type="math/tex; mode=display">
soft(x,T) = sgn(x)(|x|-T)_+</script><p>或</p>
<script type="math/tex; mode=display">
soft(x,T) = sgn(x)\max\{0,|x|-T\}</script><p>对于优化问题：</p>
<script type="math/tex; mode=display">
\arg\min_x\|X-B\|_2^2+\lambda\|X\|_1</script><p>的解为：$soft(B,\frac{\lambda}{2}) $</p>
<p>因此同理，对于优化问题$\arg\min_x\frac1 2|X-B|_2^2+\lambda|X|_1$，可以等价为优化问题$\arg\min_x|X-B|_2^2+2\lambda|X|_1$，因此解为：$soft(B,\lambda)$</p>
<p><code>python</code>可以这么实现soft函数：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">soft</span>(<span class="hljs-params">x,T</span>):<br>    <span class="hljs-keyword">return</span> np.sgn(x) * np.maximum(<span class="hljs-number">0</span>, np.fabs(x)-T)<br></code></pre></div></td></tr></table></figure>
<h2 id="Majorization-Minimization-优化框架"><a href="#Majorization-Minimization-优化框架" class="headerlink" title="Majorization-Minimization 优化框架"></a>Majorization-Minimization 优化框架</h2><ul>
<li><a href="https://blog.csdn.net/jbb0523/article/details/52134630">CSDN Majorization-Minimization优化框架</a></li>
</ul>
<p>当目标函数$J(x)$比较难优化的时候，我们可以寻找另外一个更易优化的函数$G(x)$，当$G(x)$满足一定条件时，它的最优解能够无限逼近$J(X)$的最优解。</p>
<p>$G(x)$应该满足3个条件：</p>
<ol>
<li>容易优化</li>
<li>$G_k(x)\ge J(x_k)\ \ for\ \ all \ \ x$</li>
<li>$G_k(x_k)=J(x_k)$</li>
</ol>
<h2 id="迭代软阈值-Iterative-Soft-Thresholding-IST"><a href="#迭代软阈值-Iterative-Soft-Thresholding-IST" class="headerlink" title="迭代软阈值(Iterative Soft Thresholding, IST)"></a>迭代软阈值(Iterative Soft Thresholding, IST)</h2><p>对于基追踪降噪问题(Basis Pursuit De-Noising, BPDN)：</p>
<script type="math/tex; mode=display">
\arg\min_x\frac 1 2 \|y-\Phi x\|_2^2 + \lambda\|x\|_1</script><p>对于目标函数 $f(x) = \frac 1 2 |y-\Phi x|_2^2 + \lambda|x|_1$，并不容易优化，更具MM框架，将其替代为目标函数：$u(x,z) = \frac 1 2 |y-\Phi x|_2^2 + \lambda|x|_1 - \frac 1 2 |\Phi x-\Phi z|_2^2 + \frac 1 2 |x-z|_2^2$</p>
<p>其中，由 $|\Phi|_2&lt;1$，得到: $u(x,z)\ge f(x),u(z,z) = f(z)$</p>
<p>化简该函数，可以得到：</p>
<script type="math/tex; mode=display">
u(x,z) = \frac 1 2 \|x- [z+\Phi^T(y-\Phi z)]\|_2^2 + \lambda \|x\|_1 + K</script><p>其中，K与x无关，于是原问题等价于优化：</p>
<script type="math/tex; mode=display">
u^*(x,x^*) = \frac 1 2 \|x-x^*\|_2^2+\lambda\|x\|_1</script><p>其中，$x^* = z+\Phi^T(y-\Phi z)$</p>
<p>显然，这个问题的解就是软阈值函数 $soft(x^*,\lambda)$</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>TwIST</tag>
        <tag>IST</tag>
        <tag>图像重建</tag>
      </tags>
  </entry>
  <entry>
    <title>Sublime Text 3 我的配置</title>
    <url>/2020/03/14/Sublime-Text-3-%E9%85%8D%E7%BD%AEC-11/</url>
    <content><![CDATA[<h2 id="最近用Dev-Cpp快用腻了，来配置一波Sublime"><a href="#最近用Dev-Cpp快用腻了，来配置一波Sublime" class="headerlink" title="最近用Dev-Cpp快用腻了，来配置一波Sublime"></a>最近用Dev-Cpp快用腻了，来配置一波Sublime</h2><h3 id="C-配置"><a href="#C-配置" class="headerlink" title="C++ 配置"></a>C++ 配置</h3><ol>
<li>Tools —&gt; Build System —&gt; New Build System…</li>
<li><code>Ctrl+A</code>全部删除，输入下面的代码</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;encoding&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;utf-8&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;working_dir&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$file_path&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;shell_cmd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;g++ -Wall -std=c++11 \&quot;$file_name\&quot; -o \&quot;$file_base_name\&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;-fexec-charset=gbk&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;file_regex&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;selector&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;source.c++&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;encoding&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cp936&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;variants&quot;</span><span class="hljs-punctuation">:</span> <br>    <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span>   <br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Run&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;shell_cmd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;g++ -Wall -std=c++11 \&quot;$file\&quot; -o \&quot;$file_base_name\&quot; &amp;&amp; start cmd /c \&quot;\&quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;\&quot; &amp; pause\&quot;&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></div></td></tr></table></figure>
<p>其中我们注意几个地方：</p>
<ul>
<li><code>&quot;g++&quot;</code>：编译器</li>
<li><code>&quot;-std=c++11&quot;</code>：依据C++11标准来编译（否则一些新特性会被判失效）</li>
<li><code>-Wall</code>：开启-wall提示（竞赛党的福音）</li>
<li><code>&quot;-fexec-charset=gbk&quot;</code>：GBK编码格式，默认带中文的</li>
</ul>
<ol>
<li>保存即可（路径就是他的默认路径不要改，后缀也不能改，名字随便起，如<code>cpp_11</code>）</li>
</ol>
<p>最后就可以愉快的<code>Ctrl+B</code>手动Debug啦~~</p>
<p><strong>2020.5.29 更新</strong></p>
<p>考虑到上面那样配置显示不出程序运行时间，现在配置一波能够显示程序运行时间的操作</p>
<p>首先新建New Build System，然后复制如下代码进去并替换，保存为另一个名字（如 <code>C++11_time</code>）并退出</p>
<figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>	<span class="hljs-attr">&quot;shell_cmd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;g++ \&quot;$&#123;file&#125;\&quot; -o \&quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;\&quot;&quot;</span><span class="hljs-punctuation">,</span><br>	<span class="hljs-attr">&quot;file_regex&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;</span><span class="hljs-punctuation">,</span><br>	<span class="hljs-attr">&quot;working_dir&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;file_path&#125;&quot;</span><span class="hljs-punctuation">,</span><br>	<span class="hljs-attr">&quot;selector&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;source.c, source.c++&quot;</span><span class="hljs-punctuation">,</span><br>	<span class="hljs-attr">&quot;variants&quot;</span><span class="hljs-punctuation">:</span><br>	<span class="hljs-punctuation">[</span><br>		<span class="hljs-punctuation">&#123;</span><br>			<span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Run&quot;</span><span class="hljs-punctuation">,</span><br>			<span class="hljs-attr">&quot;shell_cmd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;g++ -Wall -std=c++11 \&quot;$&#123;file&#125;\&quot; -o \&quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;\&quot; &amp;&amp; timer \&quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;\&quot; &lt; test.in &gt; test.out&quot;</span><br>		<span class="hljs-punctuation">&#125;</span><br>	<span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></div></td></tr></table></figure>
<p>在程序运行的文件夹下，创建一个<code>timer.cpp</code>文件，将如下代码复制进去，并保存运行</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">clock_t</span> begin = <span class="hljs-built_in">clock</span>();<br>	<span class="hljs-built_in">system</span>(argv[<span class="hljs-number">1</span>]);<br>	<span class="hljs-type">double</span> used = <span class="hljs-number">1000.0</span> * <span class="hljs-built_in">double</span>(<span class="hljs-built_in">clock</span>() - begin) / CLOCKS_PER_SEC - <span class="hljs-number">200.0</span>;<br>	<span class="hljs-keyword">if</span> (used &lt; <span class="hljs-number">0</span>) used = <span class="hljs-number">0.0</span>;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------------------------------\n&quot;</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Time used: %.2lf ms.\n&quot;</span>, used);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>最后，需要在程序运行的文件夹下，创建<code>test.in</code>和<code>test.out</code>文件，最终，你的文件夹目录结构如下图所示：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/xjS4EoDIhY9JrvL.png" alt="image-2020052914134487"></p>
<p>最后只需要在View里面设置一下Layout和Groups，就可以呈现出如下的样式</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200529141927647.png" alt="image-20200529141927647"></p>
<p>愉快地享用吧！</p>
<p><strong>2020.6.15 更新</strong></p>
<p>但实际上上面那个方法不太好用，还不如自己手写<code>#ifdef...#endif</code>来得灵活，与是还是用第一版的C++配置代码（尝试过删除掉最后的<code>&amp;pause</code>，但处理死循环问题就变得比较麻烦，还得打开任务管理器关闭进程），再在main函数内加入如下代码，就可以实现方案二一样的功能（记得需要在目录下创建一个<code>test.in</code>和<code>test.out</code>文件）</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOCAL</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> LOCAL</span><br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;test.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;test.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout);<br><span class="hljs-type">clock_t</span> _begin = <span class="hljs-built_in">clock</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>......<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> LOCAL</span><br><span class="hljs-type">double</span> _used = <span class="hljs-number">1000.0</span> * <span class="hljs-built_in">double</span>(<span class="hljs-built_in">clock</span>() - _begin) / CLOCKS_PER_SEC - <span class="hljs-number">200.0</span>;<br><span class="hljs-keyword">if</span> (_used &lt; <span class="hljs-number">0</span>) _used = <span class="hljs-number">0.0</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------------------------------\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Time used: %.2lf ms.\n&quot;</span>, _used);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure>
<h3 id="Python-配置"><a href="#Python-配置" class="headerlink" title="Python 配置"></a>Python 配置</h3><p>（Python的Sublime交互式配置我快哭了，REPL安装好了之后Tools里居然没有？果断放弃，采用原始的<code>Save+cmd+python xxx.py</code>的形式搞）</p>
<p><strong>2020.4.24 更新</strong></p>
<p>ohhhhhh！电脑突然开窍了，配置好啦！现在奉上步骤</p>
<ol>
<li><p>Ctrl + Shift + P 唤出Package栏并输入<code>IP</code> (Install Package)，回车等候（左下角有滚动的小条子）</p>
</li>
<li><p>等加载出来一个新的Package栏后，输入<code>SublimeREPL</code>（要安装的就是这个插件），然后回车等他安装</p>
</li>
</ol>
<p>然后就好了，可以通过 Tools —&gt; SublimeREPL —&gt; Python —&gt; Python - RUN current file来唤起控制台（在第二个标签页出现），这个时候就可以像Pycharm、Spyder一样在控制台控制输入了</p>
<p>为了方便，推荐 <strong>Shift + Alt + 8 唤起横向双栏的模式</strong>，然后<strong>F5</strong>调试（调试前记得保存代码），十分快乐</p>
<h3 id="Sublime-主题-amp-外观配置"><a href="#Sublime-主题-amp-外观配置" class="headerlink" title="Sublime 主题&amp;外观配置"></a>Sublime 主题&amp;外观配置</h3><p>主题用的是<strong>Sublime自带的Adaptive</strong>，它能自动适应我的Color主题</p>
<p>Color选用的是<strong>Tomorrow的Night（晚上用）</strong>，以及<strong>Breakers（白天用）</strong></p>
<p>字体选用<code>Inconsolata-g</code>，可以说是十分舒爽了</p>
<p>附上用户配置：</p>
<figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>	<span class="hljs-attr">&quot;color_scheme&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Packages/Tomorrow Color Schemes/Tomorrow Night.sublime-color-scheme&quot;</span><span class="hljs-punctuation">,</span><br>	<span class="hljs-attr">&quot;font_face&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Inconsolata-g&quot;</span><span class="hljs-punctuation">,</span><br>	<span class="hljs-attr">&quot;font_size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">11</span><span class="hljs-punctuation">,</span><br>	<span class="hljs-attr">&quot;ignored_packages&quot;</span><span class="hljs-punctuation">:</span><br>	<span class="hljs-punctuation">[</span><br>	<span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>	<span class="hljs-attr">&quot;theme&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Adaptive.sublime-theme&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></div></td></tr></table></figure>
<h3 id="Sublime-Snippet-设置"><a href="#Sublime-Snippet-设置" class="headerlink" title="Sublime Snippet 设置"></a>Sublime Snippet 设置</h3><p><strong>UPD 2020.6.15</strong></p>
<p>一直以为Sublime无法设置像Dev-C++一样的缺省源，然而昨天查到了，在Sublime里面叫做<code>Snippet(代码段)</code>，非常的方便</p>
<p>打开工具栏中的 <code>Tools -&gt; Developer -&gt; New Snippet...</code>，看到如下界面</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200615093633821.png" alt="image-20200615093633821"></p>
<p>第3行中的内容就是代码段内容，可以自己添加更改，其中<code>$&#123;1:this&#125;</code>为按下TAB建自动跳转的内容，冒号后面的文字为提示内容</p>
<p>第6行为代码段的名称，可以在写代码时输入该名称导入代码段</p>
<p>第8行为可使用该代码段的源代码文件类型，其类型的语法见下方官方文旦内容</p>
<details>

<figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">ActionScript: source<span class="hljs-selector-class">.actionscript</span>.<span class="hljs-number">2</span><br>AppleScript: source<span class="hljs-selector-class">.applescript</span><br>ASP: source<span class="hljs-selector-class">.asp</span><br>Batch FIle: source<span class="hljs-selector-class">.dosbatch</span><br>C#: source<span class="hljs-selector-class">.cs</span><br>C++: source.c++<br>Clojure: source<span class="hljs-selector-class">.clojure</span><br>CoffeeScript: source<span class="hljs-selector-class">.coffee</span><br>CSS: source<span class="hljs-selector-class">.css</span><br>D: source<span class="hljs-selector-class">.d</span><br>Diff: source<span class="hljs-selector-class">.diff</span><br>Erlang: source<span class="hljs-selector-class">.erlang</span><br>Go: source<span class="hljs-selector-class">.go</span><br>GraphViz: source<span class="hljs-selector-class">.dot</span><br>Groovy: source<span class="hljs-selector-class">.groovy</span><br>Haskell: source<span class="hljs-selector-class">.haskell</span><br>HTML: text<span class="hljs-selector-class">.html</span>(.basic)<br>JSP: text<span class="hljs-selector-class">.html</span><span class="hljs-selector-class">.jsp</span><br>Java: source<span class="hljs-selector-class">.java</span><br>Java Properties: source<span class="hljs-selector-class">.java-props</span><br>Java Doc: text<span class="hljs-selector-class">.html</span><span class="hljs-selector-class">.javadoc</span><br>JSON: source<span class="hljs-selector-class">.json</span><br>Javascript: source<span class="hljs-selector-class">.js</span><br>BibTex: source<span class="hljs-selector-class">.bibtex</span><br>Latex Log: text<span class="hljs-selector-class">.log</span><span class="hljs-selector-class">.latex</span><br>Latex Memoir: text<span class="hljs-selector-class">.tex</span><span class="hljs-selector-class">.latex</span><span class="hljs-selector-class">.memoir</span><br>Latex: text<span class="hljs-selector-class">.tex</span><span class="hljs-selector-class">.latex</span><br>LESS: source<span class="hljs-selector-class">.css</span><span class="hljs-selector-class">.less</span><br>TeX: text<span class="hljs-selector-class">.tex</span><br>Lisp: source<span class="hljs-selector-class">.lisp</span><br>Lua: source<span class="hljs-selector-class">.lua</span><br>MakeFile: source<span class="hljs-selector-class">.makefile</span><br>Markdown: text<span class="hljs-selector-class">.html</span><span class="hljs-selector-class">.markdown</span><br>Multi Markdown: text<span class="hljs-selector-class">.html</span><span class="hljs-selector-class">.markdown</span><span class="hljs-selector-class">.multimarkdown</span><br>Matlab: source<span class="hljs-selector-class">.matlab</span><br>Objective-C: source<span class="hljs-selector-class">.objc</span><br>Objective-C++: source.objc++<br>OCaml campl4: source<span class="hljs-selector-class">.camlp4</span><span class="hljs-selector-class">.ocaml</span><br>OCaml: source<span class="hljs-selector-class">.ocaml</span><br>OCamllex: source<span class="hljs-selector-class">.ocamllex</span><br>Perl: source<span class="hljs-selector-class">.perl</span><br>PHP: source<span class="hljs-selector-class">.php</span><br>Regular <span class="hljs-built_in">Expression</span>(python): source<span class="hljs-selector-class">.regexp</span><span class="hljs-selector-class">.python</span><br>Python: source<span class="hljs-selector-class">.python</span><br>R Console: source<span class="hljs-selector-class">.r-console</span><br>R: source<span class="hljs-selector-class">.r</span><br>Ruby on Rails: source<span class="hljs-selector-class">.ruby</span><span class="hljs-selector-class">.rails</span><br>Ruby HAML: text<span class="hljs-selector-class">.haml</span><br><span class="hljs-function"><span class="hljs-title">SQL</span><span class="hljs-params">(Ruby)</span></span>: source<span class="hljs-selector-class">.sql</span><span class="hljs-selector-class">.ruby</span><br>Regular Expression: source<span class="hljs-selector-class">.regexp</span><br>RestructuredText: text<span class="hljs-selector-class">.restructuredtext</span><br>Ruby: source<span class="hljs-selector-class">.ruby</span><br>SASS: source<span class="hljs-selector-class">.sass</span><br>Scala: source<span class="hljs-selector-class">.scala</span><br>Shell Script: source<span class="hljs-selector-class">.shell</span><br>SQL: source<span class="hljs-selector-class">.sql</span><br>Stylus: source<span class="hljs-selector-class">.stylus</span><br>TCL: source<span class="hljs-selector-class">.tcl</span><br><span class="hljs-function"><span class="hljs-title">HTML</span><span class="hljs-params">(TCL)</span></span>: text<span class="hljs-selector-class">.html</span><span class="hljs-selector-class">.tcl</span><br>Plain text: text<span class="hljs-selector-class">.plain</span><br>Textile: text<span class="hljs-selector-class">.html</span><span class="hljs-selector-class">.textile</span><br>XML: text<span class="hljs-selector-class">.xml</span><br>XSL: text<span class="hljs-selector-class">.xml</span><span class="hljs-selector-class">.xsl</span><br>YAML: source.yaml<br></code></pre></div></td></tr></table></figure>

</details>]]></content>
  </entry>
  <entry>
    <title>USST内部训练4补题</title>
    <url>/2020/05/21/USST%E5%86%85%E9%83%A8%E8%AE%AD%E7%BB%834%E8%A1%A5%E9%A2%98/</url>
    <content><![CDATA[<h2 id="一道神奇的分块题"><a href="#一道神奇的分块题" class="headerlink" title="一道神奇的分块题"></a><center>一道神奇的分块题</center></h2><span id="more"></span>
<h4 id="F-牛牛的繁星"><a href="#F-牛牛的繁星" class="headerlink" title="F. 牛牛的繁星"></a>F. <a href="https://ac.nowcoder.com/acm/contest/5205/F">牛牛的繁星</a></h4><p>题意：</p>
<p>给出长度为n的序列a，和m个询问，每次询问区间[l,r]内<strong>出现次数第k大的数的出现次数</strong>（注意：是出现次数第k大，不是第k大元素的出现次数），且强制在线。</p>
<p>题解：</p>
<p>可参考官方题解：<a href="https://ac.nowcoder.com/acm/problem/blogs/204649">https://ac.nowcoder.com/acm/problem/blogs/204649</a></p>
<p>如果是第k大元素的出现次数，那就是主席树的裸题了，开n个权值线段树，第i个维护前i个数信息，然后用前缀和思想处理在线区间询问就行了</p>
<p>但是，<strong>本题是无法使用线段树维护住的</strong>，因此就需要<del>看别人的AC代码</del>使用 <strong>暴力+优化</strong> 方法过这道题，具体实现应该是 <strong>预处理+分块+莫队的一点点思想</strong>（其实我自己还没整明白），但我所了解的莫队基本上都是离线做法。。所以这题还需要提前预处理，也就是需要提前预处理出<code>pre[i][j]</code>数组，代表<strong>前i个块中j这个元素的出现次数</strong>，这是为了方便分块时对于中间整块的处理</p>
<p>更具体的，本题需要开一个桶统计每个数的出现次数，同时还需要统计某个出现次数的数的个数，通过莫队思想更新，但是仅仅这样似乎复杂度还是不够（因为强制在线，所以无法用莫队的玄学排序），因此还需要预处理一些分块数组的信息，这样对于区间很大的询问的处理速度就加快了（应该吧）</p>
<p>对于每一次[l,r]询问，类似普通分块一样 先定位两端点所在块，如果在同一块中，就暴力更新该区间的数的所有信息，更新完后，再查找k大出现次数，这里需要仔细解释一下如何查找：</p>
<p>本题的分块数组有两个作用，除了记录每个元素所在的块之外，还可以用它来记录不同的出现次数所在的块（类似于权值线段树？或者叫做值域分块），出现次数越多，所在的块就越靠后，那么对于每一次的询问，我们就需要从最后一个块开始往第一块遍历（因为越靠后的块对应的出现次数越多），如果当前块所对应的的出现次数小于k，那么就让k减去当前块的出现次数数，然后继续查找前一块，否则就说明这个k大的出现次数在这个块里面，于是进入该块，暴力查找即可</p>
<p>对于不在同一块中的两端点，左右端点对应的零散块也是同上暴力处理，对于中间的完整快，需要利用之前的预处理，$O(1)$得到完整块内的数的素有信息，然后更新即可</p>
<p>在处理完上述所有信息并完成一次查询后，记得要把这些用到的桶和数组归零，以便下一次查询</p>
<p>另外，代码里有个注意点</p>
<ul>
<li>用emplace_back代替了push_back，否则会TLE（91分）？？具体可以百度这两者的区别</li>
</ul>
<p>个人感觉本题题的思想和 <a href="https://www.luogu.com.cn/problem/P1903">洛谷 P1903 [国家集训队]数颜色 / 维护队列</a> 这道题有一点类似（不会的可以先看看这题找找自信）</p>
<p>最后，本蒟蒻写得很乱，如果看不懂的话 就看看代码理解理解吧！QAQ</p>
<p>更具体的可以看代码</p>
<p>AC代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// fread 加速读入</span><br><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span> _nc()&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> buf[<span class="hljs-number">100000</span>],*L=buf,*R=buf;<br>    <span class="hljs-keyword">return</span> L==R&amp;&amp;(R=(L=buf)+<span class="hljs-built_in">fread</span>(buf,<span class="hljs-number">1</span>,<span class="hljs-number">100000</span>,stdin),L==R)?EOF:*L++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(T &amp;x)</span> </span>&#123;<br>	x=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> f=<span class="hljs-number">0</span>;<span class="hljs-type">char</span> ch=_nc();<br>	<span class="hljs-keyword">while</span>(ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;f|=(ch==<span class="hljs-string">&#x27;-&#x27;</span>);ch=_nc();&#125;<br>	<span class="hljs-keyword">while</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+(ch^<span class="hljs-number">48</span>);ch=_nc();&#125;<br>	x=f?-x:x;<br>	<span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//fast write</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ll x)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>)<span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;<br>    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>)<span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> n,m,type,mx,sz;<br><span class="hljs-type">int</span> block[<span class="hljs-number">100005</span>],L[<span class="hljs-number">100005</span>],R[<span class="hljs-number">100005</span>],a[<span class="hljs-number">100005</span>],cnt[<span class="hljs-number">100005</span>],num[<span class="hljs-number">100005</span>],sum[<span class="hljs-number">405</span>],pre[<span class="hljs-number">405</span>][<span class="hljs-number">100005</span>];<br><span class="hljs-type">bool</span> vis[<span class="hljs-number">100005</span>];<br><br>vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; v[<span class="hljs-number">340</span>][<span class="hljs-number">340</span>];<br>vector&lt;<span class="hljs-type">int</span>&gt; ve;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> number)</span></span>&#123;<span class="hljs-comment">//更新出现次数为x的数所在的块</span><br>    <span class="hljs-type">int</span> bo=block[x];<br>    num[x]+=number;<br>    sum[bo]+=number;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<span class="hljs-comment">//查询次数第k大的次数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=mx;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>        <span class="hljs-keyword">if</span>(k&gt;sum[i]) k-=sum[i];<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=R[i];j&gt;=L[i];j--)&#123;<br>                <span class="hljs-keyword">if</span>(k&gt;num[j]) k-=num[j];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> j;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-built_in">swap</span>(l, r);<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> bol=block[l],bor=block[r];<br>    <span class="hljs-keyword">if</span>(bol==bor)&#123;<span class="hljs-comment">//处理左右端点在同一块内的情况</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=l;i&lt;=r;i++)&#123;<br>            cnt[a[i]]++;<br>            vis[a[i]]=<span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=l;i&lt;=r;i++)&#123;<br>            <span class="hljs-keyword">if</span>(vis[a[i]])&#123;<br>                vis[a[i]]=<span class="hljs-literal">false</span>;<br>                <span class="hljs-built_in">add</span>(cnt[a[i]],<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        ans=<span class="hljs-built_in">query</span>(k);<span class="hljs-comment">//询问</span><br>        <span class="hljs-comment">//询问完了给它重置回去</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=l;i&lt;=r;i++)&#123;<br>            <span class="hljs-keyword">if</span>(!cnt[a[i]]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">add</span>(cnt[a[i]],<span class="hljs-number">-1</span>);<br>            cnt[a[i]]=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//处理左右端点不在同一块内的情况</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x:v[bol+<span class="hljs-number">1</span>][bor<span class="hljs-number">-1</span>]) <span class="hljs-built_in">add</span>(x.first,x.second);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=l;i&lt;=R[bol];i++)&#123;<br>            cnt[a[i]]++;<br>            vis[a[i]]=<span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=L[bor];i&lt;=r;i++)&#123;<br>            cnt[a[i]]++;<br>            vis[a[i]]=<span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=l;i&lt;=R[bol];i++)&#123;<br>            <span class="hljs-keyword">if</span>(vis[a[i]])&#123;<br>                <span class="hljs-type">int</span> res=pre[bor<span class="hljs-number">-1</span>][a[i]]-pre[bol][a[i]];<br>                <span class="hljs-built_in">add</span>(res,<span class="hljs-number">-1</span>);<br>                <span class="hljs-built_in">add</span>(res+cnt[a[i]],<span class="hljs-number">1</span>);<br>                vis[a[i]]=<span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=L[bor];i&lt;=r;i++)&#123;<br>            <span class="hljs-keyword">if</span>(vis[a[i]])&#123;<br>                <span class="hljs-type">int</span> res=pre[bor<span class="hljs-number">-1</span>][a[i]]-pre[bol][a[i]];<br>                <span class="hljs-built_in">add</span>(res,<span class="hljs-number">-1</span>);<br>                <span class="hljs-built_in">add</span>(res+cnt[a[i]],<span class="hljs-number">1</span>);<br>                vis[a[i]]=<span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        ans=<span class="hljs-built_in">query</span>(k);<span class="hljs-comment">//询问</span><br>        <span class="hljs-comment">//询问完了给它重置回去</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x:v[bol+<span class="hljs-number">1</span>][bor<span class="hljs-number">-1</span>]) <span class="hljs-built_in">add</span>(x.first,-x.second);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=l;i&lt;=R[bol];i++)&#123;<br>            <span class="hljs-keyword">if</span>(cnt[a[i]])&#123;<br>                <span class="hljs-type">int</span> res=pre[bor<span class="hljs-number">-1</span>][a[i]]-pre[bol][a[i]];<br>                <span class="hljs-built_in">add</span>(res,<span class="hljs-number">1</span>);<br>                <span class="hljs-built_in">add</span>(res+cnt[a[i]],<span class="hljs-number">-1</span>);<br>                cnt[a[i]]=<span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=L[bor];i&lt;=r;i++)&#123;<br>            <span class="hljs-keyword">if</span>(cnt[a[i]])&#123;<br>                <span class="hljs-type">int</span> res=pre[bor<span class="hljs-number">-1</span>][a[i]]-pre[bol][a[i]];<br>                <span class="hljs-built_in">add</span>(res,<span class="hljs-number">1</span>);<br>                <span class="hljs-built_in">add</span>(res+cnt[a[i]],<span class="hljs-number">-1</span>);<br>                cnt[a[i]]=<span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// freopen(&quot;test.in&quot;,&quot;r&quot;,stdin);</span><br>    <span class="hljs-built_in">read</span>(n),<span class="hljs-built_in">read</span>(m),<span class="hljs-built_in">read</span>(type);<span class="hljs-comment">//读入</span><br>    mx=<span class="hljs-built_in">sqrt</span>(n);<span class="hljs-comment">//mx个块</span><br>   	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=mx;i++)&#123;<br>   		L[i]=R[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>   		R[i]=n/mx*i;<br>   	&#125;<br>   	R[mx]=n;<span class="hljs-comment">//最后一个块的右端为第n，自己的习惯，也可以再开一个块</span><br>   	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=mx;i++)&#123;<br>   		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=L[i];j&lt;=R[i];j++)<br>   			block[j]=i;<span class="hljs-comment">//j号元素在i号块内</span><br>   	&#125;<br>    <span class="hljs-comment">//上面是分块预处理</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">read</span>(a[i]);<span class="hljs-comment">//读入</span><br>    <span class="hljs-comment">//下面这波是预处理前i个块中j这个元素的出现次数，即预处理pre[i][j]数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>;l&lt;=mx;l++)&#123;<br>        ve.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) pre[l][i]=pre[l<span class="hljs-number">-1</span>][i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=L[l]; i&lt;=R[l];i++) pre[l][a[i]]++;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r=l; r&lt;=mx;r++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=L[r];i&lt;=R[r];i++)&#123;<br>                num[cnt[a[i]]]--;<br>                cnt[a[i]]++;<br>                num[cnt[a[i]]]++;<br>                <span class="hljs-keyword">if</span>(num[cnt[a[i]]]==<span class="hljs-number">1</span>) ve.<span class="hljs-built_in">emplace_back</span>(cnt[a[i]]);<br>                <span class="hljs-comment">//emplace_back的使用</span><br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x:ve) <span class="hljs-keyword">if</span>(num[x]!=<span class="hljs-number">0</span>&amp;&amp;!vis[x]) v[l][r].<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">make_pair</span>(x,num[x])),vis[x]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x:ve) vis[x]=<span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-built_in">memset</span>(cnt,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(cnt));<br>        <span class="hljs-built_in">memset</span>(num,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(num));<br>    &#125;<br> <br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,l,r,k;i&lt;=m;i++)&#123;<br>        <span class="hljs-built_in">read</span>(l),<span class="hljs-built_in">read</span>(r),<span class="hljs-built_in">read</span>(k);<br>        <span class="hljs-keyword">if</span>(type==<span class="hljs-number">1</span>) l^=ans,r^=ans,k^=ans;<br>        ans=<span class="hljs-built_in">cal</span>(l,r,k);<br>       	<span class="hljs-built_in">write</span>(ans);<br>       	<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora配置smms图床</title>
    <url>/2020/05/06/Typora%E9%85%8D%E7%BD%AEsmms%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<h2 id="Typora-smms图床配置过程记录"><a href="#Typora-smms图床配置过程记录" class="headerlink" title="Typora+smms图床配置过程记录"></a><center>Typora+smms图床配置过程记录</center></h2><span id="more"></span>
<p>发现自己用Typora写东西的时候上传图片十分麻烦（打开浏览器、打开smms、复制图片并粘贴、赋值Markdown，粘贴Markdown），于是自己胡乱摸索偏好设置，发现Typora自带了PicGo图床插件的支持，又是配置了一下</p>
<h3 id="第一步：安装好Typora-PicGo"><a href="#第一步：安装好Typora-PicGo" class="headerlink" title="第一步：安装好Typora+PicGo"></a>第一步：安装好Typora+PicGo</h3><p>Typora到 <a href="https://typora.io/">官网</a> 下载</p>
<p>PicGo直接到 <a href="https://github.com/Molunerfinn/PicGo/tags">PicGo仓库链接</a> 下载最新版的即可</p>
<h3 id="第二步-Typora偏好设置"><a href="#第二步-Typora偏好设置" class="headerlink" title="第二步 Typora偏好设置"></a>第二步 Typora偏好设置</h3><p>进入Typora，<code>Ctrl+,</code>打开偏好设置，按下图所示设置好</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200506105651715.png" alt="image-20200506105651715"></p>
<h3 id="第三步-PicGo设置"><a href="#第三步-PicGo设置" class="headerlink" title="第三步 PicGo设置"></a>第三步 PicGo设置</h3><p>由于PicGo支持很多种图床，我这里就介绍两种免费的图床设置</p>
<h4 id="sm-ms图床"><a href="#sm-ms图床" class="headerlink" title="sm.ms图床"></a>sm.ms图床</h4><p>我们需要先到 <a href="https://sm.ms">sm.ms官网</a> 注册一个帐号并，按照下图所示的位置点开个人界面</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200506110041816.png" alt="image-20200506110041816"></p>
<p>然后生成个人的Token，并复制下来</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200506110129188.png" alt="image-20200506110129188"></p>
<p>打开PicGo的APP，并将复制好的Token粘贴到sm.ms的配置当中去</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200506110250938.png" alt="image-20200506110250938"></p>
<p>完结撒花~</p>
<h4 id="Gitee码云仓库作为图床"><a href="#Gitee码云仓库作为图床" class="headerlink" title="Gitee码云仓库作为图床"></a>Gitee码云仓库作为图床</h4><p>当然我现在使用的是自己的Gitee的一个仓库作为图床，具体操作如下：</p>
<p>首先你需要有一个码云帐号，然后新建一个<strong>开源</strong>的仓库</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200506110418277.png" alt="image-20200506110418277"></p>
<p>把名字复制下来</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200506110555135.png" alt="image-20200506110555135"></p>
<p>然后去到码云主界面，点击个人设置，再选择私人令牌</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200506112655463.png" alt="image-20200506112655463"></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200506112746839.png" alt="image-20200506112746839"></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200506112805394.png" alt="image-20200506112805394"></p>
<p>其中描述随便填，然后点击提交即可，你就获得了一个新的私人令牌（Token），复制下来</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200506112831619.png" alt="image-20200506112831619"></p>
<p>随后，打开PicGo，并按照下图所示下载和安装插件，之后启用插件</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200506110656724.png" alt="image-20200506110656724"></p>
<p>按照下述填写方式填写PicGo的Gitee配置，其中owner是你的码云用户名，repo是你的仓库名称，path是图片存储的仓库内的路径，token是你自己码云帐号的私人令牌</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200506112359329.png" alt="image-20200506112359329"></p>
<p>点击确定，并设置为默认图床</p>
<h3 id="第四步-愉快地享用"><a href="#第四步-愉快地享用" class="headerlink" title="第四步 愉快地享用"></a>第四步 愉快地享用</h3><p>在Typora编辑器中，随意从本地复制一个图片进来，然后右击图片，选择上传图片，就能上传自己喜欢的图片啦！~~</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/wallhaven-vgl5qp.jpg" alt="12"></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>USST练习赛10补题</title>
    <url>/2020/06/09/USST%E7%BB%83%E4%B9%A0%E8%B5%9B10%E8%A1%A5%E9%A2%98/</url>
    <content><![CDATA[<p>第一次组队参赛，再多做三题就能AK了，可惜自己做题不够快，py也不熟练，总是要调好久，还是太蒻了OTZ<br><span id="more"></span></p>
<h4 id="E-虚无的后缀"><a href="#E-虚无的后缀" class="headerlink" title="E. 虚无的后缀"></a><a href="https://ac.nowcoder.com/acm/problem/26157">E. 虚无的后缀</a></h4><p>题意： 从n个数字中选出k个数字，使得他们乘积后缀0个数最多</p>
<p>算法： 背包dp（贪心被群里大佬 X 了，我太难了）</p>
<p>思路（错误✖）： 显然能产生后缀0的乘积只有2和5相乘，因此考虑先将所有数的因子中2和5个数求出，那么题意就转化为：选出k个数，使得$\min(sum2,sum5)$最大，其中$sum2、sum5$分别为这k个数的因子中2和5的总数。可以发现，正向求这个值不太好想，我们可以转换一下思路，逆向求，即先将所有的数选上，然后贪心地不断删去$n-k$个对答案造成影响最小的数，最后的$\min(sum2,sum5)$就是答案</p>
<p>思路（正确✔）：定义状态转移方程$dp[i][j][m]$在前$i$个数中选取$j$个数，其中因子为5的个数为$m$时的因子2的最多的个数，发现m最多也就五千多点的样子，可以滚动数组压成二维的跑一遍背包dp，最后求出$\max(\min(dp[j][m],m))$即可</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n,k,dp[<span class="hljs-number">205</span>][<span class="hljs-number">5205</span>],sum5,ans;<br>pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; ha[<span class="hljs-number">205</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">read</span>(n),<span class="hljs-built_in">read</span>(k);<br>    ll x;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n)&#123;<br>        <span class="hljs-built_in">read</span>(x);<br>		<span class="hljs-keyword">while</span>(x%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>			x/=<span class="hljs-number">2</span>;<br>			ha[i].first++;<br>		&#125;<br>		<span class="hljs-keyword">while</span>(x%<span class="hljs-number">5</span>==<span class="hljs-number">0</span>)&#123;<br>			x/=<span class="hljs-number">5</span>;<br>			ha[i].second++;<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">-0x3f</span>,<span class="hljs-built_in">sizeof</span>(dp));<br>	dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=k;j&gt;=<span class="hljs-number">1</span>;j--)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> m=<span class="hljs-number">5200</span>;m&gt;=ha[i].second;m--)&#123;<br>				dp[j][m]=<span class="hljs-built_in">max</span>(dp[j][m],dp[j<span class="hljs-number">-1</span>][m-ha[i].second]+ha[i].first);<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">5200</span>;i++)&#123;<br>		ans=<span class="hljs-built_in">max</span>(ans,<span class="hljs-built_in">min</span>(dp[k][i],i));<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="J-聚会"><a href="#J-聚会" class="headerlink" title="J. 聚会"></a><a href="https://ac.nowcoder.com/acm/problem/202022">J. 聚会</a></h4><p>题意：x轴上有n个人，每个人坐标为$x_i$，同时以速度1/s往0点移动，现在可以在两点建立传送门，问所有人都到达0点时所花最少时间</p>
<p>算法：二分答案</p>
<p>思路：对x排序，然后考虑二分答案，即每次二分出一个最短时间mid，就遍历一遍x数组，找到其中第一个绝对值大于mid的点$x_p$，将传送门的一端设置在$pos=x_p+mid$处（因为这样设置能够给后面的点产生最大的贡献），那么之后如果找到绝对值大于mid的点$x_q$，就判断是否有$|x_q-pos|&gt;mid$，如果是，则这个二分的最短时间mid无法达到，需要扩大这个mid，否则可以缩小这个mid</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> _,n;<br>ll x[maxn];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(ll k)</span></span>&#123;<br>	ll pos=<span class="hljs-number">-1ll</span>&lt;&lt;<span class="hljs-number">60</span>;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n)&#123;<br>		<span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(x[i])&gt;k)&#123;<br>			<span class="hljs-keyword">if</span>(pos==<span class="hljs-number">-1ll</span>&lt;&lt;<span class="hljs-number">60</span>) pos=x[i]+k;<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(pos-x[i])&gt;k) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;_);_;_--)&#123;<br>		<span class="hljs-built_in">read</span>(n);<br>		<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">read</span>(x[i]);<br>		<span class="hljs-built_in">sort</span>(x+<span class="hljs-number">1</span>,x+<span class="hljs-number">1</span>+n);<br>		ll l=<span class="hljs-number">-1ll</span>&lt;&lt;<span class="hljs-number">60</span>,r=<span class="hljs-number">1ll</span>&lt;&lt;<span class="hljs-number">60</span>;<br>		ll ans;<br>		<span class="hljs-keyword">while</span>(l&lt;=r)&#123;<br>			ll mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>			<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) ans=mid,r=mid<span class="hljs-number">-1</span>;<br>			<span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>		&#125;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows系统安装cuda和cudnn简单教程</title>
    <url>/2022/07/19/Windows%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85cuda%E5%92%8Ccudnn%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>本篇主要记录Windows系统安装cuda和cudnn时的步骤和踩过的坑，以及重要的资源链接等。<br><span id="more"></span></p>
<p>两个重要链接：</p>
<a class="btn" href="https://developer.nvidia.com/cuda-toolkit-archive"  target="_blank">CUDA Toolkit Archive</a>
<a class="btn" href="https://developer.nvidia.com/rdp/cudnn-archive"  target="_blank">cuDNN Archive | NVIDIA Developer</a>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/Jin1Yang/article/details/124754015">https://blog.csdn.net/Jin1Yang/article/details/124754015</a></li>
</ul>
<h2 id="CUDA的安装"><a href="#CUDA的安装" class="headerlink" title="CUDA的安装"></a>CUDA的安装</h2><p>我们首先需要知道自己的Nvidia显卡对应的CUDA版本，这需要进入 <strong>NVIDIA控制面板=&gt;系统性息</strong> 进行查看：（如下图所示，我这台电脑对应了CUDA 11.6.134版本）</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220721210208439.png" alt="查看NVIDIA属性"></p>
<p>然后下载对应版本的CUDA Toolkit，CUDA下载地址：<a href="https://developer.nvidia.com/cuda-toolkit-archive">CUDA Toolkit Archive | NVIDIA Developer</a></p>
<p>然后安装即可，安装完成后，打开<code>cmd</code>输入<code>nvcc -V</code>查看是否安装成功：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220721210623363.png" alt="检查cuda是否安装成功"></p>
<h2 id="cuDNN的安装"><a href="#cuDNN的安装" class="headerlink" title="cuDNN的安装"></a>cuDNN的安装</h2><p>cuDNN下载链接：<a href="https://developer.nvidia.com/rdp/cudnn-archive">cuDNN Archive | NVIDIA Developer</a></p>
<p>选择与自己的CUDA版本对应的cuDNN版本下载，得到压缩包并解压。将其中的三个文件夹（<code>bin</code>、<code>include</code>、<code>lib</code>）复制粘贴至CUDA的根目录下并替换。</p>
<p>检查是否安装成功：进入CUDA根目录下的<code>.\extras\demo_suite</code>目录，并执行<code>bandwidthTest.exe</code>和<code>deviceQuery.exe</code>检查是否安装成功：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220721211320638.png" alt="deviceQuery.exe"></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/img/image-20220721212006039.png" alt="bandwidthTest.exe"></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>bfs和dfs板子</title>
    <url>/2020/01/16/bfs%E6%9D%BF%E5%AD%90/</url>
    <content><![CDATA[<ul>
<li>过了一个月，bfs和dfs复习，手打一遍板子。。。<span id="more"></span>
</li>
</ul>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">bool</span> vis[...]; <span class="hljs-comment">//用来去重</span><br><span class="hljs-type">int</span> dir[...][...] = &#123;...&#125;; <span class="hljs-comment">//定义方向的数组</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123; <span class="hljs-comment">//定义状态的结构体</span><br>	<span class="hljs-type">int</span> x,y,...; <span class="hljs-comment">//定义方向属性</span><br>	<span class="hljs-type">int</span> step; <span class="hljs-comment">//用来存步数（因为bfs一般是求最短路）</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(有必要的情况下需要传参)</span></span>&#123;<br>	queue &lt;node&gt; q;<br>	start.step = <span class="hljs-number">0</span>;<br>	...<br>	q.<span class="hljs-built_in">push</span>(start);<br>	...<br>	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>		node q1 = q.<span class="hljs-built_in">front</span>();<br>		q.<span class="hljs-built_in">pop</span>();<br>		<span class="hljs-keyword">if</span>(q1.某状态（通常是step）==目标状态)&#123;<br>			处理或不处理；<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>		node v;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;...;i++)&#123;<br>			<span class="hljs-type">int</span> dx = q1.x + dir[...][<span class="hljs-number">0</span>];<br>			<span class="hljs-type">int</span> dy = q1.y +dir[...][<span class="hljs-number">1</span>];<br>			...;<br>			<span class="hljs-keyword">if</span>(不满足条件) <span class="hljs-keyword">continue</span>;<br>			vis[...] = <span class="hljs-number">1</span>;<br>			v.step = q1.step + <span class="hljs-number">1</span>;<br>			v.x = dx, v.y = dy;<br>			对答案做处理<br>			q.<span class="hljs-built_in">push</span>(v);<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	处理输入;<br>	<span class="hljs-built_in">bfs</span>(参数)；<br>	处理输出;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">bool</span> vis[...]; <span class="hljs-comment">//用来去重</span><br><span class="hljs-type">int</span> dir[...][...] = &#123;...&#125;; <span class="hljs-comment">//定义方向的数组</span><br><span class="hljs-type">bool</span> f = <span class="hljs-literal">false</span>; <span class="hljs-comment">//剪枝</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(参数)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(f)&#123; <span class="hljs-comment">//剪枝</span><br>		<span class="hljs-keyword">return</span> ...;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(达到目标状态)&#123;<br>        处理答案;<br>        f = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> ...;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(遍历所有状态)&#123;<br>		<span class="hljs-keyword">if</span>(合法&amp;&amp;!vis[...])&#123;<br>		    vis[...] = <span class="hljs-number">1</span>; <span class="hljs-comment">//标记走过</span><br>            处理;<br>            <span class="hljs-built_in">dfs</span>(传参); <span class="hljs-comment">//递归</span><br>            回溯（如果需要的话）;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ...;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	处理输入;<br>    处理过程;<br>    <span class="hljs-built_in">dfs</span>(传参);<br>    处理输出;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>bfs</tag>
        <tag>dfs</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>c++补充知识（个人向）</title>
    <url>/2020/01/21/c-%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%AA%E4%BA%BA%E5%90%91%EF%BC%89/</url>
    <content><![CDATA[<h2 id="一些简单的c-知识点补充"><a href="#一些简单的c-知识点补充" class="headerlink" title="一些简单的c++知识点补充"></a><center>一些简单的c++知识点补充</center></h2><span id="more"></span>
<h2 id="（C-11特性）auto类型说明符"><a href="#（C-11特性）auto类型说明符" class="headerlink" title="（C++11特性）auto类型说明符"></a>（C++11特性）auto类型说明符</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//auto类型说明符</span><br><span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>, *p = &amp;i; <span class="hljs-comment">//i是整数、p是整型指针</span><br><span class="hljs-keyword">auto</span> sz = <span class="hljs-number">0</span>, pi = <span class="hljs-number">3.14</span>; <span class="hljs-comment">// 错误：sz和pi的类型不一致</span><br><br><span class="hljs-comment">//auto会忽略顶层const，保留底层const </span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = i, &amp;cr = ci; <br><span class="hljs-keyword">auto</span> b = ci; <span class="hljs-comment">//b是整型（const被忽略）</span><br><span class="hljs-keyword">auto</span> c = cr; <span class="hljs-comment">//c是整型（cr为ci的引用，ci是const int，但const被忽略）</span><br><span class="hljs-keyword">auto</span> d = &amp;i; <span class="hljs-comment">//d是指向i的整型指针</span><br><span class="hljs-comment">//e是指向ci这个对象的整型常量的指针（对常量对象取地址是一种底层const） </span><br><span class="hljs-keyword">auto</span> e = &amp;cr; <br></code></pre></div></td></tr></table></figure>
<h2 id="Vector容器"><a href="#Vector容器" class="headerlink" title="Vector容器"></a>Vector容器</h2><p>简单使用方法：自己体会下面的代码吧</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">vector&lt;string&gt; v1; <span class="hljs-comment">//定义vector</span><br>v1.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br>v1.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;qwed&quot;</span>);<br>v1.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;asdwrabc&quot;</span>);<br>v1.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;awefx&quot;</span>);<br>vector&lt;string&gt;::iterator it; <span class="hljs-comment">///构造迭代器</span><br><span class="hljs-keyword">for</span>(it=v1.<span class="hljs-built_in">begin</span>();it!=v1.<span class="hljs-built_in">end</span>();it++)&#123;<br>    <span class="hljs-built_in">transform</span>((*it).<span class="hljs-built_in">begin</span>(),(*it).<span class="hljs-built_in">end</span>(),(*it).<span class="hljs-built_in">begin</span>(),::toupper); <span class="hljs-comment">//把字符串全变为大写字母的方法</span><br>    cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">//输出此时迭代器指向的元素</span><br></code></pre></div></td></tr></table></figure>
<h2 id="String流操作"><a href="#String流操作" class="headerlink" title="String流操作"></a>String流操作</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">vector&lt;string&gt; a;<br>string x;<br><span class="hljs-built_in">getline</span>(cin,x);<br><span class="hljs-function">istringstream <span class="hljs-title">t</span><span class="hljs-params">(x)</span></span>; <span class="hljs-comment">//把输入的字符串构造成stream</span><br>string temp;<br><span class="hljs-keyword">while</span>(t&gt;&gt;temp)&#123; <span class="hljs-comment">//从字符串流中读取一个个字符串，并push进vector中</span><br>    a.<span class="hljs-built_in">push_back</span>(temp);<br>&#125;<br><span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">//对vector进行排序</span><br><span class="hljs-keyword">for</span>(vector&lt;string&gt;::iterator it=a.<span class="hljs-built_in">begin</span>();it!=a.<span class="hljs-built_in">end</span>();it++) <br>    cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br></code></pre></div></td></tr></table></figure>
<h2 id="bitset类型"><a href="#bitset类型" class="headerlink" title="bitset类型"></a>bitset类型</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">bitset&lt;32&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>; <span class="hljs-comment">//把n转化成32位二进制数类型</span><br>cout&lt;&lt;a; <span class="hljs-comment">//按二进制输出该数</span><br>cout&lt;&lt;a.<span class="hljs-built_in">count</span>(); <span class="hljs-comment">//输出其中1的个数（等价于__builtin_popcount(n)）</span><br>cout&lt;&lt;a.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//输出32</span><br></code></pre></div></td></tr></table></figure>
<h2 id="一些数值算法"><a href="#一些数值算法" class="headerlink" title="一些数值算法"></a>一些数值算法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//accumulate</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">10</span>;i++) a.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br><span class="hljs-type">int</span> sum = <span class="hljs-built_in">accumulate</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<span class="hljs-comment">//初值为0，返回容器所有元素之和</span><br>cout&lt;&lt;sum&lt;&lt;endl;<br><span class="hljs-comment">//partial_sum</span><br><span class="hljs-built_in">partial_sum</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),a.<span class="hljs-built_in">begin</span>());<span class="hljs-comment">//当前位置和前一位置元素之和赋值给当前位置</span><br><span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::iterator it=a.<span class="hljs-built_in">begin</span>();it!=a.<span class="hljs-built_in">end</span>();it++)<br>	cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br></code></pre></div></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-1-19 diary</title>
    <url>/2020/01/19/daily-2020-1-19/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<blockquote>
<ul>
<li>淦，今天状态好差！早上九点多才爬起来（其实寒假到现在一直都是这个状态QAQ），跟老爸推荐了快手直播做书法的路子，得知以后比较兴奋。</li>
<li>果不其然，下午刷到两个二分答案的题，一题自己没本事写不出来（脑子短路了），还有一题题目条件看错一直WA。。。卡了一个多小时，噢最后才得知输入是乱序的，加个sort就过了艹，果然今天不适合刷题。</li>
<li>我想去补了爱情公寓5和R&amp;M第四季。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>stuffs</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title>github更新代码操作</title>
    <url>/2020/02/01/github%E6%9B%B4%E6%96%B0%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<span id="more"></span>
<p><a href="https://www.cnblogs.com/wuyepeng/p/9747304.html">参考链接</a></p>
<ul>
<li><p>若要先克隆到本地，则先随便新建一个文件夹，在文件夹内git bash</p>
<figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/b4158813/</span>repository名字.git<br></code></pre></div></td></tr></table></figure>
</li>
<li><p>查看状态</p>
<figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">git status</span><br></code></pre></div></td></tr></table></figure>
<p>如果新建的文件夹名和repository名不一样，就会提示目录不对，反正要先让这两个名字相同</p>
</li>
<li><p>更新代码</p>
<p>改完文件过后，使用</p>
<figure class="highlight armasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> * <span class="hljs-comment">//*代表更新全部</span><br></code></pre></div></td></tr></table></figure>
<p>接着输入</p>
<figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">git commit -m <span class="hljs-string">&quot;更新说明&quot;</span> <span class="hljs-regexp">//</span>提交到缓存区域<br></code></pre></div></td></tr></table></figure>
<p>如果多人同时开发维护，得先</p>
<figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">git pull <span class="hljs-regexp">//</span>拉取当前分支最新代码<br></code></pre></div></td></tr></table></figure>
<p>最后</p>
<figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">git push origin <span class="hljs-keyword">master</span> <span class="hljs-title">//push</span>到远程<span class="hljs-literal">master</span>分支上<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>USST练习赛11补题</title>
    <url>/2020/06/11/USST%E7%BB%83%E4%B9%A0%E8%B5%9B11%E8%A1%A5%E9%A2%98/</url>
    <content><![CDATA[<p>第二场对抗赛，感觉自己和队友已经尽力了，然而时间还是不够，一道简单题调了好久浪费了一些时间<br><span id="more"></span></p>
<h4 id="F-最小鸽"><a href="#F-最小鸽" class="headerlink" title="F. 最小鸽"></a><a href="https://ac.nowcoder.com/acm/problem/201977">F. 最小鸽</a></h4><p>题意： 有一排鸽子，每个鸽子有一个鸽值，只有当一段区间的鸽子的 鸽值的或 大于 这段区间的最大鸽值 时，这段区间的鸽子才愿意出动，现在有q次询问，每次给出一只鸽子，问要使这只鸽子出动，需要至少同时出动多少只鸽子？</p>
<p>算法：ST表、线段树</p>
<p>思路：暴力即可，用ST表或线段树预处理一下，然后从小到大枚举区间，如果碰到满足题意的区间就输出区间大小就行了</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// rmq</span><br><span class="hljs-type">int</span> n,m,a[maxn],ST[maxn][<span class="hljs-number">23</span>],STT[maxn][<span class="hljs-number">23</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init_st</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//st init</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) ST[i][<span class="hljs-number">0</span>]=STT[i][<span class="hljs-number">0</span>]=a[i];<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;(<span class="hljs-number">1</span>&lt;&lt;j)&lt;=n;j++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))<span class="hljs-number">-1</span>&lt;=n;i++)&#123;<br>			ST[i][j]=<span class="hljs-built_in">max</span>(ST[i][j<span class="hljs-number">-1</span>],ST[i+(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))][j<span class="hljs-number">-1</span>]);<br>			STT[i][j]=STT[i][j<span class="hljs-number">-1</span>]|STT[i+(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))][j<span class="hljs-number">-1</span>];<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> tp)</span></span>&#123; <span class="hljs-comment">//查询l,r最值</span><br>	<span class="hljs-type">int</span> len=<span class="hljs-built_in">log2</span>(r-l+<span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">return</span> (tp==<span class="hljs-number">1</span>)?<span class="hljs-built_in">max</span>(ST[l][len],ST[r-(<span class="hljs-number">1</span>&lt;&lt;len)+<span class="hljs-number">1</span>][len]):(STT[l][len]|STT[r-(<span class="hljs-number">1</span>&lt;&lt;len)+<span class="hljs-number">1</span>][len]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len=<span class="hljs-number">1</span>;len&lt;=n;len++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>,x-len+<span class="hljs-number">1</span>),j=i+len<span class="hljs-number">-1</span>;i&lt;=x;i++,j=i+len<span class="hljs-number">-1</span>)&#123;<br>			<span class="hljs-type">int</span> q1=<span class="hljs-built_in">query</span>(i,j,<span class="hljs-number">1</span>);<br>			<span class="hljs-type">int</span> q2=<span class="hljs-built_in">query</span>(i,j,<span class="hljs-number">2</span>);<br>			<span class="hljs-keyword">if</span>(q2&gt;q1) <span class="hljs-keyword">return</span> len;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">read</span>(n),<span class="hljs-built_in">read</span>(m);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">read</span>(a[i]);<br>	<span class="hljs-built_in">init_st</span>();<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m)&#123;<br>		<span class="hljs-type">int</span> x;<br>		<span class="hljs-built_in">read</span>(x);<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">ask</span>(x));<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-comment">// https://ac.nowcoder.com/acm/problem/201977</span><br></code></pre></div></td></tr></table></figure>
<h4 id="K-能天使的愿望"><a href="#K-能天使的愿望" class="headerlink" title="K. 能天使的愿望"></a><a href="https://ac.nowcoder.com/acm/problem/54299">K. 能天使的愿望</a></h4><p>题意： 有$N$个店铺，每个店铺都卖$M$个铳，在第$i$个店铺买$j$个铳需要花$p[i][j]$元，此外，在每家店买大于等于$Y$把铳可以免邮费，否则每把铳需要花费额外$a[i]$的邮费，每家店只能购买一次，问买$K$把铳的最小花费</p>
<p>算法： 分组背包</p>
<p>思路：分组背包裸题。。。就加了一个邮费处理</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n,m,k,y,a[<span class="hljs-number">805</span>],p[<span class="hljs-number">805</span>][<span class="hljs-number">805</span>],dp[<span class="hljs-number">805</span>][<span class="hljs-number">805</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">read</span>(n),<span class="hljs-built_in">read</span>(m),<span class="hljs-built_in">read</span>(k),<span class="hljs-built_in">read</span>(y);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">read</span>(a[i]);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">read</span>(p[i][j]);<br>	<span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dp));<br>	dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=k;j++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>;l&lt;=<span class="hljs-built_in">min</span>(j,m);l++)&#123;<br>				<span class="hljs-keyword">if</span>(l&gt;=y) dp[i][j]=<span class="hljs-built_in">min</span>(dp[i][j],dp[i<span class="hljs-number">-1</span>][j-l]+p[i][l]);<br>				<span class="hljs-keyword">else</span> dp[i][j]=<span class="hljs-built_in">min</span>(dp[i][j],dp[i<span class="hljs-number">-1</span>][j-l]+p[i][l]+l*a[i]);<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,dp[n][k]);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-comment">// https://ac.nowcoder.com/acm/problem/54299</span><br></code></pre></div></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>Prim &amp; Kruskal</title>
    <url>/2020/02/07/kruskal/</url>
    <content><![CDATA[<h2 id="最小生成树两个板子-习题"><a href="#最小生成树两个板子-习题" class="headerlink" title="最小生成树两个板子&习题"></a><center>最小生成树两个板子&习题</center></h2><span id="more"></span>
<ul>
<li>最小生成树的$prim$算法和$kruskal$算法的个人理解，记录一下。</li>
</ul>
<hr>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li><strong>最小生成树</strong>是一副<strong>连通加权无向图</strong>中一颗权值最小的生成树</li>
</ul>
<h3 id="Prim-算法"><a href="#Prim-算法" class="headerlink" title="$Prim$算法"></a>$Prim$算法</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul>
<li>与$Dijkstra$算法相类似，对于图中的任意一个节点，找出与之相连的权值最小的边，并连接上去，同时更新答案，并将该点标记为已用过，当找到的<strong>边数==点数-1</strong>时结束</li>
</ul>
<p>注意事项：</p>
<ol>
<li>存图（链式前向星）时<strong>必须存双向边</strong>，因此边数组需要开两倍大</li>
<li>dis数组是核心，它表示已用点到未用点的最短距离</li>
</ol>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">5005</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxm=<span class="hljs-number">200005</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123; <span class="hljs-comment">//边结构体</span><br>	<span class="hljs-type">int</span> u,v,w,next;<br>&#125;e[<span class="hljs-number">2</span>*maxm];<br><span class="hljs-type">int</span> n,m,cnt,tot,head[maxn],ans,now=<span class="hljs-number">1</span>,vis[maxn],dis[maxn];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w)</span></span>&#123; <span class="hljs-comment">//加边函数</span><br>	e[++cnt].u=u;<br>    e[cnt].v=v;<br>    e[cnt].w=w;<br>    e[cnt].next=head[u];<br>    head[u]=cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//算法主体</span><br>    <span class="hljs-comment">//先把除了1点之外的点置为无穷</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++) dis[i]=inf; <br>    <span class="hljs-comment">//遍历与第一个点相连的边，注意防重边</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[<span class="hljs-number">1</span>];i;i=e[i].next)&#123; <br>		dis[e[i].v] = <span class="hljs-built_in">min</span>(dis[e[i].v],e[i].w);<br>    &#125;<br>    <span class="hljs-comment">//最小生成树边数=点数-1</span><br>    <span class="hljs-keyword">while</span>(++tot&lt;n)&#123;<br>		<span class="hljs-type">int</span> minh=inf; <span class="hljs-comment">//每次找到的边的最小值</span><br>        vis[now]=<span class="hljs-number">1</span>; <span class="hljs-comment">//一定要标记，排除环的出现</span><br>        <span class="hljs-comment">//一定是遍历所有的点，因为任何时候都有可能出现 别的点相连的边权值更小</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-keyword">if</span>(!vis[i]&amp;&amp;dis[i]&lt;minh)&#123;<br>				minh=dis[i]; <span class="hljs-comment">// 更新最小值</span><br>                now=i; <span class="hljs-comment">//同时更新当前点</span><br>            &#125;<br>        &#125;<br>        ans+=minh; <span class="hljs-comment">//更新答案</span><br>        <span class="hljs-comment">//更新与当前点相连的所有边的权值（一定要更新，否则就还是无穷）</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[now];i;i=e[i].next)&#123;<br>            <span class="hljs-type">int</span> v=e[i].v;<br>            <span class="hljs-keyword">if</span>(!vis[v]&amp;&amp;dis[v]&gt;e[i].w)&#123;<br>                dis[v]=e[i].w;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>		<span class="hljs-type">int</span> u,v,w;<br>        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br>        <span class="hljs-comment">//一定加双向边，因为要遍历所有点的情况</span><br>        <span class="hljs-built_in">addedge</span>(u,v,w); <br>        <span class="hljs-built_in">addedge</span>(v,u,w);<br>    &#125;<br>    <span class="hljs-built_in">prim</span>();<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="$Kruskal$算法"></a>$Kruskal$算法</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><ul>
<li>与$prim$算法不同，$kruskal$算法首先对所有边权排序，然后从小到大遍历每一条边，每次将权值最小的边加入答案并连接其两个节点（采用并査集完成连接操作，避免了环的产生），从而找到最小生成树</li>
</ul>
<p>注意事项：</p>
<ol>
<li>存图（链式前向星）时无需存双向边和next，因为算法开始时需要先进行排序操作</li>
</ol>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">5005</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxm=<span class="hljs-number">200005</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> u,v,w;<br>&#125;e[maxm];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Edge x1,Edge x2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x1.w&lt;x2.w;<br>&#125;<br><br><span class="hljs-type">int</span> n,m,fa[maxn],ans,cnt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w)</span></span>&#123;<br>    e[++cnt].u=u;<br>    e[cnt].v=v;<br>    e[cnt].w=w;<br>&#125;<br><br><span class="hljs-comment">// 以下是并査集模板（路径压缩）</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x==fa[x]?x:fa[x]=<span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    fa[<span class="hljs-built_in">find</span>(x)]=<span class="hljs-built_in">find</span>(y);<br>&#125;<br><span class="hljs-comment">// 初始化非常重要</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        fa[i]=i;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//算法主体</span><br>    <span class="hljs-built_in">sort</span>(e+<span class="hljs-number">1</span>,e+<span class="hljs-number">1</span>+m,cmp); <span class="hljs-comment">//对边结构体按边权排序</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123; <span class="hljs-comment">//从小到大遍历边</span><br>    	<span class="hljs-type">int</span> eu=e[i].u,ev=e[i].v;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(eu)==<span class="hljs-built_in">find</span>(ev)) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//如果在同一个树里就continue</span><br>        ans+=e[i].w; <span class="hljs-comment">//更新答案</span><br>        <span class="hljs-built_in">unite</span>(eu,ev); <span class="hljs-comment">//把节点连起来</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">init</span>(n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-type">int</span> u,v,w;<br>        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br>       	<span class="hljs-built_in">addedge</span>(u,v,w);<br>    &#125;<br>    <span class="hljs-built_in">kruskal</span>();<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<hr>
<ul>
<li>可以看出<strong>$kruskal$算法的代码量相比$prim$算法来说特别友好</strong>，这还是要归功于<strong>并査集</strong>代码的简洁性，堪称神器。</li>
</ul>
<hr>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="1-Vijos-P1190-繁忙的都市"><a href="#1-Vijos-P1190-繁忙的都市" class="headerlink" title="1. Vijos P1190 繁忙的都市"></a>1. <a href="https://vijos.org/p/1190">Vijos P1190 繁忙的都市</a></h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><ul>
<li>翻译过来就是：给你一个无向带权图，问你选了几条边，其中边权最大的权值是多少？</li>
</ul>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><ul>
<li>裸的$kruskal$，直接写就好。</li>
</ul>
<h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>    <span class="hljs-type">int</span> u,v,w;<br>&#125;e[<span class="hljs-number">3000005</span>];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Edge x1,Edge x2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x1.w&lt;x2.w;<br>&#125;<br><br><span class="hljs-type">int</span> n,m,fa[<span class="hljs-number">1000005</span>],ans,anss,cnt;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w)</span></span>&#123;<br>    e[++cnt].u=u;<br>    e[cnt].v=v;<br>    e[cnt].w=w;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) fa[i]=i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x==fa[x]?x:fa[x]=<span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    fa[<span class="hljs-built_in">find</span>(x)]=<span class="hljs-built_in">find</span>(y);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">sort</span>(e+<span class="hljs-number">1</span>,e+<span class="hljs-number">1</span>+m,cmp);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-type">int</span> eu=e[i].u,ev=e[i].v;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(eu)==<span class="hljs-built_in">find</span>(ev)) <span class="hljs-keyword">continue</span>;<br>        anss=<span class="hljs-built_in">max</span>(anss,e[i].w);<br>        ans++;<br>        <span class="hljs-built_in">unite</span>(eu,ev);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">init</span>(n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-type">int</span> u,v,w;<br>        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br>        <span class="hljs-built_in">addedge</span>(u,v,w);<br>    &#125;<br>    <span class="hljs-built_in">kruskal</span>();<br>    cout&lt;&lt;ans&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;anss;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="2-Vijos-P1234-口袋的天空"><a href="#2-Vijos-P1234-口袋的天空" class="headerlink" title="2. Vijos P1234 口袋的天空"></a>2. <a href="https://vijos.org/p/1234">Vijos P1234 口袋的天空</a></h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><ul>
<li>给你很多个节点和一些边，连接一条边需要付出边权的代价，问能否组成k个不连通的图，若可以，求出最小的代价，若不可以，输出“No Answer”。</li>
</ul>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><ul>
<li>我的思路：也是裸的$kruskal$，在算法过程中将每次加入的边权存入一个顺序数组中，$kruskal$结束后遍历一遍节点，找到全部连边情况下剩下几个不连通的图（也就是所能产生的最少的图）设为n，如过k&lt;n，则不可能，否则就从边权数组里倒序遍历n-k个权值，并用最小生成树减去这个数值即可。</li>
</ul>
<h4 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>    <span class="hljs-type">int</span> u,v,w,next;<br>&#125;e[<span class="hljs-number">3000005</span>];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Edge x1,Edge x2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x1.w&lt;x2.w;<br>&#125;<br><br><span class="hljs-type">int</span> n,m,k,fa[<span class="hljs-number">1000005</span>],ans,anss,cnt,head[<span class="hljs-number">1000005</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w)</span></span>&#123;<br>    e[++cnt].u=u;<br>    e[cnt].v=v;<br>    e[cnt].w=w;<br>    e[cnt].next=head[u];<br>    head[u]=cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) fa[i]=i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x==fa[x]?x:fa[x]=<span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    fa[<span class="hljs-built_in">find</span>(x)]=<span class="hljs-built_in">find</span>(y);<br>&#125;<br><span class="hljs-type">int</span> ccnt,f[<span class="hljs-number">200005</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">sort</span>(e+<span class="hljs-number">1</span>,e+<span class="hljs-number">1</span>+m,cmp);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-type">int</span> eu=e[i].u,ev=e[i].v;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(eu)==<span class="hljs-built_in">find</span>(ev)) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">unite</span>(eu,ev);<br>        anss+=e[i].w;<br>        f[++ccnt]=e[i].w;<br>    &#125;<br>&#125;<br>set&lt;<span class="hljs-type">int</span>&gt; se;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>    <span class="hljs-built_in">init</span>(n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-type">int</span> u,v,w;<br>        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br>        <span class="hljs-built_in">addedge</span>(u,v,w);<br>    &#125;<br>    <span class="hljs-built_in">kruskal</span>();<br>    <span class="hljs-type">int</span> bc=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(se.<span class="hljs-built_in">count</span>(<span class="hljs-built_in">find</span>(i))==<span class="hljs-number">0</span>)&#123;<br>            se.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">find</span>(i));<br>            bc++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(k&lt;bc)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;No Answer&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> num=k-bc;<br>        <span class="hljs-keyword">while</span>(num--)&#123;<br>            anss-=f[ccnt];<br>            ccnt--;<br>        &#125;<br>        cout&lt;&lt;anss&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="未完待续。。。"><a href="#未完待续。。。" class="headerlink" title="未完待续。。。"></a>未完待续。。。</h3>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
        <tag>并査集</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>[temp]预测情况汇报1</title>
    <url>/2020/02/18/temp-%E9%A2%84%E6%B5%8B%E6%83%85%E5%86%B5%E6%B1%87%E6%8A%A5/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<h2 id="Prediction-Model"><a href="#Prediction-Model" class="headerlink" title="Prediction Model"></a>Prediction Model</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>本次预测实验采用的模型为<strong>LSTM（Long Short-Term Memory）长短期记忆网络</strong>，它是一种基于<strong>RNN（Recurrent Neural Network）递归（循环）神经网络</strong>的改进神经网络，继承了RNN的Sequence to Sequence 特点，同时解决了RNN面对长时间段时间序列由于<strong>梯度发散</strong>现象导致的信息遗忘问题，对于长时序问题的预测效果十分可观。</p>
<h3 id="Model-Structure"><a href="#Model-Structure" class="headerlink" title="Model Structure"></a>Model Structure</h3><p><a href="https://b4158813.gitee.io/blog/2020/02/17/LSTM-Long-Short-Term-Memory-浅析/">see in my blog</a></p>
<h3 id="Details-in-Model-Implementation"><a href="#Details-in-Model-Implementation" class="headerlink" title="Details in Model Implementation"></a>Details in Model Implementation</h3><p>本实验采用基于Python的开源深度学习库keras构建模型，其后台为著名机器学习库TensorFlow，其源代码见<a href="https://github.com/keras-team/keras">github: keras-team/keras</a></p>
<h4 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h4><p>目前暂时还未找到十分合适的（包含有风能各项指标，数据量足够大）用于预测精确到1小时数据的数据集，因此我选取了含有<strong>“风速”</strong>这一项的一组北京市空气污染数据集，其中特征主要包括 日期（精确到1h）、pm2.5指数、露点、温度、大气压、风向、风速、降雨量、降雪量。本实验将利用其它所有数据来预测未来某时间段内的风速数据</p>
<p>（数据选取自UCI（加州大学欧文分校）的<a href="https://archive.ics.uci.edu/ml/index.php">Machine Learning Repository</a>，数据集链接：<a href="https://archive.ics.uci.edu/ml/datasets/Beijing+PM2.5+Data">beijing_air_quality数据集</a>）</p>
<h4 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h4><p>数据预处理：</p>
<ol>
<li>数据集已经将数据按时间顺序排列好，考虑到“风向”这一栏数据为类别数据(Categorical data)，并且只有4种类别，因此对这一栏进行One-Hot编码，此后，再对整个数据集进行MinMaxScaler归一化操作（可以使梯度下降过程中loss函数降低得更快，更优），公式如下：</li>
</ol>
<script type="math/tex; mode=display">
s_i=\frac{x_i-min}{max-min}</script><ol>
<li>将归一化后的时间序列数据转化为监督学习数据（简单来说就是利用过去一个时间点的数据预测未来一个时间点的目标数据），并将数据格式改为keras对应LSTM的输入格式</li>
<li>划分训练集、验证集、测试集，本次实验的比例设置为（3：1：1）</li>
</ol>
<p>LSTM模型搭建：</p>
<ul>
<li><p>经过反复试验，最终确定模型结构如下：</p>
<p>解释：LSTM网络总共三层：</p>
<ol>
<li>输入层：接受输入数据（时间步，数据维度）</li>
<li>隐含层：50个神经元，经计算得出参数为12400个，激活函数为reLU（整流线性单元）</li>
<li>输出层：1个神经元，激活函数为线性激活函数（不作任何改变）</li>
</ol>
<p><img src="https://i.loli.net/2020/02/18/oCqBZpv3F57wLmj.png" alt="image.png"></p>
</li>
<li><p>模型训练配置如下</p>
<ul>
<li>采用Adam优化算法（优于SGD和RMSprop）</li>
<li>损失函数采用均方误差(mean_squared_error)</li>
<li>epoch=50, batch_size=72</li>
<li>采用（patience=10）的回调（因为发现了epoch过多时会出现验证集上的loss不降反增的现象，考虑可能是迭代次数过多，出现过拟合了）</li>
</ul>
</li>
<li><p>实验结果</p>
<ul>
<li><p>在测试集上的损失(loss)评估结果（效果非常好）<img src="https://i.loli.net/2020/02/18/L9eIHW7QvA3PbV4.png" alt="image.png"></p>
</li>
<li><p>训练集和测试集的loss对比如下<img src="https://i.loli.net/2020/02/18/ULPeNkF2ZDAorJQ.png" alt="image.png"></p>
</li>
<li><p>由于数据集范围较广，数据是以 数据/1h的形式给出，所以无法预测1小时线，下面给出了此模型对测试集的 四小时线、日线、周线 的预测图（数据范围随机抽取）</p>
<p><img src="https://i.loli.net/2020/02/18/ZBQuSXlcCEdDrqJ.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/02/18/nwqMBysub3P2pUA.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/02/18/RgNnueETCl7Zcvq.png" alt="image.png"></p>
</li>
<li><p>可以看出，由于数据间隔较大，4小时线预测较为不准确，但趋势正确，而日线预测数据和原始数据几乎重合，周线数据除了个别数值有偏离现象，其他也吻合得非常好</p>
</li>
</ul>
</li>
</ul>
<h3 id="All-Python-Notebook-Code"><a href="#All-Python-Notebook-Code" class="headerlink" title="All Python Notebook Code"></a>All Python Notebook Code</h3><p>see in my github repo: <a href="https://github.com/b4158813/Gadgets/blob/master/keras/beijing_air_quality_practice/wind_spd_preds_practice.ipynb">wind_spd_preds_practice</a></p>
<p>看下面代码也行（含注释）</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">import</span> keras<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> mpl<br><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> OneHotEncoder<br><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> MinMaxScaler<br>mpl.rcParams[<span class="hljs-string">&#x27;figure.figsize&#x27;</span>]=<span class="hljs-number">8</span>,<span class="hljs-number">6</span><br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br><span class="hljs-comment"># 序列转化为监督学习的函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">series_to_supervised</span>(<span class="hljs-params">data, n_in=<span class="hljs-number">1</span>, n_out=<span class="hljs-number">1</span>, dropna=<span class="hljs-literal">True</span></span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    	data: origin data</span><br><span class="hljs-string">    	n_in: </span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    n_vars = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(data) <span class="hljs-keyword">is</span> <span class="hljs-built_in">list</span> <span class="hljs-keyword">else</span> data.shape[<span class="hljs-number">1</span>]<br>    df = pd.DataFrame(data)<br>    cols, names = <span class="hljs-built_in">list</span>(),<span class="hljs-built_in">list</span>()<br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n_in,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>):<br>        cols.append(df.shift(i))<br>        names+=[(<span class="hljs-string">&#x27;var%d(t-%d)&#x27;</span>%(j+<span class="hljs-number">1</span>, i)) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n_vars)]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, n_out):<br>        cols.append(df.shift(-i))<br>        <span class="hljs-keyword">if</span> i==<span class="hljs-number">0</span>:<br>            names += [(<span class="hljs-string">&#x27;var%d(t)&#x27;</span>%(j+<span class="hljs-number">1</span>)) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n_vars)]<br>        <span class="hljs-keyword">else</span>:<br>            names += [(<span class="hljs-string">&#x27;var%d(t+%d)&#x27;</span>%(j+<span class="hljs-number">1</span>, i)) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n_vars)]<br>    agg = pd.concat(cols, axis=<span class="hljs-number">1</span>)<br>    agg.columns = names<br>    <span class="hljs-keyword">if</span> dropna: <span class="hljs-comment"># 是否去除缺失值的行</span><br>        agg.dropna(inplace=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">return</span> agg<br><br><span class="hljs-comment"># 我用来plot结果对比的函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">plot_history</span>(<span class="hljs-params">model_history</span>):<br>    plt.plot(model_history.history[<span class="hljs-string">&#x27;loss&#x27;</span>],label=<span class="hljs-string">&#x27;train_loss&#x27;</span>)<br>    plt.plot(model_history.history[<span class="hljs-string">&#x27;val_loss&#x27;</span>],label=<span class="hljs-string">&#x27;vlaid_loss&#x27;</span>)<br>    plt.legend(fontsize=<span class="hljs-number">15</span>)<br>    plt.title(<span class="hljs-string">&#x27;loss-epoch graph&#x27;</span>,fontsize=<span class="hljs-number">15</span>)<br>    plt.xlabel(<span class="hljs-string">&#x27;epoch&#x27;</span>,fontsize=<span class="hljs-number">15</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;loss&#x27;</span>,fontsize=<span class="hljs-number">15</span>)<br>    plt.grid(linestyle=<span class="hljs-string">&#x27;--&#x27;</span>,alpha=<span class="hljs-number">0.5</span>)<br>    plt.legend()<br>    plt.show()<br>    <br><span class="hljs-comment"># 读取数据</span><br>data = pd.read_csv(<span class="hljs-string">&#x27;PRSA_data_2010.1.1-2014.12.31.csv&#x27;</span>)<br>data.drop([<span class="hljs-string">&#x27;year&#x27;</span>,<span class="hljs-string">&#x27;month&#x27;</span>,<span class="hljs-string">&#x27;day&#x27;</span>,<span class="hljs-string">&#x27;hour&#x27;</span>,<span class="hljs-string">&#x27;No&#x27;</span>],axis=<span class="hljs-number">1</span>,inplace=<span class="hljs-literal">True</span>)<br>data[<span class="hljs-string">&#x27;pm2.5&#x27;</span>].fillna(<span class="hljs-number">0</span>, inplace=<span class="hljs-literal">True</span>)<br>data = data[<span class="hljs-number">24</span>:].reset_index()<br>data.drop([<span class="hljs-string">&#x27;index&#x27;</span>],axis=<span class="hljs-number">1</span>,inplace=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 把列弄得好看一点</span><br>data.columns=[<span class="hljs-string">&#x27;pollution&#x27;</span>,<span class="hljs-string">&#x27;dew&#x27;</span>,<span class="hljs-string">&#x27;temp&#x27;</span>,<span class="hljs-string">&#x27;press&#x27;</span>,<span class="hljs-string">&#x27;wnd_dir&#x27;</span>,<span class="hljs-string">&#x27;wnd_spd&#x27;</span>,<span class="hljs-string">&#x27;snow&#x27;</span>,<span class="hljs-string">&#x27;rain&#x27;</span>]<br><br><span class="hljs-comment"># 把风向这一组one-hot编码</span><br>enc = OneHotEncoder(sparse=<span class="hljs-literal">False</span>)<br>obj_cols = [<span class="hljs-string">&#x27;wnd_dir&#x27;</span>]<br>trans = pd.DataFrame(enc.fit_transform(data[obj_cols]))<br>trans.columns=[<span class="hljs-string">&#x27;dir_1&#x27;</span>,<span class="hljs-string">&#x27;dir_2&#x27;</span>,<span class="hljs-string">&#x27;dir_3&#x27;</span>,<span class="hljs-string">&#x27;dir_4&#x27;</span>]<br>data.drop(obj_cols, axis=<span class="hljs-number">1</span>, inplace=<span class="hljs-literal">True</span>)<br>oh_data = pd.concat([data, trans], axis=<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 把预测数据和第一列数据换一下</span><br>old_order = <span class="hljs-built_in">list</span>(oh_data)<br>t=old_order[<span class="hljs-number">4</span>]<br>old_order[<span class="hljs-number">4</span>]=old_order[<span class="hljs-number">0</span>]<br>old_order[<span class="hljs-number">0</span>]=t<br>oh_data = oh_data[old_order]<br><br><span class="hljs-comment"># 归一化操作</span><br>scaler = MinMaxScaler(feature_range=(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>))<br>scaled_data = scaler.fit_transform(oh_data[[name <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> oh_data.columns]])<br>reframed_data = series_to_supervised(scaled_data, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 把不需要预测的列取去除</span><br>useless_cols = reframed_data.columns[<span class="hljs-number">12</span>:]<br>reframed_data.drop(useless_cols,axis=<span class="hljs-number">1</span>,inplace=<span class="hljs-literal">True</span>)<br>reframed_data.head()<br>reframed_data.info()<br><br><span class="hljs-comment"># 设定训练集、验证集比例</span><br>train_ratio = <span class="hljs-number">0.6</span><br>valid_ratio = <span class="hljs-number">0.2</span><br>train_days = <span class="hljs-built_in">int</span>(train_ratio*<span class="hljs-built_in">len</span>(reframed_data))<br>valid_days = <span class="hljs-built_in">int</span>(valid_ratio*<span class="hljs-built_in">len</span>(reframed_data))<br>test_days = <span class="hljs-built_in">len</span>(reframed_data)-train_days-valid_days<br><br><span class="hljs-comment"># 划分训练集、验证集、测试集</span><br>train = reframed_data.values[:train_days,:]<br>valid = reframed_data.values[train_days:train_days+valid_days,:]<br>test = reframed_data.values[train_days+valid_days:,:]<br><br>train_x, train_y = train[:,:-<span class="hljs-number">1</span>], train[:,-<span class="hljs-number">1</span>]<br>valid_x, valid_y = valid[:,:-<span class="hljs-number">1</span>], valid[:,-<span class="hljs-number">1</span>]<br>test_x, test_y = test[:,:-<span class="hljs-number">1</span>], test[:,-<span class="hljs-number">1</span>]<br><br><span class="hljs-comment"># 把输入调成keras的LSTM要求的输入格式</span><br>train_x = train_x.reshape((train_x.shape[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, train_x.shape[<span class="hljs-number">1</span>]))<br>valid_x = valid_x.reshape((valid_x.shape[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, valid_x.shape[<span class="hljs-number">1</span>]))<br>test_x = test_x.reshape((test_x.shape[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, test_x.shape[<span class="hljs-number">1</span>]))<br><span class="hljs-comment"># 看一下维度对不对</span><br><span class="hljs-built_in">print</span>(train_x.shape,train_y.shape,valid_x.shape,valid_y.shape,test_x.shape,test_y.shape)<br><br><span class="hljs-comment"># 建立LSTM模型</span><br>model = keras.Sequential([<br>    keras.layers.LSTM(<span class="hljs-number">50</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>, input_shape=(train_x.shape[<span class="hljs-number">1</span>],train_x.shape[<span class="hljs-number">2</span>])),<br>    keras.layers.Dense(<span class="hljs-number">1</span>, activation=<span class="hljs-string">&#x27;linear&#x27;</span>)<br>])<br><span class="hljs-comment"># 配置模型</span><br>model.<span class="hljs-built_in">compile</span>(optimizer=<span class="hljs-string">&#x27;adam&#x27;</span>,<br>             loss=<span class="hljs-string">&#x27;mean_squared_error&#x27;</span>)<br><span class="hljs-comment"># 看一下模型概括</span><br>model.summary()<br><br><span class="hljs-comment"># 设置回调</span><br>early_stop = keras.callbacks.EarlyStopping(monitor=<span class="hljs-string">&#x27;val_loss&#x27;</span>,patience=<span class="hljs-number">10</span>)<br><br><span class="hljs-comment"># 定义一个训练进度可视化函数，便于查看进度</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintDot</span>(keras.callbacks.Callback):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_epoch_end</span>(<span class="hljs-params">self, epoch, logs</span>):<br>        <span class="hljs-keyword">if</span> epoch%<span class="hljs-number">25</span>==<span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; &quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;.&quot;</span>,end=<span class="hljs-string">&#x27;&#x27;</span>)<br><br><span class="hljs-comment"># 开始训练</span><br>model_history = model.fit(train_x, train_y,<br>                         epochs=<span class="hljs-number">50</span>,<br>                         batch_size=<span class="hljs-number">72</span>,<br>                         validation_data=(valid_x, valid_y),<br>                          verbose=<span class="hljs-number">0</span>,<br>                        callbacks=[early_stop,PrintDot()],<br>                         shuffle=<span class="hljs-literal">False</span>)<br><br><span class="hljs-comment"># 绘出loss对比图</span><br>plot_history(model_history)<br><span class="hljs-comment"># 评估结果</span><br>evaluate_res = model.evaluate(test_x,test_y)<br><span class="hljs-built_in">print</span>(evaluate_res)<br><br><span class="hljs-comment"># 预测</span><br>preds = model.predict(test_x)<br><span class="hljs-comment"># 画出结果对比图</span><br>plt.plot(preds[<span class="hljs-number">8600</span>:],label=<span class="hljs-string">&#x27;test_predict&#x27;</span>)<br>plt.plot(test_y[<span class="hljs-number">8600</span>:], label=<span class="hljs-string">&#x27;test_actual&#x27;</span>)<br>plt.legend()<br>plt.show()<br><br><br><span class="hljs-comment"># 反归一化操作</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    preds=np.column_stack((preds, np.zeros(<span class="hljs-built_in">len</span>(test_y))))<br>    <br>inverse_preds = scaler.inverse_transform(preds)<br>origin_test_y = oh_data[<span class="hljs-string">&#x27;wnd_spd&#x27;</span>][train_days+valid_days:]<br>origin_test_y = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> origin_test_y]<br><br><span class="hljs-comment"># 把结果画出来并对比的函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">plot_trends</span>(<span class="hljs-params">hour_begin, hour_end</span>):<br>    plt.plot(inverse_preds[hour_begin:hour_end,<span class="hljs-number">0</span>],label=<span class="hljs-string">&#x27;actual_preds&#x27;</span>)<br>    plt.plot(origin_test_y[hour_begin:hour_end], label=<span class="hljs-string">&#x27;actual_test_y&#x27;</span>)<br>    plt.legend(fontsize=<span class="hljs-number">15</span>)<br>    plt.xlabel(<span class="hljs-string">&#x27;hour&#x27;</span>,fontsize=<span class="hljs-number">15</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;wind_speed&#x27;</span>,fontsize=<span class="hljs-number">15</span>)<br>    <span class="hljs-keyword">if</span> hour_end-hour_begin&lt;=<span class="hljs-number">24</span>:<br>        plt.title(<span class="hljs-string">&#x27;&#123;0&#125;_hours_line&#x27;</span>.<span class="hljs-built_in">format</span>(hour_end-hour_begin),fontsize=<span class="hljs-number">15</span>)<br>    <span class="hljs-keyword">else</span>:<br>        plt.title(<span class="hljs-string">&#x27;&#123;0:.0f&#125;_days_line&#x27;</span>.<span class="hljs-built_in">format</span>((hour_end-hour_begin)/<span class="hljs-number">24</span>),fontsize=<span class="hljs-number">15</span>)<br>    plt.grid(linestyle=<span class="hljs-string">&#x27;--&#x27;</span>,alpha=<span class="hljs-number">0.5</span>)<br>    plt.show()<br>    <br><span class="hljs-comment"># 我随便选取的时间（8000小时为起点）</span><br>plot_trends(<span class="hljs-number">8000</span>,<span class="hljs-number">8000</span>+<span class="hljs-number">4</span>)<br>plot_trends(<span class="hljs-number">8000</span>,<span class="hljs-number">8000</span>+<span class="hljs-number">24</span>)<br>plot_trends(<span class="hljs-number">8000</span>,<span class="hljs-number">8000</span>+<span class="hljs-number">24</span>*<span class="hljs-number">7</span>)<br><br></code></pre></div></td></tr></table></figure>
]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>[temp]预测情况汇报2</title>
    <url>/2020/07/02/temp-%E9%A2%84%E6%B5%8B%E6%83%85%E5%86%B5%E6%B1%87%E6%8A%A52/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<p>前段时间一直在准备程序设计竞赛，没有好好做过预测这方面的课题，这几天稍微闲下来一点了，于是就来搞一下。</p>
<hr>
<h4 id="2020-5-12"><a href="#2020-5-12" class="headerlink" title="2020.5.12"></a>2020.5.12</h4><p>由于本课题的问题是需要根据过去的时间序列预测未来的时间序列，也就是所谓的$Sequence-to- Vector$ 的实现，这一点我们无法简单地利用RNN或者LSTM神经网络来进行预测，归根结底就是因为这种时间序列预测的特点是<strong>无监督学习</strong>：数据集只有时间戳和特征，对于未来需要预测的时间点，只有时间序列作为自变量，因此无法将它简单地转换为<strong>监督学习</strong>数据集从而使用神经网络预测（神经网络大都是监督学习）</p>
<p>那么，我首先想到的就是利用传统的<strong>时间序列分解</strong>方法来构建这个模型</p>
<h3 id="模型的算法实现"><a href="#模型的算法实现" class="headerlink" title="模型的算法实现"></a>模型的算法实现</h3><p>对于一个时间序列$y_t$，我将其分解为以下几个部分：</p>
<ol>
<li>季节项$S_t$（呈周期变化的特征）</li>
<li>趋势项$T_t$</li>
<li>剩余项$R_t$</li>
</ol>
<p>那么，对于所有的$t\ge 0$，都有：$y_t=S_t+T_t+R_t$</p>
<p>当然也可以用乘法构建分解：$y_t=S_t\cdot T_t\cdot R_t$，等号两边取对数，就能得到一个加法构建的分解：$\ln y_t=\ln S_t+\ln T_t+\ln R_t$</p>
<p>整体的算法是基于拟合以上各项，然后累加得出最终的预测函数</p>
<p>那么对于趋势预测，我们需要重点考虑 <strong>趋势项$T_t$</strong>，对于趋势项的模型拟合，最常用的方法无外乎<strong>逻辑回归</strong>和<strong>分段线性拟合</strong>，这里我采用<strong>分段线性拟合</strong></p>
<p>众所周知，线性函数形如：$y=kx+b$，由于序列不一定是线性的，我们分段处理，假设时间为$t$，在实际环境中，系数$k$和系数$b$不可能是常数，他们都应该与时间项相关，所以我们定义为$k(t)$和$b(t)$，除此之外，时间序列走势也会变，那么就会出现<strong>变点(change point)</strong>，我们定义为$S$，这一点已经有学者做了很多研究</p>
<p>现在假设已经放置了$S$个变点，并且处于时间戳$s_j$，那么我们就需要在$s_j$上给出增长率的变化，于是我们可以假设一个向量$\delta\in R^S$，其中$\delta_i$表示在时间戳$s_j$上的增长率的变化量，假设初始的增长率为$k$，则在时间戳$t$上的增长率就是：$k+\sum_{j:t&gt;s_j}\delta_j$，为了简化表达，我写成如下函数的形式：</p>
<script type="math/tex; mode=display">
a_j(t)=\begin{cases}1,if\ t\ge s_j,\\0,otherwise.\end{cases}</script><p>那么在时间戳$t$上的增长率就是$k+a^T\delta$，$k$能够确定了，同理同样可以得出另外一个参数的表达式为$b+a^T\gamma$，至此，基于分段线性函数的模型如下：（其中，$\gamma$为偏置量）</p>
<script type="math/tex; mode=display">
y(t)=(k+a(t)\delta)\cdot t+(b+a(t)^T\gamma)</script><p>偏置项的求法为：$\gamma=(\gamma_1,\gamma_2,…,\gamma_S)^T,\gamma_j=-s_j\delta_j$</p>
<h3 id="应用模型"><a href="#应用模型" class="headerlink" title="应用模型"></a>应用模型</h3><p>由于FaceBook公司开源的fbprophet库带有了时间序列分解的模型，且原理相同，我查看了其源码，其有关线性分段部分的代码如下，符合我们的模型</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">piecewise_linear</span>(<span class="hljs-params">t, deltas, k, m, changepoint_ts</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Evaluate the piecewise linear function.</span><br><span class="hljs-string">        Parameters</span><br><span class="hljs-string">        ----------</span><br><span class="hljs-string">        t: np.array of times on which the function is evaluated.</span><br><span class="hljs-string">        deltas: np.array of rate changes at each changepoint.</span><br><span class="hljs-string">        k: Float initial rate.</span><br><span class="hljs-string">        m: Float initial offset.</span><br><span class="hljs-string">        changepoint_ts: np.array of changepoint times.</span><br><span class="hljs-string">        Returns</span><br><span class="hljs-string">        -------</span><br><span class="hljs-string">        Vector y(t).</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># Intercept changes</span><br>        gammas = -changepoint_ts * deltas<br>        <span class="hljs-comment"># Get cumulative slope and intercept at each t</span><br>        k_t = k * np.ones_like(t)<br>        m_t = m * np.ones_like(t)<br>        <span class="hljs-keyword">for</span> s, t_s <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(changepoint_ts):<br>            indx = t &gt;= t_s<br>            k_t[indx] += deltas[s]<br>            m_t[indx] += gammas[s]<br>        <span class="hljs-keyword">return</span> k_t * t + m_t<br></code></pre></div></td></tr></table></figure>
<p>接下来考虑导入数据集来验证这个模型：（选用的还是加州大学欧文分校的数据集）</p>
<p>导入数据并预处理出时间序列和风速数据，选取其中一天（24h）的数据，图线如下：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/wefwef.png" alt="wefwef"></p>
<p>对其进行时间序列分解（分段线性拟合），并预测未来一天的数据，得到下图</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/wind2.png" alt="wind2"></p>
<p>其中，淡蓝色区域为置信区间，蓝色线为预测线，作出和原始数据的对比图如下：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/wind3.png" alt="wind3"></p>
<p>可以看出效果还是不错的，但这仅限于对于一天内的风速的预测，下面尝试预测一周的时间序列：</p>
<p>找出其中一周的时间序列，原始数据如下图所示</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/wind4.png" alt="wind4"></p>
<p>可以看出每一天风速的数据是十分不稳定的，完全看不出任何规律，因此估计利用分段线性拟合的方法得不出可观的结果，结果如下：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/lWyekJtERImVYN5.png" alt="wind51"></p>
<p>结果真如所料，得不出可观的结果，究其原因，还是因为风能的<strong>日与日之间的数据不具有周期性和规律性</strong>的缘故。</p>
<hr>
<h4 id="2020-5-13"><a href="#2020-5-13" class="headerlink" title="2020.5.13"></a>2020.5.13</h4><p>由于之前的预测十分不靠谱，花了一晚上总结了一下，其实数据集也有很大的原因，暂且抛开数据集本身的原因不谈，我先考虑如何使得预测变得稍微靠谱一些。</p>
<p>预测不准的原因显然就是：数据本身没有规律性和周期性，而且数据的波动幅度较大，这一切都是基于每日的小时数据而言的，因此，我可以考虑先放弃处理微观的小时数据，以每日的24小时的数据的均值为研究对象，研究每日风力的均值的变化，那么下面实践一下。</p>
<p>首先仍然是导入数据，然后将每日的24小时风力数据的均值作为研究对象</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">y = scaled_data2[<span class="hljs-string">&#x27;y&#x27;</span>]<br>y.index=pd.DatetimeIndex(y.index)<br>daily_wind = y.resample(<span class="hljs-string">&#x27;24H&#x27;</span>).mean()<span class="hljs-comment">#24小时的均值为一个数据点</span><br>daily_wind = pd.DataFrame(daily_wind)<br>daily_wind.head()<br></code></pre></div></td></tr></table></figure>
<p>为了模型预测更准确，进行归一化操作</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">daily_wind[<span class="hljs-string">&#x27;y&#x27;</span>]=(daily_wind[<span class="hljs-string">&#x27;y&#x27;</span>]-daily_wind[<span class="hljs-string">&#x27;y&#x27;</span>].mean())/(daily_wind[<span class="hljs-string">&#x27;y&#x27;</span>].std())<span class="hljs-comment">#简单的 减均值再除以标准差 归一化</span><br>Mean=daily_wind[<span class="hljs-string">&#x27;y&#x27;</span>].mean()<br>Std=daily_wind[<span class="hljs-string">&#x27;y&#x27;</span>].std()<br></code></pre></div></td></tr></table></figure>
<p>然后，我选取前1400天的数据为训练集，其数据可视化如下：（其中出现了负值是因为我进行了归一化）</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/wind21.png" alt="wind21"></p>
<p>随后训练模型，并预测后100天的数据，结果如下图所示：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/wind22.png" alt="wind22"></p>
<p>可以看出，预测线条出现了周期性规律的变化，虽然效果可能不是很好，但已经比昨天的训练好了很多，我们抽出预测的数据和原始数据进行比对，如下图所示：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/wind23.png" alt="wind23"></p>
<p>图中黑色线条为预测线，大红色的散点为原始数据，我们将其放大：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/wind24.png" alt="wind24"></p>
<p>可以看出，总体的趋势仍然比较平缓，但由于存在一些点的数据值波动十分剧烈，导致这些值完全呈现出不可预测的状态（根本没办法预测出来），这些值的预测线和实际数据偏离很大，很显然这是这个模型的一个无法处理的缺陷</p>
<p>接下来我们定量计算一下实际值和预测值的误差(ERROR)，一般情况下，我们用均方根误差(RMSE)来衡量预测的准确程度，其计算公式如下：</p>
<script type="math/tex; mode=display">
RMSE=\frac{\sqrt{\sum_{i=1}^{n}(x_{predict}[i]-x_{actual}[i])^2}}{n}=0.1517</script><hr>
<h4 id="后续-2020-7-1"><a href="#后续-2020-7-1" class="headerlink" title="后续 2020.7.1"></a>后续 2020.7.1</h4><p>（前段时间在处理 返校 + 保研夏令营和复习 + 节能减排大赛 的相关事宜，终于忙完，特此记录）</p>
<p>经过一段时间的求证，我发现此类问题与金融大数据科学方面的<strong>股票预测</strong>十分相似，它们的共同特征都是<strong>无规律性</strong>，甚至可以说 风能数据比股票数据来得更加无规律无周期。</p>
<p>这一类问题的本质，我的理解是：实现真正意义上的<strong>无规律数据+无监督学习预测未来</strong>，如果需要对一段无规律数据预测未来的数据值，且需要预测的时间点/段的特征量无输入变量或先验知识，或仅有时间特征作为输入变量，那么这个问题就会变得十分棘手。</p>
<p>但是对应的，我也思考了可能的解决方案，就是：<strong>利用容易提前得知或预测到的未来时间点/段 的先验知识/数据 作为输入变量</strong>（比如说：我要预测明天中午12点的上海理工大学五食堂门口的风力，那么我可以提前预测明天中午12点的温度、湿度、降雨可能性 等容易提前预测的数据作为未来的先验知识或特征），这样一来，就可以利用$Seq2Seq$模型结合LSTM神经网络或其深度学习模型求解此类问题，结果也许会可观一些。</p>
<p>然而，对于此类问题，我也询问过相关方向（深度学习、预测 相关）的同学和老师，普遍给出的结论就是这类问题难以得出可靠的研究成果，或得出的成果并不具有普适性，因此研究的意义并不是很大，我打算就此告一段落。</p>
<p>虽然并没有得出十分可靠的结论，但此次研究过程中，我阅读了相关文献和博客，学习了许多新的时序建模知识是它带给我的收获。</p>
<hr>
<p>PS：研究过程中的所有代码和文件见 <a href="https://github.com/b4158813/Gadgets">我的github</a>，这个仓库下的<code>fbprophet</code>和<code>keras</code>内的代码文件就是我的成果。</p>
]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>时间序列分解</tag>
      </tags>
  </entry>
  <entry>
    <title>wxPython学习笔记</title>
    <url>/2020/02/08/wxPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<center>
见<a href="https://github.com/b4158813/Gadgets/tree/master/python%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/wxpython%E5%AD%A6%E4%B9%A0" target="_blank">github链接</a>
</center>]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>双向链表练习题</title>
    <url>/2020/01/28/%E3%80%90%E5%88%B7%E9%A2%98%E3%80%91%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="刷题记录-洛谷P1160-队列安排"><a href="#刷题记录-洛谷P1160-队列安排" class="headerlink" title="[刷题记录]洛谷P1160 队列安排"></a><center>[刷题记录]洛谷P1160 队列安排</center></h2><span id="more"></span>
<ul>
<li>年前刷的题，没来得及整理，年后来搞一下。</li>
</ul>
<hr>
<h2 id="P1160-队列安排"><a href="#P1160-队列安排" class="headerlink" title="P1160 队列安排"></a>P1160 队列安排</h2><ul>
<li><a href="https://www.luogu.com.cn/problem/P1160">题目链接</a></li>
</ul>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>老师要将$N$个同学排成一列，她首先把$1$号同学排进去，随后$2…N$号同学入队，由老师指定编号为$i$的同学站在编号为$1…(i-1)$的某位同学的左边或右边，除此之外，老师还可以从队列中去除M个同学，而其他的同学位置顺序不变。</p>
<p>最后要求你输出队列同学的编号。</p>
<p>Sample Input</p>
<figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span>//表示共有<span class="hljs-number">4</span>个同学<br><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> //将<span class="hljs-number">2</span>号同学插入到<span class="hljs-number">1</span>号同学的左边<br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> //将<span class="hljs-number">3</span>号同学插入到<span class="hljs-number">2</span>号同学的右边<br><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> //将<span class="hljs-number">4</span>号同学插入到<span class="hljs-number">1</span>号同学的左边<br><span class="hljs-symbol">2 </span>//表示有<span class="hljs-number">2</span>个需要去除的同学<br><span class="hljs-symbol">3 </span>//去除<span class="hljs-number">3</span>号同学<br><span class="hljs-symbol">3 </span>//去除<span class="hljs-number">3</span>号同学（已去除，故无效）<br></code></pre></div></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure>
<h3 id="思路-amp-解法"><a href="#思路-amp-解法" class="headerlink" title="思路&amp;解法"></a>思路&amp;解法</h3><ul>
<li><p>看到需要<strong>插入</strong>和<strong>删除</strong>操作的序列，很明显是一道<u>链表</u>题，对于我这种刚学数据结构的蒟蒻来说，还是要慢慢搞的，附上代码（含注释）。</p>
</li>
<li><p>我使用的是比较容易的<strong>结构体数组</strong>定义方式，指针还不够熟练orz。</p>
</li>
<li><p>其中最关键的<strong>插入</strong>和<strong>删除</strong>操作，为方便理解，我画了个图，如下：</p>
<p>add_left</p>
<p><img src="https://i.loli.net/2020/01/28/fTV3gIcMHFKvhkE.jpg" alt="IMG_20200128_121736.jpg" style="zoom: 25%;" /></p>
<p>add_right</p>
<p><img src="https://i.loli.net/2020/01/28/mBrKSFAJ8OnCab6.jpg" alt="IMG_20200128_121725.jpg" style="zoom:25%;" /></p>
<p>erase</p>
<p><img src="https://i.loli.net/2020/01/28/H9sOMJcplVFDnj8.jpg" alt="IMG_20200128_122303.jpg" style="zoom:25%;" /></p>
</li>
</ul>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123; <span class="hljs-comment">//定义链表中的每一个元素</span><br>	<span class="hljs-type">int</span> L,R; <span class="hljs-comment">//前驱与后继</span><br>&#125;q[<span class="hljs-number">100005</span>]; <span class="hljs-comment">//结构体数组</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_left</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> x)</span></span>&#123; <span class="hljs-comment">//在pos位置左边插入x元素</span><br>	q[x].R = pos; <br>	q[x].L = q[pos].L;<br>	q[q[pos].L].R = x;<br>	q[pos].L = x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_right</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> x)</span></span>&#123; <span class="hljs-comment">//在pos位置右边插入x元素</span><br>	q[x].L = pos;<br>	q[x].R = q[pos].R;<br>	q[q[pos].R].L=x;<br>	q[pos].R = x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123; <span class="hljs-comment">//删除x元素</span><br>	<span class="hljs-keyword">if</span>(q[x].L==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;<br>	q[q[x].L].R = q[x].R;<br>	q[q[x].R].L = q[x].L;<br>	q[x].L=<span class="hljs-number">-1</span>;<br>	q[x].R=<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//初始化，把1号放入链表第一位</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		q[i].L=q[i].R=<span class="hljs-number">-1</span>;<br>	&#125;<br>	q[<span class="hljs-number">0</span>].R=<span class="hljs-number">1</span>;<br>	q[<span class="hljs-number">1</span>].L=<span class="hljs-number">0</span>;<br>	q[<span class="hljs-number">1</span>].R=<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;n;<br>	<span class="hljs-built_in">init</span>();<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-type">int</span> x,y;<br>		cin&gt;&gt;x&gt;&gt;y;<br>		<span class="hljs-keyword">if</span>(y==<span class="hljs-number">1</span>) <span class="hljs-built_in">add_right</span>(x,i);<br>		<span class="hljs-keyword">else</span> <span class="hljs-built_in">add_left</span>(x,i);<br>	&#125;<br>	<span class="hljs-type">int</span> m;<br>	cin&gt;&gt;m;<br>	<span class="hljs-keyword">while</span>(m--)&#123;<br>		<span class="hljs-type">int</span> x;<br>		cin&gt;&gt;x;<br>		<span class="hljs-built_in">erase</span>(x);<br>	&#125;<br>	<span class="hljs-type">int</span> x = q[<span class="hljs-number">0</span>].R;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123; <span class="hljs-comment">// 遍历链表并输出</span><br>		cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>		<span class="hljs-keyword">if</span>(q[x].R==<span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;<br>		x=q[x].R;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></div></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>算法模板</tag>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图匹配</title>
    <url>/2020/03/29/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h2 id="二分图最大匹配"><a href="#二分图最大匹配" class="headerlink" title="二分图最大匹配"></a><center>二分图最大匹配</center></h2><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/u=702466903,2349702842&amp;fm=11&amp;gp=0.jpg" alt="u=702466903,2349702842&amp;fm=11&amp;gp=0"></p>
<span id="more"></span>
<p>参考blog：</p>
<ul>
<li><a href="https://blog.csdn.net/u013384984/article/details/90718287">匈牙利算法</a></li>
</ul>
<p>PS：这里只放匈牙利找增广路径的算法，关于网络流请出门左拐网络流专题</p>
<h3 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h3><p><strong>二分图</strong>：一个图的节点可以被分为两个互不相交的子集，且对于所有的边，其中一端的节点属于一个集合，另一端的节点属于另一个集合</p>
<p><strong>匹配</strong>：图G的一个匹配是一组没有公共端点的不是圈的边构成的集合（重点：边的集合、任意两条边不能有公共顶点）</p>
<p>那么<strong>最大匹配</strong>就顾名思义了：匹配数最大的一个匹配<del>（好像是废话）</del></p>
<p><strong>完美匹配</strong>：若二分图X部的每一个顶点都与Y中的一个顶点匹配，<strong>并且</strong>Y部中的每一个顶点也与X部中的一个顶点匹配，则该匹配为完美匹配</p>
<p>因此，完美匹配一定是最大匹配，但最大匹配不一定是完美匹配（可以有点没有匹配）</p>
<p><strong>完备匹配</strong>：一个二分图X部中的每一个顶点都与Y部中的一个顶点匹配，<strong>或者</strong>Y部中的每一个顶点也与X部中的一个顶点匹配，则该匹配为完备匹配</p>
<p><strong>最佳匹配</strong>：<strong>带权</strong>二分图的<strong>权值最大</strong>的<strong>完备匹配</strong>称为最佳匹配（因此：最佳匹配不一定是最大匹配）</p>
<h3 id="二分图判定"><a href="#二分图判定" class="headerlink" title="二分图判定"></a>二分图判定</h3><p><a href="https://vjudge.net/problem/HihoCoder-1121">【模板题】二分图判定</a></p>
<p>染色法：从任意一个点开始DFS，将这个点标记为1，把连到的点标记为2（也可标记为别的），如果出现了当前点和相连点标记相同，则该图不是二分图</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    col[u]=c;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>        <span class="hljs-type">int</span> v=e[i].v;<br>        <span class="hljs-keyword">if</span>(col[v]==col[u]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//不是二分图</span><br>        <span class="hljs-keyword">if</span>(col[v]==<span class="hljs-number">0</span>&amp;&amp;!<span class="hljs-built_in">judge</span>(v,<span class="hljs-number">3</span>-c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//不是二分图</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//这个点合格</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">if</span>(col[i]==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">judge</span>(i))<br>                f=<span class="hljs-literal">false</span>;<span class="hljs-comment">//不是二分图</span><br>                <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><p><a href="https://vjudge.net/problem/HihoCoder-1122">【模板题】二分图最大匹配</a></p>
<p>由于上面的blog已经讲得很详细了，我就不再赘述，这里总结一下核心步骤</p>
<p>核心步骤（<strong>找增广路径，找到则匹配数+1</strong>）：</p>
<p>给一个点找匹配点，找到的另一个点有两种情况：</p>
<ol>
<li>没有被匹配：那么就匹配上去</li>
<li>有其他点跟他匹配了：把那个其他点踹掉，<strong>递归地</strong>让他也执行这个点同样的操作，如果最后的点能回到情况1，就说明找到一条<strong>增广路径</strong>了（匹配数+1）；否则当期点就无法匹配，跳过</li>
</ol>
<p>时间复杂度：邻接表$O(n*m)$，邻接矩阵$O(n^3)$</p>
<p>注意事项：</p>
<ul>
<li>记得要遍历二分图一侧的每一个点，每次都<strong>需要将<code>used</code>数组重置为<code>0</code></strong></li>
<li>匹配找到之后，可根据题目要求选择是否要记录一下<strong>每个点匹配到的点的编号</strong></li>
<li>如果给<strong>一般图</strong>做二分图最大匹配，由于双向边的存在，最终答案是<code>ans/2</code></li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-type">void</span> <span class="hljs-title">Hungary</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123; <span class="hljs-comment">//邻接矩阵版</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<span class="hljs-comment">//遍历另一个点集找匹配</span><br>        <span class="hljs-keyword">if</span>(!used[i]&amp;&amp;gg[x][i])&#123;<span class="hljs-comment">//如果没被安排过且有连边</span><br>            used[i]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(!have[i]||<span class="hljs-built_in">Hungary</span>(have[i]))&#123;<br>            <span class="hljs-comment">//如果本身没匹配or能找到另一个匹配</span><br>                have[i]=x;<span class="hljs-comment">//标记每个点的匹配点编号</span><br>                have[x]=i;<span class="hljs-comment">//如果是一般的无向图，这行就不要写了</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//如果能匹配到，返回true</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果没匹配到，返回false</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Hungary</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<span class="hljs-comment">//邻接表版</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>        <span class="hljs-type">int</span> v=e[i].v;<br>        <span class="hljs-keyword">if</span>(!used[v])&#123;<br>            uesd[v]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(!have[v]||<span class="hljs-built_in">Hungary</span>(have[v]))&#123;<br>                have[v]=u;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//遍历一个点集</span><br>        <span class="hljs-built_in">memset</span>(used,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(used));<span class="hljs-comment">//每次都要置零</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Hungary</span>(i)) ans++;<span class="hljs-comment">//如果匹配到了，匹配数+1</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h4 id="新姿势"><a href="#新姿势" class="headerlink" title="新姿势"></a>新姿势</h4><p>如果你用上面的板子去搞这道题 <a href="https://www.luogu.com.cn/problem/P1640">洛谷 P1640 [SCOI2010]连续攻击游戏</a>，你就会被无情地扣掉50分（TLE），原因：<strong>memset复杂度为O(n)，太慢了！！！</strong></p>
<p>因此，这里需要优化，我们考虑使用<strong>时间戳</strong>进行优化：</p>
<p>设置一个时间戳<code>id</code>，每次匹配时<code>id++</code>，在判断是否访问过时，改为<code>used[v]!=id</code>，下方也对应改为<code>used[v]=id</code>，然后就完工啦~</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">...<br>    <span class="hljs-keyword">if</span>(used[v]!=id)&#123;<br>        used[v]=id;<br>        ...<br>    &#125;<br>...<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    id++;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Hungary</span>(i)) ans++;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="两个重要结论"><a href="#两个重要结论" class="headerlink" title="两个重要结论"></a>两个重要结论</h3><p><a href="https://vjudge.net/problem/HihoCoder-1127">【模板题】二分图最小点覆盖+最大独立集</a></p>
<ol>
<li><strong>二分图最小点覆盖</strong></li>
</ol>
<p><img src="https://i.loli.net/2020/03/29/x8zrCILmJ4lfvwk.png" alt="image.png"></p>
<ol>
<li><strong>二分图最大独立集</strong></li>
</ol>
<p><img src="https://i.loli.net/2020/03/29/kGsKi62Behf1pol.png" alt="image.png"></p>
<ol>
<li><strong>DAG图的最小路径覆盖数</strong></li>
</ol>
<p>DAG图的最小路径覆盖：用尽量少的不相交简单路径覆盖DAG的所有顶点</p>
<p><strong>引理：DAG图的最小路径覆盖数=节点数(n)-最大匹配数(m)</strong></p>
<h2 id="二分图最大权匹配"><a href="#二分图最大权匹配" class="headerlink" title="二分图最大权匹配"></a><center>二分图最大权匹配</center></h2><p>参考bolg：</p>
<ul>
<li><a href="https://blog.csdn.net/chenshibo17/article/details/79933191">KM算法详解+模板</a></li>
<li><a href="https://blog.csdn.net/c20180630/article/details/71080521">KM算法</a></li>
</ul>
<h3 id="KM算法"><a href="#KM算法" class="headerlink" title="KM算法"></a>KM算法</h3><p>KM算法的正确性基于以下定理：<br>        <strong>若由二分图中所有满足A[i]+B[j]=w[i,j]的边(i,j)构成的子图（称做相等子图）有完备匹配，那么这个完备匹配就是二分图的最大权匹配</strong></p>
<p>它是一个不断扩大<strong>相等子图</strong>的算法，只不过会将一侧点（通常为左侧）设立一个<strong>点标</strong>（权值为连出边的最大权值），在匹配的过程中如果无法增加匹配边了，就会尝试修改点标（左侧点减去，右侧点加上）来扩大相等子图，最后得到的一个完备匹配就是最佳匹配</p>
<p>时间复杂度：邻接矩阵$O(n^3)$</p>
<h4 id="代码（板子）"><a href="#代码（板子）" class="headerlink" title="代码（板子）"></a>代码（板子）</h4><p><a href="http://uoj.ac/problem/80">【模板题】UOJ 二分图最大权匹配</a></p>
<p>上面是板子题，这里摘抄了一个UOJ里面的BFS板子（据说DFS会TLE）</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mxn=<span class="hljs-number">411</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(ch&lt;<span class="hljs-string">&#x27;0&#x27;</span> || ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<br>    <span class="hljs-keyword">while</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">&#x27;0&#x27;</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<br>    <span class="hljs-keyword">return</span> x*f;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(LL x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>)<span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">mini</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<span class="hljs-keyword">return</span> a&lt;b?a:b;&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">maxi</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<span class="hljs-keyword">return</span> a&gt;b?a:b;&#125;<br><span class="hljs-type">int</span> nL,nR,bl,br,m;<br><span class="hljs-type">int</span> visL[mxn],visR[mxn];<br><span class="hljs-type">int</span> exL[mxn],exR[mxn];<br><span class="hljs-type">int</span> link[mxn],pre[mxn],lx[mxn];<br><span class="hljs-type">int</span> slack[mxn];<br><span class="hljs-type">int</span> mp[mxn][mxn];<br><span class="hljs-comment">//</span><br>LL ans=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> a[mxn];<br><span class="hljs-type">int</span> dtime=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> q[mxn&lt;&lt;<span class="hljs-number">1</span>],hd,tl;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Aug</span><span class="hljs-params">(<span class="hljs-type">int</span> rt)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!rt)<span class="hljs-keyword">return</span>;<br>    link[rt]=pre[rt];<br>    <span class="hljs-built_in">Aug</span>(lx[pre[rt]]);<br>    lx[pre[rt]]=rt;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-type">int</span> S)</span></span>&#123;<br>    <span class="hljs-type">int</span> i,j,tmp;++dtime;<br>    <span class="hljs-built_in">memset</span>(slack,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> slack);<br>    hd=tl=<span class="hljs-number">1</span>;q[tl]=S;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">while</span>(hd&lt;=tl)&#123;<br>            <span class="hljs-type">int</span> u=q[hd];++hd;<br>            visL[u]=dtime;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=nR;i++)&#123;<br>                <span class="hljs-keyword">if</span>(visR[i]^dtime)&#123;<br>                    tmp=exL[u]+exR[i]-mp[u][i];<br>                    <span class="hljs-keyword">if</span>(!tmp)&#123;<br>                        visR[i]=dtime;pre[i]=u;<br>                        <span class="hljs-keyword">if</span>(!link[i])&#123;<br>                            <span class="hljs-built_in">Aug</span>(i);<br>                            <span class="hljs-keyword">return</span>;<br>                        &#125;<br>                        q[++tl]=link[i];<br>                        <span class="hljs-comment">//</span><br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tmp&lt;slack[i])slack[i]=tmp,pre[i]=u;<br>                &#125;<br>            &#125;<br>        &#125;<br>        tmp=INF;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=nR;i++)<span class="hljs-keyword">if</span>(visR[i]^dtime)tmp=<span class="hljs-built_in">mini</span>(tmp,slack[i]);<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=nL;i++)&#123;<br>            <span class="hljs-keyword">if</span>(visL[i]==dtime)exL[i]-=tmp;<br>            <span class="hljs-keyword">if</span>(visR[i]==dtime)exR[i]+=tmp;<br>            <span class="hljs-keyword">else</span> slack[i]-=tmp;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=nR;i++)&#123;<br>            <span class="hljs-keyword">if</span>(visR[i]^dtime &amp;&amp; !slack[i])&#123;<br>                visR[i]=dtime;<br>                <span class="hljs-keyword">if</span>(!link[i])&#123;<br><span class="hljs-comment">//                    link[i]=pre[i];</span><br>                    <span class="hljs-built_in">Aug</span>(i);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                q[++tl]=link[i];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">KM</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=nL;i++)&#123;<br>        exL[i]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=nR;j++)<br>            exL[i]=<span class="hljs-built_in">max</span>(exL[i],mp[i][j]); <span class="hljs-comment">//点标</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=nL;i++) <span class="hljs-built_in">BFS</span>(i); <span class="hljs-comment">//给每个左边点匹配</span><br>    ans=<span class="hljs-number">0</span>;<br>    nL=bl;nR=br;<br>    <span class="hljs-comment">//下面是输出答案</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=nR;i++)&#123;<br>        <span class="hljs-keyword">if</span>(mp[link[i]][i])&#123;<br>            a[link[i]]=i;<br>            ans+=mp[link[i]][i]; <span class="hljs-comment">//找到左边点匹配的右边点</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=nL;i++)&#123;<br>        <span class="hljs-built_in">write</span>(a[i]);<br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> i,j;<br>    nL=<span class="hljs-built_in">read</span>();<br>    nR=<span class="hljs-built_in">read</span>();<br>    bl=nL;br=nR;<br>    nL=<span class="hljs-built_in">max</span>(nL,nR);<br>    nR=nL;<br>    m=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-type">int</span> u,v,w;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        u=<span class="hljs-built_in">read</span>();v=<span class="hljs-built_in">read</span>();w=<span class="hljs-built_in">read</span>();<br>        mp[u][v]=w;<br>    &#125;<br>    <span class="hljs-built_in">KM</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id=""><a href="#" class="headerlink" title=""></a><a href=""></a></h3>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>二维前缀和</title>
    <url>/2020/03/15/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<h2 id="前缀和-amp-差分"><a href="#前缀和-amp-差分" class="headerlink" title="前缀和&amp;差分"></a>前缀和&amp;差分</h2><p>很简单的前置姿势，用于处理区间中的数全部加或减某个数，以及询问区间和</p>
<p>前缀和利用$O(n)$预处理，然后通过差分$O(1)$得出区间和</p>
<ul>
<li><code>[l,r]</code>区间全部<code>+q</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">a[l]+=q, a[r+<span class="hljs-number">1</span>]-=q;<br>...<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    sum[i]=sum[i<span class="hljs-number">-1</span>]+a[i];<br>    <span class="hljs-comment">//省空间直接用a：a[i]+=a[i-1];</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>求<code>[l,r]</code>区间和</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">ans=sum[r]-sum[l<span class="hljs-number">-1</span>];<br><span class="hljs-comment">//a[r]-a[l-1]</span><br></code></pre></div></td></tr></table></figure>
<h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h2><p>Q：给定一个<code>n*m</code>大小的矩阵<code>A</code>，有若干次操作和询问，操作是以<code>(x1,y1)</code>为左上角坐标和<code>(x2,y2)</code>为右下角坐标的子矩阵的所有元素加上或减去<code>q</code>，并询问该二维区间的所有元素和</p>
<p>对于这样一个问题，可以使用二维前缀和，它主要应用了<strong>容斥原理</strong>，直接看代码吧</p>
<ul>
<li>预处理（4步操作）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">a[x1][y1]+=q;<br>a[x2][y2]+=q;<br>a[x1][y2+<span class="hljs-number">1</span>]-=q;<br>a[x2+<span class="hljs-number">1</span>][y1]-=q;<br>...<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>        a[i][j]+=a[i<span class="hljs-number">-1</span>][j]+a[i][j<span class="hljs-number">-1</span>]-a[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>求区间和（容斥原理）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">ans=a[i][j]-a[i<span class="hljs-number">-1</span>][j]-a[i][j<span class="hljs-number">-1</span>]+a[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br></code></pre></div></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title>代码tips</title>
    <url>/2020/03/02/%E4%BB%A3%E7%A0%81tips/</url>
    <content><![CDATA[<span id="more"></span>
<ul>
<li><p>手写gcd或自带__gcd算的是真实最大公约数，如果有负数存在，则最大公约数<strong>可能为负数！！！</strong></p>
</li>
<li><p>恒等式：a+b=a^b+2*(a&amp;b)</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>使用keras的LSTM模型预测时间序列的简单步骤</title>
    <url>/2020/02/17/%E4%BD%BF%E7%94%A8keras%E7%9A%84LSTM%E9%A2%84%E6%B5%8B%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E7%9A%84%E7%AE%80%E5%8D%95%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<h2 id="LSTM简单代码案例"><a href="#LSTM简单代码案例" class="headerlink" title="LSTM简单代码案例"></a><center>LSTM简单代码案例</center></h2><span id="more"></span>
<h2 id="Record-使用keras的LSTM模型预测时间序列的操作步骤（模板）"><a href="#Record-使用keras的LSTM模型预测时间序列的操作步骤（模板）" class="headerlink" title="[Record] 使用keras的LSTM模型预测时间序列的操作步骤（模板）"></a><strong>[Record]</strong> 使用keras的LSTM模型预测时间序列的操作步骤（模板）</h2><ul>
<li><p>导入库</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd <br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <br><span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword">import</span> Sequential<br><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Dense,LSTM,Dropout<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> keras<br>%matplotlib inline<br><span class="hljs-keyword">import</span> glob, os<br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> MinMaxScaler <span class="hljs-comment"># 归一化</span><br><span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> mpl<br>mpl.rcParams[<span class="hljs-string">&#x27;figure.figsize&#x27;</span>]=<span class="hljs-number">12</span>,<span class="hljs-number">8</span><br></code></pre></div></td></tr></table></figure>
</li>
<li><p>导入数据并查看</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">colomns=[<span class="hljs-string">&#x27;awefew&#x27;</span>,<span class="hljs-string">&#x27;wefwfd&#x27;</span>,...]<br>data = pd.read_csv(file_path, numes=columns) <span class="hljs-comment">#更改列名</span><br>data.head()<br></code></pre></div></td></tr></table></figure>
</li>
<li><p>简单可视化数据，便于察觉特征</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">plt.figure(figsize=(<span class="hljs-number">24</span>,<span class="hljs-number">24</span>))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(xxx):<br>    plt.subplot(xxx,<span class="hljs-number">1</span>,i+<span class="hljs-number">1</span>)<br>    plt.plot(data.values[:,i]);<br>    plt.title(....)<br>plt.show()<br></code></pre></div></td></tr></table></figure>
</li>
<li><p>找到需要预测的数据和可使用的特征，并将时间序列数据转化为监督学习问题数据</p>
<p>定义如下函数即可：</p>
<p>原理：sequence to sequence</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">series_to_supervised</span>(<span class="hljs-params">data, n_in=<span class="hljs-number">1</span>, n_out=<span class="hljs-number">1</span>, dropna=<span class="hljs-literal">True</span></span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    	data: origin data</span><br><span class="hljs-string">    	n_in: </span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    n_vars = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(data) <span class="hljs-keyword">is</span> <span class="hljs-built_in">list</span> <span class="hljs-keyword">else</span> data.shape[<span class="hljs-number">1</span>]<br>    df = pd.DataFrame(data)<br>    cols, names = <span class="hljs-built_in">list</span>(),<span class="hljs-built_in">list</span>()<br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n_in,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>):<br>        cols.append(df.shift(i))<br>        names+=[(<span class="hljs-string">&#x27;var%d(t-%d)&#x27;</span>%(j+<span class="hljs-number">1</span>, i)) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n_vars)]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, n_out):<br>        cols.append(df.shift(-i))<br>        <span class="hljs-keyword">if</span> i==<span class="hljs-number">0</span>:<br>            names += [(<span class="hljs-string">&#x27;var%d(t)&#x27;</span>%(j+<span class="hljs-number">1</span>)) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n_vars)]<br>        <span class="hljs-keyword">else</span>:<br>            names += [(<span class="hljs-string">&#x27;var%d(t+%d)&#x27;</span>%(j+<span class="hljs-number">1</span>, i)) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n_vars)]<br>    agg = pd.concat(cols, axis=<span class="hljs-number">1</span>)<br>    agg.columns = names<br>    <span class="hljs-keyword">if</span> dropna: <span class="hljs-comment"># 是否去除缺失值的行</span><br>        agg.dropna(inplace=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">return</span> agg<br></code></pre></div></td></tr></table></figure>
</li>
<li><p>归一化数据到 [0,1] 之间</p>
<p>比如可以采用sklearn中的MinMaxScaler函数，公式为</p>
<script type="math/tex; mode=display">
s_i=\frac{x_i-min}{max-min}</script><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">scaler = MinMaxScaler(feature_range=(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>))<br>scaled_data = scaler.fit_transform(data[[<span class="hljs-string">&#x27;afe&#x27;</span>,<span class="hljs-string">&#x27;wef&#x27;</span>,...]].values)<br><br><span class="hljs-comment"># 转化为监督学习问题</span><br>reframed = series_to_supervised(scaled_data,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 处理需要预测的数据，把不需要预测的数据去除</span><br>reframed.drop(reframed.columns[[..,..,...]], axis=<span class="hljs-number">1</span>,inplace=<span class="hljs-literal">True</span>)<br><br>reframed.info()<br>reframed.head()<br></code></pre></div></td></tr></table></figure>
</li>
<li><p>设置训练集、验证集、测试集大小，并开始分割</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">train_days = xxx<br>valid_days = xxx<br>values = reframed.values<br><br>train = values[:train_days, :]<br>valid = values[train_days:train_days+valid_days,:]<br>test = values[train_days+valid_days:, :]<br><span class="hljs-comment">#比如：最后一列是y，前面所有列都是x</span><br>train_x, train_y = train[:, :-<span class="hljs-number">1</span>], train[:,-<span class="hljs-number">1</span>]<br>valid_x, valid_y = valid[:, :-<span class="hljs-number">1</span>], valid[:,-<span class="hljs-number">1</span>]<br>test_x, test_y = test[:, :-<span class="hljs-number">1</span>], test[:-<span class="hljs-number">1</span>]<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>将数据重构为符合keras内LSTM模型要求的数据格式</p>
<p>即<strong>[样本数，时间步，特征数]</strong></p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 以 时间步==1 为例</span><br>train_x = train_x.reshape((train_x.shape[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, train_x.shape[<span class="hljs-number">1</span>]))<br>valid_x = valid_x.reshape((valid_x.shape[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, valid_x.shape[<span class="hljs-number">1</span>]))<br>test_x = test_x.shape((test_x.shape[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, test_x.shape[<span class="hljs-number">1</span>]))<br><br><span class="hljs-built_in">print</span>(train_x.shape,<br>     trian_y.shape,<br>     valid_x.shape,<br>     valid_y.shape,<br>     test_x.shape,<br>     test_y.shape)<br></code></pre></div></td></tr></table></figure>
</li>
<li><p>建立模型</p>
<p><strong>注意keras.layers.LSTM中input_shape的输入格式为（时间步，特征数）</strong></p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 搭一个LSTM网络，这里用最简单的三层结构</span><br>model = Sequential([<br>    keras.layers.LSTM(<span class="hljs-number">50</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>, input_shape=(train_x.shape[<span class="hljs-number">1</span>],train_x.shape[<span class="hljs-number">2</span>]))<br>    keras.layers.Dense(<span class="hljs-number">1</span>, activarion=<span class="hljs-string">&#x27;linear&#x27;</span>)<br>])<br><br><span class="hljs-comment"># 配置一下</span><br>model.<span class="hljs-built_in">compile</span>(opirmizer=<span class="hljs-string">&#x27;adam&#x27;</span>, <span class="hljs-comment"># 这里采用adam优化算法</span><br>             loss=<span class="hljs-string">&#x27;mean_squared_error&#x27;</span>) <span class="hljs-comment"># 优化的损失函数为mse</span><br><br><span class="hljs-comment"># 看一下结构</span><br>model.summary()<br></code></pre></div></td></tr></table></figure>
</li>
<li><p>训练模型</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">model_history = model.fit(train_x, train_y,<br>                         epochs=<span class="hljs-number">100</span>,<br>                         batch_size=<span class="hljs-number">32</span>,<br>                         validation_data=(valid_x, valid_y),<br>                         verbose=<span class="hljs-number">1</span>,<br>                         shuffle=<span class="hljs-literal">False</span>)<br></code></pre></div></td></tr></table></figure>
</li>
<li><p>根据需要，绘出loss对照图，观察收敛情况</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">6</span>))<br>plt.plot(model_history.epoch, model_history.history[<span class="hljs-string">&#x27;loss&#x27;</span>])<br>plt.plot(model_history.epoch, model_history.history[<span class="hljs-string">&#x27;val_loss&#x27;</span>])<br>plt.legend()<br>plt.show()<br></code></pre></div></td></tr></table></figure>
</li>
<li><p>模型预测&amp;评估&amp;可视化</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 模型预测</span><br>train_predict = model.predict(train_x)<br>valid_predict = model.predict(valid_x)<br>test_predict = model.predict(test_x)<br><br><span class="hljs-comment"># 模型评估</span><br>evaluation = model.evaluate(test_x, test_y)<br><br><span class="hljs-comment"># 把原始数据、训练、验证、测试 都画在一张图上 便于比较分析</span><br>plt.figure(figsize=(<span class="hljs-number">24</span>,<span class="hljs-number">8</span>))<br>plt.plot(values[:,-<span class="hljs-number">1</span>], c=<span class="hljs-string">&#x27;b&#x27;</span>, label=<span class="hljs-string">&#x27;Whole Data&#x27;</span>)<br>plt.plot([x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> train_predict], c=<span class="hljs-string">&#x27;g&#x27;</span>, label=<span class="hljs-string">&#x27;Train Predict&#x27;</span>)<br>plt.plot([<span class="hljs-literal">None</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> train_predict]+[x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> valid_predict], label=<span class="hljs-string">&#x27;Valid Predict&#x27;</span>)<br>plt.plot([<span class="hljs-literal">None</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> train_predict]+[<span class="hljs-literal">None</span> <span class="hljs-keyword">for</span> _ <span class="hljs-built_in">int</span> valid_predict]+[x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> test_predict], label=<span class="hljs-string">&#x27;Test Predict&#x27;</span>)<br>plt.legend(fontsize=<span class="hljs-number">15</span>)<br>plt.show()<br></code></pre></div></td></tr></table></figure>
</li>
<li><p>将预测结果<strong>反归一化</strong>并绘图比较分析</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">origin_data = np.array(data[train_days+valid_days:][<span class="hljs-string">&#x27;DATA_COL&#x27;</span>])<br><span class="hljs-comment"># 由于预测数据是1维的，但之前的scaler是5维的，所以我们用零填充剩余维度</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>    test_predict = np.column_stack((test_predict, np.zeros(<span class="hljs-number">27</span>)))<br><span class="hljs-comment"># 反归一化</span><br>inverse_test_predict = scalar.inverse_transform(test_predict)<br><span class="hljs-comment"># 绘图</span><br>plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">6</span>))<br>plt.plot(inverse_test_predict[:,<span class="hljs-number">0</span>], c=<span class="hljs-string">&#x27;r&#x27;</span>, label=<span class="hljs-string">&#x27;predict&#x27;</span>)<br>plt.plot(origin_data, c=<span class="hljs-string">&#x27;g&#x27;</span>, label=<span class="hljs-string">&#x27;origin&#x27;</span>)<br>plt.legend()<br>plt.show()<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>关于矩阵的算法</title>
    <url>/2020/07/31/%E5%85%B3%E4%BA%8E%E7%9F%A9%E9%98%B5%E7%9A%84%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>渣渣本渣得知自己研究生研究方向为计算成像，而且自己可能会主要负责编程及算法实现这块的内容，于是将重心移至矩阵这块（因为老板说这块以后要用到很多），那这次先系统学习一下关于矩阵的基础常用算法<br><span id="more"></span></p>
<h2 id="高斯消元-amp-高斯-约旦消元"><a href="#高斯消元-amp-高斯-约旦消元" class="headerlink" title="高斯消元 &amp; 高斯-约旦消元"></a>高斯消元 &amp; 高斯-约旦消元</h2><h3 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h3><p>对于一个线性方程组，我们可以把它写成增广矩阵的形式（就是把等号右侧的列向量拼到系数矩阵右侧）</p>
<script type="math/tex; mode=display">
Ax=b \Rightarrow (A\ b)</script><p>然后对增广矩阵不断进行初等行变换（只能进行一种变换），将其化为<strong>上三角矩阵</strong>，最后可以得到，矩阵最后一行最后一个元素的值就是对应的最后一个未知数的解，把这个解代入倒数第二行，得到倒数第二个未知数的解，以此类推，可以得到方程的所有解</p>
<p>时间复杂度：$O(n^3)$</p>
<p>举个栗子：</p>
<figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">x</span> - <span class="hljs-number">2</span>y + <span class="hljs-number">3</span>z = <span class="hljs-number">6</span><br><span class="hljs-attribute">4x</span> - <span class="hljs-number">5</span>y + <span class="hljs-number">6</span>z = <span class="hljs-number">12</span><br><span class="hljs-attribute">7x</span> - <span class="hljs-number">8</span>y + <span class="hljs-number">10</span>z = <span class="hljs-number">21</span><br></code></pre></div></td></tr></table></figure>
<p>写成增广矩阵为：</p>
<figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>-<span class="hljs-number">2</span> <span class="hljs-number">3</span>  | <span class="hljs-number">6</span><br><span class="hljs-symbol">4 </span>-<span class="hljs-number">5</span> <span class="hljs-number">6</span>  | <span class="hljs-number">12</span><br><span class="hljs-symbol">7 </span>-<span class="hljs-number">8</span> <span class="hljs-number">10</span> | <span class="hljs-number">21</span><br></code></pre></div></td></tr></table></figure>
<p>首先把他化为上三角矩阵，用第一行消掉之后所有行的第一个元素</p>
<p>PS：往往是将一列中最大的一个元素所对应的行作为消去使用的行（因为这样会减少误差，一些意会的证明见：<a href="https://www.luogu.com.cn/problem/solution/P3389">P3389 【模板】高斯消元 题解</a>）所以这里把第三行和第一行交换，然后用第一行消，为了写程序方便，先将首元素化为1</p>
<figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>-<span class="hljs-number">8</span>/<span class="hljs-number">7</span> <span class="hljs-number">10</span>/<span class="hljs-number">7</span> | <span class="hljs-number">3</span><br><span class="hljs-symbol">0 </span>-<span class="hljs-number">3</span>/<span class="hljs-number">7</span> -<span class="hljs-number">2</span>/<span class="hljs-number">7</span> | <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span>-<span class="hljs-number">6</span>/<span class="hljs-number">7</span> <span class="hljs-number">11</span>/<span class="hljs-number">7</span> | <span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure>
<p>以此类推，可以得到一个上三角阵：</p>
<figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>-<span class="hljs-number">8</span>/<span class="hljs-number">7</span> <span class="hljs-number">10</span>/<span class="hljs-number">7</span> | <span class="hljs-number">3</span><br><span class="hljs-symbol">0 </span>  <span class="hljs-number">1</span>  -<span class="hljs-number">2</span>/<span class="hljs-number">3</span> | <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span>  <span class="hljs-number">0</span>    <span class="hljs-number">1</span>  | <span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure>
<p>得出$x_3=3$，然后将其回代入第二个式子得到$x_2$，再回代入第一个式子得到$x_1$</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><a href="https://www.luogu.com.cn/problem/P3389">P3389 【模板】高斯消元法</a></p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">105</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps=<span class="hljs-number">1e-6</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">double</span> a[maxn][maxn],ans[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Gauss</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-type">int</span> tp=i;<span class="hljs-comment">// 记当前元素为最大</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<span class="hljs-comment">// 选出当前列最大元素对应的行</span><br>			<span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(a[j][i])&gt;<span class="hljs-built_in">fabs</span>(a[tp][i]))<br>				tp=j;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(a[tp][i])&lt;eps)&#123;<span class="hljs-comment">// 如果最大元素都是0，则无解</span><br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No Solution\n&quot;</span>);<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(tp!=i) <span class="hljs-built_in">swap</span>(a[tp],a[i]);<span class="hljs-comment">// 将该行与当前行交换</span><br>		<span class="hljs-type">double</span> div=a[i][i];<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;=n+<span class="hljs-number">1</span>;j++)<br>			a[i][j]/=div;<span class="hljs-comment">// 单位化首元素，对应行内元素也要同样处理</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<span class="hljs-comment">// 从下一行开始消元素</span><br>			div=a[j][i];<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i;k&lt;=n+<span class="hljs-number">1</span>;k++)&#123;<br>				a[j][k]-=a[i][k]*div;<br>			&#125;<br>		&#125;<br>	&#125;<br>	ans[n]=a[n][n+<span class="hljs-number">1</span>];<span class="hljs-comment">// 右下角元素为最后一个未知数的解</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<span class="hljs-comment">// 从导数第二行开始回代操作</span><br>		ans[i]=a[i][n+<span class="hljs-number">1</span>];<span class="hljs-comment">// 记录答案</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<span class="hljs-comment">// 从改行元素往后，每一个都要被消掉，对应解都要减去一个值</span><br>			ans[i]-=ans[j]*a[i][j];<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">// 输出答案</span><br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf\n&quot;</span>,ans[i]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n+<span class="hljs-number">1</span>;j++)<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,&amp;a[i][j]);<br>	<span class="hljs-built_in">Gauss</span>();<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="高斯-约旦消元"><a href="#高斯-约旦消元" class="headerlink" title="高斯-约旦消元"></a>高斯-约旦消元</h3><p>操作步骤和<strong>高斯消元</strong>相同，只不过最后将增广阵消为对角阵，从而去除了繁复的回代操作，经过证明，该方法精度最高，代码也相对较短</p>
<p>时间复杂度：$O(n^3)$</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Gauss_Jordan</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-type">int</span> tp=i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(a[j][i])&gt;<span class="hljs-built_in">fabs</span>(a[tp][i]))<br>                tp=j;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(a[tp][i]&lt;eps)&#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No Solution\n&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(tp!=i) <span class="hljs-built_in">swap</span>(a[tp],a[i]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<span class="hljs-comment">// 注意从第一行开始</span><br>            <span class="hljs-keyword">if</span>(j!=i)&#123;<span class="hljs-comment">// 且跳过当前用来消的行</span><br>                <span class="hljs-type">double</span> div=a[j][i]/a[i][i];<span class="hljs-comment">// 记住要消的倍数</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i;k&lt;=n+<span class="hljs-number">1</span>;k++)&#123;<br>                    a[j][k]-=a[i][k]*div;<span class="hljs-comment">//每行对应元素减去这个倍数的值</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf\n&quot;</span>,a[i][n+<span class="hljs-number">1</span>]/a[i][i]);<span class="hljs-comment">//最后答案要再除以一个系数</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="矩阵求逆"><a href="#矩阵求逆" class="headerlink" title="矩阵求逆"></a>矩阵求逆</h3><p>学过线代的我们都知道，一个矩阵的逆矩阵的求法（前提是该矩阵可逆，可以通过行列式值不为零或满秩等判断），最常用的就是在它右边拼一个同大小单位阵，然后通过初等行变换把左侧矩阵化为单位阵，则此时右侧矩阵即原矩阵的逆矩阵（证明略）</p>
<p>对于这样一个情况，我们很容易发现这就是一个<strong>高斯-约旦消元</strong>的过程，只不过右侧不是一个列向量，而是一个同阶矩阵，那么如法炮制，很容易得到解法</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><p><a href="https://www.luogu.com.cn/problem/P4783">P4783 【模板】矩阵求逆</a></p>
<p>这个题需要注意的是有个模数，因此不需要用<code>double</code>存矩阵元素，除法用扩欧或费马小定理算下逆元就行了，注意出现负数，我在一开始就把他全部转正了</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> n;<br>ll a[<span class="hljs-number">405</span>][<span class="hljs-number">805</span>];<br><br><span class="hljs-function">ll <span class="hljs-title">exgcd</span><span class="hljs-params">(ll &amp;x,ll &amp;y,ll a,ll b)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)&#123;<br>		x=<span class="hljs-number">1</span>,y=<span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> a;<br>	&#125;<br>	ll res=<span class="hljs-built_in">exgcd</span>(x,y,b,a%b);<br>	ll tx=x;<br>	x=y;<br>	y=tx-a/b*y;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Gauss_Jordan</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-type">int</span> tp=i;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>			<span class="hljs-keyword">if</span>(a[j][i]&gt;a[tp][i])<br>				tp=j;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(a[tp][i]==<span class="hljs-number">0</span>)&#123;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No Solution\n&quot;</span>);<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(tp!=i) <span class="hljs-built_in">swap</span>(a[tp],a[i]);<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>			<span class="hljs-keyword">if</span>(j!=i)&#123;<br>				ll x,y;<br>				<span class="hljs-built_in">exgcd</span>(x,y,a[i][i],mod);<br>				x=(x+mod)%mod;<br>				ll div=a[j][i]*x%mod;<br>				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i;k&lt;=n+n;k++)&#123;<span class="hljs-comment">// 这里要到2n</span><br>					a[j][k]-=a[i][k]*div%mod;<br>					a[j][k]=(a[j][k]+mod)%mod;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		ll x,y;<br>		<span class="hljs-built_in">exgcd</span>(x,y,a[i][i],mod);<br>		x=(x+mod)%mod;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,a[i][j+n]*x%mod);<br>		&#125;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i][j]),<br>			a[i][j]=(a[i][j]+mod)%mod;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) a[i][i+n]=<span class="hljs-number">1</span>;<span class="hljs-comment">// 拼一个单位阵</span><br>	<span class="hljs-built_in">Gauss_Jordan</span>();<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h2 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h2><p>参考blog：</p>
<ul>
<li><a href="https://blog.csdn.net/a_forever_dream/article/details/83654397">CSDN 线性基详解</a></li>
</ul>
<p>这是一个比较偏<strong>程序设计竞赛</strong>的算法（应该叫数据结构），可以用来存储一组集合的一种<strong>基</strong>，类似于线代里面的线性无关组，线性基内的元素通过<strong>异或</strong>操作能不多不少恰好表示出整个集合的所有元素</p>
<h3 id="构造方式"><a href="#构造方式" class="headerlink" title="构造方式"></a>构造方式</h3><p><strong>通过不断插入集合元素来完成构造</strong></p>
<p>从集合内元素最高位开始，往低位数，如果插入的数字$x$当前位为1，则判断是否该位的线性基已存在，若存在，则让$x$异或该基，看下一位，重复上述操作；否则令该位线性基为$x$，结束</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(ll x)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">60</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">if</span>((<span class="hljs-number">1ll</span>&lt;&lt;i)&amp;x)&#123;<br>            <span class="hljs-keyword">if</span>(p[i]) x^=p[i];<br>            <span class="hljs-keyword">else</span>&#123;<br>                p[i]=x;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>经过构造过程，我们可以得到一组集合的线性基，该线性基集合中存储了从高位到低位每一位为1的所有信息，并且这些信息都是通过原集合中若干元素异或得到的，因此，可以通过线性基表示出原集合的所有元素（具体证明见上方blog）</p>
<h3 id="给定集合取出任意个求最大异或和"><a href="#给定集合取出任意个求最大异或和" class="headerlink" title="给定集合取出任意个求最大异或和"></a>给定集合取出任意个求最大异或和</h3><p><a href="https://www.luogu.com.cn/problem/P3812">P3812 【模板】线性基</a></p>
<p>构造好线性基后，只需要通过从高位到低位的贪心过程就可以AC此题，具体贪心流程为：</p>
<p>初始解为<code>ans=0</code>，从最高位开始遍历，如果<code>(p[i]^ans)&gt;ans</code>则让<code>ans^=p[i]</code>，最后得到的<code>ans</code>就是答案</p>
<p>证明：显然可以发现，不断使得当前最高位变大的过程是最优的，因此只需要不断取能使答案变大的就行了</p>
<p>PS：<code>^</code>运算符优先级低于<code>&gt;</code>，因此要加括号</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">int</span> n;<br>ll p[<span class="hljs-number">65</span>];<br>ll x;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">ins</span><span class="hljs-params">(ll x)</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">50</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>		<span class="hljs-keyword">if</span>((<span class="hljs-number">1ll</span>&lt;&lt;i)&amp;x)&#123;<br>			<span class="hljs-keyword">if</span>(p[i]) x^=p[i];<br>			<span class="hljs-keyword">else</span>&#123;<br>				p[i]=x;<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;x),<span class="hljs-built_in">ins</span>(x);<br>	ll ans=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">50</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>		<span class="hljs-keyword">if</span>((ans^p[i])&gt;ans) ans^=p[i];<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>冠状病毒(coronavirus)介绍</title>
    <url>/2020/02/01/%E5%86%A0%E7%8A%B6%E7%97%85%E6%AF%92/</url>
    <content><![CDATA[<h2 id="油管搬运-李永乐老师-“冠状病毒”是什么？"><a href="#油管搬运-李永乐老师-“冠状病毒”是什么？" class="headerlink" title="[油管搬运]李永乐老师 “冠状病毒”是什么？"></a><center>[油管搬运]李永乐老师 “冠状病毒”是什么？</center></h2><span id="more"></span>
<h2 id=""><a href="#" class="headerlink" title=""></a><iframe width="560" height="315" src="https://www.youtube.com/embed/E46_veB0DPU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></h2>]]></content>
      <categories>
        <category>vedios</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>科普</tag>
      </tags>
  </entry>
  <entry>
    <title>分块专题</title>
    <url>/2020/04/10/%E5%88%86%E5%9D%97%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h2 id="优雅的暴力：分块"><a href="#优雅的暴力：分块" class="headerlink" title="优雅的暴力：分块"></a><center>优雅的暴力：分块</center></h2><span id="more"></span>
<p>参考blog：</p>
<ul>
<li><a href="http://hzwer.com/8053.html">[分块] 数列分块入门1 - 9 by hzwer</a></li>
</ul>
<h3 id="分块1（区间加、单点查询）"><a href="#分块1（区间加、单点查询）" class="headerlink" title="分块1（区间加、单点查询）"></a>分块1（区间加、单点查询）</h3><ul>
<li><a href="https://loj.ac/problem/6277">分块入门1</a></li>
</ul>
<h3 id="分块2（区间加、区间询问大于-小于x的值的个数）"><a href="#分块2（区间加、区间询问大于-小于x的值的个数）" class="headerlink" title="分块2（区间加、区间询问大于/小于x的值的个数）"></a>分块2（区间加、区间询问大于/小于x的值的个数）</h3><ul>
<li><p><a href="https://www.luogu.com.cn/problem/P2801">教主的魔法</a></p>
</li>
<li><p><a href="https://loj.ac/problem/6278">分块入门2</a></p>
</li>
</ul>
<h3 id="分块3（区间加、区间询问前驱）"><a href="#分块3（区间加、区间询问前驱）" class="headerlink" title="分块3（区间加、区间询问前驱）"></a>分块3（区间加、区间询问前驱）</h3><ul>
<li><a href="https://loj.ac/problem/6279">分块入门3</a></li>
</ul>
<h3 id="分块4（区间加、区间求和）"><a href="#分块4（区间加、区间求和）" class="headerlink" title="分块4（区间加、区间求和）"></a>分块4（区间加、区间求和）</h3><ul>
<li><p><a href="https://loj.ac/problem/6280">分块入门4</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problem/P3372">线段树1</a></p>
</li>
</ul>
<h3 id="分块5（区间开根号、区间求和）"><a href="#分块5（区间开根号、区间求和）" class="headerlink" title="分块5（区间开根号、区间求和）"></a>分块5（区间开根号、区间求和）</h3><ul>
<li><a href="https://loj.ac/problem/6281">分块入门5</a></li>
</ul>
<h3 id="分块6（单点插入、单点询问）"><a href="#分块6（单点插入、单点询问）" class="headerlink" title="分块6（单点插入、单点询问）"></a>分块6（单点插入、单点询问）</h3><ul>
<li><a href="https://loj.ac/problem/6282">分块入门6</a>（数据随机，可不重构）</li>
</ul>
<h3 id="分块7（区间乘、区间加、单点询问）"><a href="#分块7（区间乘、区间加、单点询问）" class="headerlink" title="分块7（区间乘、区间加、单点询问）"></a>分块7（区间乘、区间加、单点询问）</h3><ul>
<li><a href="https://loj.ac/problem/6283">分块入门7</a></li>
</ul>
<h3 id="分块8（区间询问等于c的个数、区间元素修改为c）"><a href="#分块8（区间询问等于c的个数、区间元素修改为c）" class="headerlink" title="分块8（区间询问等于c的个数、区间元素修改为c）"></a>分块8（区间询问等于c的个数、区间元素修改为c）</h3><ul>
<li><a href="https://loj.ac/problem/6284">分块入门8</a></li>
</ul>
<h3 id="分块9（询问区间众数）"><a href="#分块9（询问区间众数）" class="headerlink" title="分块9（询问区间众数）"></a>分块9（询问区间众数）</h3><ul>
<li><a href="https://loj.ac/problem/6285">分块入门9</a></li>
</ul>
<p>还没解决。。。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>划分数的问题</title>
    <url>/2020/01/18/%E5%88%92%E5%88%86%E6%95%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="dp入门：划分数"><a href="#dp入门：划分数" class="headerlink" title="dp入门：划分数"></a><center>dp入门：划分数</center></h2><span id="more"></span>
<h2 id="P1025-数的划分"><a href="#P1025-数的划分" class="headerlink" title="P1025 数的划分"></a>P1025 数的划分</h2><p><a href="https://www.luogu.com.cn/problem/P1025">题目链接</a></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>将整数n划分成k份，每一份<strong>不能</strong>为空，任意两个方案不相同（忽略顺序），求分法总数。</p>
<h3 id="思路-amp-解法"><a href="#思路-amp-解法" class="headerlink" title="思路&amp;解法"></a>思路&amp;解法</h3><ul>
<li>十分经典的dp题目，可以这么考虑这道题：现在有k个盘子和n个苹果，要求你把苹果放到盘子里，且任何一个盘子不能为空，问有多少种不同的放法？<br>这么一想就好理解多了，下面开始dp：</li>
</ul>
<ol>
<li><p>定义状态：$dp[i][j]$：把$j$个苹果放入$i$个盘子的不同放法总数；</p>
</li>
<li><p>状态转移：这么想，任何一个时候无非两种状态：</p>
<ol>
<li><p>$i&gt;j$，这个时候一定会出现空盘子，所以直接$dp[i][j]=0$就行了；</p>
</li>
<li><p>$i\leq j$，这个时候又出来两种情况：如果至少有一个盘子里只有一个苹果，那么这个时候的状态数就等于$dp[i-1][j-1]$；如果所有盘子都是有两个或者以上的苹果的时候，我可以<strong>先从每个盘子里取出一个苹果</strong>（共取出$i$个苹果），剩下的状态不就是$dp[i][j-i]$吗？这两种情况加起来，就是这个时候的状态。所以得出如下状态转移方程：</p>
<script type="math/tex; mode=display">
dp[i][j]=\begin{cases}0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (i>j)\\ dp[i-1][j-1]+dp[i][j-i]\ \ \ \ \ \ (else)\end{cases}</script></li>
</ol>
</li>
</ol>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> dp[<span class="hljs-number">10</span>][<span class="hljs-number">205</span>];<br><span class="hljs-type">int</span> n,k;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;n&gt;&gt;k;<br>	dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>			<span class="hljs-keyword">if</span>(i&gt;j)&#123;<br>				dp[i][j] = <span class="hljs-number">0</span>;<br>			&#125;<span class="hljs-keyword">else</span>&#123;<br>				dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + dp[i][j-i];<br>			&#125;<br>		&#125;<br>	&#125;<br>	cout&lt;&lt;dp[k][n]&lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="变式"><a href="#变式" class="headerlink" title="变式"></a>变式</h2><ul>
<li><p>可以看出，这一题的要求是每个划分不能为空，那么如果是可以为空呢？</p>
<p>题目变为：将整数n划分成k份，每一份<strong>可以</strong>为空，任意两个方案不相同（忽略顺序），求分法总数。</p>
</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>其实很像，只是有略微的改动。dp数组还是那么定义，状态转移如下：</p>
<ol>
<li><p>$i&gt;j$，此时不能是0了，因为可以为空，所以状态等于前一个状态，即$dp[i][j]=dp[i-1][j]$；</p>
</li>
<li><p>$i\leq j$，此时，也是两种情况：</p>
<ol>
<li><p>有空盘子，其实就对应于$i&gt;j$的情况，因为就算我苹果多，我也可以都堆在一起放对吧，所以这个状态要考虑在内；</p>
</li>
<li><p>没空盘子，那么跟上一题一样，我可以先从每个盘子里都取走一个苹果，剩下就都和上一题一样了。得出状态转移方程如下：</p>
<script type="math/tex; mode=display">
dp[i][j]=\begin{cases}dp[i-1][j]\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (i>j)\\ dp[i-1][j]+dp[i][j-i]\ \ \ \ \ \ (else)\end{cases}</script></li>
</ol>
</li>
</ol>
<hr>
<p>代码我就不敲了 <del>懒</del></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>初级dp练习</title>
    <url>/2020/04/18/%E5%88%9D%E7%BA%A7dp%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="dp刷题练习"><a href="#dp刷题练习" class="headerlink" title="dp刷题练习"></a><center>dp刷题练习</center></h2><span id="more"></span>
<p>题目来源：洛谷题单 <a href="https://www.luogu.com.cn/training/1060#problems">新手动态规划合集</a></p>
<h4 id="P1832-A-B-Problem（再升级）"><a href="#P1832-A-B-Problem（再升级）" class="headerlink" title="P1832 A+B Problem（再升级）"></a><a href="https://www.luogu.com.cn/problem/P1832">P1832 A+B Problem（再升级）</a></h4><p>给定一个正整数n，求将其分解成若干素数之和的方案总数</p>
<p>solution：先欧拉筛打出素数表，然后跑一遍完全背包即可</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1005</span>; <br><span class="hljs-type">int</span> n,f[maxn],prime[maxn],phi[maxn],cnt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>	phi[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>	f[<span class="hljs-number">0</span>]=f[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">if</span>(f[i]==<span class="hljs-number">0</span>)&#123;<br>			prime[++cnt]=i;<br>			phi[i]=i<span class="hljs-number">-1</span>;<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=n;j++)&#123;<br>			f[i*prime[j]]=<span class="hljs-number">1</span>;<br>			<span class="hljs-keyword">if</span>(i%prime[j]==<span class="hljs-number">0</span>)&#123;<br>				phi[i*prime[j]]=phi[i]*prime[j];<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<span class="hljs-keyword">else</span> phi[i*prime[j]]=phi[i]*phi[prime[j]];<br>		&#125;<br>	&#125;<br>&#125;<br>ll dp[maxn];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-built_in">init</span>(n);<br>    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;i++)&#123;<br>    	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;j++)&#123;<br>    		<span class="hljs-keyword">if</span>(j&gt;=prime[i]) dp[j]+=dp[j-prime[i]];<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,dp[n]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h4 id="P1470-USACO2-3-最长前缀-Longest-Prefix"><a href="#P1470-USACO2-3-最长前缀-Longest-Prefix" class="headerlink" title="P1470 [USACO2.3]最长前缀 Longest Prefix"></a><a href="https://www.luogu.com.cn/problem/P1470">P1470 [USACO2.3]最长前缀 Longest Prefix</a></h4><p>给一个字符串集合，和一个长字符串，问能用集合中的元素拼成长字符串的最长前缀长度是多少</p>
<p>solution：对于集合中的每个字符串，我们可以先跑一遍KMP的到next数组，然后去匹配长字符串，如果可以匹配上，就用一个前缀和数组将对应位置打上标记（+1），最后求一遍前缀和，过程中如果出现等于0的和，说明这一位没有匹配到，那么最长前缀就是这一位之前的所有字符的个数</p>
<p><del>(这是dp嘛。。)</del></p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>string s,t[<span class="hljs-number">205</span>];<br><span class="hljs-type">int</span> kmp[<span class="hljs-number">205</span>],sum[<span class="hljs-number">200005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//	freopen(&quot;P1470_3.in&quot;,&quot;r&quot;,stdin);</span><br>	<span class="hljs-type">int</span> cnt=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;t[cnt])&#123;<br>    	<span class="hljs-keyword">if</span>(t[cnt]==<span class="hljs-string">&quot;.&quot;</span>)&#123;<br>    		cnt--;<br>    		<span class="hljs-keyword">break</span>;<br>		&#125;<br>		t[cnt]=<span class="hljs-string">&quot;0&quot;</span>+t[cnt];<br><span class="hljs-comment">//		cout&lt;&lt;t[cnt]&lt;&lt;endl;</span><br>    	cnt++;<br>	&#125;<br>	string temp;<br>	s+=<span class="hljs-string">&quot;0&quot;</span>;<br>	<span class="hljs-keyword">while</span>(cin&gt;&gt;temp)&#123;<br>		s+=temp;<br>	&#125;<br>	<span class="hljs-type">int</span> len=s.<span class="hljs-built_in">size</span>();<br><span class="hljs-comment">//	cout&lt;&lt;s&lt;&lt;endl;</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=cnt;k++)&#123;<br>		<span class="hljs-built_in">memset</span>(kmp,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(kmp));<br>		<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=t[k].<span class="hljs-built_in">size</span>();i++)&#123;<br>			<span class="hljs-keyword">while</span>(j&amp;&amp;t[k][j+<span class="hljs-number">1</span>]!=t[k][i]) j=kmp[j];<br>			<span class="hljs-keyword">if</span>(t[k][j+<span class="hljs-number">1</span>]==t[k][i]) j++;<br>			kmp[i]=j;<br>		&#125;<br>		j=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;i++)&#123;<br>			<span class="hljs-keyword">while</span>(j&amp;&amp;t[k][j+<span class="hljs-number">1</span>]!=s[i]) j=kmp[j];<br>			<span class="hljs-keyword">if</span>(t[k][j+<span class="hljs-number">1</span>]==s[i]) j++;<br>			<span class="hljs-keyword">if</span>(j==t[k].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)&#123;<br>				sum[i-t[k].<span class="hljs-built_in">size</span>()+<span class="hljs-number">2</span>]++;<br>				sum[i+<span class="hljs-number">1</span>]--;<br><span class="hljs-comment">//				printf(&quot;sumz:%d sumy:%d\n&quot;,i-t[k].size()+2,i+1);</span><br>				j=kmp[j];<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;i++)&#123;<br>		sum[i]+=sum[i<span class="hljs-number">-1</span>];<br>		<span class="hljs-keyword">if</span>(sum[i]&lt;=<span class="hljs-number">0</span>)&#123;<br>			cout&lt;&lt;i<span class="hljs-number">-1</span>&lt;&lt;endl;<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		&#125;<br>	&#125;<br>	cout&lt;&lt;len&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h4 id="P2858-USACO06FEB-Treats-for-the-Cows-G-S"><a href="#P2858-USACO06FEB-Treats-for-the-Cows-G-S" class="headerlink" title="P2858 [USACO06FEB]Treats for the Cows G/S"></a><a href="https://www.luogu.com.cn/problem/P2858">P2858 [USACO06FEB]Treats for the Cows G/S</a></h4><p>给出一段序列代表零食的价值，每天只可以取出头部或者尾部的一个零食，每次卖出的价格为<strong>天数x价值</strong>，求卖出去的最大总价格</p>
<p>solution：区间dp，定义状态如下</p>
<script type="math/tex; mode=display">
dp[i][j]:卖出时，头部零食为i，尾部零食为j时的最大卖出总价格</script><script type="math/tex; mode=display">
转移:dp[i][j]=max(dp[i+1][j]+(n-len+1)*v[i],dp[i][j-1]+(n-len+1)*v[j])</script><p>初始化时，<code>dp[i][i]=n*v[i]</code>，因为如果只剩下物品，那么最后一天卖是最赚的，除此之外，每次更新时，都需要将卖出的新物品置为倒数第len个卖的（len为区间长度），其实如果要方便理解的话，可以倒着枚举长度</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI=<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps=<span class="hljs-number">1e-6</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">2147483647</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">10000</span>;<br><span class="hljs-type">int</span> n,a[<span class="hljs-number">2005</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">2005</span>][<span class="hljs-number">2005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) dp[i][i]=a[i]*n;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len=<span class="hljs-number">2</span>;len&lt;=n;len++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>,ends=j+len<span class="hljs-number">-1</span>;ends&lt;=n;j++,ends=j+len<span class="hljs-number">-1</span>)&#123;<br>			dp[j][ends]=<span class="hljs-built_in">max</span>(dp[j+<span class="hljs-number">1</span>][ends]+a[j]*(n-len+<span class="hljs-number">1</span>),dp[j][ends<span class="hljs-number">-1</span>]+a[ends]*(n-len+<span class="hljs-number">1</span>));<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,dp[<span class="hljs-number">1</span>][n]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h4 id="P1091-合唱队形"><a href="#P1091-合唱队形" class="headerlink" title="P1091 合唱队形"></a><a href="https://www.luogu.com.cn/problem/P1091">P1091 合唱队形</a></h4><p>给一段序列，问要使得序列严格先升后降，最少需要删除几个元素</p>
<p>solution：从左往右跑一遍LIS，再从右往左跑一遍LIS，最后枚举每个元素，计算<code>dp1[i]+dp2[i]-1</code>的最大值，拿序列长度减去这个最大值就是答案</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp1[<span class="hljs-number">105</span>],dp2[<span class="hljs-number">105</span>],a[<span class="hljs-number">105</span>];<br><span class="hljs-type">int</span> ans;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> n;<br>	cin&gt;&gt;n;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		cin&gt;&gt;a[i];<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		dp1[i]=<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>			<span class="hljs-keyword">if</span>(a[i]&gt;a[j]) dp1[i] = <span class="hljs-built_in">max</span>(dp1[i],dp1[j]+<span class="hljs-number">1</span>);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>		dp2[i]=<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=n;j&gt;=<span class="hljs-number">1</span>;j--)&#123;<br>			<span class="hljs-keyword">if</span>(a[i]&gt;a[j]) dp2[i] = <span class="hljs-built_in">max</span>(dp2[i],dp2[j]+<span class="hljs-number">1</span>);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		ans = <span class="hljs-built_in">max</span>(ans,dp1[i]+dp2[i]<span class="hljs-number">-1</span>);<br>	&#125;<br>	cout&lt;&lt;n-ans&lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h4 id="P1077-摆花"><a href="#P1077-摆花" class="headerlink" title="P1077 摆花"></a><a href="https://www.luogu.com.cn/problem/P1077">P1077 摆花</a></h4><p>有<code>n</code>种花，每种花<code>a[i]</code>盆，要求摆<code>m</code>盆，同种花需要连续摆，问有多少种摆法</p>
<p>solution：dp，定义状态如下</p>
<script type="math/tex; mode=display">
dp[i][j]:前i种花摆了j盆的总方案数\\
转移：dp[i][j]+=dp[i-1][j-k](0\le k\le \min(j,a[i]))</script><p>初始化<code>dp[0][0]=1</code></p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">1e6</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> n,m,a[<span class="hljs-number">105</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>	dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=<span class="hljs-built_in">min</span>(j,a[i]);k++)&#123;<br>				dp[i][j]=(dp[i][j]+dp[i<span class="hljs-number">-1</span>][j-k])%mod;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,dp[n][m]);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h4 id="P1095-守望者的逃离"><a href="#P1095-守望者的逃离" class="headerlink" title="P1095 守望者的逃离"></a><a href="https://www.luogu.com.cn/problem/P1095">P1095 守望者的逃离</a></h4><p>一个人要逃离荒岛，在1s内他可以选择跑步（17m/s，不耗蓝）、闪现（60m/s 耗10点蓝）、原地休息（回蓝4点/s），给出初始法力值、离出口的距离、荒岛沉默的时间，问能否逃出，如果能，输出最短时间，否则输出能逃的最远距离</p>
<p>solution：将闪现和跑步分开处理，先处理闪现，在规定时间内，能交闪现就交，否则就原地回蓝，dp一遍处理好之后，再处理跑步</p>
<script type="math/tex; mode=display">
处理闪现和回蓝：dp[i]=
\begin{cases}
dp[i-1]+60\ (m>=10)\\
dp[i-1]\ \ \ \ \ \ \ \ \ \ (m<10)
\end{cases}\\
处理跑步：dp[i]=\max(dp[i-1]+17,dp[i])</script><details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> m,s,t; <br><span class="hljs-type">int</span> dp[<span class="hljs-number">300005</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;m,&amp;s,&amp;t);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=t;i++)&#123;<br>		<span class="hljs-keyword">if</span>(m&gt;=<span class="hljs-number">10</span>) m-=<span class="hljs-number">10</span>,dp[i]=dp[i<span class="hljs-number">-1</span>]+<span class="hljs-number">60</span>;<br>		<span class="hljs-keyword">else</span> m+=<span class="hljs-number">4</span>,dp[i]=dp[i<span class="hljs-number">-1</span>];<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=t;i++)&#123;<br>		dp[i]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>]+<span class="hljs-number">17</span>,dp[i]);<br>		<span class="hljs-keyword">if</span>(dp[i]&gt;=s)&#123;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n%d\n&quot;</span>,i);<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n%d\n&quot;</span>,dp[t]);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h4 id="IOI-2000-T1-回文字串"><a href="#IOI-2000-T1-回文字串" class="headerlink" title="IOI 2000 T1 回文字串"></a><a href="https://www.luogu.com.cn/problem/P1435">IOI 2000 T1 回文字串</a></h4><p>给一个字符串，问能使其回文所需插入的最少字符数</p>
<p>solution：原字符串和自身reverse的LCS长度就是不需要改变的长度，所以剩下的就是需要插入的字符个数</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>string s,t;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">1005</span>][<span class="hljs-number">1005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); <br>	cin&gt;&gt;s;<br>	t=s;<br>	<span class="hljs-built_in">reverse</span>(t.<span class="hljs-built_in">begin</span>(),t.<span class="hljs-built_in">end</span>());<br>	<span class="hljs-type">int</span> lens=s.<span class="hljs-built_in">size</span>(),lent=t.<span class="hljs-built_in">size</span>();<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;lens;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;lent;j++)&#123;<br>			<span class="hljs-keyword">if</span>(s[i]==t[j])&#123;<br>				dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]=dp[i][j]+<span class="hljs-number">1</span>;<br>			&#125;<span class="hljs-keyword">else</span>&#123;<br>				dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(dp[i][j+<span class="hljs-number">1</span>],dp[i+<span class="hljs-number">1</span>][j]);<br>			&#125;<br>		&#125;<br>	&#125;<br>	cout&lt;&lt;lens-dp[lens][lent]&lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h4 id="P5662-纪念品"><a href="#P5662-纪念品" class="headerlink" title="P5662 纪念品"></a><a href="https://www.luogu.com.cn/problem/P5662">P5662 纪念品</a></h4><p>有N种纪念品，有T天可以交易，初始有M块钱，给出每种纪念品在每天的价格，每天可以任意次地购买或卖出任意纪念品（前提是手上的钱足够），问最后手里能最多有多少钱</p>
<p>solution：需要巧妙地转换一下，如果我们在第<code>i</code>天买了一个东西，而在第<code>i+1</code>天卖掉它，再立刻买它的话，就相当于在第<code>i+1</code>天没有对这个东西做任何交易，因此这样就可以把连续的不交易转换成每天都进行一次无效的（或有效的）交易，因此可以将两天的物品价格做一个差分，这个差值就是两天交易的收益（可以是负的），而代价是前一天的价格，因此问题转换成了<strong>背包</strong>，但是，这个背包多了一层维度，就是天数，因此需要先枚举每一天，在每一天对所有种类的物品做一次背包，得出最大的收益，然后更新最大收益，到下一天，如此循环到倒数第二天（因为倒数第一天买卖无意义了），注意每次都要给dp数组置零，以及更新最大收益</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI=<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps=<span class="hljs-number">1e-6</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">2147483647</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">10000</span>;<br><span class="hljs-type">int</span> t,n,m,p[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">10005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;t,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=t;i++)&#123;<br>    	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>    		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;p[i][j]);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;t;i++)&#123;<br>		<span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dp));<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=p[i][j];k&lt;=m;k++)&#123;<br>				dp[k]=<span class="hljs-built_in">max</span>(dp[k],dp[k-p[i][j]]+p[i+<span class="hljs-number">1</span>][j]-p[i][j]);<br>			&#125;<br>		&#125;<br>		m=<span class="hljs-built_in">max</span>(m,dp[m]+m);<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,m);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h4 id="P1564-膜拜"><a href="#P1564-膜拜" class="headerlink" title="P1564 膜拜"></a><a href="https://www.luogu.com.cn/problem/P1564">P1564 膜拜</a></h4><p>一个机房有两位神犇，有n个同学，他们都会膜拜两位中的一位，现在要给同学们分机房，老师只会把连续一段的同学分进一个机房，需要保证每个机房的两位神犇的崇拜者人数之差不超过m，问至少需要多少个机房</p>
<p>solution：定义状态如下</p>
<script type="math/tex; mode=display">
dp[i]:前i个同学分配到的最少机房总数</script><p>考虑如何转移，如果中间有一段同学都是膜拜同一个神犇的，则就把他们都分配到一个机房就行了，比较巧妙的是，可以在初始输入时利用前缀和处理，膜拜其中一个神犇的就+1，另一个的就-1，那么转移方程如下</p>
<script type="math/tex; mode=display">
if(sum[i]-sum[j-1]==i-j+1||sum[i]-sum[j-1]<=m)\\
dp[i]=min(dp[i],dp[j-1]+1)</script><p>即：如果有一段同学都是膜拜同一个神犇的，或者两者差值不超过m，则可以转移，就是把这一段同学分配到一个同一个房间中</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI=<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps=<span class="hljs-number">1e-6</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">2147483647</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">10000</span>;<br><span class="hljs-type">int</span> n,m,a[<span class="hljs-number">2505</span>],sum[<span class="hljs-number">2505</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">2505</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    	<span class="hljs-type">int</span> x;<br>    	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>    	<span class="hljs-keyword">if</span>(x==<span class="hljs-number">2</span>) a[i]=a[i<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>;<br>    	<span class="hljs-keyword">else</span> a[i]=a[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>    	dp[i]=<span class="hljs-number">1e9</span>;<br>	&#125;<br>	dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>			<span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(a[i]-a[j<span class="hljs-number">-1</span>])==i-j+<span class="hljs-number">1</span>||<span class="hljs-built_in">abs</span>(a[i]-a[j<span class="hljs-number">-1</span>])&lt;=m)&#123;<br>				dp[i]=<span class="hljs-built_in">min</span>(dp[i],dp[j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>);<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,dp[n]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h4 id="P1020-导弹拦截"><a href="#P1020-导弹拦截" class="headerlink" title="P1020 导弹拦截"></a><a href="https://www.luogu.com.cn/problem/P1020">P1020 导弹拦截</a></h4><p>给出一串序列代表依次发射过来的导弹高度，每个拦截系统只能拦截不超过前一次拦截的导弹高度的导弹，问最多能拦截多少导弹，以及如果要拦截所有导弹，需要多少导弹拦截系统</p>
<p>solution：第一问很简单，就是求一个最长不上升子序列（upper_bound可以解决），第二问需要转化一下，可以草稿纸上画画图，其实就是求最长上升子序列的长度</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI=<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps=<span class="hljs-number">1e-6</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">2147483647</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">100105</span>;<br><span class="hljs-type">int</span> a[maxn],n;<br><span class="hljs-type">int</span> dp2[maxn],dp1[maxn],len1,len2;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-type">int</span> x;<br><span class="hljs-comment">//	freopen(&quot;P1020_3.in&quot;,&quot;r&quot;,stdin);</span><br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;x)&#123;<br>    	a[++n]=x;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">if</span>(dp2[len2]&lt;a[i]) dp2[++len2]=a[i];<br>		<span class="hljs-keyword">else</span>&#123;<br>			<span class="hljs-type">int</span> pos=<span class="hljs-built_in">lower_bound</span>(dp2+<span class="hljs-number">1</span>,dp2+<span class="hljs-number">1</span>+len2,a[i])-dp2;<br>			dp2[pos]=a[i];<br>		&#125;<br>		<span class="hljs-keyword">if</span>(len1==<span class="hljs-number">0</span>||dp1[len1]&gt;=a[i]) dp1[++len1]=a[i];<br>		<span class="hljs-keyword">else</span>&#123;<br>			<span class="hljs-type">int</span> pos=<span class="hljs-built_in">upper_bound</span>(dp1+<span class="hljs-number">1</span>,dp1+<span class="hljs-number">1</span>+len1,a[i],<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;())-dp1;<br>			dp1[pos]=a[i];<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n%d\n&quot;</span>,len1,len2);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h4 id="P1103-书本整理"><a href="#P1103-书本整理" class="headerlink" title="P1103 书本整理"></a><a href="https://www.luogu.com.cn/problem/P1103">P1103 书本整理</a></h4><p>有n本书，问从中去掉m本后所有书的不整齐度最小是多少（不整齐度定义为每两本书的宽度的差的绝对值的和）</p>
<p>solution：转换一下，及时求从n本书中选出n-m本书，使得不整齐度最小，则可以定义状态如下</p>
<script type="math/tex; mode=display">
dp[i][j]:选到第i本书且i号必选，总共选出了j本书的最小不整齐度\\
转移：dp[i][j]=min(dp[i][j],dp[k][j-1]+abs(a[i]-a[k]))</script><details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>	<span class="hljs-type">int</span> x,y;<br>&#125;a[<span class="hljs-number">205</span>];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node x1,node x2)</span></span>&#123;<br>	<span class="hljs-keyword">return</span> x1.x&lt;x2.x;<br>&#125;<br><span class="hljs-type">int</span> cha,dp[<span class="hljs-number">205</span>][<span class="hljs-number">205</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    m=n-m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a[i].x,&amp;a[i].y);<br>	&#125;<br>	<span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">1</span>,<span class="hljs-built_in">sizeof</span>(dp));<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) dp[i][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">1</span>+n,cmp);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-built_in">min</span>(i,m);j++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;i;k++)&#123;<br>				dp[i][j]=<span class="hljs-built_in">min</span>(dp[i][j],dp[k][j<span class="hljs-number">-1</span>]+<span class="hljs-built_in">abs</span>(a[i].y-a[k].y));<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-type">int</span> ans=<span class="hljs-number">1e9</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		ans=<span class="hljs-built_in">min</span>(ans,dp[i][m]);<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h4 id="P1833-樱花"><a href="#P1833-樱花" class="headerlink" title="P1833 樱花"></a><a href="https://www.luogu.com.cn/problem/P1833">P1833 樱花</a></h4><p>有n棵樱花树，有的樱花树能无限次看，有的有限定次数，每个樱花看一次需要花费指定的时间，因此可以得到指定的美学值，问在时间范围内可以获得的最大美学值是多少</p>
<p>solution：一眼就看出是完全背包+分组背包的混合，直接写就行</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI=<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps=<span class="hljs-number">1e-6</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">2147483647</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">10015</span>;<br><span class="hljs-type">int</span> a1,a2,b1,b2,n,a[maxn],b[maxn],p[maxn];<br><span class="hljs-type">int</span> dp[maxn/<span class="hljs-number">10</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d:%d %d:%d %d&quot;</span>,&amp;a1,&amp;b1,&amp;a2,&amp;b2,&amp;n);<br>    <span class="hljs-keyword">if</span>(a2&lt;a1) a2+=<span class="hljs-number">24</span>;<br>	<span class="hljs-type">int</span> ti=(a2-a1)*<span class="hljs-number">60</span>+(b2-b1);<br><span class="hljs-comment">//	cout&lt;&lt;ti&lt;&lt;endl;</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a[i],&amp;b[i],&amp;p[i]);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">if</span>(p[i]==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//完全背包</span><br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=a[i];j&lt;=ti;j++)&#123;<br>				dp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j-a[i]]+b[i]);<br>			&#125;<br>		&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//分组背包</span><br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=ti;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br>				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=p[i];k++)&#123;<br>					<span class="hljs-keyword">if</span>(j&gt;=k*a[i]) dp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j-k*a[i]]+k*b[i]);<br>				&#125; <br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,dp[ti]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h4 id="P1006-传纸条"><a href="#P1006-传纸条" class="headerlink" title="P1006 传纸条"></a><a href="https://www.luogu.com.cn/problem/P1006">P1006 传纸条</a></h4><p>翻译过来就是：给一个n*m的矩阵，问从左上角走到右下角（矩阵元素值都为0），走两条完全不同的路，所获得的最大收益（收益为经过的矩阵元素之和）</p>
<p>solution：由于是同步走，所以突破点就在于任何时刻的步数是一样的，只不过所在的坐标位不一样，因而只需要知道了横纵坐标中的任意一个值，就是可得到另一个值，于是定义如下状态</p>
<script type="math/tex; mode=display">
dp[sum][i][j]:走了sum步，第一条路处于i行，第二条路处于j行的最大收益</script><p>那么转移如下：</p>
<script type="math/tex; mode=display">
dp[sum][i][j]=max(dp[sum-1][i][j],dp[sum-1][i-1][j],dp[sum-1][i][j-1],dp[sum-1][i-1][j-1])+mm[i][sum-i+1]+mm[j][sum-j+1]</script><p>但是由于两者不能走同一个格子，所以当<code>i==j</code>时，就是重合的时候，这种情况下，转移的时候只能加一次矩阵元素值，因此上面的更新可以分开来写，加元素值的时候，写成下面的样子</p>
<p><code>dp[sum][i][j]+=(i==j)?mm[i][sum-i+1]:mm[i][sum-i+1]+mm[j][sum-j+1]</code></p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI=<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps=<span class="hljs-number">1e-6</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">2147483647</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">10000</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> n,m,mm[<span class="hljs-number">55</span>][<span class="hljs-number">55</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">250</span>][<span class="hljs-number">55</span>][<span class="hljs-number">55</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>    		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;mm[i][j]);<br>		&#125;<br>	<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> sum=<span class="hljs-number">2</span>;sum&lt;=n+m<span class="hljs-number">-1</span>;sum++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n&amp;&amp;i&lt;=sum;i++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n&amp;&amp;j&lt;=sum;j++)&#123;<br>				dp[sum][i][j]=<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(dp[sum<span class="hljs-number">-1</span>][i<span class="hljs-number">-1</span>][j],dp[sum<span class="hljs-number">-1</span>][i][j<span class="hljs-number">-1</span>]),<span class="hljs-built_in">max</span>(dp[sum<span class="hljs-number">-1</span>][i][j],dp[sum<span class="hljs-number">-1</span>][i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]));<br>				dp[sum][i][j]+=(i==j)?mm[i][sum-i+<span class="hljs-number">1</span>]:(mm[i][sum-i+<span class="hljs-number">1</span>]+mm[j][sum-j+<span class="hljs-number">1</span>]);<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,dp[n+m<span class="hljs-number">-1</span>][n][n]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h4 id="P1005-矩阵取数游戏"><a href="#P1005-矩阵取数游戏" class="headerlink" title="P1005 矩阵取数游戏"></a><a href="https://www.luogu.com.cn/problem/P1005">P1005 矩阵取数游戏</a></h4><p>有一个n*m的矩阵，每次从每一行的左右两端任取一个元素出来，得到对应的得分（乘以$2^i$，$i$表示第$i$次取），问最终能获得的得分最大值</p>
<p>solution：任意行与行之间的取数是相互独立的，因此考虑对每一行进行区间dp，对于第$i$行，定义状态$dp[st][en]$：取到剩下$st$位置到$en$位置时，这一行所对应的的得分最大值，则转移方程如下：</p>
<script type="math/tex; mode=display">
dp[st][en]=\max(dp[st][en],dp[st-1][en]+2^{m-(en-st+1)},dp[st][en+1]+2^{m-(en-st+1)})</script><p>即：从区间左端点左侧转移过来或者从右端点右侧转移过来，最后需要在所有的$dp[j][j]$中找$dp[j][j]+2^m$的最大值更新答案，对于每一行都如此操作，最后求和就是答案</p>
<p>PS：需用高精，然而<code>__int128</code>也可过</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// fast read</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(T &amp;x)</span> </span>&#123;<br>	x=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> f=<span class="hljs-number">0</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br>	<span class="hljs-keyword">while</span>(ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;f|=(ch==<span class="hljs-string">&#x27;-&#x27;</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<br>	<span class="hljs-keyword">while</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<br>	x=f?-x:x;<br>	<span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//fast write</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(__int128 x)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>)<span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;<br>    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>)<span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br><br>__int128 n,m,a[<span class="hljs-number">85</span>][<span class="hljs-number">85</span>],dp[<span class="hljs-number">85</span>][<span class="hljs-number">85</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> __int128 <span class="hljs-title">qpow</span><span class="hljs-params">(__int128 x,__int128 y)</span></span>&#123;<br>	__int128 base=x,ans=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">while</span>(y)&#123;<br>		<span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) ans*=base;<br>		base*=base;<br>		y&gt;&gt;=<span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">read</span>(n),<span class="hljs-built_in">read</span>(m);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>			<span class="hljs-built_in">read</span>(a[i][j]);<br>		&#125;<br>	&#125;<br>	__int128 ans=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dp));<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len=m;len&gt;=<span class="hljs-number">1</span>;len--)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> st=<span class="hljs-number">1</span>,en=st+len<span class="hljs-number">-1</span>;en&lt;=m;st++,en=st+len<span class="hljs-number">-1</span>)&#123;<br>				dp[st][en]=<span class="hljs-built_in">max</span>(dp[st][en],<span class="hljs-built_in">max</span>(dp[st<span class="hljs-number">-1</span>][en]+a[i][st<span class="hljs-number">-1</span>]*<span class="hljs-built_in">qpow</span>(<span class="hljs-number">2</span>,m-(en-st+<span class="hljs-number">1</span>)),dp[st][en+<span class="hljs-number">1</span>]+a[i][en+<span class="hljs-number">1</span>]*<span class="hljs-built_in">qpow</span>(<span class="hljs-number">2</span>,m-(en-st+<span class="hljs-number">1</span>))));<br>			&#125;<br>		&#125;<br>		__int128 tp=<span class="hljs-number">-1</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>			tp=<span class="hljs-built_in">max</span>(tp,<span class="hljs-built_in">qpow</span>(<span class="hljs-number">2</span>,m)*a[i][j]+dp[j][j]);<br>		&#125;<br>		ans+=tp;<br>	&#125;<br>	<span class="hljs-built_in">write</span>(ans);<br>	<span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h4 id="P2015-二叉苹果树"><a href="#P2015-二叉苹果树" class="headerlink" title="P2015 二叉苹果树"></a><a href="https://www.luogu.com.cn/problem/P2015">P2015 二叉苹果树</a></h4><p>给出一棵有边权的二叉树，要求保留从根节点出发的q条边，删去其余边，问剩余的树的边权和最大值</p>
<p>solution：树形dp，考虑第$u$号节点，定义状态$dp[u][j]$：以$u$节点为根的子树保留$j$条边所具有的的最大边权和，则转移方程如下：</p>
<script type="math/tex; mode=display">
dp[u][j]=\max(dp[u][j],dp[u][j-k-1]+dp[v][k]+edge.w)</script><p>其中，$v$为一个子节点，$edge.w$为$u,v$的边权，$k$代表$v$这棵子树保留$k$条边，且 $j\le \min(size[u],q),k&lt;=\min(size[v],q)$，其中$size$为子树大小</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// fast read</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(T &amp;x)</span> </span>&#123;<br>	x=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> f=<span class="hljs-number">0</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br>	<span class="hljs-keyword">while</span>(ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;f|=(ch==<span class="hljs-string">&#x27;-&#x27;</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<br>	<span class="hljs-keyword">while</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<br>	x=f?-x:x;<br>	<span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">int</span> n,q;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span><br>&#123;<br>	<span class="hljs-type">int</span> u,v,w,next;<br>&#125;e[<span class="hljs-number">205</span>];<br><span class="hljs-type">int</span> cnt,head[<span class="hljs-number">205</span>],dp[<span class="hljs-number">205</span>][<span class="hljs-number">205</span>],sz[<span class="hljs-number">205</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w)</span></span>&#123;e[cnt]=&#123;u,v,w,head[u]&#125;,head[u]=cnt++;&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fath)</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(v!=fath)&#123;<br>			<span class="hljs-built_in">dfs</span>(v,u);<br>			sz[u]+=sz[v]+<span class="hljs-number">1</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v,w=e[i].w;<br>		<span class="hljs-keyword">if</span>(v!=fath)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-built_in">min</span>(q,sz[u]);j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br>				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-built_in">min</span>(j<span class="hljs-number">-1</span>,q);k&gt;=<span class="hljs-number">0</span>;k--)&#123;<br>					dp[u][j]=<span class="hljs-built_in">max</span>(dp[u][j],dp[u][j-k<span class="hljs-number">-1</span>]+dp[v][k]+w);<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">read</span>(n),<span class="hljs-built_in">read</span>(q);<br>	<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>		<span class="hljs-type">int</span> u,v,w;<br>		<span class="hljs-built_in">read</span>(u),<span class="hljs-built_in">read</span>(v),<span class="hljs-built_in">read</span>(w);<br>		<span class="hljs-built_in">addedge</span>(u,v,w),<span class="hljs-built_in">addedge</span>(v,u,w);<br>	&#125;<br>	<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,dp[<span class="hljs-number">1</span>][q]);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h4 id="P3177-树上染色"><a href="#P3177-树上染色" class="headerlink" title="P3177 树上染色"></a><a href="https://www.luogu.com.cn/problem/P3177">P3177 树上染色</a></h4>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>简单理解勒让德变换</title>
    <url>/2020/01/16/%E5%8B%92%E8%AE%A9%E5%BE%B7%E5%8F%98%E6%8D%A2-1/</url>
    <content><![CDATA[<h2 id="勒让德变换的热力学简单理解"><a href="#勒让德变换的热力学简单理解" class="headerlink" title="勒让德变换的热力学简单理解"></a><center>勒让德变换的热力学简单理解</center></h2><blockquote>
<p>“哥哥，我想换个变量!”</p>
</blockquote>
<span id="more"></span>
<h2 id="勒让德变换-Legendre-transformation"><a href="#勒让德变换-Legendre-transformation" class="headerlink" title="勒让德变换(Legendre transformation)"></a><strong>勒让德变换(Legendre transformation)</strong></h2><ul>
<li>最近在搞热统，在回顾热力学基本方程的时候发现了这么个玩意儿，但由于本人没系统学习过<strong>分析力学</strong>，这里仅谈一下对该变换比较浅层的理解（仅针对热力学的理解）。</li>
</ul>
<hr>
<p>当然定义还是要说一下的啦：<br><img src="https://i.loli.net/2020/01/16/9HtKMjZIONFpin2.jpg" alt="帮助理解的图"><br>从纯数学角度来说，对于一个上凸函数 $y=px-f(x)$（其中$f(x)$为下凸函数，且是可微的）对其求导，导数为零，满足</p>
<script type="math/tex; mode=display">
p=\frac{df}{dx}</script><p>这样从 $x$ 到 $p$ 建立起一个映射，即$x$到曲线斜率的映射。<br>我们令 $x=g(p)$，即 $p$ 到 $x$ 的逆映射存在（就是<strong>反函数</strong>啦），因为 $f(x)$ 是一个下凸函数，其斜率与曲线上的点是一一对应的。<br>这样，我们就定义了一个新的函数与 $f$ 相对应：</p>
<script type="math/tex; mode=display">
f^*(p)=g(p)\cdot p-f(g(p))</script><p>该函数是以 $p$ 为自变量的函数。从 $f$ 到 $f^* $ 的变换就称为<strong>勒让德变换</strong>，即把原来在的 $f$ 对应于一个它的对偶空间的 $f^* $ 。</p>
<p><del>能原谅我其实没太看懂吗</del></p>
<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ul>
<li>最简单的理解就是：这个自变量<u><strong>不好看</strong></u>，我换一个自变量。</li>
<li>往应用方面去理解的话，可以这么说：在表示一个系统的时候，往往有多种表示方法，每种表示方法之间可以<u>通过勒让德变换来构建联系</u>。（或者说：我想换个变量，怎么办？勒让德变换！）</li>
</ul>
<h3 id="热力学应用"><a href="#热力学应用" class="headerlink" title="热力学应用"></a>热力学应用</h3><p>举个简单的栗子：</p>
<blockquote>
<p>热力学基本方程：$dU=TdS-PdV$，噢这里自变量是$S$和$V$，那我想要自变量变成$S$和$P$咋办呢？</p>
</blockquote>
<p>我们知道，热力学能（$U$）是一种<strong>热力学势</strong>，由上述方程可知它是自然变量$S$和$V$的函数：$U(S,V)$，而想要改写成$S$和$P$的函数关系，似乎就需要引入一个新的<strong>热力学势</strong>，这个热力学势就是<strong>焓(H)</strong>，整个过程的呈现如下：</p>
<script type="math/tex; mode=display">
dU=TdS-PdV</script><p>等号两边作如下变换：</p>
<script type="math/tex; mode=display">
dU+d(PV)=TdS-PdV+PdV+VdP</script><p>化简：</p>
<script type="math/tex; mode=display">
d(U+PV)=TdS+VdP</script><p>yep！这个等号左边微分符号内就是我们所说的 <strong>焓($H=U+PV$)</strong> 啦,因此有:</p>
<script type="math/tex; mode=display">
dH=TdS+VdP</script><hr>
<p>以上过程就是热力学中的勒让德变换的简单应用啦！</p>
<ul>
<li>当然，还有其他的<strong>热力学势</strong>，如：<u>亥姆霍兹自由能($A(T,V)$)</u>和<u>吉布斯自由能($G(T,P)$)</u>，均可以由基本方程和勒让德变换获得，笔者将继续摸索下去。</li>
</ul>
]]></content>
      <categories>
        <category>物理</category>
      </categories>
      <tags>
        <tag>热力学</tag>
        <tag>对偶</tag>
      </tags>
  </entry>
  <entry>
    <title>区间DP浅析</title>
    <url>/2020/03/08/%E5%8C%BA%E9%97%B4DP%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h2 id="动态规划の区间dp"><a href="#动态规划の区间dp" class="headerlink" title="动态规划の区间dp"></a><center>动态规划の区间dp</center></h2><span id="more"></span>
<h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><ul>
<li>将一个序列（或者环）分成一段段的小区间，过求解区间内的最优值（通过枚举分割点），进而将每一段区间合并得出整体的最优值</li>
</ul>
<h2 id="一般的板子"><a href="#一般的板子" class="headerlink" title="一般的板子"></a>一般的板子</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>;l&lt;=len;l++)&#123;<span class="hljs-comment">//枚举长度</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>,ends=j+l<span class="hljs-number">-1</span>;ends&lt;len;j++,ends=j+l<span class="hljs-number">-1</span>)&#123;<span class="hljs-comment">// 枚举起点+终点</span><br>        dp[j][ends]=inf; <span class="hljs-comment">//如果处理的是min问题，需要初始化为inf</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;ends;k++)&#123;<span class="hljs-comment">//枚举分割点</span><br>            dp[j][ends]=max/<span class="hljs-built_in">min</span>(dp[j][ends],dp[j][k]+dp[k+<span class="hljs-number">1</span>][ends]+something);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>特殊情况下可能用不到上述板子，但整体思路相同，都是用小区间更新大区间</p>
<h2 id="一堆习题（难点在于状态转移方程）"><a href="#一堆习题（难点在于状态转移方程）" class="headerlink" title="一堆习题（难点在于状态转移方程）"></a>一堆习题（难点在于状态转移方程）</h2><p>以下习题难度依次上升。。</p>
<h3 id="NOI-1995-石子合并"><a href="#NOI-1995-石子合并" class="headerlink" title="NOI 1995 石子合并"></a><a href="https://www.luogu.com.cn/problem/P1880">NOI 1995 石子合并</a></h3><p>题意：$N$堆石子摆成一个环，每次可以讲相邻两堆石子合并，合并得分为两堆石子数之和，求只剩一堆时的最终得分的最大值和最小值</p>
<p>题解：首先破链成环，即把环的前$n-1$个元素拼到第$n$个元素后面形成一个$2n-1$的链，这样就能遍历到所有状态</p>
<p>状态转移方程如下</p>
<script type="math/tex; mode=display">
dp[l][r]=max(dp[l][r],dp[l][k]+dp[k+1][r]+sum[l\to r])</script><p>其中$sum$是从l到r的所有石子的数目之和</p>
<p>PS：需要注意求最小值时的初始化问题，以及递推完后需要再滚一遍求出所有可能值中的最优值</p>
<p>AC代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>;<br><span class="hljs-type">int</span> dp1[<span class="hljs-number">805</span>][<span class="hljs-number">805</span>],dp2[<span class="hljs-number">805</span>][<span class="hljs-number">805</span>];<br><span class="hljs-type">int</span> a[<span class="hljs-number">4005</span>],sum[<span class="hljs-number">4005</span>];<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;n;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		cin&gt;&gt;a[i];<br>		sum[i]=sum[i<span class="hljs-number">-1</span>]+a[i];<br>		dp2[i][i]=<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) sum[i+n]=sum[i+n<span class="hljs-number">-1</span>]+a[i];<br>	<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len=<span class="hljs-number">1</span>;len&lt;=n;len++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>,lens=j+len;lens&lt;<span class="hljs-number">2</span>*n&amp;&amp;j&lt;<span class="hljs-number">2</span>*n;j++,lens=j+len)&#123;<br>			dp2[j][lens]=inf;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=j;k&lt;lens;k++)&#123;<br>				dp2[j][lens]=<span class="hljs-built_in">min</span>(dp2[j][lens],dp2[j][k]+dp2[k+<span class="hljs-number">1</span>][lens]+sum[lens]-sum[j<span class="hljs-number">-1</span>]);<br>				dp1[j][lens]=<span class="hljs-built_in">max</span>(dp1[j][lens],dp1[j][k]+dp1[k+<span class="hljs-number">1</span>][lens]+sum[lens]-sum[j<span class="hljs-number">-1</span>]);<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-type">int</span> ansmin=inf,ansmax=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		ansmin=<span class="hljs-built_in">min</span>(ansmin,dp2[i][i+n<span class="hljs-number">-1</span>]);<br>		ansmax=<span class="hljs-built_in">max</span>(ansmax,dp1[i][i+n<span class="hljs-number">-1</span>]);<br>	&#125;<br>	<br>	cout&lt;&lt;ansmin&lt;&lt;endl&lt;&lt;ansmax&lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="洛谷-P1063-能量项链"><a href="#洛谷-P1063-能量项链" class="headerlink" title="洛谷 P1063 能量项链"></a><a href="https://www.luogu.com.cn/problem/P1063">洛谷 P1063 能量项链</a></h3><p>题意：点链接进去看吧</p>
<p>题解：区间dp，直接上状态转移方程</p>
<script type="math/tex; mode=display">
dp[l][r]=max(dp[l][r],dp[l][k]+dp[k+1][r]+a[l]*a[k+1]*a[r+1])</script><p>其中$a_i$代表第$i$个输入的标记值</p>
<p>PS：注意一下dp方程中的下标问题（其实自己举个例子就能推出来是这么个原理）</p>
<p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>;<br><span class="hljs-type">int</span> n,dp[<span class="hljs-number">405</span>][<span class="hljs-number">405</span>],a[<span class="hljs-number">405</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;n;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		cin&gt;&gt;a[i];<br>		a[i+n]=a[i];<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len=<span class="hljs-number">2</span>;len&lt;=n;len++)&#123;<span class="hljs-comment">//长度最短为2</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>,ends=len+j<span class="hljs-number">-1</span>;ends&lt;<span class="hljs-number">2</span>*n&amp;&amp;j&lt;<span class="hljs-number">2</span>*n;j++,ends=len+j<span class="hljs-number">-1</span>)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=j;k&lt;ends;k++)&#123;<br>				dp[j][ends]=<span class="hljs-built_in">max</span>(dp[j][ends],dp[j][k]+dp[k+<span class="hljs-number">1</span>][ends]+a[j]*a[k+<span class="hljs-number">1</span>]*a[ends+<span class="hljs-number">1</span>]);<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) ans=<span class="hljs-built_in">max</span>(ans,dp[i][i+n<span class="hljs-number">-1</span>]);<br>	cout&lt;&lt;ans&lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="POJ-1651-Multiplication-Puzzle"><a href="#POJ-1651-Multiplication-Puzzle" class="headerlink" title="POJ 1651 Multiplication Puzzle"></a><a href="https://vjudge.net/problem/POJ-1651">POJ 1651 Multiplication Puzzle</a></h3><p>题意：有一个序列，你可以任意删掉除了首尾之外的一个元素，然后获得该元素与相邻两元素的乘积的分数，求可得到的最小分数</p>
<p>题解：区间dp，状态转移方程如下</p>
<script type="math/tex; mode=display">
dp[l][r]=min(dp[l][r],dp[l][k]+dp[k][r]+a[l]*a[k]*a[r])</script><p>PS：注意首尾元素不能取，因此初始长度为3</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>;<br><span class="hljs-type">int</span> n,dp[<span class="hljs-number">405</span>][<span class="hljs-number">405</span>],a[<span class="hljs-number">405</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;n;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		cin&gt;&gt;a[i];<br>	&#125;<br>	<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len=<span class="hljs-number">3</span>;len&lt;=n;len++)&#123;<span class="hljs-comment">// 初始长度最短为3</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>,ends=len+j<span class="hljs-number">-1</span>;ends&lt;=n;j++,ends=len+j<span class="hljs-number">-1</span>)&#123;<br>			dp[j][ends]=inf;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=j+<span class="hljs-number">1</span>;k&lt;ends;k++)&#123;<br>				dp[j][ends]=<span class="hljs-built_in">min</span>(dp[j][ends],dp[j][k]+dp[k][ends]+a[j]*a[k]*a[ends]);<br>			&#125;<br>		&#125;<br>	&#125;<br>	cout&lt;&lt;dp[<span class="hljs-number">1</span>][n]&lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-comment">//https://vjudge.net/problem/POJ-1651</span><br></code></pre></div></td></tr></table></figure>
<h3 id="POJ-2955-Brackets"><a href="#POJ-2955-Brackets" class="headerlink" title="POJ 2955 Brackets"></a><a href="https://vjudge.net/problem/POJ-2955">POJ 2955 Brackets</a></h3><p>题意：给一串只有<code>()[]</code>这四个字符的字符串，要求求出最长的合法的括号表达式的子序列长度</p>
<p>题解：区间dp，状态转移需要考虑$s[l]$是否和$s[r]$匹配，如果匹配就要加上2，其他的就按照正常的枚举分割点操作来更新</p>
<script type="math/tex; mode=display">
dp[l][r]=max(dp[l][r],dp[l][k]+dp[k+1][r])\\
if(s[l]==s[r])\ dp[l][r]=dp[l+1][r-1]+2</script><p>AC代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>string s;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">while</span>(cin&gt;&gt;s&amp;&amp;s!=<span class="hljs-string">&quot;end&quot;</span>)&#123;<br>		<span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dp));<br>		<span class="hljs-type">int</span> len=s.<span class="hljs-built_in">length</span>();<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;i++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>,ends=j+i<span class="hljs-number">-1</span>;ends&lt;len;j++,ends=j+i<span class="hljs-number">-1</span>)&#123;<br>				<span class="hljs-keyword">if</span>((s[ends]==<span class="hljs-string">&#x27;)&#x27;</span>&amp;&amp;s[j]==<span class="hljs-string">&#x27;(&#x27;</span>)||(s[ends]==<span class="hljs-string">&#x27;]&#x27;</span>&amp;&amp;s[j]==<span class="hljs-string">&#x27;[&#x27;</span>))&#123;<br>					dp[j][ends]=dp[j+<span class="hljs-number">1</span>][ends<span class="hljs-number">-1</span>]+<span class="hljs-number">2</span>;<br>				&#125;<br>				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=j;k&lt;ends;k++)&#123;<br>					dp[j][ends]=<span class="hljs-built_in">max</span>(dp[j][ends],dp[j][k]+dp[k][ends]);<br>				&#125; <br>			&#125;	<br>		&#125;<br>		cout&lt;&lt;dp[<span class="hljs-number">0</span>][len<span class="hljs-number">-1</span>]&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="洛谷-P1043-数字游戏"><a href="#洛谷-P1043-数字游戏" class="headerlink" title="洛谷 P1043 数字游戏"></a><a href="https://www.luogu.com.cn/problem/P1043">洛谷 P1043 数字游戏</a></h3><p>题意：有一圈数，现在要求你把它分成非空的m份，计算每一份的和，然后把这些和乘起来，最终的到一个k，求k的最大值和最小值</p>
<p>题解：一看就是个环状的区间dp，但是分成m分这一点稍微有点难考虑，其实也就是dp方程多了一维罢了，状态如下</p>
<script type="math/tex; mode=display">
dp[i][j][k]:该序列从i到j的区间分成k份所得的最优解</script><p>转移方程如下</p>
<script type="math/tex; mode=display">
dp[i][j][k]=max(dp[i][j][k],dp[i][h][k-1]*(sum[j]-sum[h]))</script><p>其中$h$为枚举的中间点，$sum$数组为前缀和数组</p>
<p>按照套路，我们的枚举顺序如下：</p>
<ol>
<li>枚举区间长度</li>
<li>枚举起点+终点</li>
<li>枚举中间点</li>
</ol>
<p>现在多了一个m份，我们知道中间点的枚举一定是最内层的（因为他要更新答案），那么我们可以把分割成m份的操作放在倒数第二层循环，也就是$ijk$顺序枚举</p>
<p>AC代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>;<br><span class="hljs-type">int</span> dp1[<span class="hljs-number">185</span>][<span class="hljs-number">185</span>][<span class="hljs-number">115</span>],dp2[<span class="hljs-number">185</span>][<span class="hljs-number">185</span>][<span class="hljs-number">115</span>];<br><span class="hljs-type">int</span> a[<span class="hljs-number">155</span>],sum[<span class="hljs-number">155</span>];<br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">giao</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>	<span class="hljs-keyword">return</span> (x%<span class="hljs-number">10</span>+<span class="hljs-number">10</span>)%<span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;n&gt;&gt;m;<br>	<span class="hljs-built_in">memset</span>(dp2,<span class="hljs-number">0x3f3f3f</span>,<span class="hljs-built_in">sizeof</span>(dp2));<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		cin&gt;&gt;a[i];<br>		sum[i]=sum[i<span class="hljs-number">-1</span>]+a[i];<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) sum[i+n]=sum[i+n<span class="hljs-number">-1</span>]+a[i];<br>	<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;=<span class="hljs-number">2</span>*n;j++)&#123;<br>			dp1[i][j][<span class="hljs-number">1</span>]=dp2[i][j][<span class="hljs-number">1</span>]=<span class="hljs-built_in">giao</span>(sum[j]-sum[i<span class="hljs-number">-1</span>]);<br>		&#125; <br>	&#125;<br>	<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,r=l+i<span class="hljs-number">-1</span>;l&lt;<span class="hljs-number">2</span>*n;l++,r=l+i<span class="hljs-number">-1</span>)&#123; <br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">2</span>;k&lt;=m;k++)&#123;<br>				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> h=l+k<span class="hljs-number">-1</span>;h&lt;r;h++)&#123;<br>					dp1[l][r][k]=<span class="hljs-built_in">max</span>(dp1[l][r][k],dp1[l][h][k<span class="hljs-number">-1</span>]*<span class="hljs-built_in">giao</span>(sum[r]-sum[h]));<br>					dp2[l][r][k]=<span class="hljs-built_in">min</span>(dp2[l][r][k],dp2[l][h][k<span class="hljs-number">-1</span>]*<span class="hljs-built_in">giao</span>(sum[r]-sum[h]));<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-type">int</span> ansmin=inf,ansmax=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		ansmin=<span class="hljs-built_in">min</span>(ansmin,dp2[i][i+n<span class="hljs-number">-1</span>][m]);<br>		ansmax=<span class="hljs-built_in">max</span>(ansmax,dp1[i][i+n<span class="hljs-number">-1</span>][m]);<br>	&#125;<br>	<br>	cout&lt;&lt;ansmin&lt;&lt;endl&lt;&lt;ansmax&lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="HDU-4632-回文子序列"><a href="#HDU-4632-回文子序列" class="headerlink" title="HDU 4632 回文子序列"></a><a href="https://vjudge.net/problem/HDU-4632">HDU 4632 回文子序列</a></h3><p>题意：求出给定字符串内的不同的回文子序列的个数</p>
<p>题解：区间dp，但是“回文”这个性质很特殊，我们定义如下状态</p>
<script type="math/tex; mode=display">
dp[l][r]:l到r区间内具有的回文子序列的个数</script><p>接下来考虑状态转移，首先，我们可以得出</p>
<script type="math/tex; mode=display">
dp[l][r]=dp[l+1][r]\cup dp[l][r-1]\\由容斥原理得\\dp[l][r]=d[l+1][r]+dp[l][r-1]-dp[l+1][r-1]</script><p>这是所有情况都成立的，但是，如果出现了第$l$位和第$r$位的字符相同的情况的话，状态就可以增加以这两个字符为始末的回文串总数的数量，于是有如下状态转移成立</p>
<script type="math/tex; mode=display">
if(s[l]==s[r])\ \ dp[l][r]=dp[l][r]+dp[l+1][r-1]+1</script><p>PS：初始化的时候，每单个字符组成的区间的dp值为1（一个字符天然是回文的）</p>
<p>AC代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">10007</span>;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">2005</span>][<span class="hljs-number">2005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> t;<br>	cin&gt;&gt;t;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> m=<span class="hljs-number">1</span>;m&lt;=t;m++)&#123;<br>		<span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dp));<br>		string s;<br>		cin&gt;&gt;s;<br>		<span class="hljs-type">int</span> lens=s.<span class="hljs-built_in">length</span>();<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;lens;i++) dp[i][i]=<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=lens;i++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>,ends=j+i<span class="hljs-number">-1</span>;ends&lt;lens;j++,ends=j+i<span class="hljs-number">-1</span>)&#123;<br>				dp[j][ends]=((dp[j+<span class="hljs-number">1</span>][ends]+dp[j][ends<span class="hljs-number">-1</span>]-dp[j+<span class="hljs-number">1</span>][ends<span class="hljs-number">-1</span>])%mod+mod)%mod;<br>				<span class="hljs-keyword">if</span>(s[j]==s[ends])<br>					dp[j][ends]=(dp[j][ends]+dp[j+<span class="hljs-number">1</span>][ends<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>)%mod;<br>			&#125;<br>		&#125;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case %d: %d\n&quot;</span>,m,dp[<span class="hljs-number">0</span>][lens<span class="hljs-number">-1</span>]%mod);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-comment">// https://vjudge.net/problem/HDU-4632</span><br></code></pre></div></td></tr></table></figure>
<p><strong>接下来是最终挑战</strong></p>
<h3 id="洛谷-P1220-关路灯"><a href="#洛谷-P1220-关路灯" class="headerlink" title="洛谷 P1220 关路灯"></a><a href="https://www.luogu.com.cn/problem/P1220">洛谷 P1220 关路灯</a></h3><p>题意：给出一排灯的位置坐标、每秒消耗功率值和你初始的位置，你每秒可以走1m，求把所有灯都关了所消耗的功率的最小值</p>
<p>题解：想是能想到是区间dp，但存在以下难点</p>
<h4 id="难点1：状态和状态转移"><a href="#难点1：状态和状态转移" class="headerlink" title="难点1：状态和状态转移"></a>难点1：状态和状态转移</h4><p>我们可以想到状态如下</p>
<script type="math/tex; mode=display">
dp[l][r]:关掉l到r区间内所有灯所消耗的功率值</script><p>但这TMD怎么更新？好像缺了点什么，没错，关完这些灯你站在哪里？</p>
<p>只有两个选择：在$l$或在$r$，那么就好办了，状态改写为如下</p>
<script type="math/tex; mode=display">
dp[l][r][0]:关掉l到r区间内所有灯后，你站在l点，所消耗的功率值\\dp[l][r][1]:关掉l到r区间内所有灯后，你站在r点，所消耗的功率值</script><p>那么转移就好办了</p>
<script type="math/tex; mode=display">
dp[l][r][0]=min(dp[l+1][r][0]+cal(),dp[l+1][r][1]+cal())\\dp[l][r][1]=min(dp[l][r-1][0]+cal(),dp[l][r-1][1]+cal())</script><p>其中$cal()$函数是要计算的这一步的功率消耗值（可以拿前缀和搞）</p>
<h4 id="难点2：遍历顺序"><a href="#难点2：遍历顺序" class="headerlink" title="难点2：遍历顺序"></a>难点2：遍历顺序</h4><p>我们观察一下状态转移方程，<code>l</code>是由<code>l+1</code>更新过来的，因此<code>l</code>需要倒序遍历，相反的<code>r</code>需要顺序遍历，发现先遍历<code>l</code>比较别扭（从最长开始更新），因此考虑先遍历<code>r</code>，得出代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> pos[<span class="hljs-number">1005</span>],power[<span class="hljs-number">1005</span>];<br><span class="hljs-type">int</span> n,st;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">55</span>][<span class="hljs-number">55</span>][<span class="hljs-number">3</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>	<span class="hljs-keyword">return</span> (pos[r]-pos[l])*(power[i]+power[n]-power[j]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;n&gt;&gt;st;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;pos[i]&gt;&gt;power[i];<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) power[i]=power[i<span class="hljs-number">-1</span>]+power[i];<br>	<span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0x3f3f3f</span>,<span class="hljs-built_in">sizeof</span>(dp));<span class="hljs-comment">// 求最小初始化</span><br>	dp[st][st][<span class="hljs-number">0</span>]=dp[st][st][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>	<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=st;j&lt;=n;j++)&#123; <span class="hljs-comment">//先遍历右端点</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=j<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">1</span>;i--)&#123; <span class="hljs-comment">//后遍历左端点</span><br>			dp[i][j][<span class="hljs-number">0</span>]=<span class="hljs-built_in">min</span>(dp[i+<span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>]+<span class="hljs-built_in">cal</span>(i,j,i,i+<span class="hljs-number">1</span>),dp[i+<span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>]+<span class="hljs-built_in">cal</span>(i,j,i,j));<br>			dp[i][j][<span class="hljs-number">1</span>]=<span class="hljs-built_in">min</span>(dp[i][j<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+<span class="hljs-built_in">cal</span>(i<span class="hljs-number">-1</span>,j<span class="hljs-number">-1</span>,i,j),dp[i][j<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]+<span class="hljs-built_in">cal</span>(i<span class="hljs-number">-1</span>,j<span class="hljs-number">-1</span>,j<span class="hljs-number">-1</span>,j));<br>		&#125;<br>	&#125;<br>	cout&lt;&lt;<span class="hljs-built_in">min</span>(dp[<span class="hljs-number">1</span>][n][<span class="hljs-number">1</span>],dp[<span class="hljs-number">1</span>][n][<span class="hljs-number">0</span>])&lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<hr>
<ul>
<li>感想：orz，dp也太恶心了吧，毫无套路可寻，完全靠经验和智商</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈&amp;单调队列</title>
    <url>/2020/01/28/%E5%8D%95%E8%B0%83%E6%A0%88&amp;%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="刷题记录-单调栈-单调队列练习"><a href="#刷题记录-单调栈-单调队列练习" class="headerlink" title="[刷题记录]单调栈&单调队列练习"></a><center>[刷题记录]单调栈&单调队列练习</center></h2><span id="more"></span>
<ul>
<li>最近学到<strong>单调栈</strong>&amp;<strong>单调队列</strong>，题目也开始有点考验思维了，下面做简单介绍。</li>
</ul>
<hr>
<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>顾名思义，就是满足<strong>单调性</strong>的<strong>栈</strong>结构，可以是单调递增or递减or自己定义。</li>
</ul>
<h3 id="实现（核心代码）"><a href="#实现（核心代码）" class="headerlink" title="实现（核心代码）"></a>实现（核心代码）</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(!stack.<span class="hljs-built_in">empty</span>() &amp;&amp; x &gt; stack.<span class="hljs-built_in">top</span>())&#123; <span class="hljs-comment">// 严格单调递增</span><br>    <span class="hljs-comment">//这里一般做一些答案处理</span><br>	stack.<span class="hljs-built_in">pop</span>();<br>&#125;<br>stack.<span class="hljs-built_in">push</span>(x);<br></code></pre></div></td></tr></table></figure>
<h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><h4 id="1-POJ-3250-Bad-Hair-Day"><a href="#1-POJ-3250-Bad-Hair-Day" class="headerlink" title="1. POJ 3250 Bad Hair Day"></a>1. <a href="https://vjudge.net/problem/POJ-3250#author=Tiw_Air_OAO">POJ 3250 Bad Hair Day</a></h4><h5 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h5><ul>
<li>有$N$头牛从左到右排成一排，每头牛有一个高度为$h<em>i$，设左数第$i$头牛与「它右边第一头高度$\geq h_i$」的牛之间有$c_i$头牛，试求$\sum ^{N}</em>{i=1}c_{i}$。</li>
</ul>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><ul>
<li>应用单调栈的思想，由于牛头都是朝着右边看，所以把输入的每头牛<strong>倒序</strong>压入一个<strong>单调不增的</strong>单调栈中，每次需要弹出元素时需要处理一下答案。</li>
</ul>
<h5 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll a[<span class="hljs-number">100005</span>];<br>stack&lt;ll&gt; s;<br>ll ans[<span class="hljs-number">100005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	ll n;<br>	cin&gt;&gt;n;<br>	<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		cin&gt;&gt;a[i];<br>		ans[i]=<span class="hljs-number">1</span>; <span class="hljs-comment">//方便后续累加</span><br>	&#125;<br>	<br>	<span class="hljs-keyword">for</span>(ll i=n;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>		<span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>()&amp;&amp;a[i]&gt;a[s.<span class="hljs-built_in">top</span>()])&#123;<br>			ans[i]+=ans[s.<span class="hljs-built_in">top</span>()]; <span class="hljs-comment">//处理答案</span><br>			s.<span class="hljs-built_in">pop</span>();<br>		&#125;<br>		s.<span class="hljs-built_in">push</span>(i);<br>	&#125;<br>	ll anss=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++) anss+=ans[i]; <span class="hljs-comment">//求和</span><br>	cout&lt;&lt;anss-n&lt;&lt;endl; <span class="hljs-comment">//多加了n，需要减去</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="2-POJ-2259-Largest-Rectangle-in-a-Histogram"><a href="#2-POJ-2259-Largest-Rectangle-in-a-Histogram" class="headerlink" title="2. POJ 2259 Largest Rectangle in a Histogram "></a>2. <a href="https://vjudge.net/problem/POJ-2559">POJ 2259 Largest Rectangle in a Histogram </a></h4><h5 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h5><ul>
<li><p>有一个直方图，宽度为1，现给出一串数字，表示直方图每一段的高度，要求求出直方图所围成的最大矩形面积。</p>
<p>Sample Input</p>
<figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">7 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">1000</span> <span class="hljs-number">1000</span> <span class="hljs-number">1000</span> <span class="hljs-number">1000</span><br><span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-number">8</span><br><span class="hljs-number">4000</span><br></code></pre></div></td></tr></table></figure>
<p>比如样例1的图如下：</p>
<p><img src="https://i.loli.net/2020/01/29/s1SKXNlWOymbiPJ.png" alt="image.png"></p>
</li>
</ul>
<h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h5><ul>
<li>我们发现，直方图的每一小段都对应着一个最大矩形，那么我们可以通过求这些矩形的最大值来求出答案；</li>
<li>具体的每一段最大矩形的求法：应用<strong>严格单调递增的</strong>单调栈按照上一题的方式，先从左往右撸一遍直方图，再从右往左撸一遍，把两次单调栈的答案记录下来并求和再减1，就得到了每一段对应的最大宽度，最后再乘以长度并求$max$即可。</li>
</ul>
<h5 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll a[<span class="hljs-number">100005</span>];<br>ll ans1[<span class="hljs-number">100005</span>],ans2[<span class="hljs-number">100005</span>];<br>ll ans;<br>stack&lt;ll&gt; s;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	ll n;<br>	<span class="hljs-keyword">while</span>(cin&gt;&gt;n&amp;&amp;n)&#123;<br>		ans=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>()) s.<span class="hljs-built_in">pop</span>();<br>		<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i]);<br>			ans1[i]=ans2[i]=<span class="hljs-number">1</span>;<br>		&#125;<br>		<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>()&amp;&amp;a[i]&lt;=a[s.<span class="hljs-built_in">top</span>()])&#123;<br>				ans1[i]+=ans1[s.<span class="hljs-built_in">top</span>()];<br>				s.<span class="hljs-built_in">pop</span>();<br>			&#125;<br>			s.<span class="hljs-built_in">push</span>(i);<br>		&#125;<br>		<span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>()) s.<span class="hljs-built_in">pop</span>();<br>	<span class="hljs-comment">//	for(int i=1;i&lt;=n;i++) cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;;</span><br>		<span class="hljs-keyword">for</span>(ll i=n;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>			<span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>()&amp;&amp;a[i]&lt;=a[s.<span class="hljs-built_in">top</span>()])&#123;<br>				ans2[i]+=ans2[s.<span class="hljs-built_in">top</span>()];<br>				s.<span class="hljs-built_in">pop</span>();<br>			&#125;<br>			s.<span class="hljs-built_in">push</span>(i);<br>		&#125;<br>	<span class="hljs-comment">//	for(int i=1;i&lt;=n;i++) cout&lt;&lt;ans2[i]&lt;&lt;&quot; &quot;;</span><br>		<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			ans1[i]=(ans1[i]+ans2[i]<span class="hljs-number">-1</span>)*a[i];<br>			ans=<span class="hljs-built_in">max</span>(ans1[i],ans);<br>		&#125;<br>		cout&lt;&lt;ans&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-comment">//https://vjudge.net/problem/POJ-2559 </span><br></code></pre></div></td></tr></table></figure>
<h4 id="3-洛谷P1823-音乐会的等待"><a href="#3-洛谷P1823-音乐会的等待" class="headerlink" title="3. 洛谷P1823 音乐会的等待"></a>3. <a href="https://www.luogu.com.cn/problem/P1823">洛谷P1823 音乐会的等待</a></h4><h5 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h5><ul>
<li>N个人正在排队进入一个音乐会，队列中任意两个人A和B，如果他们是相邻或他们之间没有人比A或B高，那么他们是可以互相看得见的。写一个程序计算出有多少对人可以互相看见；</li>
<li>洛谷蓝题，比前面两题多了点坑。</li>
</ul>
<h5 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h5><ul>
<li><p>思考：我们从左至右依次观察，如果出现有一个人比前一个人高，那么这个人之后的任何一个人都不可能看到这个人之前的那一个人（写得有点绕），因此我们只需要维护一个<strong>单调递减的</strong>单调栈来处理这个问题就可以了；</p>
</li>
<li><p>想要A了这题还需要考虑到当前后两个人身高相同时，后面一个人看到的人数是前一个人看到的人数+1。</p>
</li>
</ul>
<h5 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll n,a[<span class="hljs-number">500005</span>];<br>ll ans[<span class="hljs-number">500005</span>];<br>stack&lt;ll&gt; s;<br>ll anss;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;n;<br>	<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		cin&gt;&gt;a[i];<br>		ans[i]=<span class="hljs-number">1</span>; <span class="hljs-comment">//方便相加</span><br>	&#125;<br>	<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>()&amp;&amp;a[i]&gt;=a[s.<span class="hljs-built_in">top</span>()])&#123;<br>			anss+=ans[s.<span class="hljs-built_in">top</span>()];<br>			<span class="hljs-keyword">if</span>(a[s.<span class="hljs-built_in">top</span>()]==a[i]) ans[i]+=ans[s.<span class="hljs-built_in">top</span>()]; <span class="hljs-comment">//两人等高时的情况</span><br>			s.<span class="hljs-built_in">pop</span>();<br>		&#125;<br>		<span class="hljs-keyword">if</span>(!s.<span class="hljs-built_in">empty</span>()) anss++;<br>		s.<span class="hljs-built_in">push</span>(i);<br>	<span class="hljs-comment">//	cout&lt;&lt;&quot;ans&quot;&lt;&lt;i&lt;&lt;&quot;=&quot;&lt;&lt;ans[i]&lt;&lt;endl;</span><br>	&#125;<br>	cout&lt;&lt;anss&lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-comment">//https://www.luogu.com.cn/problem/P1823</span><br></code></pre></div></td></tr></table></figure>
<hr>
<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul>
<li>顾名思义，就是满足<strong>单调性</strong>的<strong>队列</strong>结构，可以是单调递增or递减or自己定义。</li>
</ul>
<h3 id="练习题-1"><a href="#练习题-1" class="headerlink" title="练习题"></a>练习题</h3><h4 id="1-洛谷P1886-滑动窗口"><a href="#1-洛谷P1886-滑动窗口" class="headerlink" title="1. 洛谷P1886 滑动窗口"></a>1. <a href="https://www.luogu.com.cn/problem/P1886">洛谷P1886 滑动窗口</a></h4><h5 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h5><ul>
<li>有一个长为$n$的序列$a$，以及一个大小为$k$的窗口，现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的<strong>最大值</strong>和<strong>最小值</strong>。</li>
</ul>
<p>Sample Input</p>
<figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">8 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> -<span class="hljs-number">1</span> -<span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span><br></code></pre></div></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight subunit"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs subunit"><span class="hljs-string">-1</span> <span class="hljs-string">-3</span> <span class="hljs-string">-3</span> <span class="hljs-string">-3</span> 3 3<br>3 3 5 5 6 7<br></code></pre></div></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/01/29/etpoBhC5dZa21sc.png" alt="image.png"></p>
<h5 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h5><ul>
<li><p>构造一个单调队列，在求最大值时单调递减，求最小值时单调递增，输出时输出每个队列中的front元素即可；</p>
</li>
<li><p>蒟蒻的我使用的是STL中的deque（双向队列），中间处理过程较复杂，一定不是最优的方法，就当练习了一下deque的用法吧。</p>
</li>
</ul>
<h5 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码"></a>AC代码</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>deque&lt;<span class="hljs-type">int</span>&gt; q1;<br>deque&lt;<span class="hljs-type">int</span>&gt; q2;<br><span class="hljs-type">int</span> a[<span class="hljs-number">1000005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> n,k;<br>	cin&gt;&gt;n&gt;&gt;k;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//构造单调递增队列</span><br>		<span class="hljs-keyword">while</span>(!q2.<span class="hljs-built_in">empty</span>()&amp;&amp;a[i]&lt;a[q2.<span class="hljs-built_in">back</span>()])&#123;<br>			q2.<span class="hljs-built_in">pop_back</span>();<br>		&#125;<br>		q2.<span class="hljs-built_in">push_back</span>(i);<br>		<span class="hljs-keyword">if</span>(i-k+<span class="hljs-number">1</span>&gt;q2.<span class="hljs-built_in">front</span>()) q2.<span class="hljs-built_in">pop_front</span>(); <span class="hljs-comment">//处理越界问题</span><br>		<span class="hljs-keyword">if</span>(i&gt;=k) cout&lt;&lt;a[q2.<span class="hljs-built_in">front</span>()]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">//输出</span><br>	&#125;<br>	cout&lt;&lt;endl;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123; <span class="hljs-comment">//单调递减队列</span><br>		<span class="hljs-keyword">while</span>(!q1.<span class="hljs-built_in">empty</span>()&amp;&amp;a[i]&gt;=a[q1.<span class="hljs-built_in">back</span>()])&#123;<br>			q1.<span class="hljs-built_in">pop_back</span>();<br>		&#125;<br>		q1.<span class="hljs-built_in">push_back</span>(i);<br>		<span class="hljs-keyword">if</span>(i-k+<span class="hljs-number">1</span>&gt;q1.<span class="hljs-built_in">front</span>()) q1.<span class="hljs-built_in">pop_front</span>(); <span class="hljs-comment">//同上</span><br>		<span class="hljs-keyword">if</span>(i&gt;=k) cout&lt;&lt;a[q1.<span class="hljs-built_in">front</span>()]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-comment">//https://www.luogu.com.cn/problem/P1886</span><br></code></pre></div></td></tr></table></figure>
<hr>
<ul>
<li>总体来说<strong>单调栈</strong>的思维灵活性和难度更大一些，当然<strong>单调队列</strong>也十分有用，都需要细品。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈和队列</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论入门:Nim游戏&amp;SG函数</title>
    <url>/2020/05/02/%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%85%A5%E9%97%A8-Nim%E6%B8%B8%E6%88%8F-SG%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="博弈论のNim游戏-SG函数入门"><a href="#博弈论のNim游戏-SG函数入门" class="headerlink" title="博弈论のNim游戏&SG函数入门"></a><center>博弈论のNim游戏&SG函数入门</center></h2><span id="more"></span>
<p>参考blog：</p>
<ul>
<li><a href="https://blog.csdn.net/A_Comme_Amour/article/details/79347291">[学习笔记] （博弈论）Nim游戏和SG函数</a></li>
</ul>
<h2 id="Nim游戏-amp-博弈游戏基本概念"><a href="#Nim游戏-amp-博弈游戏基本概念" class="headerlink" title="Nim游戏&amp;博弈游戏基本概念"></a>Nim游戏&amp;博弈游戏基本概念</h2><p><a href="https://www.luogu.com.cn/problem/P2197">P2197 【模板】nim游戏</a></p>
<p>十分经典的博弈游戏，大致规则如下：有两名选手$Alice和Bob$，以及$N$堆石子，第$i$堆中有$A_i$个石子，两个人轮流从任意一堆中取出任意数量的石子（至少取1颗，至多取光这一堆所有石子），当一方无法行动时，另一方获胜，规定$Alice$先手，请你判断在两者足够聪明的情况下，谁会获得胜利？</p>
<p>这是一个典型的ICG游戏（公平组合游戏），对于ICG的定义如下：</p>
<ul>
<li>两名选手，轮流行动，每次行动可以在有限合法操作集合中选择一个</li>
<li>对于游戏的任何一种可能局面（Position），合法操作集合只取决于这个局面本身，与选手、以前的操作或其他任何因素无关，局面的改变称为“移动”</li>
<li>如果轮到某名移动，且当前局面的合法移动集合为空（无法移动），则该选手判负</li>
</ul>
<p>对于局面，在博弈论中，有更进一步的定义：</p>
<ul>
<li>P-Position：先手必败 局面</li>
<li>N-Position：先手必胜 局面</li>
</ul>
<p>他们有如下的性质：</p>
<ul>
<li>合法操作集合为空的局面是P局面</li>
<li>可以移动到P局面的局面是N局面</li>
<li>所有移动都只能到N局面的局面是P局面</li>
</ul>
<p>对于<strong>Nim游戏</strong>来说，它有一个神奇的结论：<strong>如果$N$堆石子的个数的异或和为$0$（即${xor}_{i=1}^nA_i=0$）则先手必败，否则先手必胜</strong></p>
<p>证明如下：</p>
<p><img src="https://i.loli.net/2020/05/02/xj3hVwQaZJ5Atyq.png" alt="image.png"></p>
<p>简单来说就是：如果当前异或和为0，则下一步操作一定会让异或和变为非零，再下一步操作有至少一种方案能使得异或和为0，如此循环下去，因此如果某一方开局异或和就为0，那么最后某一方的异或和肯定还是为0（即所有石子数量都为0，这是必败的）</p>
<h2 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h2><p>对于类似于Nim游戏这类ICG来说，都可以通过把局面看成点，每个局面和它的子局面连一条有向边从而抽象成为在一个DAG（有向无环图）上进行的游戏，为了解决通常情况下的ICG游戏问题，便有了定义在DAG上的SG函数</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>先介绍一下$mex$运算：最小的不属于这个集合的非负整数，例如：$mex{0,1,2,4}=3、mex{2,3,5}=0$</p>
<p>对于一个给定的有向无环图，定义关于图的每个顶点的SG函数如下：</p>
<p>$SG(x)=mex{SG(y)|y是x的后继}$，即 <strong>一个点的SG函数为在它所有后继的SG函数未出现过的最小值</strong></p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul>
<li>对于无后继的点$x$，它的$SG(x)=0$</li>
<li><p>对于一个$SG(x)=0$的点，如果他有后继，则它的所有后继都满足$SG(y)\neq 0$</p>
</li>
<li><p>对于一个$SG(x)\neq 0$的点，必定存在一个后继$y$满足$SG(y)=0$</p>
</li>
</ul>
<p>发现没有，该性质和ICG游戏的N、P局面是一一对应的，因此，可以理解为：顶点$x$所代表的局面是P局面（先手必败）当且仅当$SG(x)=0$</p>
<h3 id="SG定理"><a href="#SG定理" class="headerlink" title="SG定理"></a>SG定理</h3><script type="math/tex; mode=display">
\begin{aligned}
&对于任意游戏x的所有子游戏:x=x_1+x_2+x_3+...+x_n\\
&有:SG(x)=SG(x_1)xorSG(x_2)xorSG(x_3)...SG(x_n)\\
\end{aligned}</script><p>有了这个定理，其实也就就可以解释Nim游戏的P局面为什么是异或和为0先手必败了</p>
<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>例题：取石子问题，有1堆n个的石子，每次只能取${1,3,6}$个石子，先取完石子者胜利，则种局面的SG值为多少？</p>
<p>$x=0,SG(0)=0$</p>
<p>$x=1,可以取走1个石子，SG(1)=mex{SG(1-1)}=mex{SG(0)}=1$</p>
<p>$x=2,可以取走1个石子，SG(2)=mex{SG(2-1)}=mex{SG(1)}=0$</p>
<p>$x=3,可以取走1、3个石子，SG(3)=mex{SG(3-1),SG(3-3)}=mex{SG(2),SG(0)}=1$</p>
<p>$x=4,可以取走1、3个石子，SG(4)=mex{SG(4-1),SG(4-3)}=mex{SG(3),SG(1)}=0$</p>
<p>$x=5,可以取走1、3个石子，SG(5)=mex{SG(5-1),SG(5-3)}=mex{SG(4),SG(2)}=1$</p>
<p>$x=6,可以取走1、3、6个石子，SG(6)=mex{SG(6-1),SG(6-3),SG(6-6)}=mex{SG(5),SG(3),SG(0)}=2$</p>
<p>……</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">x</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th>8</th>
<th>…</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SG(x)</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td>2</td>
<td>…</td>
</tr>
</tbody>
</table>
</div>
<p>因此，如果有好几堆石子，则根据SG定理，整个游戏的SG函数值就是所有子游戏的SG函数值的异或和，这样便得出了Nim游戏的答案</p>
<h3 id="SG值计算方法"><a href="#SG值计算方法" class="headerlink" title="SG值计算方法"></a>SG值计算方法</h3><ol>
<li><p>可选步数为$[1,m]$的连续整数：直接取模即可，$SG(x)=x\ mod\ (m+1)$</p>
</li>
<li><p>可选步数为任意步：$SG(x)=x$</p>
</li>
<li>可选步数为一系列不连续的数（如例题）：用模板计算</li>
</ol>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">get_sg</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<span class="hljs-comment">//一堆有n个石子</span><br>    <span class="hljs-comment">//f是取法集合,功m种取法</span><br>    <span class="hljs-built_in">sort</span>(f+<span class="hljs-number">1</span>,f+<span class="hljs-number">1</span>+m);<span class="hljs-comment">//坑点，需要先排序，保证每种取法都循环到</span><br>    <span class="hljs-built_in">memset</span>(sg,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(sg));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<span class="hljs-comment">//标记sg函数值有没有出现过</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;f[j]&lt;=i&amp;&amp;j&lt;=m;j++)<br>            vis[sg[i-f[j]]]=<span class="hljs-number">1</span>;<span class="hljs-comment">//</span><br>       	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;j++)<br>            <span class="hljs-keyword">if</span>(vis[j]==<span class="hljs-number">0</span>)&#123;<br>                sg[i]=j;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="阶梯Nim"><a href="#阶梯Nim" class="headerlink" title="阶梯Nim"></a>阶梯Nim</h2><p>Nim游戏的变式：有一个$n$层的阶梯，层阶梯上放着不同数量的石子（如图所示），两个人轮流操作，每次可以从任意阶梯取走任意数量的石子放到下一级阶梯中，当一方无法操作时（所有石子都到达地面），另一方获胜</p>
<p><img src="https://i.loli.net/2020/05/02/Ja5hW23EHQUrNTb.png" alt="_5D228F52-337F-8BB8-8E41-FC55B110B0DE_.png" style="zoom:50%;" /></p>
<p>这个问题可以将它巧妙地转变成为奇数阶梯层的Nim游戏，为什么呢？</p>
<p>因为：如果对方将一些石子从奇数层放到了下一层（偶数层），那我们就按照Nim游戏一样从奇数层取石子；如果对方将石子从偶数层放到了下一层（奇数层），我们完全可以把对方放置的这一些石子在原封不动地放置到下一层（偶数层），这样一来，奇数层的石子没有发生变化，因此整个问题就转换为了奇数层的Nim游戏，将石子数求异或和判断是否为0即可</p>
<p>练习题：<a href="https://www.luogu.com.cn/problem/P2575">P2575 高手过招</a>（转化阶梯Nim+SG定理）</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> _,n,pan[<span class="hljs-number">21</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;_);_;_--)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>		<span class="hljs-type">int</span> x,k;<br>		<span class="hljs-type">int</span> ans2=<span class="hljs-number">0</span>;<br>		<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n)&#123;<br>			<span class="hljs-built_in">memset</span>(pan,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(pan));<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>			<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,x)&#123;<br>				<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;k);<br>				pan[k]=<span class="hljs-number">1</span>;<br>			&#125;<br>			<span class="hljs-type">int</span> tp=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>,ans1=<span class="hljs-number">0</span>;<br>			<span class="hljs-type">int</span> j=<span class="hljs-number">20</span>;<br>			<span class="hljs-keyword">while</span>(pan[j]) j--;<br>			j--;<br>			<span class="hljs-keyword">for</span>(;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br>				<span class="hljs-keyword">if</span>(!pan[j])&#123;<br>					++cnt;<br>					<span class="hljs-keyword">if</span>(cnt&amp;<span class="hljs-number">1</span>) ans1^=tp;<br>					tp=<span class="hljs-number">0</span>;<br>				&#125;<span class="hljs-keyword">else</span> tp++;<br>			&#125;<br>			ans2^=ans1;<br>		&#125;<br>		ans2?<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>):<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>卷积神经网络CNN(Convoluted Neural Network)</title>
    <url>/2020/02/15/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CCNN-Convoluted-Neural-Network/</url>
    <content><![CDATA[<h2 id="CNN简单介绍"><a href="#CNN简单介绍" class="headerlink" title="CNN简单介绍"></a><center>CNN简单介绍</center></h2><span id="more"></span>
<p>关于<strong>CNN卷积神经网络</strong>的知识点</p>
<hr>
<h2 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><h4 id="1-卷积层（Convolutional-Layer）"><a href="#1-卷积层（Convolutional-Layer）" class="headerlink" title="1. 卷积层（Convolutional Layer）"></a>1. 卷积层（Convolutional Layer）</h4><ul>
<li>设置卷积核和个数，设定步长，每次以卷积核尺寸为大小对原始图片矩阵不断进行卷积运算（说白了就是内积），如下图所示</li>
<li>我们发现卷积运算后，第一个feature_map中第三列绝对值最大，说明原始图片有一个竖直方向的特征，同理，第二个feature_map中第三列为0，第二行的绝对值最大，说明原始图片对应地方有一条水平方向的特征，以此类推</li>
<li>所以卷积核就相当于一个<strong>特征提取器</strong></li>
</ul>
<p><img src="https://i.loli.net/2020/02/15/xOjJG6k4bWa1IiX.png" alt="image.png"></p>
<h4 id="2-池化层（Pooling-Layer）"><a href="#2-池化层（Pooling-Layer）" class="headerlink" title="2. 池化层（Pooling Layer）"></a>2. 池化层（Pooling Layer）</h4><ul>
<li>通过上一层的22卷积核操作后，原来的44图像矩阵被缩小到33，而池化层则通过降采样的方式，在不影响图像质量的情况下压缩图片，减少参数，如下图（采用MaxPooling，大小为22，步长为1，取每个窗口最大值跟新）</li>
<li>通常采用如下两种池化方式：<ul>
<li>MaxPooling：取滑动窗口最大值</li>
<li>AveragePooling：取滑动窗口平均值</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2020/02/15/4wrgesiHySdmak1.png" alt="image.png"></p>
<ul>
<li>Zero Padding（补零）：为了使每次卷积或池化后的图片大小不变而采用的措施（简单数学计算而已）</li>
</ul>
<p><img src="https://i.loli.net/2020/02/15/H9rjSUvVbo2E7yF.png" alt="image.png"></p>
<h4 id="Flatten-Layer-amp-Fully-Connected-Layer"><a href="#Flatten-Layer-amp-Fully-Connected-Layer" class="headerlink" title="Flatten Layer &amp; Fully Connected Layer"></a>Flatten Layer &amp; Fully Connected Layer</h4><ul>
<li>做完上述两步后，就可以把数据“拍平”，丢到Flatten层，然后把Flatten层的output放到Full connected layer 里，然后用softmax对其进行分类</li>
</ul>
<p><img src="https://i.loli.net/2020/02/15/G68NQx7Yq2Xdohi.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>周报：2020.10.26 ~ 2020.11.1</title>
    <url>/2020/10/26/%E5%91%A8%E6%8A%A5%EF%BC%9A2020-10-26-2020-11-1/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<h2 id="2020-10-26-周一"><a href="#2020-10-26-周一" class="headerlink" title="2020.10.26 周一"></a>2020.10.26 周一</h2><p>已重构完SRT-LBM的顶盖驱动流C++代码（降低了一点常数复杂度），发现仍旧不能满足较大雷诺数的情况，查阅了相关文献后，发现使用MRT-LB模型（多松弛时间）似乎可以解决此问题，但仍旧较为复杂</p>
<p>研究了一晚上，发现高雷诺数的宏观大尺度流动模拟<del>可太难了</del>门槛和算力需求比较高，考虑临时更改模型为<strong>小尺度的自然对流流温耦合场模拟</strong>，这个应该会好做一些，而且可以应用在芯片散热这方面，目前的目标是先做一个简单的方腔自然对流流温耦合模型，大概就是何院士书中的如下案例：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201026205644980.png" alt="image-20201026205644980" style="zoom:50%;" /></p>
<p>然而，关于边界条件和一些变量的初始化还是没弄明白，明天继续</p>
<h2 id="2020-10-27"><a href="#2020-10-27" class="headerlink" title="2020.10.27"></a>2020.10.27</h2><p>今天先熟悉了一下<strong>非平衡态外推格式</strong>，在顶盖驱动流内部加了两个小方块作为练习样例，如下图所示：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/顶盖驱动 顶部方块.png" alt="顶盖驱动 顶部方块" style="zoom: 33%;" /></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/顶盖驱动 双方块.png" alt="顶盖驱动 双方块" style="zoom:33%;" /></p>
<h2 id="2020-10-28"><a href="#2020-10-28" class="headerlink" title="2020.10.28"></a>2020.10.28</h2><p>完成了结题答辩PPT的理论基础板块制作，并且这两天成功实现了LBM的两个经典算例：<strong>Couette流</strong>和<strong>Poiseuille流</strong>，如下图所示：</p>
<ul>
<li><p>Couette流：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201029235714276.png" alt="image-20201029235714276" style="zoom:33%;" /></p>
</li>
</ul>
<details>
    <summary>Couette Flow</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Q = <span class="hljs-number">9</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> NX = <span class="hljs-number">100</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> NY = <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> e[Q][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;&#125;;<br><span class="hljs-type">double</span> w[Q] = &#123;<span class="hljs-number">4.0</span>/<span class="hljs-number">9</span>,<span class="hljs-number">1.0</span>/<span class="hljs-number">9</span>,<span class="hljs-number">1.0</span>/<span class="hljs-number">9</span>,<span class="hljs-number">1.0</span>/<span class="hljs-number">9</span>,<span class="hljs-number">1.0</span>/<span class="hljs-number">9</span>,<span class="hljs-number">1.0</span>/<span class="hljs-number">36</span>,<span class="hljs-number">1.0</span>/<span class="hljs-number">36</span>,<span class="hljs-number">1.0</span>/<span class="hljs-number">36</span>,<span class="hljs-number">1.0</span>/<span class="hljs-number">36</span>&#125;;<br><span class="hljs-type">double</span> rho[NX+<span class="hljs-number">1</span>][NY+<span class="hljs-number">1</span>], u[NX+<span class="hljs-number">1</span>][NY+<span class="hljs-number">1</span>][<span class="hljs-number">2</span>], u0[NX+<span class="hljs-number">1</span>][NY+<span class="hljs-number">1</span>][<span class="hljs-number">2</span>], f[NX+<span class="hljs-number">1</span>][NY+<span class="hljs-number">1</span>][Q], F[NX+<span class="hljs-number">1</span>][NY+<span class="hljs-number">1</span>][Q];<br><span class="hljs-type">double</span> U,Re,dx,dy,dt,Lx,Ly,rho0,tau,niu,c,cs;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">feq</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">double</span> rho,<span class="hljs-type">double</span> u[<span class="hljs-number">2</span>])</span></span>&#123;<br>    <span class="hljs-type">double</span> res;<br>    <span class="hljs-type">double</span> eu = e[k][<span class="hljs-number">0</span>]*u[<span class="hljs-number">0</span>]+e[k][<span class="hljs-number">1</span>]*u[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">double</span> uu = u[<span class="hljs-number">0</span>]*u[<span class="hljs-number">0</span>]+u[<span class="hljs-number">1</span>]*u[<span class="hljs-number">1</span>];<br>    res = w[k] * rho * (<span class="hljs-number">1</span> + eu/(cs*cs) + (eu*eu)/(<span class="hljs-number">2</span>*cs*cs*cs*cs) - uu/(<span class="hljs-number">2</span>*cs*cs));<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    dx = <span class="hljs-number">1.0</span>;<br>    dy = <span class="hljs-number">1.0</span>;<br>    Lx = <span class="hljs-number">1.0</span>*dx*NX;<br>    Ly = <span class="hljs-number">1.0</span>*dy*NY;<br>    dt = <span class="hljs-number">1.0</span>;<br>    U = <span class="hljs-number">0.1</span>;<br>    rho0 = <span class="hljs-number">1.0</span>;<br>    Re = <span class="hljs-number">1000</span>;<br>    niu = U*Lx/Re;<br>    c = dx/dt;<br>    cs = c/<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">3.0</span>);<br>    tau = niu/(cs*cs) + <span class="hljs-number">0.5</span>*dt;<br>    <span class="hljs-built_in">memset</span>(u,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(u));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=NX;i++)&#123;<br>        u[i][NY][<span class="hljs-number">0</span>] = U; <span class="hljs-comment">// lid speed = U</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=NY;j++)&#123;<br>            rho[i][j] = rho0;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;Q;k++)&#123;<br>                f[i][j][k] = <span class="hljs-built_in">feq</span>(k,rho[i][j],u[i][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">evolution</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// collision &amp; streaming</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=NX;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;NY;j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;Q;k++)&#123;<br>                <span class="hljs-type">int</span> ip = i - e[k][<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> jp = j - e[k][<span class="hljs-number">1</span>];<br>                <span class="hljs-comment">// periodic boundary</span><br>                <span class="hljs-keyword">if</span>(ip&lt;<span class="hljs-number">0</span>) ip=NX;<br>                <span class="hljs-keyword">if</span>(ip&gt;NX) ip=<span class="hljs-number">0</span>;<br>                F[i][j][k] = f[ip][jp][k] + (<span class="hljs-built_in">feq</span>(k,rho[ip][jp],u[ip][jp]) - f[ip][jp][k])/tau;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(u0,u,<span class="hljs-built_in">sizeof</span>(u));<br>    <span class="hljs-built_in">memset</span>(rho,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(rho));<br>    <span class="hljs-built_in">memset</span>(u,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(u));<br><br>    <span class="hljs-comment">// for(int j=1;j&lt;NY;j++)&#123;</span><br>    <span class="hljs-comment">//     for(int k=0;k&lt;Q;k++)&#123;</span><br>    <span class="hljs-comment">//         if(k==1||k==5||k==8)&#123;</span><br>    <span class="hljs-comment">//             int ip = NX-e[k][0];</span><br>    <span class="hljs-comment">//             int jp = j-e[k][1];</span><br>    <span class="hljs-comment">//             F[NX][j][k] = f[ip][jp][k] + (feq(k,rho[ip][jp],u[ip][jp]) - f[ip][jp][k])/tau;</span><br>    <span class="hljs-comment">//         &#125;</span><br>    <span class="hljs-comment">//         if(k==3||k==6||k==7)&#123;</span><br>    <span class="hljs-comment">//             int ip = 0-e[k][0];</span><br>    <span class="hljs-comment">//             int jp = j-e[k][1];</span><br>    <span class="hljs-comment">//             F[0][j][k] = f[ip][jp][k] + (feq(k,rho[ip][jp],u[ip][jp]) - f[ip][jp][k])/tau;</span><br>    <span class="hljs-comment">//         &#125;</span><br>    <span class="hljs-comment">//         if(k==1||k==5||k==8)</span><br>    <span class="hljs-comment">//             F[0][j][k] = F[NX][j][k];</span><br>    <span class="hljs-comment">//         if(k==3||k==6||k==7)</span><br>    <span class="hljs-comment">//             F[NX][j][k] = F[0][j][k];</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">// &#125;</span><br><br>    <br><br>    <span class="hljs-comment">// get_macro_value</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=NX;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;NY;j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;Q;k++)&#123;<br>                f[i][j][k] = F[i][j][k];<br>                rho[i][j] += f[i][j][k];<br>                u[i][j][<span class="hljs-number">0</span>] += e[k][<span class="hljs-number">0</span>] * f[i][j][k];<br>                u[i][j][<span class="hljs-number">1</span>] += e[k][<span class="hljs-number">1</span>] * f[i][j][k];<br>            &#125;<br>            u[i][j][<span class="hljs-number">0</span>] /= rho[i][j];<br>            u[i][j][<span class="hljs-number">1</span>] /= rho[i][j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// top &amp; bottom boundary</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=NX;i++)&#123;<br>        rho[i][<span class="hljs-number">0</span>] = rho[i][<span class="hljs-number">1</span>];<br>        rho[i][NY] = rho[i][NY<span class="hljs-number">-1</span>];<br>        u[i][NY][<span class="hljs-number">0</span>] = U;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;Q;k++)&#123;<br>            f[i][<span class="hljs-number">0</span>][k] = <span class="hljs-built_in">feq</span>(k,rho[i][<span class="hljs-number">0</span>],u[i][<span class="hljs-number">0</span>]) + (<span class="hljs-number">1</span><span class="hljs-number">-1</span>/tau) * (f[i][<span class="hljs-number">1</span>][k] - <span class="hljs-built_in">feq</span>(k,rho[i][<span class="hljs-number">1</span>],u[i][<span class="hljs-number">1</span>]));<br>            f[i][NY][k] = <span class="hljs-built_in">feq</span>(k,rho[i][NY],u[i][NY]) + (<span class="hljs-number">1</span><span class="hljs-number">-1</span>/tau) * (f[i][NY<span class="hljs-number">-1</span>][k] - <span class="hljs-built_in">feq</span>(k,rho[i][NY<span class="hljs-number">-1</span>],u[i][NY<span class="hljs-number">-1</span>]));<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">ERR</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">double</span> tp1=<span class="hljs-number">0</span>,tp2=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;NX;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;NY;j++)&#123;<br>            tp1 += ((u[i][j][<span class="hljs-number">0</span>]-u0[i][j][<span class="hljs-number">0</span>])*(u[i][j][<span class="hljs-number">0</span>]-u0[i][j][<span class="hljs-number">0</span>])+(u[i][j][<span class="hljs-number">1</span>]-u0[i][j][<span class="hljs-number">1</span>])*(u[i][j][<span class="hljs-number">1</span>]-u0[i][j][<span class="hljs-number">1</span>]));<br>            tp2 += (u[i][j][<span class="hljs-number">0</span>]*u[i][j][<span class="hljs-number">0</span>]+u[i][j][<span class="hljs-number">1</span>]*u[i][j][<span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    tp1 = <span class="hljs-built_in">sqrt</span>(tp1);<br>    tp2 = <span class="hljs-built_in">sqrt</span>(tp2);<br>    <span class="hljs-keyword">return</span> tp1/(tp2+<span class="hljs-number">1e-30</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>&#123;<br>    ostringstream name;<br>    name&lt;&lt;<span class="hljs-string">&quot;couette_flow&quot;</span>&lt;&lt;num&lt;&lt;<span class="hljs-string">&quot;.dat&quot;</span>;<br>    <span class="hljs-function">ofstream <span class="hljs-title">out</span><span class="hljs-params">(name.str().c_str())</span></span>;<br>    out&lt;&lt;<span class="hljs-string">&quot;Title= \&quot;LBM Couette Flow\&quot;\n&quot;</span>&lt;&lt;<span class="hljs-string">&quot;VARIABLES=\&quot;X\&quot;,\&quot;Y\&quot;,\&quot;U\&quot;,\&quot;V\&quot;\n&quot;</span>&lt;&lt;<span class="hljs-string">&quot;ZONE T=\&quot;BOX\&quot;,I=&quot;</span>&lt;&lt;NX+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot;,J=&quot;</span>&lt;&lt;NY+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot;,F=POINT&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=NX;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=NY;j++)&#123;<br>            out&lt;&lt;<span class="hljs-built_in">double</span>(i)/Lx&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-built_in">double</span>(j)/Ly&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;u[i][j][<span class="hljs-number">0</span>]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;u[i][j][<span class="hljs-number">1</span>]&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;;i++)&#123;<br>        <span class="hljs-built_in">evolution</span>();<br>        <span class="hljs-keyword">if</span>(i%<span class="hljs-number">100</span>==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">double</span> error = <span class="hljs-built_in">ERR</span>();<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%dth error = %e\n&quot;</span>,i,error);<br>            <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">1000</span>)&#123;<br>                <span class="hljs-keyword">if</span>(i%<span class="hljs-number">1000</span>==<span class="hljs-number">0</span>) <span class="hljs-built_in">output</span>(i);<br>                <span class="hljs-keyword">if</span>(error&lt;<span class="hljs-number">1.0e-5</span>) <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<ul>
<li><p>Poiseuille流：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201029235758244.png" alt="image-20201029235758244" style="zoom:33%;" /></p>
</li>
</ul>
<details>
    <summary>Poiseuille Flow</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Q = <span class="hljs-number">9</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> NX = <span class="hljs-number">100</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> NY = <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> e[Q][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;&#125;;<br><span class="hljs-type">double</span> w[Q] = &#123;<span class="hljs-number">4.0</span>/<span class="hljs-number">9</span>,<span class="hljs-number">1.0</span>/<span class="hljs-number">9</span>,<span class="hljs-number">1.0</span>/<span class="hljs-number">9</span>,<span class="hljs-number">1.0</span>/<span class="hljs-number">9</span>,<span class="hljs-number">1.0</span>/<span class="hljs-number">9</span>,<span class="hljs-number">1.0</span>/<span class="hljs-number">36</span>,<span class="hljs-number">1.0</span>/<span class="hljs-number">36</span>,<span class="hljs-number">1.0</span>/<span class="hljs-number">36</span>,<span class="hljs-number">1.0</span>/<span class="hljs-number">36</span>&#125;;<br><span class="hljs-type">double</span> gamma[Q] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1.0</span>/<span class="hljs-number">3</span>,<span class="hljs-number">1.0</span>/<span class="hljs-number">3</span>,<span class="hljs-number">1.0</span>/<span class="hljs-number">3</span>,<span class="hljs-number">1.0</span>/<span class="hljs-number">3</span>,<span class="hljs-number">1.0</span>/<span class="hljs-number">12</span>,<span class="hljs-number">1.0</span>/<span class="hljs-number">12</span>,<span class="hljs-number">1.0</span>/<span class="hljs-number">12</span>,<span class="hljs-number">1.0</span>/<span class="hljs-number">12</span>&#125;;<br><span class="hljs-type">double</span> rho[NX+<span class="hljs-number">1</span>][NY+<span class="hljs-number">1</span>], u[NX+<span class="hljs-number">1</span>][NY+<span class="hljs-number">1</span>][<span class="hljs-number">2</span>], u0[NX+<span class="hljs-number">1</span>][NY+<span class="hljs-number">1</span>][<span class="hljs-number">2</span>], f[NX+<span class="hljs-number">1</span>][NY+<span class="hljs-number">1</span>][Q], F[NX+<span class="hljs-number">1</span>][NY+<span class="hljs-number">1</span>][Q];<br><span class="hljs-type">double</span> U,Re,dx,dy,dt,Lx,Ly,rho0,tau,niu,c,cs,f_x,f_y;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">rectangle</span><br>&#123;<br>    <span class="hljs-type">int</span> x1,y1,x2,y2;<br>&#125;rec[<span class="hljs-number">1</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">feq</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">double</span> rho,<span class="hljs-type">double</span> u[<span class="hljs-number">2</span>])</span></span>&#123;<br>    <span class="hljs-type">double</span> res;<br>    <span class="hljs-type">double</span> eu = e[k][<span class="hljs-number">0</span>]*u[<span class="hljs-number">0</span>]+e[k][<span class="hljs-number">1</span>]*u[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">double</span> uu = u[<span class="hljs-number">0</span>]*u[<span class="hljs-number">0</span>]+u[<span class="hljs-number">1</span>]*u[<span class="hljs-number">1</span>];<br>    res = w[k] * rho * (<span class="hljs-number">1</span> + eu/(cs*cs) + (eu*eu)/(<span class="hljs-number">2</span>*cs*cs*cs*cs) - uu/(<span class="hljs-number">2</span>*cs*cs));<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">inrec</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> id)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x&gt;=rec[id].x1&amp;&amp;x&lt;=rec[id].x2&amp;&amp;y&gt;=rec[id].y1&amp;&amp;y&lt;=rec[id].y2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">set_single_rec_geo</span><span class="hljs-params">(<span class="hljs-type">int</span> id,<span class="hljs-type">int</span> x1,<span class="hljs-type">int</span> y1,<span class="hljs-type">int</span> x2,<span class="hljs-type">int</span> y2)</span></span>&#123;<br>    rec[id] = rectangle&#123;x1,y1,x2,y2&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    dx = <span class="hljs-number">1.0</span>;<br>    dy = <span class="hljs-number">1.0</span>;<br>    Lx = <span class="hljs-number">1.0</span>*dx*NX;<br>    Ly = <span class="hljs-number">1.0</span>*dy*NY;<br>    dt = <span class="hljs-number">1.0</span>;<br>    rho0 = <span class="hljs-number">1.0</span>;<br>    f_x = <span class="hljs-number">1e-5</span>;<br>    f_y = <span class="hljs-number">0</span>;<br>    Re = <span class="hljs-number">3000</span>;<br>    niu = <span class="hljs-number">0.01</span>;<br>    c = dx/dt;<br>    cs = c/<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">3.0</span>);<br>    tau = niu/(cs*cs) + <span class="hljs-number">0.5</span>*dt;<br><br>    <span class="hljs-built_in">set_single_rec_geo</span>(<span class="hljs-number">0</span>,<span class="hljs-number">30</span>,<span class="hljs-number">30</span>,<span class="hljs-number">60</span>,<span class="hljs-number">60</span>);<br><br>    <span class="hljs-built_in">memset</span>(u,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(u));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=NX;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=NY;j++)&#123;<br>            rho[i][j] = rho0;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;Q;k++)&#123;<br>                f[i][j][k] = <span class="hljs-built_in">feq</span>(k,rho[i][j],u[i][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">evolution</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// collision &amp; streaming</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=NX;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;NY;j++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">inrec</span>(i,j,<span class="hljs-number">0</span>)) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;Q;k++)&#123;<br>                <span class="hljs-type">int</span> ip = i - e[k][<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> jp = j - e[k][<span class="hljs-number">1</span>];<br>                <span class="hljs-comment">// periodic boundary</span><br>                <span class="hljs-keyword">if</span>(ip&lt;<span class="hljs-number">0</span>) ip=NX;<br>                <span class="hljs-keyword">if</span>(ip&gt;NX) ip=<span class="hljs-number">0</span>;<br>                F[i][j][k] = f[ip][jp][k] + (<span class="hljs-built_in">feq</span>(k,rho[ip][jp],u[ip][jp]) - f[ip][jp][k])/tau;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(u0,u,<span class="hljs-built_in">sizeof</span>(u));<br>    <span class="hljs-built_in">memset</span>(rho,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(rho));<br>    <span class="hljs-built_in">memset</span>(u,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(u));<br><br>    <span class="hljs-comment">// get_macro_value</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=NX;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;NY;j++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">inrec</span>(i,j,<span class="hljs-number">0</span>)) rho[i][j] = <span class="hljs-number">1.0</span>;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;Q;k++)&#123;<br>                    f[i][j][k] = F[i][j][k] + gamma[k] * (f_x * e[k][<span class="hljs-number">0</span>] + f_y * e[k][<span class="hljs-number">1</span>]);<br>                    rho[i][j] += f[i][j][k];<br>                    u[i][j][<span class="hljs-number">0</span>] += e[k][<span class="hljs-number">0</span>] * f[i][j][k];<br>                    u[i][j][<span class="hljs-number">1</span>] += e[k][<span class="hljs-number">1</span>] * f[i][j][k];<br>                &#125;<br>            &#125;<br>            u[i][j][<span class="hljs-number">0</span>] /= rho[i][j];<br>            u[i][j][<span class="hljs-number">1</span>] /= rho[i][j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// top &amp; bottom boundary</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=NX;i++)&#123;<br>        rho[i][<span class="hljs-number">0</span>] = rho[i][<span class="hljs-number">1</span>];<br>        rho[i][NY] = rho[i][NY<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;Q;k++)&#123;<br>            f[i][<span class="hljs-number">0</span>][k] = <span class="hljs-built_in">feq</span>(k,rho[i][<span class="hljs-number">0</span>],u[i][<span class="hljs-number">0</span>]) + (<span class="hljs-number">1</span><span class="hljs-number">-1</span>/tau) * (f[i][<span class="hljs-number">1</span>][k] - <span class="hljs-built_in">feq</span>(k,rho[i][<span class="hljs-number">1</span>],u[i][<span class="hljs-number">1</span>]));<br>            f[i][NY][k] = <span class="hljs-built_in">feq</span>(k,rho[i][NY],u[i][NY]) + (<span class="hljs-number">1</span><span class="hljs-number">-1</span>/tau) * (f[i][NY<span class="hljs-number">-1</span>][k] - <span class="hljs-built_in">feq</span>(k,rho[i][NY<span class="hljs-number">-1</span>],u[i][NY<span class="hljs-number">-1</span>]));<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">ERR</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">double</span> tp1=<span class="hljs-number">0</span>,tp2=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;NX;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;NY;j++)&#123;<br>            tp1 += ((u[i][j][<span class="hljs-number">0</span>]-u0[i][j][<span class="hljs-number">0</span>])*(u[i][j][<span class="hljs-number">0</span>]-u0[i][j][<span class="hljs-number">0</span>])+(u[i][j][<span class="hljs-number">1</span>]-u0[i][j][<span class="hljs-number">1</span>])*(u[i][j][<span class="hljs-number">1</span>]-u0[i][j][<span class="hljs-number">1</span>]));<br>            tp2 += (u[i][j][<span class="hljs-number">0</span>]*u[i][j][<span class="hljs-number">0</span>]+u[i][j][<span class="hljs-number">1</span>]*u[i][j][<span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    tp1 = <span class="hljs-built_in">sqrt</span>(tp1);<br>    tp2 = <span class="hljs-built_in">sqrt</span>(tp2);<br>    <span class="hljs-keyword">return</span> tp1/(tp2+<span class="hljs-number">1e-30</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>&#123;<br>    ostringstream name;<br>    name&lt;&lt;<span class="hljs-string">&quot;poiseuille_flow_with_rec&quot;</span>&lt;&lt;num&lt;&lt;<span class="hljs-string">&quot;.dat&quot;</span>;<br>    <span class="hljs-function">ofstream <span class="hljs-title">out</span><span class="hljs-params">(name.str().c_str())</span></span>;<br>    out&lt;&lt;<span class="hljs-string">&quot;Title= \&quot;LBM Couette Flow\&quot;\n&quot;</span>&lt;&lt;<span class="hljs-string">&quot;VARIABLES=\&quot;X\&quot;,\&quot;Y\&quot;,\&quot;U\&quot;,\&quot;V\&quot;\n&quot;</span>&lt;&lt;<span class="hljs-string">&quot;ZONE T=\&quot;BOX\&quot;,I=&quot;</span>&lt;&lt;NX+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot;,J=&quot;</span>&lt;&lt;NY+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot;,F=POINT&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=NX;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=NY;j++)&#123;<br>            out&lt;&lt;<span class="hljs-built_in">double</span>(i)/Lx&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-built_in">double</span>(j)/Ly&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;u[i][j][<span class="hljs-number">0</span>]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;u[i][j][<span class="hljs-number">1</span>]&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;;i++)&#123;<br>        <span class="hljs-built_in">evolution</span>();<br>        <span class="hljs-keyword">if</span>(i%<span class="hljs-number">100</span>==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">double</span> error = <span class="hljs-built_in">ERR</span>();<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%dth error = %e\n&quot;</span>,i,error);<br>            <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">1000</span>)&#123;<br>                <span class="hljs-keyword">if</span>(i%<span class="hljs-number">1000</span>==<span class="hljs-number">0</span>) <span class="hljs-built_in">output</span>(i);<br>                <span class="hljs-keyword">if</span>(error&lt;<span class="hljs-number">1.0e-5</span>) <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<p>两个基本算例主要是熟悉两种边界条件处理格式：</p>
<ol>
<li>周期性边界格式</li>
<li>压力边界格式</li>
</ol>
<p>其中周期性边界处理只需要巧妙地利用<strong>模运算</strong>实现左壁和右壁边界分布函数的碰撞和迁移，即左壁面的右方向离散速度由右壁面确定，反之亦然。</p>
<h2 id="2020-10-29"><a href="#2020-10-29" class="headerlink" title="2020.10.29"></a>2020.10.29</h2><p>主要实现了对cpu芯片背后半导体排布的简单建模，大概就是模拟下面这个小方框里面的一些半导体块受横向流体作用时的流场速度分布</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/cpu.jpg" alt="cpu" style="zoom:33%;" /></p>
<p>模拟结果如下图所示：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/cpu_fx1e-5_25w lattice_2wdt_streamline.png" alt="cpu_fx1e-5_25w lattice_2wdt_streamline" style="zoom: 50%;" /></p>
<p>模拟使用的参数为：500*500的网格，格子运动粘度0.01，x正方向压力1e-5</p>
<p>可以看到在空当比较大的位置流体能很顺利地流过，而在中间空隙比较小的地方流体也可以通过，不过速度较小，类似于被”汽封“了；并且，在一些半导体块尾侧会出现卡门涡街，这属于可以预料到的情况。</p>
<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><ul>
<li>关于压力项和压力边界的理论基础现在还没有学习到位，需要后续继续着重学习</li>
<li>查到了一篇关于MRT-LBM的博文<a href="https://blog.csdn.net/weixin_37783345/article/details/102744924">CSDN: 力驱动泊萧叶流，基于 MRT-LBM 的流场与声场仿真计算 —王富海2017</a>，打算之后仔细看看，先码一下</li>
</ul>
<h2 id="2020-10-30-2020-10-31"><a href="#2020-10-30-2020-10-31" class="headerlink" title="2020.10.30 ~ 2020.10.31"></a>2020.10.30 ~ 2020.10.31</h2><p>基本上LBM的东西算是告一段落了，我不太想再搞下去了，已经约定好周日去交大见蔡老师了，目前LBM阶段性任务算是肝完了，先放一放了，这两天临时抱佛脚再仔细看看NLOS吧。</p>
<h2 id="2020-11-1"><a href="#2020-11-1" class="headerlink" title="2020.11.1"></a>2020.11.1</h2><p>啊~总算是给蔡老师一个交代了，我以为我一个月没啥进度，结果老师说我进度还不错，嘿嘿，关键让我高兴的是，我不用再做这个NLOS的东西啦，老师给我讲述了一下俺们课题组近年来的研究方向，并给我发了33篇关于计算光谱学的文献，从今天起，我要过上每天看文献的日子啦，我还主动跟老师说每周什么时候汇报一下，初步定了是<strong>每周一晚上</strong>，通过腾讯会议的方式，nice！终于有适合我的活干了，干巴得！</p>
]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>周报</tag>
      </tags>
  </entry>
  <entry>
    <title>周报: 2020.10.19 ~ 2020.10.25</title>
    <url>/2020/10/25/%E5%91%A8%E6%8A%A5-2020-10-19-2020-10-25/</url>
    <content><![CDATA[<p>由于很快要踏入研究生生活，为了提前适应每周需要开组会讨论的科研生活，在此blog搭建本人的周报、月报栏目，记录每日所做，每周周日上传周报，月底上传月报，本篇为第一篇，囍。<br><span id="more"></span></p>
<h2 id="2020-10-25-周日"><a href="#2020-10-25-周日" class="headerlink" title="2020.10.25 周日"></a>2020.10.25 周日</h2><p>由于今天是周日，就不分开写每天做了啥，简单总结一下这一周的工作</p>
<h3 id="实现了LBM简单案例——顶盖驱动流"><a href="#实现了LBM简单案例——顶盖驱动流" class="headerlink" title="实现了LBM简单案例——顶盖驱动流"></a>实现了LBM简单案例——顶盖驱动流</h3><p>参考blog：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/150569936">知乎：格子玻尔兹曼方法（Lattice Boltzmann Method）的简单应用-顶盖驱动流</a></li>
</ul>
<p>matlab的模拟结果如下图所示（当然它其实是个动图）：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201025154440608.png" alt="image-20201025154440608" style="zoom: 33%;" /></p>
<p>需要注意的是，matlab代码使用的边界条件为 <strong>非平衡态反弹格式</strong>（下面是我的笔记，从何雅玲院士书中提炼出的）：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201025155127434.png" alt="image-20201025155127434" style="zoom:50%;" /></p>
<p>然而这种边界处理对于高雷诺数情况下容易出现发散，对于本案例来说不是很友好，本人尝试将其改为了更为熟练的python代码，如下：</p>
<details>
    <summary>code</summary>

<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> mpl<br><br>Lx = <span class="hljs-number">100</span><br>Ly = <span class="hljs-number">100</span><br><br>dL = <span class="hljs-number">1</span><br>dT = <span class="hljs-number">1</span><br><br>NX = Lx // dL<br>NY = Ly // dL<br><br>w = [<span class="hljs-number">4</span>/<span class="hljs-number">9</span>, <span class="hljs-number">1</span>/<span class="hljs-number">9</span>, <span class="hljs-number">1</span>/<span class="hljs-number">9</span>, <span class="hljs-number">1</span>/<span class="hljs-number">9</span>, <span class="hljs-number">1</span>/<span class="hljs-number">9</span>, <span class="hljs-number">1</span>/<span class="hljs-number">36</span>, <span class="hljs-number">1</span>/<span class="hljs-number">36</span>, <span class="hljs-number">1</span>/<span class="hljs-number">36</span>, <span class="hljs-number">1</span>/<span class="hljs-number">36</span>]<br>e = [[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>], [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>], [-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>], [<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], [-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], [-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>], [<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>]]<br><br>X = np.arange(NX+<span class="hljs-number">1</span>)<br>Y = np.arange(NY+<span class="hljs-number">1</span>)<br>x,y = np.meshgrid(X,Y)<br><br><span class="hljs-comment"># plt.plot(x,y)</span><br><span class="hljs-comment"># plt.show()</span><br><br>rho = np.zeros((NX+<span class="hljs-number">1</span>,NY+<span class="hljs-number">1</span>))<br>u = np.zeros((NX+<span class="hljs-number">1</span>,NY+<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))<br>f = np.zeros((NX+<span class="hljs-number">1</span>,NY+<span class="hljs-number">1</span>,<span class="hljs-number">9</span>))<br>f_eq = np.zeros((NX+<span class="hljs-number">1</span>,NY+<span class="hljs-number">1</span>,<span class="hljs-number">9</span>))<br><br>c = dL / dT <br>c_s = c / <span class="hljs-number">3</span>**<span class="hljs-number">0.5</span><br>rho_0 = <span class="hljs-number">1</span> <span class="hljs-comment"># density_0</span><br>U = <span class="hljs-number">0.1</span> <span class="hljs-comment"># blank speed</span><br>Re = <span class="hljs-number">1000</span><br>nu = U * Lx / Re<br>tau = nu / c_s**<span class="hljs-number">2</span> + <span class="hljs-number">0.5</span> * dT <span class="hljs-comment"># relaxation time</span><br><br>rho[:,:] = rho_0<br>u[<span class="hljs-number">0</span>,:,<span class="hljs-number">0</span>] = U<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):<br>    f[:,:,i] = w[i] * rho[:,:] * (<span class="hljs-number">1</span> + (u[:,:,<span class="hljs-number">0</span>]*e[i][<span class="hljs-number">0</span>] + u[:,:,<span class="hljs-number">1</span>]*e[i][<span class="hljs-number">1</span>])/c_s**<span class="hljs-number">2</span> +(u[:,:,<span class="hljs-number">0</span>]*e[i][<span class="hljs-number">0</span>] + u[:,:,<span class="hljs-number">1</span>]*e[i][<span class="hljs-number">1</span>])**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*c_s**<span class="hljs-number">4</span>) - (u[:,:,<span class="hljs-number">0</span>]*u[:,:,<span class="hljs-number">0</span>] + u[:,:,<span class="hljs-number">1</span>]*u[:,:,<span class="hljs-number">1</span>])/(<span class="hljs-number">2</span>*c_s**<span class="hljs-number">2</span>))<br><br><span class="hljs-comment"># lbm</span><br>MaxIteration = <span class="hljs-number">100</span><br><span class="hljs-keyword">for</span> ite <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(MaxIteration):<br>    <span class="hljs-comment"># collision</span><br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):<br>        f_eq = w[k] * rho[:,:] * (<span class="hljs-number">1</span> + (u[:,:,<span class="hljs-number">0</span>]*e[k][<span class="hljs-number">0</span>] + u[:,:,<span class="hljs-number">1</span>]*e[k][<span class="hljs-number">1</span>])/c_s**<span class="hljs-number">2</span> +(u[:,:,<span class="hljs-number">0</span>]*e[k][<span class="hljs-number">0</span>] + u[:,:,<span class="hljs-number">1</span>]*e[k][<span class="hljs-number">1</span>])**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*c_s**<span class="hljs-number">4</span>) - (u[:,:,<span class="hljs-number">0</span>]*u[:,:,<span class="hljs-number">0</span>] + u[:,:,<span class="hljs-number">1</span>]*u[:,:,<span class="hljs-number">1</span>])/(<span class="hljs-number">2</span>*c_s**<span class="hljs-number">2</span>))<br>        f[:,:,k] += (f_eq - f[:,:,k]) * dT/tau<br>    <span class="hljs-comment"># print(&#x27;iteration:%d\n&#x27;%(ite+1),f,end=&#x27;\n------------\n&#x27;)</span><br>    <span class="hljs-comment"># streaming</span><br>    f[:,<span class="hljs-number">1</span>:,<span class="hljs-number">1</span>] = f[:,:NY,<span class="hljs-number">1</span>] <span class="hljs-comment"># left -&gt; right</span><br>    f[:,:NY,<span class="hljs-number">3</span>] = f[:,<span class="hljs-number">1</span>:,<span class="hljs-number">3</span>] <span class="hljs-comment"># right -&gt; left</span><br>    f[:NX,:,<span class="hljs-number">2</span>] = f[<span class="hljs-number">1</span>:,:,<span class="hljs-number">2</span>] <span class="hljs-comment"># bottom -&gt; top</span><br>    f[<span class="hljs-number">1</span>:,:,<span class="hljs-number">4</span>] = f[:NX,:,<span class="hljs-number">4</span>] <span class="hljs-comment"># top -&gt; bottom</span><br>    f[:NX,<span class="hljs-number">1</span>:,<span class="hljs-number">5</span>] = f[<span class="hljs-number">1</span>:,:NY,<span class="hljs-number">5</span>] <span class="hljs-comment"># leftbottom -&gt; righttop</span><br>    f[<span class="hljs-number">1</span>:,:NY,<span class="hljs-number">7</span>] = f[:NX,<span class="hljs-number">1</span>:,<span class="hljs-number">7</span>] <span class="hljs-comment"># righttop -&gt; leftbottom</span><br>    f[<span class="hljs-number">1</span>:,<span class="hljs-number">1</span>:,<span class="hljs-number">8</span>] = f[:NX,:NY,<span class="hljs-number">8</span>] <span class="hljs-comment"># lefttop -&gt; rightbottom</span><br>    f[:NX,:NY,<span class="hljs-number">6</span>] = f[<span class="hljs-number">1</span>:,<span class="hljs-number">1</span>:,<span class="hljs-number">6</span>] <span class="hljs-comment"># rightbottom -&gt; lefttop</span><br><br>    <span class="hljs-comment"># boundary condition</span><br>    <span class="hljs-comment"># left bounce back</span><br>    f[:,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>] = f[:,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>]<br>    f[:,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>] = f[:,<span class="hljs-number">0</span>,<span class="hljs-number">7</span>]<br>    f[:,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>] = f[:,<span class="hljs-number">0</span>,<span class="hljs-number">6</span>]<br><br>    <span class="hljs-comment"># right bounce back</span><br>    f[:,NY,<span class="hljs-number">3</span>] = f[:,NY,<span class="hljs-number">1</span>]<br>    f[:,NY,<span class="hljs-number">6</span>] = f[:,NY,<span class="hljs-number">8</span>]<br>    f[:,NY,<span class="hljs-number">7</span>] = f[:,NY,<span class="hljs-number">5</span>]<br><br>    <span class="hljs-comment"># bottom bounce back</span><br>    f[NX,:,<span class="hljs-number">2</span>] = f[NX,:,<span class="hljs-number">4</span>]<br>    f[NX,:,<span class="hljs-number">5</span>] = f[NX,:,<span class="hljs-number">7</span>]<br>    f[NX,:,<span class="hljs-number">6</span>] = f[NX,:,<span class="hljs-number">8</span>]<br><br>    <span class="hljs-comment"># moving lid</span><br>    rho_temp = f[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>:NY,<span class="hljs-number">0</span>]+f[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>:NY,<span class="hljs-number">1</span>]+f[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>:NY,<span class="hljs-number">3</span>]+<span class="hljs-number">2</span>*(f[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>:NY,<span class="hljs-number">2</span>]+f[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>:NY,<span class="hljs-number">5</span>]+f[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>:NY,<span class="hljs-number">6</span>])<br>    f[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>:NY,<span class="hljs-number">4</span>] = f[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>:NY,<span class="hljs-number">2</span>]<br>    f[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>:NY,<span class="hljs-number">7</span>] = <span class="hljs-number">0.5</span>*f[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>:NY,<span class="hljs-number">1</span>]-<span class="hljs-number">0.5</span>*f[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>:NY,<span class="hljs-number">3</span>]+f[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>:NY,<span class="hljs-number">5</span>]-<span class="hljs-number">0.5</span>*rho_temp*U<br>    f[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>:NY,<span class="hljs-number">8</span>] = <span class="hljs-number">0.5</span>*f[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>:NY,<span class="hljs-number">3</span>]-<span class="hljs-number">0.5</span>*f[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>:NY,<span class="hljs-number">1</span>]+f[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>:NY,<span class="hljs-number">6</span>]+<span class="hljs-number">0.5</span>*rho_temp*U<br><br>    rho = np.<span class="hljs-built_in">sum</span>(f,axis=<span class="hljs-number">2</span>)<br><br>    u = np.zeros((NX+<span class="hljs-number">1</span>,NY+<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):<br>        u[:,:,<span class="hljs-number">0</span>] += f[:,:,k]*e[k][<span class="hljs-number">0</span>]<br>        u[:,:,<span class="hljs-number">1</span>] += f[:,:,k]*e[k][<span class="hljs-number">1</span>]<br><br>    u[:,:,<span class="hljs-number">0</span>] /= rho<br>    u[:,:,<span class="hljs-number">1</span>] /= rho<br><br>    u[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>:NY,<span class="hljs-number">0</span>] = U<br>    u[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>:NY,<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br><br>u_norm = (u[:,:,<span class="hljs-number">0</span>]**<span class="hljs-number">2</span> + u[:,:,<span class="hljs-number">1</span>]**<span class="hljs-number">2</span>)**<span class="hljs-number">0.5</span><br>plt.imshow(u_norm)<br>plt.colorbar()<br>plt.show()<br></code></pre></div></td></tr></table></figure>

</details>

<p>仍旧会出现发散情况，于是继续查阅资料，在何雅玲院士的书中发现了对于速度边界更为好用的<strong>非平衡态外推格式</strong>：（附上书上原文和我的简单笔记）</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/非平衡态外推格式.png" alt="非平衡态外推格式"></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201025155752200.png" alt="image-20201025155752200" style="zoom:50%;" /></p>
<p>简单来说就是：对于边界上的节点，若宏观参数未知（比如：密度$\rho$），则用相邻节点的已知参数代替，并用相邻节点的非平衡态函数代替此节点的非平衡态函数，然后加上碰撞项，即可得到此节点的分布函数，最终公式为：（其中O为边界节点，B为其相邻节点）</p>
<script type="math/tex; mode=display">
f_{\alpha}(O,t) = f_{\alpha}^{eq}(O,t) + (1 - \frac{1}{\tau})\left[f_{\alpha}(B,t) - f_{\alpha}^{eq}(B,t)\right]</script><p>考虑用C++重构代码，并用tecplot绘制流场图，发现可以任意调整Re数都不会出现发散的情况，其中Re=1000的情况如下图所示：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201025160511465.png" alt="image-20201025160511465" style="zoom: 50%;" /></p>
<p>何院士的代码：</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Q=<span class="hljs-number">9</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> NX=<span class="hljs-number">256</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> NY=<span class="hljs-number">256</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> U=<span class="hljs-number">0.1</span>;<br><span class="hljs-type">int</span> e[Q][<span class="hljs-number">2</span>]=&#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;&#125;;<br><span class="hljs-type">double</span> w[Q]=&#123;<span class="hljs-number">4.0</span>/<span class="hljs-number">9</span>,<span class="hljs-number">1.0</span>/<span class="hljs-number">9</span>,<span class="hljs-number">1.0</span>/<span class="hljs-number">9</span>,<span class="hljs-number">1.0</span>/<span class="hljs-number">9</span>,<span class="hljs-number">1.0</span>/<span class="hljs-number">9</span>,<span class="hljs-number">1.0</span>/<span class="hljs-number">36</span>,<span class="hljs-number">1.0</span>/<span class="hljs-number">36</span>,<span class="hljs-number">1.0</span>/<span class="hljs-number">36</span>,<span class="hljs-number">1.0</span>/<span class="hljs-number">36</span>&#125;;<br><span class="hljs-type">double</span> rho[NX+<span class="hljs-number">1</span>][NY+<span class="hljs-number">1</span>],u[NX+<span class="hljs-number">1</span>][NY+<span class="hljs-number">1</span>][<span class="hljs-number">2</span>],u0[NX+<span class="hljs-number">1</span>][NY+<span class="hljs-number">1</span>][<span class="hljs-number">2</span>],f[NX+<span class="hljs-number">1</span>][NY+<span class="hljs-number">1</span>][Q],F[NX+<span class="hljs-number">1</span>][NY+<span class="hljs-number">1</span>][Q];<br><span class="hljs-type">int</span> i,j,k,ip,jp,n;<br><span class="hljs-type">double</span> c,Re,dx,dy,Lx,Ly,dt,rho0,P0,tau_f,niu,error;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">feq</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">double</span> rho,<span class="hljs-type">double</span> u[<span class="hljs-number">2</span>])</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">evolution</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-keyword">for</span>(n=<span class="hljs-number">0</span>;;n++)&#123;<br>        <span class="hljs-built_in">evolution</span>();<br>        <span class="hljs-keyword">if</span>(n%<span class="hljs-number">100</span>==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">Error</span>();<br>            cout&lt;&lt;<span class="hljs-string">&quot;The&quot;</span>&lt;&lt;n&lt;&lt;<span class="hljs-string">&quot;th computation result:&quot;</span>&lt;&lt;endl&lt;&lt;<span class="hljs-string">&quot;The u,v of point (NX/2,NY/2)is : &quot;</span>&lt;&lt;<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">6</span>)&lt;&lt;u[NX/<span class="hljs-number">2</span>][NY/<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;u[NX/<span class="hljs-number">2</span>][NY/<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]&lt;&lt;endl;<br>            cout&lt;&lt;<span class="hljs-string">&quot;The max relative error of uv is:&quot;</span>&lt;&lt;<span class="hljs-built_in">setiosflags</span>(ios::scientific)&lt;&lt;error&lt;&lt;endl;<br>            <span class="hljs-keyword">if</span>(n&gt;=<span class="hljs-number">1000</span>)&#123;<br>                <span class="hljs-keyword">if</span>(n%<span class="hljs-number">1000</span>==<span class="hljs-number">0</span>) <span class="hljs-built_in">output</span>(n);<br>                <span class="hljs-keyword">if</span>(error&lt;<span class="hljs-number">1.0e-6</span>) <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    dx=<span class="hljs-number">1.0</span>;<br>    dy=<span class="hljs-number">1.0</span>;<br>    Lx=dx*<span class="hljs-built_in">double</span>(NY);<br>    Ly=dy*<span class="hljs-built_in">double</span>(NX);<br>    dt=dx;<br>    c=dx/dt;<br>    rho0=<span class="hljs-number">1.0</span>;<br>    Re=<span class="hljs-number">1000</span>;<br>    niu=U*Lx/Re;<br>    tau_f=<span class="hljs-number">3.0</span>*niu+<span class="hljs-number">0.5</span>;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;tau_f= &quot;</span>&lt;&lt;tau_f&lt;&lt;endl;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=NX;i++)<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;=NY;j++)&#123;<br>            u[i][j][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>            u[i][j][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>            rho[i][j]=rho0;<br>            u[i][NY][<span class="hljs-number">0</span>]=U;<br>            <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;Q;k++)&#123;<br>                f[i][j][k]=<span class="hljs-built_in">feq</span>(k,rho[i][j],u[i][j]);<br>            &#125;<br>        &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">feq</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">double</span> rho,<span class="hljs-type">double</span> u[<span class="hljs-number">2</span>])</span></span>&#123;<br>    <span class="hljs-type">double</span> eu,uv,feq;<br>    eu=(e[k][<span class="hljs-number">0</span>]*u[<span class="hljs-number">0</span>]+e[k][<span class="hljs-number">1</span>]*u[<span class="hljs-number">1</span>]);<br>    uv=(u[<span class="hljs-number">0</span>]*u[<span class="hljs-number">0</span>]+u[<span class="hljs-number">1</span>]*u[<span class="hljs-number">1</span>]);<br>    feq=w[k]*rho*(<span class="hljs-number">1.0</span>+<span class="hljs-number">3.0</span>*eu+<span class="hljs-number">4.5</span>*eu*eu<span class="hljs-number">-1.5</span>*uv);<br>    <span class="hljs-keyword">return</span> feq;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">evolution</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// collision</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;NX;i++)<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;NY;j++)<br>            <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;Q;k++)&#123;<br>                ip=i-e[k][<span class="hljs-number">0</span>];<br>                jp=j-e[k][<span class="hljs-number">1</span>];<br>                F[i][j][k]=f[ip][jp][k]+(<span class="hljs-built_in">feq</span>(k,rho[ip][jp],<br>                u[ip][jp])-f[ip][jp][k])/tau_f;<br>            &#125;<br>    <br>    <span class="hljs-comment">// streaming</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;NX;i++)<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;NY;j++)&#123;<br>            u0[i][j][<span class="hljs-number">0</span>]=u[i][j][<span class="hljs-number">0</span>];<br>            u0[i][j][<span class="hljs-number">1</span>]=u[i][j][<span class="hljs-number">1</span>];<br>            rho[i][j]=<span class="hljs-number">0</span>;<br>            u[i][j][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>            u[i][j][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;Q;k++)&#123;<br>                f[i][j][k]=F[i][j][k];<br>                rho[i][j]+=f[i][j][k];<br>                u[i][j][<span class="hljs-number">0</span>]+=e[k][<span class="hljs-number">0</span>]*f[i][j][k];<br>                u[i][j][<span class="hljs-number">1</span>]+=e[k][<span class="hljs-number">1</span>]*f[i][j][k];<br>            &#125;<br>            u[i][j][<span class="hljs-number">0</span>]/=rho[i][j];<br>            u[i][j][<span class="hljs-number">1</span>]/=rho[i][j];<br>        &#125;<br>    <span class="hljs-comment">// left &amp; right boundary</span><br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;NY;j++)<br>        <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;Q;k++)&#123;<br>            rho[NX][j]=rho[NX<span class="hljs-number">-1</span>][j];<br>            f[NX][j][k]=<span class="hljs-built_in">feq</span>(k,rho[NX][j],u[NX][j])+(f[NX<span class="hljs-number">-1</span>][j][k]-<span class="hljs-built_in">feq</span>(k,rho[NX<span class="hljs-number">-1</span>][j],u[NX<span class="hljs-number">-1</span>][j]))*(<span class="hljs-number">1</span><span class="hljs-number">-1</span>/tau_f);<br>            rho[<span class="hljs-number">0</span>][j]=rho[<span class="hljs-number">1</span>][j];<br>            f[<span class="hljs-number">0</span>][j][k]=<span class="hljs-built_in">feq</span>(k,rho[<span class="hljs-number">0</span>][j],u[<span class="hljs-number">0</span>][j])+(f[<span class="hljs-number">1</span>][j][k]-<span class="hljs-built_in">feq</span>(k,rho[<span class="hljs-number">1</span>][j],u[<span class="hljs-number">1</span>][j]))*(<span class="hljs-number">1</span><span class="hljs-number">-1</span>/tau_f);<br>        &#125;<br><br>    <span class="hljs-comment">// top &amp; bottom boundary</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=NX;i++)<br>        <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;Q;k++)&#123;<br>            rho[i][<span class="hljs-number">0</span>]=rho[i][<span class="hljs-number">1</span>];<br>            f[i][<span class="hljs-number">0</span>][k]=<span class="hljs-built_in">feq</span>(k,rho[i][<span class="hljs-number">0</span>],u[i][<span class="hljs-number">0</span>])+(f[i][<span class="hljs-number">1</span>][k]-<span class="hljs-built_in">feq</span>(k,rho[i][<span class="hljs-number">1</span>],u[i][<span class="hljs-number">1</span>]))*(<span class="hljs-number">1</span><span class="hljs-number">-1</span>/tau_f);<br>            rho[i][NY]=rho[i][NY<span class="hljs-number">-1</span>];<br>            u[i][NY][<span class="hljs-number">0</span>]=U;<br>            f[i][NY][k]=<span class="hljs-built_in">feq</span>(k,rho[i][NY],u[i][NY])+(f[i][NY<span class="hljs-number">-1</span>][k]-<span class="hljs-built_in">feq</span>(k,rho[i][NY<span class="hljs-number">-1</span>],u[i][NY<span class="hljs-number">-1</span>]))*(<span class="hljs-number">1</span><span class="hljs-number">-1</span>/tau_f);<br>        &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span></span>&#123;<br>    ostringstream name;<br>    name&lt;&lt;<span class="hljs-string">&quot;cavity_100_&quot;</span>&lt;&lt;m&lt;&lt;<span class="hljs-string">&quot;.dat&quot;</span>;<br>    <span class="hljs-function">ofstream <span class="hljs-title">out</span><span class="hljs-params">(name.str().c_str())</span></span>;<br>    out&lt;&lt;<span class="hljs-string">&quot;Title= \&quot;LBM Lid Driven Flow\&quot;\n&quot;</span>&lt;&lt;<span class="hljs-string">&quot;VARIABLES=\&quot;X\&quot;,\&quot;Y\&quot;,\&quot;U\&quot;,\&quot;V\&quot;\n&quot;</span>&lt;&lt;<span class="hljs-string">&quot;ZONE T=\&quot;BOX\&quot;,I=&quot;</span>&lt;&lt;NX+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot;,J=&quot;</span>&lt;&lt;NY+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot;,F=POINT&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;=NY;j++)<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=NX;i++)&#123;<br>            out&lt;&lt;<span class="hljs-built_in">double</span>(i)/Lx&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-built_in">double</span>(j)/Ly&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;u[i][j][<span class="hljs-number">0</span>]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;u[i][j][<span class="hljs-number">1</span>]&lt;&lt;endl;<br>        &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">double</span> temp1,temp2;<br>    temp1=<span class="hljs-number">0</span>;<br>    temp2=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;NX;i++)<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;NY;j++)&#123;<br>            temp1 +=((u[i][j][<span class="hljs-number">0</span>]-u0[i][j][<span class="hljs-number">0</span>])*(u[i][j][<span class="hljs-number">0</span>]-u0[i][j][<span class="hljs-number">0</span>])+(u[i][j][<span class="hljs-number">1</span>]-u0[i][j][<span class="hljs-number">1</span>])*(u[i][j][<span class="hljs-number">1</span>]-u0[i][j][<span class="hljs-number">1</span>]));<br>            temp2 +=(u[i][j][<span class="hljs-number">0</span>]*u[i][j][<span class="hljs-number">0</span>]+u[i][j][<span class="hljs-number">1</span>]*u[i][j][<span class="hljs-number">1</span>]);<br>        &#125;<br>    temp1=<span class="hljs-built_in">sqrt</span>(temp1);<br>    temp2=<span class="hljs-built_in">sqrt</span>(temp2);<br>    error=temp1/(temp2+<span class="hljs-number">1e-30</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>



<h3 id="传统LBM方法对于大雷诺数的发散情况"><a href="#传统LBM方法对于大雷诺数的发散情况" class="headerlink" title="传统LBM方法对于大雷诺数的发散情况"></a>传统LBM方法对于大雷诺数的发散情况</h3><p>对于传统的均分网格lbm方法，对于雷诺数稍大一些（&gt;5000）的情况就会发散，十分让人头疼，因此需要考虑找到处理大雷诺数的情况，需要查阅文献找找方法</p>
<h3 id="利用python分割pdf文件"><a href="#利用python分割pdf文件" class="headerlink" title="利用python分割pdf文件"></a>利用python分割pdf文件</h3><p>今天给小组成员发了boltzmann方程的推导过程， 让他们熟悉熟悉，总不能啥也不干吧。。。（打算之后每周都发一点东西给他们看看）</p>
<p>为了更加人性化，我用python切割pdf文件，把电子书的一部分做成pdf发给他们，这样压力会小点，具体代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PyPDF2 <span class="hljs-keyword">import</span> PdfFileReader, PdfFileWriter<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">split</span>(<span class="hljs-params">path,name_tit</span>):<br>    pdf = PdfFileReader(path) <span class="hljs-comment"># 读取pdf文件</span><br>    pagestart = <span class="hljs-number">49</span> - <span class="hljs-number">1</span> <span class="hljs-comment"># 起始页</span><br>    pageend = <span class="hljs-number">52</span> - <span class="hljs-number">1</span> <span class="hljs-comment"># 结束页</span><br>    pdf_writer = PdfFileWriter() <span class="hljs-comment"># 创建写入对象</span><br>    <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(pagestart,pageend+<span class="hljs-number">1</span>):<br>        pdf_writer.addPage(pdf.getPage(idx)) <span class="hljs-comment"># 获取页面并添入</span><br>    output = <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;name_tit&#125;</span> <span class="hljs-subst">&#123;pagestart-<span class="hljs-number">7</span>&#125;</span>~<span class="hljs-subst">&#123;pageend-<span class="hljs-number">7</span>&#125;</span>.pdf&#x27;</span> <span class="hljs-comment"># 命名</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(output, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> output_file: <span class="hljs-comment"># 保存为pdf文件</span><br>        pdf_writer.write(output_file)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    paht = <span class="hljs-string">r&#x27;C:\Users\wlx\Desktop\专业创新实践\Boltzmann方法的理论及应用--何雅玲版.pdf&#x27;</span><br>    split(paht,<span class="hljs-string">&#x27;boltzmann method&#x27;</span>)<br><br></code></pre></div></td></tr></table></figure>
<h2 id="下周计划"><a href="#下周计划" class="headerlink" title="下周计划"></a>下周计划</h2><ul>
<li><p>重构一遍顶盖驱动流的C++代码，要熟练掌握</p>
</li>
<li><p>找到处理大雷诺数的方法</p>
</li>
<li><p>熟悉周期性边界条件</p>
</li>
<li><p>计算一个类似于下图所示的简单案例</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201025161043611.png" alt="image-20201025161043611" style="zoom:50%;" /></p>
</li>
<li><p>应用周期性边界条件，计算一个下图所示案例</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201025161226643.png" alt="image-20201025161226643" style="zoom:50%;" /></p>
</li>
</ul>
]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>周报</tag>
      </tags>
  </entry>
  <entry>
    <title>周报：2020-11-16~2020-11-22</title>
    <url>/2020/11/30/%E5%91%A8%E6%8A%A5%EF%BC%9A2020-11-16-2020-11-22/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<h2 id="Paper-1"><a href="#Paper-1" class="headerlink" title="Paper 1"></a>Paper 1</h2><h3 id="Titile"><a href="#Titile" class="headerlink" title="Titile"></a>Titile</h3><p>《多模光纤光谱仪，实现高分辨率+低损耗》</p>
<p><strong>[1]Redding Brandon,Cao Hui. Using a multimode fiber as a high-resolution, low-loss spectrometer.[J]. Optics letters,2012,37(16).</strong></p>
<h3 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h3><p>光线在光纤中传播，出口端光场分布（忽略磁场，主要是电场）方程为：</p>
<script type="math/tex; mode=display">
E(r,\theta,\lambda,L) = \sum_mA_m\Psi_m(r,\theta,\lambda)\exp[-i(\beta_m(\lambda)L-\omega t)]</script><p>光纤内部结构通常为 “纤芯+包膜” 形式，不同的导模会导致光线产生不同程度的反射、折射，同时，多模光纤就能够实现对不同波长光的不同导出模式，对应的光纤末端显现的光斑样貌也不同，通过铟镓砷相机捕获光斑，入射光的不同波长光在导模作用下产生不同光斑，依此构建映射关系，得出线性数学模型。</p>
<p>该文献定义了一个correlation function，只有当两个相邻波长光产生 基本上不同 的相关函数值时，才能认定该分辨率可行。</p>
<p>需要了解的是，越长的光纤，能够对入射光传递的变化也越大，即末端收到的信号差别也就越大，因此本论文使用了1m、2m、5m三种长度的光纤作对比。</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201130224302395.png" alt="image-20201130224302395" style="zoom:50%;" /></p>
<p>从空间和波长两个方面出发来离散化模型，得到的光斑和传递举证如下图所示</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201130224421654.png" alt="image-20201130224421654" style="zoom:50%;" /></p>
<h3 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h3><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201130224459507.png" alt="image-20201130224459507" style="zoom:50%;" /></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201130224526031.png" alt="image-20201130224526031" style="zoom:50%;" /></p>
<h2 id="Paper-2"><a href="#Paper-2" class="headerlink" title="Paper 2"></a>Paper 2</h2><h3 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h3><p>《高分辨率宽谱全光纤光谱仪》</p>
<p><strong>Redding B , Alam M , Seifert M , et al. High-resolution and broadband all-fiber spectrometers[J]. Optica, 2014, 1(3).</strong></p>
<h3 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h3><p>承接着上一篇文献，这篇把光纤长度扩展到了100m实现了1pm的分辨率，同时，把长度缩短到了4cm，实现了400~750nm的宽光谱重建。</p>
<p>实验装置是 单模（用于实现同一方向偏振的光） 接 多模（用于实现色散效果）</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201130225315210.png" alt="image-20201130225315210" style="zoom:50%;" /></p>
<p>同样，定义了一个相关函数，并且确定了分辨率为1.5pm</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201130225350184.png" alt="image-20201130225350184" style="zoom:50%;" /></p>
<h4 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h4><p>对于长光纤，有一个非常重要的问题，就是它受温度的影响很大，因为它太灵敏了，对于这个问题，作者提出了一个非常简单的数学方法：考虑温度$\delta T$的影响，对于光场函数$E(r,\theta,\lambda,L) = \sum_mA_m\Psi_m(r,\theta,\lambda)\exp[-i(\beta_m(\lambda)L-\omega t)]$的影响最大的一部分就是指数$\beta_mL$这一部分，因为这一部分乘了长度。</p>
<p>作者将同一波长下的温度变化引起的参数变化等效为不同波长下同意温度的参数值，即$\beta_m(\lambda+\delta\lambda,T)L(T) = \beta_m(\lambda,T+\delta T)L(T+\delta T)$，理论上来说，每个导模的波长变化都不同，但是，根据实验结果来看，小范围的温度波动对所有导模波长的影响都是相同的，因此上式成立。</p>
<p>从而可以选取一段波长的参数作为“基底”，实现简单的数学修正</p>
<h3 id="Results-1"><a href="#Results-1" class="headerlink" title="Results"></a>Results</h3><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201130230312911.png" alt="image-20201130230312911" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>周报</tag>
      </tags>
  </entry>
  <entry>
    <title>周报：2020-11-2 ~ 2020-11-8</title>
    <url>/2020/11/02/%E5%91%A8%E6%8A%A5%EF%BC%9A2020-11-2-2020-11-8/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<h2 id="Paper1"><a href="#Paper1" class="headerlink" title="Paper1"></a>Paper1</h2><h3 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h3><p>《基于滤光片光谱仪的目标光谱估计》</p>
<p><strong>[1] Chang Cheng-Chun,Lee Heung-No. On the estimation of target spectrum for filter-array based spectrometers.[J]. Optics express,2008,16(2).</strong></p>
<h3 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h3><p>采用性能较差但成本较低的滤光片（宽谱），利用NNLS（非负最小二乘）算法实现了光谱重建工作</p>
<h4 id="Models"><a href="#Models" class="headerlink" title="Models"></a>Models</h4><p>基本数学模型如下图所示：其中向量$r$为观测光谱，$s$为光源原本的光谱值</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/1.png" alt="1" style="zoom:50%;" /></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201110102316251.png" alt="image-20201110102316251" style="zoom:50%;" /></p>
<h4 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h4><p>把$s$看作模型参数，$r$是我们已经可以观测到的事件，目的就是需要估计这个模型参数值，也就是一个<strong>似然</strong>的过程，可以考虑<strong>最大后验概率估计MAP</strong>，但由于我们没有对模型参数$s$的先验知识，所以这个估计退化为<strong>极大似然估计MLE</strong><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201110102832221.png" alt="image-20201110102832221" style="zoom: 67%;" /></p>
<p>把$r$式代入，显然这个问题取决于噪声的分布情况，考虑将噪声设置为<strong>多元高斯分布</strong>，那么这个似然函数就变为了高斯函数<img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201110102959281.png" alt="image-20201110102959281" style="zoom:50%;" /></p>
<p>显然，这个函数取得最大值，等价于指数部分取得最小值，经过对指数部分的求导化简，得到解：<img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201110103144113.png" alt="image-20201110103144113" style="zoom:50%;" />，考虑将噪声函数设置为标准高斯分布，以及H矩阵设置为方正，就可以将解进一步化简为<img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201110103302247.png" alt="image-20201110103302247" style="zoom:50%;" /></p>
<p>同时，文献说明了在噪声高斯分布的均值为0的情况下，这些估计都是对于光源光谱的无偏估计</p>
<p>这里需要注意的点是：<strong>滤光片数量N和取样的波长数量M的关系</strong>，由于需要求解$(H^TH)^{-1}$，因此这个$M*M$的矩阵需要满秩，因此必须有$N\ge M$（否则这个矩阵的秩就是N了，不可能满秩了），也就是说滤光片数量需要足够多。同时，文献也简单证明了使用广义逆的有偏问题。</p>
<p>最后，文献介绍了两个算法：SVD（奇异值分解）和NNLS（非负最小二乘），前者就是利用SVD将H矩阵特征提取出来，设置一个Threshold来确定$s$；后者归结为求解下式<img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201110104617132.png" alt="image-20201110104617132" style="zoom:50%;" />，采用不断迭代的方法，最终总是可以收敛的。</p>
<h4 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h4><p>实验设备如下：数字相机（获取光源数据）+计算机（实现算法，绘出图像）+DSP板（数字信号处理）</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201110104106778.png" alt="image-20201110104106778" style="zoom:67%;" /></p>
<h4 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h4><p>Fig. 3为采用的宽谱滤光片情况，Fig. 4为实验结果，可以看出，NNLS能够很好地还原$s$，而SVD表现很差</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201110104804715.png" alt="image-20201110104804715" style="zoom:67%;" /></p>
]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>周报</tag>
      </tags>
  </entry>
  <entry>
    <title>周报：2020-11-23~2020-11-29</title>
    <url>/2020/11/30/%E5%91%A8%E6%8A%A5%EF%BC%9A2020-11-23-2020-11-29/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<p>这周的四篇论文，前三篇都是出自同一个团队，采用的方法类似，但侧重点不同</p>
<h2 id="Paper-1"><a href="#Paper-1" class="headerlink" title="Paper 1"></a>Paper 1</h2><h3 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h3><p>《选取稀疏模板实现滤光片光谱仪光谱重建》</p>
<p>Chang C C . Spectrum reconstruction for filter-array spectrum sensor from sparse template selection[J]. Optical Engineering, 2011.</p>
<h3 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h3><p>本文着重讲述了，在大规模的欠定线性方程组中，<strong>利用高斯曲线拟合整个光谱</strong>的方法，用<strong>吉洪诺夫正则化非负最小二乘</strong>方法实现比较合理的光谱重建</p>
<p>下图是文献核心算法部分</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201130231042683.png" alt="image-20201130231042683" style="zoom:50%;" /></p>
<p>同时，本文详细介绍了吉洪诺夫正则化（通常为L2正则化）和L1范数正则化方法</p>
<h3 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h3><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201130231221437.png" alt="image-20201130231221437" style="zoom:50%;" /></p>
<p>红线：NNLS；黑线：TNNLS；绿线：真值</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201130231308244.png" alt="image-20201130231308244" style="zoom:50%;" /></p>
<p>黑线：L1正则化方法</p>
<h2 id="Paper-2"><a href="#Paper-2" class="headerlink" title="Paper 2"></a>Paper 2</h2><h3 id="Title-1"><a href="#Title-1" class="headerlink" title="Title"></a>Title</h3><p>《基于光滤光片微型光谱仪的光谱重建自适应正则化方法》</p>
<p>Kurokawa U , Choi B I , Chang C C . Filter-Based Miniature Spectrometers: Spectrum Reconstruction Using Adaptive Regularization[J]. IEEE Sensors Journal, 2011, 11(7):1556-1563.</p>
<h3 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h3><p>本文着重于讲述了吉洪诺夫正则化参数的选取方法：L曲线方法和广义交叉验证法（GCV）</p>
<p>L曲线是类似与下图（我画的）的一种曲线，选取转折点为最优的正则化参数</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201130231825070.png" alt="image-20201130231825070" style="zoom:33%;" /></p>
<p>本文提到了 zeroth-order、first-order、second-order 的吉洪诺夫矩阵，本文着重展示了zeroth-order中应用L曲线的优势</p>
<h3 id="Results-1"><a href="#Results-1" class="headerlink" title="Results"></a>Results</h3><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201130232032636.png" alt="image-20201130232032636" style="zoom:50%;" /></p>
<p>结果显示，窄带光谱比宽谱要好重建，同时，在零阶吉洪诺夫矩阵下，L曲线要明显好于GCV方法</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201130232200124.png" alt="image-20201130232200124" style="zoom:50%;" /></p>
<p>最后，附录还提供了zeroth-order、first-order、second-order 三种吉洪诺夫矩阵的所有对比实验结果，供读者参考，可以发现的是，有些情况下GCV表现得要比L曲线好很多。</p>
<h2 id="Paper-3"><a href="#Paper-3" class="headerlink" title="Paper 3"></a>Paper 3</h2><h3 id="Title-2"><a href="#Title-2" class="headerlink" title="Title"></a>Title</h3><p>《芯片光谱仪光谱重建的新型非均匀性矫正算法》</p>
<p>Chang C C . Spectrum Reconstruction for On-Chip Spectrum Sensor Array Using a Novel Blind Nonuniformity Correction Method[J]. IEEE Sensors Journal, 2012, 12(8):2586-2592.</p>
<h3 id="Contents-1"><a href="#Contents-1" class="headerlink" title="Contents"></a>Contents</h3><p>本章侧重于描述 <strong>入射光照射在不同色散传感器上的光强分布不均匀性</strong> 问题，因此提出了一个迭代算法用于修正入射光权值系数</p>
<p>对于本问题，数学模型需要在前部乘上一个权重系数，然后利用TNNLS算法解决重建问题</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201130233323061.png" alt="image-20201130233323061" style="zoom:50%;" /></p>
<p>关键是修正权系数，算法流程如下，右侧是我写的证明算法收敛的笔记</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201130233507551.png" alt="image-20201130233507551" style="zoom:50%;" /></p>
<p>考虑到各种误差波动因素，所以需要对Setp6得出的A矩阵进行平滑操作，这里作者接了两个滤波操作（卷积）用来抹平噪声。</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201130233600359.png" alt="image-20201130233600359" style="zoom:50%;" /></p>
<h3 id="Results-2"><a href="#Results-2" class="headerlink" title="Results"></a>Results</h3><p>左边是模拟，右边是实验</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201130233823895.png" alt="image-20201130233823895"></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201130233851092.png" alt="image-20201130233851092"></p>
<p>可以看出，由于实际情况各种难以控制的因素影响，算法优化效果要劣于模拟结果，但是仍旧有很大的优化效果。</p>
<h2 id="Paper-4"><a href="#Paper-4" class="headerlink" title="Paper 4"></a>Paper 4</h2><h3 id="Title-3"><a href="#Title-3" class="headerlink" title="Title"></a>Title</h3><p>《基于液晶设备的压缩感知光谱测量方法》</p>
<p>August Y , Stern A . Compressive sensing spectrometry based on liquid crystal devices[J]. Optics Letters, 2013, 38(23):4996-4999.</p>
<h3 id="Contents-2"><a href="#Contents-2" class="headerlink" title="Contents"></a>Contents</h3><p>本文介绍了一种脱离于香农-奈奎斯特采样定理的新型<strong>稀疏采样方法</strong>——压缩感知，在目标频谱图稀疏的情况下，通过小规模的随机亚采样（而不是等间隔采样）方式，能够实现对原谱图的重建，该采样方式的理论可行性已经被证明。</p>
<p>下图是该实验装置图，作者采用各向异性的液晶作为色散元件，通过施加不同大小的电压幅值，使液晶方向发生改变，从而对光线产生不同程度的色散效果，进而可以建立线性方程组求解，可以看到在入射和出射处都加了线性偏振片，以保证光线的偏振效果相同。</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201201094635907.png" alt="image-20201201094635907" style="zoom:50%;" /></p>
<p>下方，左图为三种理论的液晶对应的光谱传递矩阵，右图为实验测得的结果</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201201094909515.png" alt="image-20201201094909515"></p>
<h3 id="Results-3"><a href="#Results-3" class="headerlink" title="Results"></a>Results</h3><p>最终，传递矩阵可以写为如下形式，作者采用了一些数学方法，将该矩阵等效为了部分的傅里叶矩阵$\phi_i = \frac{1}{2} - \frac{1}{2}\cos(\beta_i\omega)$</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201201095028629.png" alt="image-20201201095028629" style="zoom:50%;" /></p>
<p>最后，利用TwIST算法解最小二乘，以及Coiflets 3 小波变换实现稀疏采样，实现了重建工作</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201201095311609.png" alt="image-20201201095311609" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>周报</tag>
      </tags>
  </entry>
  <entry>
    <title>周报：2020-11-30~2020-12-6</title>
    <url>/2020/12/10/%E5%91%A8%E6%8A%A5%EF%BC%9A2020-11-30-2020-12-6/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<h2 id="Paper-1"><a href="#Paper-1" class="headerlink" title="Paper 1"></a>Paper 1</h2><h3 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h3><p>《基于非负矩阵分解数值方法的集成光子腔光谱技术》</p>
<p>[1] Huang Z , Xiong D , Zhang G , et al. Nonnegative Matrix Factorization Numerical Method for Integrated Photonic Cavity Based Spectroscopy[J]. Journal of Nanomaterials, 2014, 2014:1-5.</p>
<h3 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h3><p>数学模型与传统的光谱重建方法相同，最终都归结为一个解<strong>欠定线性方程组</strong>的问题，本文对于传递矩阵$T$的处理方式有所不同，它使用了线性代数方法 <strong>非负矩阵分解</strong></p>
<script type="math/tex; mode=display">
T \approx WH \\
V_{iu} \approx (WH)_{iu} = \sum_{a=1}^r = W_{ia}H_{au}</script><p>这样一来，一个大规模的欠定问题（Undetermined）就被降维了，因为一个$n\times m$的矩阵被标示位了一个$n\times r$和一个$r\times m$的矩阵的乘积，类似于接下来要看的压缩感知 </p>
<p>所选取的128个通道的滤波器如下图所示：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201210143043332.png" alt="image-20201210143043332" style="zoom:50%;" /></p>
<p>最终的解析解如下：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201210143119209.png" alt="image-20201210143119209" style="zoom:50%;" /></p>
<h3 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h3><p>重建结果要明显优于传统方法</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201210143225603.png" alt="image-20201210143225603" style="zoom:50%;" /></p>
<h2 id="Paper-2"><a href="#Paper-2" class="headerlink" title="Paper 2"></a>Paper 2</h2><p>这是一篇压缩感知经典文献，但是由于时间关系并没有看完，打算下周看完，并放在下周记录</p>
<h2 id="OMP-algorithm"><a href="#OMP-algorithm" class="headerlink" title="OMP algorithm"></a>OMP algorithm</h2><p>这周还完成了一个比较经典的压缩感知重建算法OMP算法（正交匹配追踪）， 它是传统的MP算法的改进</p>
<p>参考资料：</p>
<ul>
<li><p>[1] Pati Y C , Rezaiifar R , Krishnaprasad P S . Orthogonal Matching Pursuit: Recursive Function Approximation with Applications to Wavelet Decomposition[C]// 1993:40-44.</p>
</li>
<li><p>正交匹配跟踪算法OMP - 阿珺的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/52276805">https://zhuanlan.zhihu.com/p/52276805</a></p>
</li>
<li><p>形象易懂讲解算法II——压缩感知 - 咚懂咚懂咚的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/22445302">https://zhuanlan.zhihu.com/p/22445302</a></p>
</li>
</ul>
<h3 id="Contents-1"><a href="#Contents-1" class="headerlink" title="Contents"></a>Contents</h3><p>对于一个压缩感知问题，我们可以写成如下的一个矩阵表示的线性方程组形式</p>
<script type="math/tex; mode=display">
y = Ax</script><p>目前，已知向量$y$和压缩感知矩阵$A$，需要求向量$x$，令$y$的长度位$n$，$x$的长度为$m$，则满足$n&lt;&lt;m$，是一个典型的欠定问题</p>
<p>我们认为$A$的每一列元素都是一个基信号，称为<strong>原子</strong>，可以将A表示为</p>
<script type="math/tex; mode=display">
A = \pmatrix{a_1 & a_2 & ... & a_m}</script><p>于是，我们可以将$y$写成每一个$A$原子的线性组合：</p>
<script type="math/tex; mode=display">
Ax = a_1x_1 + a_2x_2 + a_3x_3 = y</script><p>OMP算法流程：</p>
<ol>
<li><p>定义一个<strong>残差</strong>值 $r$（初值为$y$），一个空的<strong>原子序列$A_{new}$</strong>，和一个空的<strong>稀疏系数值$x_{rec}$</strong></p>
</li>
<li><p><strong>计算A中每个原子对于残差$r$的贡献</strong>，即 计算 $\langle a_i,r\rangle$，并找到对y影响最大的原子，即 绝对值最大的原子：</p>
</li>
</ol>
<script type="math/tex; mode=display">
\mathop{\arg\max}_{a_i} |\langle a_i,r \rangle|\\或\\
\mathop{\arg\max}_{a_i} |A^Ty|</script><ol>
<li>将这个最大的贡献值定义为A与y的<strong>相关系数</strong>，并将这个原子加入<strong>原子序列</strong>中</li>
<li>计算该原子序列对于y的贡献，得到的值用于更新$x_{rec}$</li>
<li>从y中减去这个原子序列贡献的影响，得到新的残差，即 从y中减去所有与该原子序列有关的信息，使得新残差r与该原子序列正交，如下图所示：</li>
</ol>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/v2-1985176b8a57d50f94ab9f6d9ff0d4c2_1440w.jpg" alt="img"></p>
<ol>
<li>回到第2步，反复迭代，直到达到迭代次数 $I$（即 稀疏系数$K$）</li>
</ol>
<p>最终得到的$x_{rec}$即为我们需要的稀疏系数向量</p>
<p>需要注意的是：OMP算法要保证压缩感知矩阵A的每个列（原子）都两两不相关，否则容易出现错误的解</p>
<h3 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h3><p>这次用到的是一个$256\times256$的<code>lena.jpg</code>，重建单通道（Blue）像素值</p>
<p>采用DCT（离散余弦变换）作为<strong>系数基矩阵</strong>，随机的高斯分布为<strong>观测矩阵</strong></p>
<p>结果如下（其中，<code>k</code>为稀疏系数，<code>sample_rate</code>为采样率）</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/lena256_B.jpg" alt="lena256_B" style="zoom:50%;" /></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/B_different_k.jpg" alt="B_different_k"></p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><details>
    <summary>code</summary>

<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> scipy.optimize <span class="hljs-keyword">as</span> spopt<br><span class="hljs-keyword">import</span> scipy.fftpack <span class="hljs-keyword">as</span> spfft<br><span class="hljs-keyword">import</span> scipy.ndimage <span class="hljs-keyword">as</span> spimg<br><br><span class="hljs-comment"># OMP algorithm</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">OMP</span>(<span class="hljs-params">y,A,K</span>):<br>	col = A.shape[<span class="hljs-number">1</span>]<br>	residual = y<br>	ind = []<br>	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(K):<br>		prod = np.fabs(np.dot(A.T,residual))<br>		pos = np.argmax(prod)<br>		ind.append(pos)<br>		a = np.dot(np.linalg.pinv(A[:,ind]),y)<br>		residual = y-np.dot(A[:,ind],a)<br>	<br>	Res = np.zeros((col,))<br>	Res[ind] = a<br>	<span class="hljs-comment"># print(Res.shape)</span><br>	<span class="hljs-keyword">return</span> Res<br><br>img = cv2.imread(<span class="hljs-string">&quot;lena.jpg&quot;</span>)<br>img = img[<span class="hljs-number">128</span>:<span class="hljs-number">128</span>+<span class="hljs-number">256</span>, <span class="hljs-number">128</span>:<span class="hljs-number">128</span>+<span class="hljs-number">256</span>, <span class="hljs-number">0</span>]<br><br><span class="hljs-comment"># cv2.imshow(&quot;img&quot;,img)</span><br><span class="hljs-comment"># cv2.waitKey(0)</span><br><br><span class="hljs-comment"># radom gaussian matrix ----&gt; undersample</span><br>sample_rate = <span class="hljs-number">0.7</span><br>N = <span class="hljs-number">256</span><br>Phi = np.random.randn(<span class="hljs-built_in">int</span>(sample_rate*N),N)<br>Phi /= np.linalg.norm(Phi)<br><br><span class="hljs-comment"># plt.imshow(Phi)</span><br><span class="hljs-comment"># plt.colorbar()</span><br><span class="hljs-comment"># plt.show()</span><br><span class="hljs-comment"># exit(0)</span><br><br><br><span class="hljs-comment"># DCT matrix ----&gt; sparse base</span><br>Psi = np.zeros((N,N))<br>n = np.array(<span class="hljs-built_in">range</span>(N))<br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):<br>	Psi[k,:] = (<span class="hljs-number">2</span>/N)**<span class="hljs-number">0.5</span>*np.cos((<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>)*k*np.pi/<span class="hljs-number">2</span>/N)<br>Psi[<span class="hljs-number">0</span>,:] /= <span class="hljs-number">2</span>**<span class="hljs-number">0.5</span><br>Psi = Psi.T<br><br><span class="hljs-comment"># plt.imshow(Psi)</span><br><span class="hljs-comment"># plt.colorbar()</span><br><span class="hljs-comment"># plt.show()</span><br><span class="hljs-comment"># exit(0)</span><br><br><br><span class="hljs-comment"># measurement ----&gt; undersample image</span><br>measure_mat = np.dot(Phi,img)<br><br><span class="hljs-comment"># K coefficient for N colomns</span><br>sparse_coe = np.zeros((N,N))<br><br><span class="hljs-comment"># θ = Φ ψ</span><br>Theta = np.dot(Phi,Psi)<br><br><br>time_consume = []<br><span class="hljs-comment"># OMP for every colomn</span><br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>,<span class="hljs-number">40</span>,<span class="hljs-number">10</span>):<br>	st = time.perf_counter()<br>	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):<br>		sparse_coe[:,i] = OMP(measure_mat[:,i],Theta,k)<br>	en = time.perf_counter()<br>	img_rec = np.dot(Psi,sparse_coe)<br>	img_rec /= img_rec.<span class="hljs-built_in">max</span>()<br>	img_rec *= <span class="hljs-number">255</span><br>	img_rec = img_rec.astype(np.uint8)<br>	<span class="hljs-comment"># print(img_rec.shape)</span><br>	<span class="hljs-comment"># print(img.shape)</span><br>	<span class="hljs-comment"># cv2.imshow(&quot;img&quot;,img)</span><br>	cv2.imshow(<span class="hljs-string">&quot;rate=%.1f,k=%d&quot;</span>%(sample_rate,k),img_rec)<br>	sys.stdout.writelines(<span class="hljs-string">f&quot;rate=<span class="hljs-subst">&#123;sample_rate:<span class="hljs-number">.1</span>f&#125;</span>,k=<span class="hljs-subst">&#123;k&#125;</span> runtime:<span class="hljs-subst">&#123;en-st&#125;</span>s\n&quot;</span>)<br>	time_consume.append(en-st)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br><br><br><br><span class="hljs-comment"># sparse_coe[sparse_coe!=0] = 255</span><br><span class="hljs-comment"># sparse_coe = sparse_coe.astype(np.uint8)</span><br><span class="hljs-comment"># cv2.imshow(&quot;sparse_coe&quot;,sparse_coe)</span><br><span class="hljs-comment"># cv2.waitKey(0)</span><br><br><span class="hljs-comment"># plt.figure(figsize=(12,8))</span><br><span class="hljs-comment"># # plt.plot([i for i in range(256)],img[:,0])</span><br><span class="hljs-comment"># # plt.plot([i for i in range(256)],img_rec[:,0])</span><br><span class="hljs-comment"># # plt.legend([&#x27;origin&#x27;,&#x27;reconstruction&#x27;],fontsize=15)</span><br><span class="hljs-comment"># # plt.title(&#x27;Reconstruction result for column 0 with sample_rate=%.1f&#x27;%sample_rate, fontsize=15)</span><br><span class="hljs-comment"># plt.plot([i for i in range(10,110,10)],time_consume)</span><br><span class="hljs-comment"># plt.xlabel(&#x27;K coefficient&#x27;,fontsize=15)</span><br><span class="hljs-comment"># plt.ylabel(&#x27;consuming time(s)&#x27;,fontsize=15)</span><br><span class="hljs-comment"># plt.title(&#x27;Consuming time for different k value&#x27;,fontsize=20)</span><br><span class="hljs-comment"># plt.grid()</span><br><span class="hljs-comment"># plt.legend([&#x27;sample_rate=%.1f&#x27;%sample_rate],fontsize=15)</span><br><span class="hljs-comment"># plt.show()</span><br><br></code></pre></div></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>周报</tag>
      </tags>
  </entry>
  <entry>
    <title>周报：2020-11-9 ~ 2020-11-15</title>
    <url>/2020/11/10/%E5%91%A8%E6%8A%A5%EF%BC%9A2020-11-9-2020-11-15/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<h2 id="Paper-1"><a href="#Paper-1" class="headerlink" title="Paper 1"></a>Paper 1</h2><h3 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h3><p>《无序/随机介质透射阵：光谱偏振测量方法》</p>
<p><strong>[1] Kohlgraf-Owens Thomas W,Dogariu Aristide. Transmission matrices of random media: means for spectral polarimetric measurements.[J]. Optics letters,2010,35(13).</strong></p>
<h3 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h3><h4 id="Mechanism"><a href="#Mechanism" class="headerlink" title="Mechanism"></a>Mechanism</h4><p>Stokes vector &amp; 4 x 4 Meuller matrix</p>
<script type="math/tex; mode=display">
S = 
\begin{pmatrix}
I \\
Q \\
U \\
V
\end{pmatrix}
\\
M = 
\begin{pmatrix}
M_{11} & M_{12} & M_{13} & M_{14}\\
M_{21} & M_{22} & M_{23} & M_{24}\\
M_{31} & M_{32} & M_{33} & M_{34}\\
M_{41} & M_{42} & M_{43} & M_{44}\\
\end{pmatrix}\\
I = \bar M S</script><p>其中，$I=E_x^2(t) + E_y^2(t)$ 表示总光强</p>
<p>$Q = E_x^2(t) - E_y^2(t)$ 表示x轴线偏振光分量</p>
<p>$U = 2E_x(t)E_y(t)\cos[\delta_y(t)-\delta_x(t)]$ 表示45°方向线偏振光分量</p>
<p>$V = 2E_x(t)E_y(t)\sin[\delta_y(t)-\delta_x(t)]$ 表示右旋圆偏振光分量</p>
<p>且，显然有 $I^2 = Q^2 + U^2 + V^2$</p>
<p>如果仅仅是为了重建光强分布，只需要考虑Meuller矩阵的第一行即可</p>
<p>对于每一个波长，从 $I = \bar M S$ 可以重建得到 $\hat S = \bar M^{-1} I$，对于全体波长，可以通过对波长积分获得整体的总光强 $I_i = \int \bar M_i(\lambda)S(\lambda)d\lambda$</p>
<h4 id="Apparatus"><a href="#Apparatus" class="headerlink" title="Apparatus"></a>Apparatus</h4><p>$140\mu m$ 直径光纤束，$3\mu m$ 纤芯，一端覆盖$0.5\mu m$桂球，由于随机分布，测得平均光谱响应标准差为$24\%$，偏振特性标准差为$31\%$，另一端接CCD相机，配置两个光源，一个是OL490光源，FWHM 8nm，取样每3nm认为是恒定值，从520~580nm；另一个是AOTF，FWHM 2.5nm，取样每1.5nm认为恒定，从544~557.5nm</p>
<h4 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h4><p>对于单峰光谱、复杂光谱且偏振状况相同的情况、复杂光谱且偏振状况不同的情况，重建结果都十分可观，误差均可保证在1%~3%左右</p>
<h2 id="Paper-2"><a href="#Paper-2" class="headerlink" title="Paper 2"></a>Paper 2</h2><h3 id="Title-1"><a href="#Title-1" class="headerlink" title="Title"></a>Title</h3><p>《相位调制阵列的微型光谱仪》</p>
<p><strong>[1] Tao Yang,Yuchao Chen,Xing’ao Li,Wei Huang,Yongyuan Zhu. A micro-spectrometer with phase modulation array[J]. Frontiers of Optoelectronics,2014,7(1).</strong></p>
<h3 id="Contents-1"><a href="#Contents-1" class="headerlink" title="Contents"></a>Contents</h3><h4 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h4><p>在有机玻璃板（聚甲基丙烯酸甲酯，PMMA）上开设干涉凹槽作为干涉仪，玻璃板上侧照射光源，下侧连接CCD或CMOS板。不同的凹槽可以形成不同的干涉效应，通过对不同的干涉效应与CCD像素点间建立映射关系，形成线性方程组，并得到对应系数矩阵，完成数学建模过程，随后通过吉洪诺夫正则化方法的最小二乘法（即 岭回归）完成对入射光谱的反演重建。</p>
<h4 id="Results-1"><a href="#Results-1" class="headerlink" title="Results"></a>Results</h4><ol>
<li>重建分辨率足够高，能够达到9.35GHz的水平</li>
<li>能够重建宽波光谱，从300nm~1000nm（红外 ~ 紫外），且精度高</li>
<li>能够实现对复杂光谱的重建</li>
<li>由于影响重建效果的因素较多，作者总结出两点必须要满足的条件<ul>
<li>采样间隔要大于峰宽（否则会失真）</li>
<li>当两个相邻干涉仪（凹槽）得到的光强效果相同时，CCD上的像素要能够分辨出来</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>周报</tag>
      </tags>
  </entry>
  <entry>
    <title>周报：2020-12-14~2020-12-20</title>
    <url>/2020/12/17/%E5%91%A8%E6%8A%A5%EF%BC%9A2020-12-14-2020-12-20/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<p>本周主要研读了以下内容：</p>
<ul>
<li>中科院大学的刘铭鑫博士 的博士学位论文<strong>《基于压缩感知的编码孔径光谱成像技术研究》</strong></li>
<li>Correa C V , Arguello H , Arce G R . <strong>Spatio-spectral uniform multi-frame coded apertures for compressive spectral imaging</strong>[C]// IEEE Global Conference on Signal &amp; Information Processing. IEEE, 2015.</li>
<li>Rueda H , Lau D , Arce G R . <strong>RGB detectors on compressive snapshot multi-spectral imagers</strong>[C]// IEEE Global Conference on Signal &amp; Information Processing. IEEE, 2015.</li>
<li>Rueda H , Arguello H , Arce G R . <strong>Colored coded aperture compressive spectral imaging: Design and experimentation</strong>[C]// 2015 IEEE Global Conference on Signal and Information Processing (GlobalSIP). IEEE, 2015.</li>
<li>Rueda H , Arguello H , Arce G R . <strong>DMD-based implementation of patterned optical filter arrays for compressive spectral imaging</strong>[J]. Journal of the Optical Society of America A Optics Image Science &amp; Vision, 2015, 32(1):80-9.</li>
</ul>
<h2 id="Paper-1"><a href="#Paper-1" class="headerlink" title="Paper 1"></a>Paper 1</h2><h3 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h3><p>《空间-光谱均匀多帧/多框架编码孔径压缩光谱成像》</p>
<p>Correa C V , Arguello H , Arce G R . <strong>Spatio-spectral uniform multi-frame coded apertures for compressive spectral imaging</strong>[C]// IEEE Global Conference on Signal &amp; Information Processing. IEEE, 2015.</p>
<h3 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h3><p>取代随机分布的编码孔径，作者提出了一种新型的编码孔径（空间-光谱均匀编码孔径，简称SUM）</p>
<p>模型还是CASSI经典模型，公式如下：我在下方补充说明了一下，g为投射在探测器上的光强，F是初始光源，T为编码孔径矩阵，ω是噪声。关于式子中是$(m+k)$还是$(m-k)$并不重要，这取决于怎样定义色散轴的正方向<img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201217215735098.png" alt="image-20201217215735098"></p>
<p>使用单个编码孔径，最后投射到探测器上的有$N(N+L-1)\times N = NV$个元素，而初始有$N\times N\times L$个元素，因此压缩率为$NV/N^2L \approx 1/L$</p>
<p>如果使用$K$个编码孔径，则投射到探测器上有$KNV$个元素，因此采样率为$KNV/N^2L \approx K/L$</p>
<p>将$K$个编码孔径矩阵拼在一起，写成列向量的形式：</p>
<script type="math/tex; mode=display">
\mathbf{H} = [\mathbf H_0^T,...,\mathbf H_{K-1}^T]^T</script><p>下图呈现了一个$K=2,N=4,L=3$的编码孔径矩阵的结果</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201217220837061.png" alt="image-20201217220837061"></p>
<p>我做了一些注释，很好理解：</p>
<ul>
<li><p>横向子矩阵是同一个编码孔径对不同波段的采样结果，相邻的两个矩阵右边的会比左边的低$N$个元素的位置，这是因为每产生一次色散，该波段的图像就会偏离$N$个元素的位置，所以每个子矩阵的大小都是$N(N+L-1)\times N^2$</p>
</li>
<li><p>纵向则代表不同的编码孔径对应的矩阵$\mathbf H_i$</p>
</li>
</ul>
<p>根据RIP条件（约束等距性条件），作者提出了一种生成SUM编码的算法</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201217222019368.png" alt="image-20201217222019368"></p>
<h3 id="Experiments-amp-Results"><a href="#Experiments-amp-Results" class="headerlink" title="Experiments &amp; Results"></a>Experiments &amp; Results</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>使用空间分辨率为$128\times 128$，8个光谱段，光谱带介于450nm~620nm之间，做对比实验：伯努利随机分布的编码孔径($p=0.5$) 和 SUM编码孔径</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201217222219726.png" alt="image-20201217222219726"></p>
<p>发现SUM结果好于random：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201217222252229.png" alt="image-20201217222252229"></p>
<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>使用$128\times 128$像素，30个光谱段，400nm~700nm，K（编码孔径种类数）取2,4,6,8</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201217222416336.png" alt="image-20201217222416336"></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201217222432892.png" alt="image-20201217222432892"></p>
<h2 id="Paper-2"><a href="#Paper-2" class="headerlink" title="Paper 2"></a>Paper 2</h2><h3 id="Title-1"><a href="#Title-1" class="headerlink" title="Title"></a>Title</h3><p>《基于RGB探测器的压缩快照多光谱成像仪》</p>
<p>Rueda H , Lau D , Arce G R . <strong>RGB detectors on compressive snapshot multi-spectral imagers</strong>[C]// IEEE Global Conference on Signal &amp; Information Processing. IEEE, 2015.</p>
<h3 id="Contents-1"><a href="#Contents-1" class="headerlink" title="Contents"></a>Contents</h3><p>本文主要使用并对比了三种FPA探测器：</p>
<ol>
<li>传统单色（monochromatic）探测器</li>
<li>RGB-Bayer探测器（拜尔探测器）</li>
<li>Foven探测器</li>
</ol>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219192736580.png" alt="image-20201219192736580" style="zoom: 50%;" /></p>
<p>在数学模型中，作者将其写成了如下格式：</p>
<script type="math/tex; mode=display">
\mathbf{g=Hf=XPTf}</script><p>其中，$\mathbf T$代表编码矩阵，$\mathbf P$代表色散矩阵，$\mathbf X$代表FPA响应矩阵</p>
<p>仍旧需要解决一个带L1正则化的欠定最小二乘问题：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219193059421.png" alt="image-20201219193059421" style="zoom:67%;" /></p>
<h3 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h3><p>实验采用 宽带氙气灯 作为光源，光谱带宽范围为 450nm~670nm，光源像素为$256\times 256$，光谱数量$L=24$，编码孔径编码方式采用$p=0.5$的伯努利随机分布，优化算法采用GPSR，定义压缩率$R=K/L$，其中K为快照拍摄次数（注意：每一次拍照都换一个新的编码孔径）。</p>
<p>结果如下：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219193435370.png" alt="image-20201219193435370"></p>
<p>绝对误差图如下：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219194136329.png" alt="image-20201219194136329"></p>
<p>之后，作者又测试了两组数据立方体，L=31，分辨率$512\times 512$，结果分别如下：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219194244203.png" alt="image-20201219194244203"></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219194256647.png" alt="image-20201219194256647"></p>
<h3 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h3><p>结果显示，相较于传统的单色传感器：</p>
<ul>
<li>Foveon 传感器 有 3dB 的提升</li>
<li>Bayer 传感器 有 2dB 的提升</li>
</ul>
<h2 id="Paper-3"><a href="#Paper-3" class="headerlink" title="Paper 3"></a>Paper 3</h2><h3 id="Title-2"><a href="#Title-2" class="headerlink" title="Title"></a>Title</h3><p>《颜色编码孔径压缩光谱成像：设计与实验》</p>
<p>Rueda H , Arguello H , Arce G R . <strong>Colored coded aperture compressive spectral imaging: Design and experimentation</strong>[C]// 2015 IEEE Global Conference on Signal and Information Processing (GlobalSIP). IEEE, 2015.</p>
<h3 id="Contents-2"><a href="#Contents-2" class="headerlink" title="Contents"></a>Contents</h3><p>本文的方法类似于上一篇文章，与传统的Block-Unblock编码孔径（CA）不一样，本文提出了一种带颜色的编码孔径（CCA），使得采样结果与波长有关，从而降低混叠图像的相关性，能有效提高欠定问题的求解精确性，并且能实现尽可能少的快照拍摄次数来往成重建工作。</p>
<p>下图显示了传统的编码孔径和颜色编码孔径的对比：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219195620028.png" alt="image-20201219195620028"></p>
<p>模型还是如此：<img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219195643587.png" alt="image-20201219195643587" style="zoom:50%;" />，从而，有这么一个公式可以表示数据立方体的第$k$个光谱带 和 第$l$次快照使用的编码孔径的任意点的数据：<img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219195748065.png" alt="image-20201219195748065" style="zoom: 67%;" /></p>
<p>显然：$j-\lfloor\frac{j}{N}\rfloor N = j \mod N$，所以上式是展示 <strong>第$j$个数据对应的行和列</strong></p>
<p>色散效果对应的矩阵是一个 $N(N+L-1)\times N^2L$ 的矩阵，如下：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219200339487.png" alt="image-20201219200339487"></p>
<p>编码孔径对应一个 $T_{(N^2L\times N^2L)}$ 的对角阵，对应每个元素是否被block，将$\mathbf P$与$\mathbf T$相乘，得到如下采样矩阵：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219200457907.png" alt="image-20201219200457907" style="zoom:67%;" /></p>
<p>上图是传统CA与CCA的对比图，可以发现：</p>
<ul>
<li>CA对应的矩阵每一个光谱段编码模式相同，而CCA每一个光谱段编码模式不相同</li>
</ul>
<p>这是有利于欠定问题的解决的。</p>
<p>为了实现编码孔径的每个像素都能有2种及以上的滤光效果，作者制利用<strong>人造晶圆（Fabricated wafer）</strong>制作了这样的编码孔径，如下图所示：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219201831957.png" alt="image-20201219201831957"></p>
<p>最左侧显示了晶圆上的210个不同的编码孔径，每个编码孔径的编码模式不同，且都由低通和高通滤光片（尺寸约20$\mu m$）组成。</p>
<p>优化问题还是这样一个问题：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219202009172.png" alt="image-20201219202009172" style="zoom: 67%;" /></p>
<h3 id="Experiments-1"><a href="#Experiments-1" class="headerlink" title="Experiments"></a>Experiments</h3><p>FPA传感器像素大小 $7.4\mu m$，分辨率 $2048\times 2048$，用一个$3\times3$的super-pixel 窗口来匹配FPA与编码孔径大小（因为CA中的滤光片尺寸约$20\mu m\approx3\times 7.4\mu m$），采用GPSR优化算法。</p>
<h3 id="Results-1"><a href="#Results-1" class="headerlink" title="Results"></a>Results</h3><p>快照数 K=1、K=6 对比：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219204128637.png" alt="image-20201219204128637"></p>
<p>与原RGB图对比：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219204215181.png" alt="image-20201219204215181"></p>
<h2 id="Paper-4"><a href="#Paper-4" class="headerlink" title="Paper 4"></a>Paper 4</h2><h3 id="Title-3"><a href="#Title-3" class="headerlink" title="Title"></a>Title</h3><p>《基于DMD的模板滤光片阵列压缩光谱成像》</p>
<p>Rueda H , Arguello H , Arce G R . <strong>DMD-based implementation of patterned optical filter arrays for compressive spectral imaging</strong>[J]. Journal of the Optical Society of America A Optics Image Science &amp; Vision, 2015, 32(1):80-9.</p>
<h3 id="Contents-3"><a href="#Contents-3" class="headerlink" title="Contents"></a>Contents</h3><p>本文采用<strong>模板滤光片阵列</strong>取代传统的编码孔径，也就是彩色编码孔径CCA，它不仅可以调制空间维度，还可以同时调制光谱维度。</p>
<p>本文采用三种不同的滤光片L、H、B，分别对应着 低通滤波、高通滤波、带通滤波，采用<strong>DMD外接一系列滤光片</strong>实现，模型如下图：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219213617854.png" alt="image-20201219213617854"></p>
<p>能够实现如下图类似彩色编码孔径的效果：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219213829422.png" alt="image-20201219213829422" style="zoom:67%;" /></p>
<p>传统的数学模型：<img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219213920606.png" alt="image-20201219213920606" style="zoom:67%;" /></p>
<p>由于 编码孔径影响的是空间分辨率，而FPA和色散影响的是光谱分辨率，所以作者将其改写成下式：<img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219214011117.png" alt="image-20201219214011117" style="zoom:67%;" /></p>
<p>对于本文，数学模型需要改一改，因为<strong>不同的编码孔径滤过的光谱段是不同的</strong>：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219214204867.png" alt="image-20201219214204867"></p>
<p>其中，$\bar T_r(x,y)$ 对应三种波长响应不同的滤波器的block-unblock情况，于是成像问题就可以形象地用下图呈现：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219214622998.png" alt="image-20201219214622998" style="zoom:67%;" /></p>
<p>定义CCA的透过率为</p>
<script type="math/tex; mode=display">
R = \sum_{i,j,k}T_{ijk}/N^2L</script><p>对于离散化的模型，传统模型：<img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219214817396.png" alt="image-20201219214817396" style="zoom: 67%;" /></p>
<p>而本实验模型为：<img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219214850334.png" alt="image-20201219214850334" style="zoom:67%;" /></p>
<p>其中，$(\xi_r)_k\in[0,1]$ 代表第$r$个滤光片阵列对于第$k$个光谱带的响应</p>
<p>作者给出了与前面文献相同的坐标表示法、P矩阵和测量矩阵：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219215051907.png" alt="image-20201219215051907" style="zoom:67%;" /></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219215101843.png" alt="image-20201219215101843" style="zoom:67%;" /></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219215125222.png" alt="image-20201219215125222" style="zoom:67%;" /></p>
<h3 id="Experiments-2"><a href="#Experiments-2" class="headerlink" title="Experiments"></a>Experiments</h3><h4 id="Simulation"><a href="#Simulation" class="headerlink" title="Simulation"></a>Simulation</h4><p>实验用氙气灯作光源，光谱 450nm~650nm，灰度CCD相机 $\Delta_d = 9.9\mu m$ 8位强度值，数据立方体尺寸 $256\times 256 \times 8$</p>
<p>实验用CA和CCA的透过率基本固定在50%，都采用伯努利随机分布，$p=0.1-0.8$</p>
<p>CCA的滤光片种类设置为（ 2种、4种、8种 ）这三种情况</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219215715235.png" alt="image-20201219215715235"></p>
<p>将FPA的像素尺寸和CCA、CA的像素尺寸都设置为$256\times 256$，以完成匹配</p>
<p>采用GPSR优化算法求解最小二乘，系数基是 二维小波变换 乘 离散余弦变换，快照数量$K=1,2,…,8$</p>
<h4 id="Results-2"><a href="#Results-2" class="headerlink" title="Results"></a>Results</h4><p>实验表明 R=0.2、0.3 时重建效果最好，并得出一个大致结论：</p>
<ul>
<li>$R\approx 1/K$ 时结果更优</li>
</ul>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219220207992.png" alt="image-20201219220207992">C-模拟</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219220605180.png" alt="image-20201219220605180"></p>
<p>模拟结果显示：</p>
<ul>
<li>V（滤光片种类）越多，效果越好</li>
<li>K（快照次数）越多，效果越好，因为每次快照是用的不同的编码模板，信息更多</li>
</ul>
<h4 id="Experiment-setup"><a href="#Experiment-setup" class="headerlink" title="Experiment setup"></a>Experiment setup</h4><p>作者真实实验设备的搭建如下，其中滤光片阵列是加在一个圆盘上</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219220708339.png" alt="image-20201219220708339"></p>
<p>需要有一个同步控制系统控制DMD、转盘、FPA的交替同步成像，如下图所示</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219220820311.png" alt="image-20201219220820311"></p>
<h4 id="Results-3"><a href="#Results-3" class="headerlink" title="Results"></a>Results</h4><p>实验结果表明：</p>
<ul>
<li>传统的CA成像结果会产生更多像素聚集在一起的情况，而CCA成像像素分布更加均匀</li>
</ul>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219220900527.png" alt="image-20201219220900527"></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219220926004.png" alt="image-20201219220926004"></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201219220951289.png" alt="image-20201219220951289"></p>
]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>周报</tag>
      </tags>
  </entry>
  <entry>
    <title>周报：2020-12-21~2020-12-27</title>
    <url>/2020/12/24/%E5%91%A8%E6%8A%A5%EF%BC%9A2020-12-21-2020-12-27/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<p>本周主要做了以下工作：</p>
<p>阅读两篇 UC Berkeley 计算成像实验室的论文：</p>
<ol>
<li>Antipa N , Kuo G , Heckel R , et al. <strong>DiffuserCam:lensless single-exposure 3D imaging</strong>[J]. Optica, 2018.</li>
</ol>
<p>学习 上面两篇论文的 Diffuser Cam源码 <a href="https://waller-lab.github.io/DiffuserCam/tutorial.html">DiffuserCam</a></p>
<h2 id="Paper-1"><a href="#Paper-1" class="headerlink" title="Paper 1"></a>Paper 1</h2><h3 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h3><p>《漫射相机：无镜片单曝光三维成像》</p>
<p>Antipa N , Kuo G , Heckel R , et al. <strong>DiffuserCam:lensless single-exposure 3D imaging</strong>[J]. Optica, 2018.</p>
<h3 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h3><p>作者提出了一种基于<strong>diffuser</strong>（漫射片，毛玻璃片）的无物镜三维成像系统，由于每一个空间位置的点光源都能够<strong>通过diffuser产生伪随机折射</strong>最终在sensor上呈现出一种 <strong>caustics（焦散线）</strong>的图案，在数学上 称为<strong>Point Spead Functions (PSFs)</strong>，<strong>便能够通过一些标定手段获得</strong>diffuser对于三维空间中每一个空间点对应到sensor上一个图案的传递函数（矩阵），结合<strong>压缩感知</strong>和最优化算法，进而实现通过混杂的二维sensor图案反演得到三维原图像。</p>
<p>本文针对大规模的（100million）像素块标定过程，引入了shift invariance assumption（位移不变性假设）和paraxial approximation（近轴近似），将标定规模降低至仅需标定 0轴 的范围，大大降低标定复杂度。</p>
<p>实验器材仅需：diffuser、sensor、aperture（用来控制diffuser成像投影在sensor上的大小）</p>
<p>大致的实验模型如下：在diffuser前加一个aperture，后方放置sensor 即可</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201227162038327.png" alt="image-20201227162038327"></p>
<p>通过 z轴 标定后得到H矩阵，应用最优化算法即可得到三维成像结果。</p>
<h3 id="Specifics"><a href="#Specifics" class="headerlink" title="Specifics"></a>Specifics</h3><p>设 sensor上图案矩阵的向量表示为 $\mathbf b$，diffuser的传递矩阵为 $\mathbf H$，三维场景元素矩阵的向量表示为 $\mathbf v$，则 有：</p>
<script type="math/tex; mode=display">
\mathbf b = \mathbf {Hv}</script><p>式中，$\mathbf H$ 的每一列都代表 三维场景中单个像素块对sensor的所有元素的贡献。</p>
<p>需要求解的问题，即：</p>
<script type="math/tex; mode=display">
\mathbf {\hat v} = \mathop{\arg\min}_{\mathbf v \ge 0} \frac 1 2 \|\mathbf b - \mathbf {Hv}\|_2^2 + \lambda \|\Psi\mathbf v\|_1</script><p>为了应用压缩感知，需要 $\mathbf H$ 满足</p>
<ol>
<li>每列都尽量不相关</li>
<li>焦散图案需要较高的空间频率</li>
</ol>
<p>本实验装置有两个特性参数需要控制：</p>
<ol>
<li>焦比 f-number（焦距与光圈比值）：决定了成像分辨率</li>
<li>平均焦距：决定了最佳放置sensor的位置</li>
</ol>
<p>此外，还需要考虑的问题是 轴向位置的影响、侧向位移的影响</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201227165956486.png" alt="image-20201227165956486" style="zoom: 33%;" /></p>
<p>此处，在计算矩阵乘法 $\mathbf {Hv}$ 时，写成求和式，如下：</p>
<script type="math/tex; mode=display">
b(x',y') = \sum_{x,y,z} \mathbf v(x,y,z)h(x',y';x,y,z).</script><p>计算复杂度过高，从而引入了shift invariance assumption（位移不变性假设）和paraxial approximation（近轴近似），将同一 z轴坐标的 不同 $(x,y)$ 像素值产生的对sensor的成像近似为 <strong>正比于</strong> 同一z轴坐标 在$(0,0)$处产生的对sensor的成像，这样一来，上式的计算可以消掉两个维度：</p>
<p>$h(x’,y’;x,y,z) = h(x’+mx,y’+my;z)$</p>
<p>从而有：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201227170944901.png" alt="image-20201227170944901"></p>
<p>其中，$*$ 表示求三维离散卷积，这种模型为本文提出的 convolution model，它拥有一些优点：</p>
<ol>
<li>使得计算每 $\mathbf {Hv}$ 变得更简单</li>
<li>它提供了一个本系统满足稀疏性的一个有效的证据</li>
<li>使得标定过程变得更简单</li>
</ol>
<p>在求解这样一个最优化模型时，由于规模太大，梯度投影计算复杂度过高，因此作者应用了针对大规模的<strong>ADMM算法（交替方向乘子法）</strong>(详情见2011年论文 S. Boyd, N. Parikh, E. Chu, B. Peleato, and J. Eckstein, “<strong>Distributed optimization and statistical learning via the alternating direction method of multipliers</strong>,” Foundations and Trends in Machine Learning 3, 1–122 (2011).)，因此需要<strong>变量分离</strong>操作（查了一下，ADMM是双变量迭代优化算法）：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201227171441778.png" alt="image-20201227171441778" style="zoom: 67%;" /></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201227172301162.png" alt="image-20201227172301162" style="zoom:67%;" /></p>
<p>经过分析，总的计算复杂度为 $O(n^3logn)$，受制于三维FFT复杂度。</p>
<p>此外，本文还提到了成像角度问题，最终设置了x和y方向的两个满足 <strong>两点分辨率</strong>的临界角度 $41.5°，30°$</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201227172640721.png" alt="image-20201227172640721" style="zoom:67%;" /></p>
<p>同时，作者提出了一种新的分辨率判别形式用来：multi-point resolution，即多点分辨率，此处是16个点。因为作者发现 <strong>本实验装置的重建分辨率与成像物体的复杂性有关</strong>，复杂的物体重建，多点分辨率设定会比两点的更优。</p>
<p>针对分辨率问题，作者提出了 <strong>Local condition nuber theory（局部条件数理论）</strong>，即 定义<strong>局部条件数</strong>为成像的 $\mathbf v$ 中非零元素的数量，显然，非零元素越多，效果越差（混杂现象多）。</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201227174100537.png" alt="image-20201227174100537" style="zoom:67%;" /></p>
<p>在实验阶段，作者为了验证近轴近似的正确性，<strong>在同一z轴坐标下，测出了不同角度的PSF图像</strong>，并将<strong>所有角度的PSF与0°的PSF作内积</strong>，并对比，得到图像：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201227174421944.png" alt="image-20201227174421944" style="zoom:67%;" /></p>
<p>理论上来讲，同意z轴坐标下所有角度的PSF都是相同的，从上图的结果来看，所有角度的PSF最差也有75%的相似度，因此可以认为近似成立。</p>
<p>上图右下角的子图中，蓝色实线为<strong>所有重建的单点峰宽与重建0°点的峰宽比值</strong>，并用0°点峰宽做标准化，红色点线为实行完全标定的结果（误差很小），然而为了降低复杂度，本实验仍然使用简化的标定方法。</p>
<h3 id="Experiments-amp-Results"><a href="#Experiments-amp-Results" class="headerlink" title="Experiments &amp; Results"></a>Experiments &amp; Results</h3><p>实验采用128个z轴平面，z=10.86mm ~ 36.26mm，三维图像在 $2048\times 2048\times 128$ 网格上重建，重建物体为<strong>USAF1951分辨率板</strong>和<strong>一株绿色植物</strong>，结果如下：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201227175627628.png" alt="image-20201227175627628"></p>
<h2 id="图像处理知识点"><a href="#图像处理知识点" class="headerlink" title="图像处理知识点"></a>图像处理知识点</h2><h3 id="关于cv2和matplotlib的imshow区别"><a href="#关于cv2和matplotlib的imshow区别" class="headerlink" title="关于cv2和matplotlib的imshow区别"></a>关于cv2和matplotlib的imshow区别</h3><ul>
<li><p>opencv存储图像默认 BGR 顺序，PIL的Image读取默认RGB</p>
</li>
<li><p>opencv的imshow默认opencv格式，matplotlib的imshow默认RGB格式</p>
</li>
</ul>
<p><strong>建议尽量不要混用</strong>，如果非要的话，可以用以下方式处理：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># cv2读入，plt.imshow显示图像</span><br>img = cv2.imread(<span class="hljs-string">&#x27;lena.jpg&#x27;</span>)<br>img = cv2.cvtColor(img,cv2.COLOR_BGR2RGB) <span class="hljs-comment"># 需要转换成RGB</span><br>plt.imshow(img)<br></code></pre></div></td></tr></table></figure>
<h3 id="关于fft计算线性卷积-和-i-fftshift的作用"><a href="#关于fft计算线性卷积-和-i-fftshift的作用" class="headerlink" title="关于fft计算线性卷积 和 (i)fftshift的作用"></a>关于fft计算线性卷积 和 (i)fftshift的作用</h3><p>在数学与信号处理种，通常计算信号的卷积 是 将其通过傅里叶变换转换到频域，然后计算频域的乘积，再逆变换回去，DFT的快速算法是FFT，时间复杂度$O(nlogn)$，其具体实现见 <a href="https://b4158813.gitee.io/blog/2020/06/30/FFT-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2-%E5%8F%8A%E4%BC%98%E5%8C%96/">我的blog：FFT及其优化</a>，然而，可以证明FFT计算得到的其实是<strong>循环卷积</strong>，并不是我们通常想得到的<strong>线性卷积</strong>。</p>
<p>为了解决上述问题，需要再傅里叶变换前进行一些操作，称之为padding 0（在卷积神经网络中又学到过，即 补零操作），之后再进行FFT就能得到线性卷积（可以严格证明）。</p>
<p>为了将频谱零频点移动到图像中央，我们需要对原图进行 (i)fftshift 操作</p>
<ul>
<li><p>fftshift 将信号（图像）向正方向（右下）移动一半尺寸的位置</p>
</li>
<li><p>ifftshift 将信号（图像）向负方向（左上）移动一半尺寸的位置</p>
</li>
</ul>
<p>上述的 一半尺寸 指：偶数$\frac n 2$，奇数$\frac{n-1}2$</p>
<p>因此，在求卷积之前，我们都需要进行 (i)fftshift 操作</p>
<h2 id="FISTA-Algorithm"><a href="#FISTA-Algorithm" class="headerlink" title="FISTA Algorithm"></a>FISTA Algorithm</h2><p>FISTA（快速迭代阈值收缩算法）基于梯度下降，收敛复杂度为$O(1/k^2)$，比传统的ISTA（复杂度 $O(1/k)$）更快。</p>
<p>参考UC Berkeley计算成像实验室代码：</p>
<ul>
<li><a href="https://waller-lab.github.io/DiffuserCam/tutorial/GD.html">GD: FISTA</a></li>
</ul>
<details>
    <summary>code</summary>

<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># To add a new cell, type &#x27;# %%&#x27;</span><br><span class="hljs-comment"># To add a new markdown cell, type &#x27;# %% [markdown]&#x27;</span><br><br><span class="hljs-comment"># %%</span><br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> numpy.fft <span class="hljs-keyword">as</span> fft<br><span class="hljs-keyword">from</span> IPython <span class="hljs-keyword">import</span> display<br><span class="hljs-keyword">import</span> cv2<br><br><br><span class="hljs-comment"># %%</span><br>f = <span class="hljs-number">1</span>/<span class="hljs-number">8</span><br>psf_data = <span class="hljs-string">&#x27;psf_sample.tif&#x27;</span><br>raw_data = <span class="hljs-string">&#x27;rawdata_hand_sample.tif&#x27;</span><br>iters = <span class="hljs-number">100</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_data</span>(<span class="hljs-params">show_im=<span class="hljs-literal">True</span></span>):<br>    psf = Image.<span class="hljs-built_in">open</span>(psf_data)<br>    data = Image.<span class="hljs-built_in">open</span>(raw_data)<br>    psf = np.array(psf,dtype=<span class="hljs-string">&#x27;float32&#x27;</span>)<br>    data = np.array(data,dtype=<span class="hljs-string">&#x27;float32&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;origin_size_psf: <span class="hljs-subst">&#123;psf.shape&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;origin_size_rawdata: <span class="hljs-subst">&#123;data.shape&#125;</span>&quot;</span>)<br><br>    <span class="hljs-comment"># reduce noise</span><br>    noise = np.mean(psf[<span class="hljs-number">5</span>:<span class="hljs-number">15</span>,<span class="hljs-number">5</span>:<span class="hljs-number">15</span>])<br>    psf -= noise<br>    data -= noise<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">resize</span>(<span class="hljs-params">img,factor</span>):<br>        num = <span class="hljs-built_in">int</span>(-np.log2(factor))<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num): <span class="hljs-comment"># use 2x2 box to do convolution</span><br>            img = <span class="hljs-number">0.25</span> * (img[::<span class="hljs-number">2</span>,::<span class="hljs-number">2</span>,...]+img[<span class="hljs-number">1</span>::<span class="hljs-number">2</span>,::<span class="hljs-number">2</span>,...]+img[::<span class="hljs-number">2</span>,<span class="hljs-number">1</span>::<span class="hljs-number">2</span>,...]+img[<span class="hljs-number">1</span>::<span class="hljs-number">2</span>,<span class="hljs-number">1</span>::<span class="hljs-number">2</span>,...])<br>        <span class="hljs-keyword">return</span> img<br><br>    psf = resize(psf, f)<br>    data = resize(data, f)<br><br>    psf /= np.linalg.norm(psf.ravel())<br>    data /= np.linalg.norm(data.ravel())<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;new_size_psf: <span class="hljs-subst">&#123;psf.shape&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;new_size_data: <span class="hljs-subst">&#123;data.shape&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">if</span> show_im:<br>        plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">8</span>))<br>        plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br>        plt.imshow(psf, cmap=<span class="hljs-string">&#x27;gray&#x27;</span>)<br>        plt.title(<span class="hljs-string">&#x27;psf&#x27;</span>)<br>        plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br>        plt.imshow(data, cmap=<span class="hljs-string">&#x27;gray&#x27;</span>)<br>        plt.title(<span class="hljs-string">&#x27;raw_data&#x27;</span>)<br>        plt.show()<br>    <span class="hljs-keyword">return</span> psf,data<br>hahaha = load_data()<br><br><br><span class="hljs-comment"># # %%</span><br><span class="hljs-comment"># def shift():</span><br><span class="hljs-comment">#     delta = np.zeros((5,5))</span><br><span class="hljs-comment">#     delta[2][2] = 1</span><br><span class="hljs-comment">#     delta_shifted = fft.ifftshift(delta)</span><br><span class="hljs-comment">#     fft_mag = np.abs(fft.fft2(delta_shifted))</span><br><span class="hljs-comment">#     fft_arg = np.angle(fft.fft2(delta_shifted))</span><br><span class="hljs-comment">#     fft_mag_o = np.abs(fft.fft2(delta))</span><br><span class="hljs-comment">#     fft_arg_o = np.angle(fft.fft2(delta))</span><br><br><span class="hljs-comment">#     plt.figure(figsize=(8,6))</span><br><br><span class="hljs-comment">#     plt.subplot(2,3,1)</span><br><span class="hljs-comment">#     plt.imshow(delta,cmap=&#x27;gray&#x27;)</span><br><span class="hljs-comment">#     plt.title(&#x27;origin delta&#x27;)</span><br><span class="hljs-comment">#     plt.subplot(2,3,2)</span><br><span class="hljs-comment">#     plt.imshow(fft_mag_o,vmin=-3,vmax=3,cmap=&#x27;gray&#x27;)</span><br><span class="hljs-comment">#     plt.title(&#x27;magnitude origin delta&#x27;)</span><br><span class="hljs-comment">#     plt.subplot(2,3,3)</span><br><span class="hljs-comment">#     plt.imshow(fft_arg_o,vmin=-3,vmax=3,cmap=&#x27;gray&#x27;)</span><br><span class="hljs-comment">#     plt.title(&#x27;phase origin delta&#x27;)</span><br>    <br><span class="hljs-comment">#     plt.subplot(2,3,4)</span><br><span class="hljs-comment">#     plt.imshow(delta_shifted,cmap=&#x27;gray&#x27;)</span><br><span class="hljs-comment">#     plt.title(&#x27;shifted delta&#x27;)</span><br><span class="hljs-comment">#     plt.subplot(2,3,5)</span><br><span class="hljs-comment">#     plt.imshow(fft_mag,vmin=-3,vmax=3,cmap=&#x27;gray&#x27;)</span><br><span class="hljs-comment">#     plt.title(&#x27;magnitude shifted delta&#x27;)</span><br><span class="hljs-comment">#     plt.subplot(2,3,6)</span><br><span class="hljs-comment">#     plt.imshow(fft_arg,vmin=-3,vmax=3,cmap=&#x27;gray&#x27;)</span><br><span class="hljs-comment">#     plt.title(&#x27;phase shifted delta&#x27;)</span><br><span class="hljs-comment">#     plt.show()</span><br><br><span class="hljs-comment"># shift()</span><br><br><br><span class="hljs-comment"># %%</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">nxt2</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">2</span>**np.ceil(np.log2(x)))<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">init_mat</span>(<span class="hljs-params">h</span>):<br>    pixel_start = (np.<span class="hljs-built_in">max</span>(h) + np.<span class="hljs-built_in">min</span>(h)) / <span class="hljs-number">2</span><br>    x = np.ones(h.shape) * pixel_start<br><br>    padded_shape = [nxt2(<span class="hljs-number">2</span>*n-<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> h.shape]<br>    starti = (padded_shape[<span class="hljs-number">0</span>] - h.shape[<span class="hljs-number">0</span>]) // <span class="hljs-number">2</span><br>    endi = starti + h.shape[<span class="hljs-number">0</span>]<br>    startj = (padded_shape[<span class="hljs-number">1</span>] - h.shape[<span class="hljs-number">1</span>]) // <span class="hljs-number">2</span><br>    endj = startj + h.shape[<span class="hljs-number">1</span>]<br>    hpad = np.zeros(padded_shape)<br>    hpad[starti:endi,startj:endj] = h<br><br>    H = fft.fft2(fft.ifftshift(hpad), norm=<span class="hljs-string">&#x27;ortho&#x27;</span>)<br>    HH = np.conj(H)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">crop</span>(<span class="hljs-params">X</span>):<br>        <span class="hljs-keyword">return</span> X[starti:endi,startj:endj]<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pad</span>(<span class="hljs-params">v</span>):<br>        vpad = np.zeros(padded_shape).astype(np.complex64)<br>        vpad[starti:endi,startj:endj] = v<br>        <span class="hljs-keyword">return</span> vpad<br>    <br>    utils = [crop, pad]<br>    v = np.real(pad(x))<br><br>    <span class="hljs-keyword">return</span> H,HH,v,utils<br><br><br><span class="hljs-comment"># %%</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">grad</span>(<span class="hljs-params">AH, H, vk, b, crop, pad</span>):<br>    Av = calcA(H, vk, crop)<br>    diff = Av - b<br>    <span class="hljs-keyword">return</span> np.real(calcAHerm(AH, diff, pad))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calcA</span>(<span class="hljs-params">A, vk, crop</span>):<br>    Vk = fft.fft2(fft.ifftshift(vk))<br>    <span class="hljs-keyword">return</span> crop(fft.fftshift(fft.ifft2(A * Vk)))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calcAHerm</span>(<span class="hljs-params">AH, diff, pad</span>):<br>    xpad = pad(diff)<br>    X = fft.fft2(fft.ifftshift(xpad))<br>    <span class="hljs-keyword">return</span> fft.fftshift(fft.ifft2(AH * X))<br><br><br><span class="hljs-comment"># %%</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">grad_descent</span>(<span class="hljs-params">h, b</span>):<br>    H, HH, v, utils = init_mat(h)<br>    crop, pad = utils[<span class="hljs-number">0</span>],utils[<span class="hljs-number">1</span>]<br><br>    alpha = np.real(<span class="hljs-number">1.8</span>/(np.<span class="hljs-built_in">max</span>(HH * H)))<br>    iterations = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">non_neg</span>(<span class="hljs-params">xi</span>):<br>        xi = np.maximum(xi, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> xi<br><br>    proj = non_neg<br><br>    parent_var = [H, HH, b, crop, pad, alpha, proj]<br><br>    vk = v<br><br>    tk = <span class="hljs-number">1</span><br>    xk = v<br><br>    <span class="hljs-keyword">for</span> iterations <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(iters):<br>        vk, tk, xk = fista_update(vk,tk,xk,parent_var)<br>        <span class="hljs-keyword">if</span> iterations % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>:<br>            image = proj(crop(vk))<br>            plt.imshow(image, cmap=<span class="hljs-string">&#x27;gray&#x27;</span>)<br>            plt.title(<span class="hljs-string">f&#x27;Reconstruction after iteration <span class="hljs-subst">&#123;iterations&#125;</span>&#x27;</span>)<br>            plt.show()<br>            display.clear_output(wait=<span class="hljs-literal">True</span>)<br>    <br>    <span class="hljs-keyword">return</span> proj(crop(vk))<br><br><br><span class="hljs-comment"># %%</span><br><span class="hljs-comment"># normal gradient descent</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gd_update</span>(<span class="hljs-params">vk, parent_var</span>):<br>    H, HH, b, crop, pad, alpha, proj = parent_var<br>    gradient = grad(HH, H, vk, crop, pad)<br>    vk -= alpha * gradient<br>    vk = proj(vk)<br>    <span class="hljs-keyword">return</span> vk<br><br><br><span class="hljs-comment"># %%</span><br><span class="hljs-comment"># momentum</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">nesterow_udpate</span>(<span class="hljs-params">vk, p, mu, parent_var</span>):<br>    H, HH, b, crop, pad, alpha, proj = parent_var<br>    <br>    p_prev = p<br>    gradient = grad(HH, H, vk, b, crop, pad)<br>    p = mu * p - alpha * gradient<br>    vk += -mu * p_prev + (<span class="hljs-number">1</span> + mu) * p<br>    vk = proj(vk)<br>    <br>    <span class="hljs-keyword">return</span> vk, p<br><br><br><span class="hljs-comment"># %%</span><br><span class="hljs-comment"># FISTA algorithm</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fista_update</span>(<span class="hljs-params">vk, tk, xk, parent_var</span>):<br>    H, HH, b, crop, pad, alpha, proj = parent_var<br><br>    xk1 = xk<br>    gradient = grad(HH, H, vk, b, crop, pad)<br>    vk -= alpha * gradient<br>    xk = proj(vk)<br>    tk1 = (<span class="hljs-number">1</span> + np.sqrt(<span class="hljs-number">1</span> + <span class="hljs-number">4</span> * tk * tk)) / <span class="hljs-number">2</span><br>    vk = xk + (tk - <span class="hljs-number">1</span>) / tk1 *(xk - xk1)<br>    tk = tk1<br>    <span class="hljs-keyword">return</span> vk, tk, xk<br><br><br><span class="hljs-comment"># %%</span><br>psf ,data = load_data()<br>final_im = grad_descent(psf, data)<br>plt.imshow(final_im, cmap=<span class="hljs-string">&#x27;gray&#x27;</span>)<br>plt.title(<span class="hljs-string">f&#x27;Reconstruction after <span class="hljs-subst">&#123;iters&#125;</span> iterations&#x27;</span>)<br>plt.show()<br><br><br><span class="hljs-comment"># %%</span><br></code></pre></div></td></tr></table></figure>

</details>

<p>成像结果：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201227180224551.png" alt="image-20201227180224551"></p>
]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>周报</tag>
      </tags>
  </entry>
  <entry>
    <title>周报：2020-12-28~2021-1-3</title>
    <url>/2021/01/04/%E5%91%A8%E6%8A%A5%EF%BC%9A2020-12-28-2021-1-3/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<p>本周校内工作：</p>
<ul>
<li>做本科课程设计</li>
<li>准备《专业创新实践》答辩（写论文+做PPT）</li>
</ul>
<p>本周研究生工作：</p>
<ul>
<li>Monakhova K , Yanny K , Aggarwal N , et al. <strong>Spectral DiffuserCam: lensless snapshot hyperspectral imaging with a spectral filter array</strong>[J]. Optica, 2020.</li>
<li>看DiffuserCam的YouTube视频<a href="https://www.youtube.com/watch?v=Uq2iuxvyPa4&amp;t=1329s">Computational Imaging Webinar SPACE: Seminar 2. Laura Waller, UC Berkeley</a></li>
</ul>
<p>本周工作并不是很多，论文看了一半，下周看完写总结。</p>
]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>周报</tag>
      </tags>
  </entry>
  <entry>
    <title>周报：2020-12-7~2020-12-13</title>
    <url>/2020/12/10/%E5%91%A8%E6%8A%A5%EF%BC%9A2020-12-7-2020-12-13/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<p>本周主要研读了以下内容：</p>
<ul>
<li>中科院大学的刘铭鑫博士 的博士学位论文<strong>《基于压缩感知的编码孔径光谱成像技术研究》</strong></li>
<li>Arguello, H, Carin, et al. <strong>Compressive Coded Aperture Spectral Imaging: An Introduction</strong>[J]. IEEE Signal Processing Magazine, 2014.</li>
<li>Galvis L , Arguello H , Arce G R . <strong>Synthetic coded apertures in compressive spectral imaging</strong>[C]// 2014 IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP). IEEE, 2014.</li>
<li>Galvis L , Arguello H , Arce G R . <strong>Synthetic coded apertures in compressive spectral imaging: Experimental validation</strong>[C]// 2015 IEEE Global Conference on Signal and Information Processing (GlobalSIP). IEEE, 2016.</li>
</ul>
<p>同时，实现了CoSaOMP算法（压缩采样匹配追踪），发现确实比OMP重建效果好，但用时更长。</p>
<h2 id="CASSI-系统"><a href="#CASSI-系统" class="headerlink" title="CASSI 系统"></a>CASSI 系统</h2><h3 id="双色散型光谱维编码"><a href="#双色散型光谱维编码" class="headerlink" title="双色散型光谱维编码"></a>双色散型光谱维编码</h3><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201212150504924.png" alt="image-20201212150504924"></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201212145728927.png" alt="image-20201212145728927"></p>
<p>如图所示，数据立方体<strong>首先经过色散分光</strong>，然后经过一个<strong>编码孔径进行调制</strong>，得到调制后的数据，随后再<strong>反色散分光</strong>（目的是为了将shearing过的数据恢复成初始的立方体，称为<strong>合光</strong>），最后投射（沿光谱维度积分）在探测器上</p>
<p>合光后的数学表示为</p>
<script type="math/tex; mode=display">
I_3(x,y,\lambda) = T(x-\alpha(\lambda-\lambda_c),y)\cdot I_0(x,y,\lambda) = H(x,y,\lambda)\cdot I_0(x,y,\lambda)</script><p><strong>可以发现，本质上可以这么理解：数据立方体的每一个光谱段的空间信息都被不同地过滤了。</strong></p>
<ul>
<li>补充说明：如果色散作用是使得两相邻光谱沿$x$坐标轴正向错开一个像素单位，那么数据立方体中的第一个光谱段空间信息并没有被错开，等效于它被原始的编码孔径过滤了，但从第2个开始就不一样了，假设现在观察的对象为第$i$个光谱段的空间信息，发现其实它相对于第1个光谱段 在$x$轴正向错开了$(i-1)$个像素单位，等效于 它被原始编码孔径在沿$x$轴负向错开$(i-1)$个像素单位之后得到的编码孔径过滤了，依此类推，所以数据立方体的每一个波段信息都不同，称为光谱维编码</li>
<li>因此，编码孔径的长度应该是 <strong>$空间维度尺寸 + 光谱维度尺寸 - 1$</strong>，而探测器尺寸应该为 $空间维度尺寸$</li>
</ul>
<p>最终透射在探测器上的数学表示为</p>
<script type="math/tex; mode=display">
I_4 = \int H(x,y,\lambda)\cdot I_0(x,y,\lambda)d\lambda</script><h3 id="单色散型空间维编码"><a href="#单色散型空间维编码" class="headerlink" title="单色散型空间维编码"></a>单色散型空间维编码</h3><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201212150911819.png" alt="image-20201212150911819"></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201212152144119.png" alt="image-20201212152144119"></p>
<p>数据立方体首先经过编码孔径调制（此时所有光谱维度的空间信息都被相同的无差别过滤了），然后再色散分光，最后投射到探测器上</p>
<p>探测器前的光谱信息数学表示为：（得到光强信息，只需要对下式在波长上积分）</p>
<script type="math/tex; mode=display">
I_4(x,y,\lambda) = I_0(x-\alpha(\lambda-\lambda_c),y,\lambda) \cdot T(x-\alpha(\lambda-\lambda_c),y)</script><ul>
<li>因此，编码孔径的尺寸与数据立方体空间尺寸相同，而探测器尺寸应该为 $空间维度尺寸+光谱维度尺寸-1$</li>
</ul>
<p>最终投射在探测器上的光强为</p>
<script type="math/tex; mode=display">
D(x,y) = \int I_0(x-\alpha(\lambda)\cdot(\lambda-\lambda_c),y,\lambda) \cdot T(x-\alpha(\lambda-\lambda_c),y)d\lambda</script><h3 id="探测器像元离散化"><a href="#探测器像元离散化" class="headerlink" title="探测器像元离散化"></a>探测器像元离散化</h3><p>由于真实情况下，所有探测器获取的数据都是离散化的结果（对应探测器的<strong>像元</strong>信息），因此需要对上面讨论的方程进行离散化建模</p>
<p>考虑单色散型空间维编码，设 探测器像元尺寸为 $\Delta d$，系统噪声为 $\sigma$，那么对于探测器像元$(i,j)$而言，它所获取的光强可以表示为：</p>
<script type="math/tex; mode=display">
D_{i,j} = \iint rect\left(\frac{x}{\Delta d}-i\right)\otimes rect\left(\frac{y}{\Delta d}-j\right)D(x,y)dxdy + \sigma</script><p>这个式子表明：<strong>一个像元上的光强 是 对应像元位置的连续空间位置的光谱信息的叠加</strong></p>
<p>这里补充解释一下，看下图：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201212170350356.png" alt="image-20201212170350356" style="zoom: 67%;" /></p>
<ul>
<li><p>我从其他文献中（<em>Galvis L , Arguello H , Arce G R . Synthetic coded apertures in compressive spectral imaging: Experimental validation[C]// 2015 IEEE Global Conference on Signal and Information Processing (GlobalSIP). IEEE, 2016.</em>），也看到了类似的式子，想表达的意思是相同的。图中红线部分的<strong>矩形函数</strong>用来表示对应坐标的像元矩形，张量积的意义就是把对应行列的向量做张量积，最终的结果也是对应的像元矩形，所以<strong>矩形函数的存在把积分限限制在了对应像元内部</strong>。</p>
</li>
<li><p>那么上式的意义就很明了了：<strong>连续函数$g$ 对像元对应位置的矩形内元素进行积分</strong>，也就是像元内光谱信息的累加，我改写为下式，就很好理解了</p>
<script type="math/tex; mode=display">
D_{i,j} = \mathop\iint_{x\in\left[\lfloor\frac{x}{\Delta d}\rfloor\Delta d,\lfloor\frac{x}{\Delta d}\rfloor\Delta d+\Delta d\right]\\y\in\left[\lfloor\frac{y}{\Delta d}\rfloor\Delta d,\lfloor\frac{y}{\Delta d}\rfloor\Delta d+\Delta d\right]} D(x,y)dxdy</script></li>
</ul>
<h3 id="数字微反射镜（Digital-Micromirror-Device-DMD）"><a href="#数字微反射镜（Digital-Micromirror-Device-DMD）" class="headerlink" title="数字微反射镜（Digital Micromirror Device, DMD）"></a>数字微反射镜（Digital Micromirror Device, DMD）</h3><p>DMD是一种常用的空间光调制器（Spatial Light Modulator, SLM），它是由多个高速数字式光反射开关组成的阵列，一个小镜片对应一个像素，相对于TFT-LCD（液晶）的透射率低，对比度小，DMD的反射率高，对比度大。结合光源和光学器件，DMD可以实现在速度、精度和效率上远超其他空间光调制方式的二进制图形。DMD的每个镜片都可以分别围绕铰接斜轴进行 +/-12° 的偏转，镜片的偏转是通过更改底层CMOS控制电路和镜片复位信号的二进制状态进行单独控制的，从而使其可以在DLP投影系统倾向光源（打开）或背离光源（关闭），在投影表面造成像素的或明或暗。</p>
<p>通过研读文献，了解到编码孔径的大多都是采用DMD实现的，通过编程设置镜片偏转实现布尔类型的编码孔径。</p>
<h2 id="Paper-1"><a href="#Paper-1" class="headerlink" title="Paper 1"></a>Paper 1</h2><h3 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h3><p>《合成编码孔径压缩光谱成像》</p>
<p>Galvis L , Arguello H , Arce G R . <strong>Synthetic coded apertures in compressive spectral imaging</strong>[C]// 2014 IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP). IEEE, 2014.</p>
<h3 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h3><p>通常情况下，Brady等人创造出的，传统的基于编码孔径的压缩感知光谱成像系统（CASSI）常常会出现 编码孔径像素 与 焦平面探测器像素 不匹配的问题，如下图所示：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201213203511359.png" alt="image-20201213203511359" style="zoom:67%;" /></p>
<p>传统的解决方案是设置一个 super-pixel 如上图所示，将编码孔径的$2\times 2$个像素与FPA的$3\times 3$个像素匹配起来，整体当成一个“超级像素“来处理，这样的处理方式显然会造成最终成像结果的空间分辨率和光谱分辨率低下的问题，本文提出了一种新型处理方式，通过人工合成一种编码孔径，将原始编码孔径设置的值通过数学建模的方式映射到新的合成编码孔径上，这种编码孔径的像素大小与FPA像素大小一致，因此不需要采用 super-pixel，分辨率大大提高。</p>
<p>传统模型如下：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201213204224336.png" alt="image-20201213204224336" style="zoom:67%;" /></p>
<p>​    <img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201213204251220.png" alt="image-20201213204251220" style="zoom:67%;" /></p>
<p>需要注意的是，作者采用的是单色散型编码模式，因此最终投影到FPA上的是一个经过色散的倾斜的数据立方体，这里作者将其划分为三个部分，因此上式多了一个求和号（u）</p>
<p>新的合成编码孔径模型示意图如下：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201213204554520.png" alt="image-20201213204554520" style="zoom:67%;" /></p>
<p>以 $\Delta_d:\Delta c = 2:3$ 为例，作者将$2\times 2$的原始孔径与新孔径做对比，显然原始孔径一个pixel的值会贡献到新孔径的相邻几个部分，如上图所示，右侧的图的深浅表示了其中一个原始像素对各个新像素点的贡献大小，这里作者用了一段<del>我看了整整两天都没看懂的</del>公式描述了这一点：（这个式子确实有点迷，但意思作者写的很明白了）</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201213204846612.png" alt="image-20201213204846612" style="zoom:67%;" /></p>
<p>最后，抛出最终的新模型：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201213205030668.png" alt="image-20201213205030668" style="zoom:67%;" /></p>
<p>需要注意的是，上式第一个求和号上限乘了一个$p_1$（即一个超级像素的尺寸与一个FPA像素尺寸之比），这么写直观上是<strong>光谱维度数据变密了，是原来的$p_1$倍</strong>，感觉是因为 像素点变多了（因为编码孔径$\Delta_c$变小了），因此色散产生的光谱数据遍多了。</p>
<h3 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h3><p>实验中FPA尺寸为$384\times 384$，光谱段数为24，单色仪采样了$450-650$之间的波段，探测器为CCD相机AVT Marlin F0033B，有$656\times 492$个像素，每个像素尺寸为$9.9\mu m$。作者分别做了25%和50%透过率的两种编码孔径做对比实验，编码孔径分辨率为$256\times 256$，所以显然与FPA分辨率比值为$2:3$。</p>
<p>所需重建的问题是 优化一个带有L1正则化的最小二乘，采用了GPSR（梯度投影稀疏重建法）算法，稀疏基采用 8 basis二维小波变换矩阵 与 一维离散余弦变换 的克罗内克积，最终成像结果为一个$384\times 384 \times 24$的数据立方体。</p>
<h3 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h3><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201213210455048.png" alt="image-20201213210455048" style="zoom:67%;" /></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201213210530309.png" alt="image-20201213210530309" style="zoom:67%;" /></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201213210600925.png" alt="image-20201213210600925" style="zoom:67%;" /></p>
<h2 id="Paper-2"><a href="#Paper-2" class="headerlink" title="Paper 2"></a>Paper 2</h2><p>这篇文章是上一篇文章的实验验证部分， 对比了传统的CASSI方法和合成编码空间方法的重建结果，表明新方法显著的优势。</p>
<p>PS：我发现它更加详细地解释了理论模型部分。</p>
<p>结果如下方图片所示：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201213210930571.png" alt="image-20201213210930571" style="zoom:50%;" /></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20201213210946473.png" alt="image-20201213210946473" style="zoom:67%;" /></p>
<h2 id="CoSaOMP-算法实现"><a href="#CoSaOMP-算法实现" class="headerlink" title="CoSaOMP 算法实现"></a>CoSaOMP 算法实现</h2><p>下图是稀疏系数k不同时的重建结果</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/B_Different_k.png" alt="B_Different_k"></p>
<p>下图是OMP与CoSaMP在相同条件下的对比</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/rate_7&amp;k_10.jpg" style="zoom:67%;" /></p>
<p>下图是CoSaMP算法在不同稀疏稀疏k取值下的重建时间</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/test1.png" alt="test1"></p>
<details>
    <summary>code</summary>

<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> scipy.optimize <span class="hljs-keyword">as</span> spopt<br><span class="hljs-keyword">import</span> scipy.fftpack <span class="hljs-keyword">as</span> spfft<br><span class="hljs-keyword">import</span> scipy.ndimage <span class="hljs-keyword">as</span> spimg<br><br><span class="hljs-comment"># Compressive Sampling Matching Pursuit algorithm</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">OMP</span>(<span class="hljs-params">y,A,K</span>):<br>	col = A.shape[<span class="hljs-number">1</span>]<br>	residual = y<br>	ind = np.array([],dtype=np.int64)<br>	Res = np.zeros((col))<br>	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(K):<br>		prod = np.fabs(np.dot(A.T,residual))<br>		ind = np.union1d(ind, np.argsort(-prod)[:<span class="hljs-number">2</span>*K])<br>		tmp = np.zeros((<span class="hljs-number">256</span>))<br>		tmp[ind] = np.dot(np.linalg.pinv(A[:,ind]),y)<br>		pos_tmp = np.argsort(-np.fabs(tmp))[:K]<br>		Res[pos_tmp] = tmp[pos_tmp]<br>		residual = y-np.dot(A,Res)<br>	<span class="hljs-keyword">return</span> Res<br><br>img = cv2.imread(<span class="hljs-string">&quot;lena.jpg&quot;</span>)<br>img = img[<span class="hljs-number">128</span>:<span class="hljs-number">128</span>+<span class="hljs-number">256</span>, <span class="hljs-number">128</span>:<span class="hljs-number">128</span>+<span class="hljs-number">256</span>, <span class="hljs-number">0</span>]<br><br><span class="hljs-comment"># cv2.imshow(&quot;img&quot;,img)</span><br><span class="hljs-comment"># cv2.waitKey(0)</span><br><br><span class="hljs-comment"># radom gaussian matrix ----&gt; undersample</span><br>sample_rate = <span class="hljs-number">0.7</span><br>N = <span class="hljs-number">256</span><br>Phi = np.random.randn(<span class="hljs-built_in">int</span>(sample_rate*N),N)<br>Phi /= np.linalg.norm(Phi)<br><br><span class="hljs-comment"># plt.imshow(Phi)</span><br><span class="hljs-comment"># plt.colorbar()</span><br><span class="hljs-comment"># plt.show()</span><br><span class="hljs-comment"># exit(0)</span><br><br><br><span class="hljs-comment"># DCT matrix ----&gt; sparse base</span><br>Psi = np.zeros((N,N))<br>n = np.array(<span class="hljs-built_in">range</span>(N))<br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):<br>	Psi[k,:] = (<span class="hljs-number">2</span>/N)**<span class="hljs-number">0.5</span>*np.cos((<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>)*k*np.pi/<span class="hljs-number">2</span>/N)<br>Psi[<span class="hljs-number">0</span>,:] /= <span class="hljs-number">2</span>**<span class="hljs-number">0.5</span><br>Psi = Psi.T<br><br><span class="hljs-comment"># plt.imshow(Psi)</span><br><span class="hljs-comment"># plt.colorbar()</span><br><span class="hljs-comment"># plt.show()</span><br><span class="hljs-comment"># exit(0)</span><br><br><br><span class="hljs-comment"># measurement ----&gt; undersample image</span><br>measure_mat = np.dot(Phi,img)<br><br><span class="hljs-comment"># K coefficient for N colomns</span><br>sparse_coe = np.zeros((N,N))<br><br><span class="hljs-comment"># θ = Φ ψ</span><br>Theta = np.dot(Phi,Psi)<br><br><br>time_consume = []<br><span class="hljs-comment"># OMP for every colomn</span><br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>,<span class="hljs-number">25</span>,<span class="hljs-number">5</span>):<br>	st = time.perf_counter()<br>	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):<br>		sparse_coe[:,i] = OMP(measure_mat[:,i],Theta,k)<br>	en = time.perf_counter()<br>	img_rec = np.dot(Psi,sparse_coe)<br>	img_rec /= img_rec.<span class="hljs-built_in">max</span>()<br>	img_rec *= <span class="hljs-number">255</span><br>	img_rec = img_rec.astype(np.uint8)<br>	<span class="hljs-comment"># print(img_rec.shape)</span><br>	<span class="hljs-comment"># print(img.shape)</span><br>	<span class="hljs-comment"># cv2.imshow(&quot;img&quot;,img)</span><br>	sys.stdout.writelines(<span class="hljs-string">f&quot;rate=<span class="hljs-subst">&#123;sample_rate:<span class="hljs-number">.1</span>f&#125;</span>,k=<span class="hljs-subst">&#123;k&#125;</span> runtime:<span class="hljs-subst">&#123;en-st&#125;</span>s &quot;</span>)<br>	time_consume.append(en-st)<br>	mse = np.<span class="hljs-built_in">sum</span>((img_rec-img)**<span class="hljs-number">2</span>)/<span class="hljs-number">256</span>/<span class="hljs-number">256</span><br>	PSNR = <span class="hljs-number">10</span>*np.log10(np.<span class="hljs-built_in">max</span>(img_rec)**<span class="hljs-number">2</span>/mse)<br>	sys.stdout.writelines(<span class="hljs-string">f&#x27;PSNR = <span class="hljs-subst">&#123;PSNR&#125;</span>dB\n&#x27;</span>)<br>	img_rec = cv2.putText(img_rec,<span class="hljs-string">f&quot;PSNR=<span class="hljs-subst">&#123;PSNR:<span class="hljs-number">.0</span>f&#125;</span>&quot;</span>,(<span class="hljs-number">20</span>,<span class="hljs-number">20</span>),cv2.FONT_HERSHEY_SIMPLEX,<span class="hljs-number">0.5</span>,(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>),<span class="hljs-number">1</span>)<br>	cv2.imshow(<span class="hljs-string">&quot;rate=%.1f,k=%d&quot;</span>%(sample_rate,k),img_rec)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br><br><br><br><span class="hljs-comment"># sparse_coe[sparse_coe!=0] = 255</span><br><span class="hljs-comment"># sparse_coe = sparse_coe.astype(np.uint8)</span><br><span class="hljs-comment"># cv2.imshow(&quot;sparse_coe&quot;,sparse_coe)</span><br><span class="hljs-comment"># cv2.waitKey(0)</span><br><br><span class="hljs-comment"># plt.figure(figsize=(12,8))</span><br><span class="hljs-comment"># # plt.plot([i for i in range(256)],img[:,0])</span><br><span class="hljs-comment"># # plt.plot([i for i in range(256)],img_rec[:,0])</span><br><span class="hljs-comment"># # plt.legend([&#x27;origin&#x27;,&#x27;reconstruction&#x27;],fontsize=15)</span><br><span class="hljs-comment"># # plt.title(&#x27;Reconstruction result for column 0 with sample_rate=%.1f&#x27;%sample_rate, fontsize=15)</span><br><span class="hljs-comment"># plt.plot([i for i in range(10,50,10)],time_consume)</span><br><span class="hljs-comment"># plt.xlabel(&#x27;K coefficient&#x27;,fontsize=15)</span><br><span class="hljs-comment"># plt.ylabel(&#x27;consuming time(s)&#x27;,fontsize=15)</span><br><span class="hljs-comment"># plt.title(&#x27;CoSaMP: Consuming time for different k value&#x27;,fontsize=20)</span><br><span class="hljs-comment"># plt.grid()</span><br><span class="hljs-comment"># plt.legend([&#x27;sample_rate=%.1f&#x27;%sample_rate],fontsize=15)</span><br><span class="hljs-comment"># plt.show()</span><br><br></code></pre></div></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>周报</tag>
      </tags>
  </entry>
  <entry>
    <title>周报：2021-1-11~2021-1-17</title>
    <url>/2021/01/23/%E5%91%A8%E6%8A%A5%EF%BC%9A2021-1-11-2021-1-17/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<p>本周内容：</p>
<ul>
<li>Takatani T , Aoto T , Mukaigawa Y . <strong>One-Shot Hyperspectral Imaging Using Faced Reflectors</strong>[C]// Computer Vision &amp; Pattern Recognition. IEEE, 2017.</li>
</ul>
<h2 id="Paper-1"><a href="#Paper-1" class="headerlink" title="Paper 1"></a>Paper 1</h2><h3 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h3><p>《基于反射镜的快照式高光谱成像》</p>
<p>Takatani T , Aoto T , Mukaigawa Y . <strong>One-Shot Hyperspectral Imaging Using Faced Reflectors</strong>[C]// Computer Vision &amp; Pattern Recognition. IEEE, 2017.</p>
<h3 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h3><p>文章主要创新地提出了一种轻量级的高光谱成像系统，即 利用一堆耦合镜和附着在耦合镜壁面的滤光片实现分光作用，通过光场的传播，最终到达相机传感器处的光线被分为了好几段，从光场信息中重建恢复出高光谱信息。</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210123175319177.png" alt="image-20210123175319177" style="zoom:67%;" /></p>
<p>本装置的数学模型为：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210123175456997.png" alt="image-20210123175456997" style="zoom:67%;" /></p>
<p>考虑到反射镜的反射作用，对于又$i$次反射的光线，模型为：</p>
<script type="math/tex; mode=display">
y_{k,i} = \int_\Lambda l(\lambda)s(\lambda)f^i(\lambda)c_k(\lambda)d\lambda</script><p>离散化后，为：</p>
<script type="math/tex; mode=display">
y_{k,i} = \sum_{\lambda_b\le \lambda \le \lambda_e} l_\lambda s_\lambda f^i_\lambda c_{k,\lambda}\\
=y_{k,i} = \sum_{\lambda_b\le \lambda \le \lambda_e} a_{k,i,\lambda}s_\lambda</script><p>写成矩阵形式：</p>
<script type="math/tex; mode=display">
y_{k,i} = =\mathbf {a^T}_{k,i} \mathbf s</script><p>对于 $k=3$ 个通道（RGB），以及 $N$次反射的情况，有：</p>
<script type="math/tex; mode=display">
\mathbf {y=As}</script><p>通过将普遍的最小二乘问题归结为具有框约束的二次规划问题（凸优化问题），进而利用 <code>quadratic cone programming</code>技术结合python 的<code>cvxopt</code> 模块求解</p>
<h3 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h3><p>作者着重探究了使用 <strong>耦合镜</strong> 和 使用 <strong>万花筒式镜</strong> 的情况，并利用人造数据集验证了方法的正确性，最后实际实验验证：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210123180500307.png" alt="image-20210123180500307" style="zoom:67%;" /></p>
<p>上图中，相机最终采集的 绿色树叶 图像被分为了好几段，从左至右空间分辨率越来越差，但包含了很多光谱信息。</p>
<p>最终重建出的光谱信息如下图左侧所示，右侧为真值</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210123180617382.png" alt="image-20210123180617382"></p>
<p>作者最终总结道，误差平均约为 14% 并提出了几点问题，包括 空间光谱分辨率的权衡、滤光片耗散作用，仍旧具有很大改进空间</p>
]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>周报</tag>
      </tags>
  </entry>
  <entry>
    <title>周报：2021-1-18~2021-1-24</title>
    <url>/2021/01/23/%E5%91%A8%E6%8A%A5%EF%BC%9A2021-1-18-2021-1-24/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<p>本周工作：</p>
<ul>
<li><p>Xiong Z , Wang L , Li H , et al. <strong>Snapshot Hyperspectral Light Field Imaging</strong>[C]// 2017 IEEE Conference on Computer Vision and Pattern Recognition (CVPR). IEEE, 2017.</p>
</li>
<li><p>Single-shot three-dimensional imaging with a scattering layer</p>
</li>
<li><p>Rueda H , Arguello H , Arce G R . <strong>High-dimensional optimization of color coded apertures for compressive spectral cameras</strong>[C]// 2017 25th European Signal Processing Conference (EUSIPCO). 2017.</p>
</li>
</ul>
<h2 id="Paper-1"><a href="#Paper-1" class="headerlink" title="Paper 1"></a>Paper 1</h2><h3 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h3><p>《散射层快照高光谱成像》</p>
<p>Single-shot three-dimensional imaging with a scattering layer</p>
<h3 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h3><p>本文提出了一种基于 Scattering layer 的快照式高光谱相机，通过将一片薄散射层（scattering layer）放置于一个2D成像传感器前，形成一个 类光场相机。利用散射层散射出的光斑具有 数据独立性和空间遍历性 的特征，来实现<strong>三维重建</strong>（注：此处的第三维 是指 <strong>深度</strong> 维度）。</p>
<h4 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h4><p>散射层具备自己独特的Point spread function (PSF)，理论表示如下：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210130150833850.png" alt="image-20210130150833850" style="zoom:67%;" /></p>
<p>将统计学理论应用，$s_j$和$S(r)$的协方差可以表示为：</p>
<script type="math/tex; mode=display">
C_j(\hat r) = \int {s_j(r+\hat r)S(r)dr}</script><p>散射层散射出的光斑图样具有统计学特征，充分发展的光斑图样具有沿中心呈<strong>负指数分布</strong>的特点，其方差等于均值的平方，基于moment factoring theorem 和 Van Cittert - Zernike theorem，上面的式子可以简化为：</p>
<script type="math/tex; mode=display">
C_j (\hat r) = |\Gamma_j(\hat r)|^2 + \bar S\bar {s_j}</script><p>其中$\Gamma_j(r)$ 代表block函数的功率谱。</p>
<p>根据傅里叶切片定理，可以证明：</p>
<script type="math/tex; mode=display">
|\Gamma(0)|^2 = \bar S\bar {s_j}, |\Gamma(r)|^2\approx 0\ when\ r>>0</script><h4 id="Calibration"><a href="#Calibration" class="headerlink" title="Calibration"></a>Calibration</h4><p>本文将scattering layer 放置在一个多孔孔径后面，通过开关孔径窗口实现指定位置的scattering layer的打开与关闭。</p>
<p>在标定过程种，本文应用了沿着深度方向上的按比例放大缩小的近似原理：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210130152628424.png" alt="image-20210130152628424" style="zoom: 67%;" /></p>
<p>因此，只需要在一个参考深度下标定一个2D平面的点即可。</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210130152745524.png" alt="image-20210130152745524" style="zoom:67%;" /></p>
<h3 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h3><p>本文以9个正方形孔为例，首先轮流打开每一个小孔并标定PSF，最后通过全开所有孔测出所测物体在scattering layer成像所形成的光斑图像，然后应用理论，将该图像与每一个孔的PSF求协方差，得到每个孔角度下的该物体的成像。</p>
<p>标定实验图：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210130152716594.png" alt="image-20210130152716594" style="zoom:67%;" /></p>
<p>成像实验中，在不同深度（深度差为5cm）放置了两个物体：X 和 3</p>
<p>成像实验图：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210130152825464.png" alt="image-20210130152825464" style="zoom:67%;" /></p>
<h3 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h3><p>可以看出，在开不同窗口时，位于焦平面上的X并没有受到影响，但是不在焦点处的3的光强具有显著变化，当全开窗口时，可以明显看出来深度上的差异，同时，图(f)将PSF中的$\Delta z$调为了50cm，因此此刻呈现的图像等价于3处在焦平面上。</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210130152854872.png" alt="image-20210130152854872" style="zoom:67%;" /></p>
<h2 id="Paper-2"><a href="#Paper-2" class="headerlink" title="Paper 2"></a>Paper 2</h2><h3 id="Title-1"><a href="#Title-1" class="headerlink" title="Title"></a>Title</h3><p>《高维彩色编码孔径最优化下的压缩光谱成像》</p>
<p>Rueda H , Arguello H , Arce G R . <strong>High-dimensional optimization of color coded apertures for compressive spectral cameras</strong>[C]// 2017 25th European Signal Processing Conference (EUSIPCO). 2017.</p>
<h3 id="Contents-1"><a href="#Contents-1" class="headerlink" title="Contents"></a>Contents</h3><p>本文提出了一种编码孔径最优化设计方案，并利用迭代算法实现，相对于传统的随机生成编码孔径有8dB的提高。</p>
<h4 id="Theory-1"><a href="#Theory-1" class="headerlink" title="Theory"></a>Theory</h4><p>作者将RIP条件中的矩阵$\mathbf {A_{|\rho||\rho|}}$：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210130153654434.png" alt="image-20210130153654434" style="zoom:67%;" /></p>
<p>中的关于编码孔径的一项单独拎出来作为一个系数$\beta$：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210130153813079.png" alt="image-20210130153813079" style="zoom:67%;" /></p>
<p>RIP条件证明我们需要使系数$\beta$越小越好，因此需要寻找上式最小值时的矩阵$\mathbf t$，将编码孔径矩阵拆分为三维结构形式$(R+L)\times (R+L)\times L$，并将优化问题写成如下形式：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210130154115565.png" alt="image-20210130154115565" style="zoom:67%;" /></p>
<p>其中 $U<em>{i,j},V</em>{i,j},W<em>{i,j}$分别代表 $x-y,y-\lambda,x-\lambda$的控制项，$\tau</em>{i/j/k}$为权重系数。</p>
<p>作者提出了新的迭代算法实现这样的优化问题求解：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210130154302724.png" alt="image-20210130154302724" style="zoom:67%;" /></p>
<h3 id="Results-1"><a href="#Results-1" class="headerlink" title="Results"></a>Results</h3><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210130154326928.png" alt="image-20210130154326928"></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210130154341336.png" alt="image-20210130154341336"></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210130154356472.png" alt="image-20210130154356472"></p>
]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>周报</tag>
      </tags>
  </entry>
  <entry>
    <title>周报：2021-1-25~2021-1-31</title>
    <url>/2021/01/30/%E5%91%A8%E6%8A%A5%EF%BC%9A2021-1-25-2021-1-31/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<p>本周工作：</p>
<ul>
<li><p>阅读文献综述：Song H , Zhang W , Li H , et al. <strong>Review of compact computational spectral information acquisition systems</strong>[J]. Frontiers of Information Technology &amp; Electronic Engineering, 2020.</p>
</li>
<li><p>阅读文献综述：Cao X , Yue T , Lin X , et al. <strong>Computational Snapshot Multispectral Cameras: Toward dynamic capture of the spectral world</strong>[J]. IEEE Signal Processing Magazine, 2016, 33(5):95-108.</p>
</li>
<li><p>阅读文献：Liang J , Liu J , Patten S , et al. <strong>Coded-aperture broadband light field imaging using digital micromirror devices</strong>[J]. Optica, 2020.</p>
</li>
</ul>
<h2 id="Paper-1"><a href="#Paper-1" class="headerlink" title="Paper 1"></a>Paper 1</h2><h3 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h3><p>《紧凑型计算光谱信息采集系统文献综述》</p>
<p><strong>Review of compact computational spectral information acquisition systems</strong></p>
<h3 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h3><p>整理了个思维导图，如下</p>


	<div class="row">
    <embed src="map.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h2 id="Paper-2"><a href="#Paper-2" class="headerlink" title="Paper 2"></a>Paper 2</h2><h3 id="Title-1"><a href="#Title-1" class="headerlink" title="Title"></a>Title</h3><p>《计算成像快照式多光谱相机：对光谱世界的动态捕捉技术》</p>
<p><strong>Computational Snapshot Multispectral Cameras: Toward dynamic capture of the spectral world</strong></p>
<h3 id="Contents-1"><a href="#Contents-1" class="headerlink" title="Contents"></a>Contents</h3><p>整理了个思维导图，如下</p>


	<div class="row">
    <embed src="map_Computational_Snapshot_Multispectral_Cameras.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h2 id="Paper-3"><a href="#Paper-3" class="headerlink" title="Paper 3"></a>Paper 3</h2><h3 id="Title-2"><a href="#Title-2" class="headerlink" title="Title"></a>Title</h3><p>《基于DMD的编码孔径宽谱光场成像》</p>
<p><strong>Coded-aperture broadband light field imaging using digital micromirror devices</strong></p>
<h3 id="Contents-2"><a href="#Contents-2" class="headerlink" title="Contents"></a>Contents</h3><p>本文提出了一种能够实现4D成像（2D空间维度，2D角度维度）的编码孔径光场相机，由于DMD对宽谱光具有严重的空间色散，因此本文作者利用这一点，采用对称布置以抵消空间色散的影响，作者称其为<strong>DECALF(dispersion-eliminated Coded-aperture light field)</strong></p>
<p>随后，作者利用该装置实现了对静态和动态生物的追踪成像，效果尚可。</p>
<p>实验装置示意图如下图所示：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210218224304211.png" alt="image-20210218224304211" style="zoom:67%;" /></p>
<p>下图中(a)为呈现在中间平面的像，(b)为最终成像平面的像：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210218224713543.png" alt="image-20210218224713543" style="zoom:67%;" /></p>
<h3 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h3><p>静态枫叶的成像（4D像），可以看出有角度上的深浅变化：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210218224732158.png" alt="image-20210218224732158" style="zoom:67%;" /></p>
<p>斑马鱼幼虫动态成像：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210218224959344.png" alt="image-20210218224959344" style="zoom:67%;" /></p>
<p>成年斑马鱼活体动态成像：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210218225034904.png" alt="image-20210218225034904" style="zoom:67%;" /></p>
<p>正常斑马鱼 和 残疾斑马鱼活体动态成像的对比：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210218225122058.png" alt="image-20210218225122058" style="zoom:67%;" /></p>
]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>周报</tag>
      </tags>
  </entry>
  <entry>
    <title>周报：2021-1-4~2021-1-10</title>
    <url>/2021/01/09/%E5%91%A8%E6%8A%A5%EF%BC%9A2021-1-4-2021-1-10/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<p>本周校内工作：</p>
<ul>
<li>《专业创新实践》课程论文答辩结束</li>
<li>《课程设计》大作业 1.10 完工</li>
</ul>
<p>本周毕业设计工作：</p>
<ul>
<li><p>看完SpectralDiffuserCam论文并阅读源码 <a href="https://github.com/Waller-Lab/SpectralDiffuserCam">Waller-Lab / SpectralDiffuserCam</a></p>
</li>
<li><p>阅读文献：Daniel S. Jeon, Seung-Hwan Baek, Shinyoung Yi, Qiang Fu, Xiong Dun, Wolfgang Heidrich, and Min H. Kim. 2019. <strong>Compact snapshot hyperspectral imaging with diffracted rotation</strong>. <i>ACM Trans. Graph.</i> 38, 4, Article 117 (July 2019), 13 pages. DOI:<a href="https://doi.org/10.1145/3306346.3322946">https://doi.org/10.1145/3306346.3322946</a></p>
</li>
</ul>
<h2 id="Paper-1"><a href="#Paper-1" class="headerlink" title="Paper 1"></a>Paper 1</h2><h3 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h3><p>《光谱Diffuser相机：基于滤光片阵列的无镜片快照高光谱成像》</p>
<p>Monakhova K , Yanny K , Aggarwal N , et al. <strong>Spectral DiffuserCam: lensless snapshot hyperspectral imaging with a spectral filter array</strong>[J]. Optica, 2020.</p>
<h3 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h3><p>本文是基于该课题组前一篇DiffuserCam的三维成像文章，实验装置与DiffuserCam相同，不同的是将滤光片阵列附着在传感器上，使得sensor能接受到不同光谱段的色彩信息，从二维图像中利用FISTA重建算法求解欠定优化问题，从而恢复出原始高光谱图像。</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210112154209616.png" alt="image-20210112154209616"></p>
<p>其中的PSF需要标定，在sensor上附着多个滤光片阵列，每一个都用来收集不同的光谱信息（如下图所示），最终叠加得到图像。</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210112165716969.png" alt="image-20210112165716969" style="zoom:50%;" /></p>
<h3 id="Code-Explanation"><a href="#Code-Explanation" class="headerlink" title="Code Explanation"></a>Code Explanation</h3><p>Python代码中，<code>helper_functions.py</code> 定义了包括crop和pad等操作，并且实现了将64个光谱段的图像叠加并生成RGB图像的函数，用于可视化重建结果。</p>
<p>代码实现的卷积操作和diffusercam的类似，还是需要先傅里叶变换，再在频域内求乘法，再反变换回去。</p>
<p>核心代码为 <code>fista_spectral_cupy.py</code>，主要实现了 带有TV正则化、低秩修正、稀疏修正参数的FISTA优化算法，采用幂迭代求解最大模特征值，用来确定迭代步长大小。</p>
<h2 id="Paper-2"><a href="#Paper-2" class="headerlink" title="Paper 2"></a>Paper 2</h2><h3 id="Title-1"><a href="#Title-1" class="headerlink" title="Title"></a>Title</h3><p>《基于衍射旋转图案的压缩快照式高光谱成像》</p>
<p>Daniel S. Jeon, Seung-Hwan Baek, Shinyoung Yi, Qiang Fu, Xiong Dun, Wolfgang Heidrich, and Min H. Kim. 2019. <strong>Compact snapshot hyperspectral imaging with diffracted rotation</strong>. <i>ACM Trans. Graph.</i> 38, 4, Article 117 (July 2019), 13 pages</p>
<h3 id="Contents-1"><a href="#Contents-1" class="headerlink" title="Contents"></a>Contents</h3><p>本文提出了一种基于衍射方法的快照高光谱成像技术，作者自己设计了一种小型的螺旋形衍射元件，将其装在相机镜头前，通过标定得到独特的PSF传递函数，然后利用U-Net神经网络实现端到端的重建方法。</p>
<p>本文提到，利用衍射方法实现高光谱成像，有以下两个问题：</p>
<ol>
<li>传统衍射元件无法实现在不连续光照条件下的全光谱段成像</li>
<li>由于衍射产生的图案并不是高度编码的（如 编码孔径），所以问题的欠定性更强，更难求解</li>
</ol>
<p>为了解决这两个问题，本文提出的方法有如下特点：</p>
<ul>
<li>自行设计制作一种能够实现随光谱段变化而产生各向异的PSF变化的衍射元件</li>
<li><p>采用端到端的基于U-net的神经网络方法解决高度欠定问题</p>
</li>
<li><p>体积小，仅需相机和单个衍射元件即可完成图像捕捉</p>
</li>
</ul>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210112185541576.png" alt="image-20210112185541576" style="zoom:67%;" /></p>
<p>下图所示为设计的PSF图样，随着波长变化，它会发生旋转：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210112185616868.png" alt="image-20210112185616868" style="zoom: 67%;" /></p>
<p>所设计出的DOE如下图所示，它能够对不同波长的光产生不同的PSF响应。</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210112222349977.png" alt="image-20210112222349977" style="zoom:67%;" /></p>
<p>关于PSF的标定：</p>
<ul>
<li>它解释了光源深度和光源x,y位置对PSF图像的影响。其中，光源深度对PSF的影响在深度 &gt;1.0m 之后就可以忽略不计，而x,y位置在视场角度27度以内都不会发生很大变化，可以认为忽略不计，因此标定只需要在空间中选定一个点标定即可。</li>
</ul>
<p>关于优化求解部分，为了解决高度欠定问题，作者使用了基于U-net的神经网络实现重建过程，求解模型为：</p>
<script type="math/tex; mode=display">
\mathbf{J=\Phi I}\\
\mathbf{\Phi = \Omega P}</script><p>其中，$\mathbf J$为传感器收集的数据，$\mathbf \Phi$为传感器敏感度矩阵$\mathbf \Omega$与PSF矩阵$\mathbf P$的乘积</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210112222643969.png" alt="image-20210112222643969" style="zoom: 67%;" /></p>
<p>作者将最终的成像结果与DD-CASSI和基于prism的高光谱相机做了对比，结果明显优于这两者。</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210112223026136.png" alt="image-20210112223026136"></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210112223035036.png" alt="image-20210112223035036"></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210112223226717.png" alt="image-20210112223226717"></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210112223058583.png" alt="image-20210112223058583" style="zoom: 67%;" /></p>
]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>周报</tag>
      </tags>
  </entry>
  <entry>
    <title>周报：2021-2-1~2021-2-7</title>
    <url>/2021/02/04/%E5%91%A8%E6%8A%A5%EF%BC%9A2021-2-1-2021-2-7/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<p>本周工作：</p>
<ul>
<li><p>查询CTIS专利情况</p>
</li>
<li><p>找到两篇关于 TwIST算法 的论文，以及代码</p>
</li>
</ul>
<h2 id="CTIS专利情况"><a href="#CTIS专利情况" class="headerlink" title="CTIS专利情况"></a>CTIS专利情况</h2><p>一开始简单写了个爬取 <a href="https://www.iprabc.com/">吉江数据</a> 的python爬虫，由于反爬的强大，无果，后考虑手动查找（结果并不多，60多个），结果已发送给导师。</p>
<h2 id="两篇-TwIST-论文"><a href="#两篇-TwIST-论文" class="headerlink" title="两篇 TwIST 论文"></a>两篇 TwIST 论文</h2><ol>
<li><p>BioucasDias, José M, Figueiredo M A T . Two-Step Algorithms for Linear Inverse Problems with Non-Quadratic Regularization[J]. 2006.</p>
</li>
<li><p>José M Bioucas-Dias, Figueiredo M A T . A New TwIST: Two-Step Iterative Shrinkage/Thresholding Algorithms for Image Restoration[J]. IEEE Transactions on Image Processing, 2008, 16(12):2992-3004.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>周报</tag>
      </tags>
  </entry>
  <entry>
    <title>周报：2021-2-15~2021-2-21</title>
    <url>/2021/02/18/%E5%91%A8%E6%8A%A5%EF%BC%9A2021-2-15-2021-2-21/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<p>本周工作：</p>
<ul>
<li><p>Ding H , Chen C , Zhao H , et al. <strong>Smartphone based multispectral imager and its potential for point-of-care testing</strong>[J]. Analyst, 2019, 144.</p>
</li>
<li><p>Deng C , Hu X , Suo J , et al. <strong>Snapshot hyperspectral imaging via spectral basis multiplexing in Fourier domain</strong>[J]. Optics Express, 2018, 26(25):32509.</p>
</li>
<li><p>Andrea Toulouse, Johannes Drozella, Simon Thiele,等. <strong>3D-printed miniature spectrometer for the visible range with a 100 × 100 μm2 footprint</strong>[J]. 2021.</p>
</li>
</ul>
<h2 id="Paper-1"><a href="#Paper-1" class="headerlink" title="Paper 1"></a>Paper 1</h2><h3 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h3><p>《基于智能手机的多光谱成像仪及其即时检验的潜力》</p>
<p><strong>Smartphone based multispectral imager and its potential for point-of-care testing</strong></p>
<h3 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h3><p>本文提出了一种受昆虫复眼结构启发的能够结合手机相机实现的小型多光谱成像仪，目的是为了能够实现一次曝光时间内获取多光谱图像。</p>
<p>用于实现色散的小薄片本质采用了昆虫复眼结构，即：将若干成像镜片排列在 自制的法布里佩罗标准具（设定的不同谐振腔深度实现滤光片效果）前方，因此可以直接在后方成像，但所成的像在几何上有旋转偏差，因此只需要稍加处理即可完成多光谱图像数据立方体的构建。</p>
<p>为了实现化学和生物医学即时测量，作者定义了一个光学密度optical density (OD)用于量化和可视化，计算公式如下：</p>
<script type="math/tex; mode=display">
OD(x,y,\lambda) = \log{\frac{I'(x,y,\lambda)}{I'_0(x,y,\lambda)}}</script><p>色散装置如下：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210218230349379.png" alt="image-20210218230349379" style="zoom:67%;" /></p>
<p>整体装置示意图如下，其中，可以看到光源是经过线偏振的一束光，在光源后方放置了一个与光源正交的线偏振片，原因是：测量的物体发出的光在经过内部介质多次散射（基本上多余10次）后，已经处于解偏振状态，因此这些光是能够通过该偏振片的；而那些没有经过介质散射的光仍旧具有原来的偏振状态，因此无法通过该偏振片，传感器就能分辨出来光的强弱，也就能实现即时检测。</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210218230430514.png" alt="image-20210218230430514"></p>
<p>此外，手机获取到图像数据后，为了提高计算能力，考虑将数据通过WiFi传输到计算主机中，在主机中完成高速运算后再将数据返回给手机，手机上就能看到重建的图像。</p>
<p>重建的原理如下图（即：先构建几何转换一一对应关系，再实现转换）：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210218230253354.png" alt="image-20210218230253354"></p>
<h3 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h3><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210218231236195.png" alt="image-20210218231236195"></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210218231253813.png" alt="image-20210218231253813"></p>
<h2 id="Paper-2"><a href="#Paper-2" class="headerlink" title="Paper 2"></a>Paper 2</h2><h3 id="Title-1"><a href="#Title-1" class="headerlink" title="Title"></a>Title</h3><p>《傅里叶域复用快照高光谱成像》</p>
<p>Deng C , Hu X , Suo J , et al. <strong>Snapshot hyperspectral imaging via spectral basis multiplexing in Fourier domain</strong>[J]. Optics Express, 2018, 26(25):32509.</p>
<h3 id="Contents-1"><a href="#Contents-1" class="headerlink" title="Contents"></a>Contents</h3><p>本文提出了一种Fourier-Spectral-Multiplexing (FSM) 技术，通过将入射光进行滤光后经过正弦调制（DMD实现，满足在频域具有最小重叠），将调制后的图像经过求和并傅里叶变换转化到频域，会发现在频域有多个不同位置的亮斑，又因为自然图像傅里叶系数主要集中在中心的低频区域，因此可以只对亮斑的中心小部分低频区域采样即可通过算法重建出较好的高光谱图像。</p>
<p>本问题最终归结为一个压缩感知问题：</p>
<script type="math/tex; mode=display">
\min_{\bf {w}}\|{\bf {W}}\|_{\mathcal l_{2,1}} subject\ \ to\ \ {\bf {Y=SX}},\ \ and \ \ {\bf{X=TW}}</script><p>通过模拟试验出了对频域图案裁剪（欠采样）的最优尺寸：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210301103948393.png" alt="image-20210301103948393"></p>
<p>采用Matlab内基于拉格朗日乘子法的二次规划求解器，来求解约束优化问题，数据集为哥伦比亚大学的CAVE实验室多光谱数据库。</p>
<p>本文另一个重要亮点是采用了广义交替投影法（generalized alternative projection）来为重建图像解混叠：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210301104314805.png" alt="image-20210301104314805"></p>
<h3 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h3><p>实验部分，滤光作用使用了一个高速同步旋转圆盘(synchronized rotating color wheel, CW)实现，通过最小化两两光谱段响应的最大协方差来确定滤光片的种类和数量，最终定为六个。</p>
<p>灰度正弦调制模板(gray scale sinusoidal pattern module, GSM)采用DMD实现，应用抖动算法(dithering algorithm)实现二进制编码。</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210301104735432.png" alt="image-20210301104735432"></p>
<h3 id="Results-1"><a href="#Results-1" class="headerlink" title="Results"></a>Results</h3><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210301104803001.png" alt="image-20210301104803001"></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210301104814842.png" alt="image-20210301104814842"></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210301104827926.png" alt="image-20210301104827926"></p>
<h2 id="Paper-3"><a href="#Paper-3" class="headerlink" title="Paper 3"></a>Paper 3</h2><h3 id="Title-2"><a href="#Title-2" class="headerlink" title="Title"></a>Title</h3><p>《100*100平方微米尺寸3D打印微型可见光波段光谱仪》</p>
<p>Andrea Toulouse, Johannes Drozella, Simon Thiele,等. <strong>3D-printed miniature spectrometer for the visible range with a 100 × 100 μm2 footprint</strong>[J]. 2021.</p>
<h3 id="Contents-2"><a href="#Contents-2" class="headerlink" title="Contents"></a>Contents</h3><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210301105247999.png" alt="image-20210301105247999"></p>
<p><img src="C:\Users\wlx\AppData\Roaming\Typora\typora-user-images\image-20210301105441657.png" alt="image-20210301105441657"></p>
<p><img src="C:\Users\wlx\AppData\Roaming\Typora\typora-user-images\image-20210301105600456.png" alt="image-20210301105600456"></p>
]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>周报</tag>
      </tags>
  </entry>
  <entry>
    <title>周报：2021-3-1~2021-3-7</title>
    <url>/2021/03/08/%E5%91%A8%E6%8A%A5%EF%BC%9A2021-3-1-2021-3-7/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<p>本周工作：</p>
<ul>
<li><p>利用小波基优化了前期OMP算法的程序，2D图像重建结果得到显著提升</p>
</li>
<li><p>实现了CASSI的TwIST算法，并应用到了Columbia University的CAVE多光谱数据集上，图像重建各波段光谱恢复良好，但图像分辨率较低</p>
</li>
</ul>
<h2 id="基于小波基的2D图像CS重建-OMP算法"><a href="#基于小波基的2D图像CS重建-OMP算法" class="headerlink" title="基于小波基的2D图像CS重建(OMP算法)"></a>基于小波基的2D图像CS重建(OMP算法)</h2><p>最近下载到了一些CS的算法代码，也看了一些博客，学习到了如何对2D图像在稀疏基作用下进行稀疏表示，并用OMP算法进行重建的步骤。将其对我前期的OMP算法代码进行了改进，发现重构效果也不差，噪声更小。</p>
<p>参考Blog：</p>
<ul>
<li><a href="https://blog.csdn.net/qq_37694664/article/details/78724204">CSDN 压缩感知稀疏基之离散小波变换</a></li>
</ul>
<p>原始在DCT基下重建的效果如下：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210309095247973.png" alt="image-20210309095247973" style="zoom:50%;" /></p>
<p>在DWT基下的重建效果如下：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210309095401761.png" alt="image-20210309095401761" style="zoom: 80%;" /></p>
<p>其中生成DWT基的代码如下（并附上我自己改的Python版）：</p>
<details>
    <summary>Matlab code</summary>

<figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-comment">%  程序作者：沙威，香港大学电气电子工程学系，wsha@eee.hku.hk</span><br><span class="hljs-comment">%  参考文献：小波分析理论与MATLAB R2007实现，葛哲学，沙威，第20章  小波变换在矩阵方程求解中的应用（沙威、陈明生编写）.</span><br><br><span class="hljs-comment">%  构造正交小波变换矩阵，图像大小N*N，N=2^P，P是整数。</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ww</span>=<span class="hljs-title">DWT</span><span class="hljs-params">(N)</span></span><br><br>[h,g]= wfilters(<span class="hljs-string">&#x27;sym8&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>);       <span class="hljs-comment">%  分解低通和高通滤波器</span><br><br><span class="hljs-comment">% N=256;                           %  矩阵维数(大小为2的整数幂次)</span><br>L=<span class="hljs-built_in">length</span>(h);                       <span class="hljs-comment">%  滤波器长度</span><br>rank_max=<span class="hljs-built_in">log2</span>(N);                  <span class="hljs-comment">%  最大层数</span><br>rank_min=double(int8(<span class="hljs-built_in">log2</span>(L)))+<span class="hljs-number">1</span>;  <span class="hljs-comment">%  最小层数</span><br>ww=<span class="hljs-number">1</span>;   <span class="hljs-comment">%  预处理矩阵</span><br><br><span class="hljs-comment">%  矩阵构造</span><br><span class="hljs-keyword">for</span> jj=rank_min:rank_max<br>    <br>    nn=<span class="hljs-number">2</span>^jj;<br>    <br>    <span class="hljs-comment">%  构造向量</span><br>    p1_0=sparse([h,<span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,nn-L)]);<br>    p2_0=sparse([g,<span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,nn-L)]);<br>    <br>    <span class="hljs-comment">%  向量圆周移位</span><br>    <span class="hljs-keyword">for</span> ii=<span class="hljs-number">1</span>:nn/<span class="hljs-number">2</span><br>        p1(ii,:)=<span class="hljs-built_in">circshift</span>(p1_0&#x27;,<span class="hljs-number">2</span>*(ii<span class="hljs-number">-1</span>))&#x27;;<br>        p2(ii,:)=<span class="hljs-built_in">circshift</span>(p2_0&#x27;,<span class="hljs-number">2</span>*(ii<span class="hljs-number">-1</span>))&#x27;;<br>    <span class="hljs-keyword">end</span><br>    <br>    <span class="hljs-comment">%  构造正交矩阵</span><br>    w1=[p1;p2];<br>    mm=<span class="hljs-number">2</span>^rank_max-<span class="hljs-built_in">length</span>(w1);<br>    w=sparse([w1,<span class="hljs-built_in">zeros</span>(<span class="hljs-built_in">length</span>(w1),mm);<span class="hljs-built_in">zeros</span>(mm,<span class="hljs-built_in">length</span>(w1)),<span class="hljs-built_in">eye</span>(mm,mm)]);<br>    ww=ww*w;<br>    <br>    clear p1;clear p2;<br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure>

</details>

<details>
    <summary>Python code</summary>

<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pywt<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">DWT</span>(<span class="hljs-params">N</span>):<br>    sym8 = pywt.Wavelet(<span class="hljs-string">&#x27;haar&#x27;</span>) <span class="hljs-comment"># 选sym8小波</span><br>    lod,hid = sym8.dec_lo, sym8.dec_hi <span class="hljs-comment"># 分解低通和高通</span><br>    L = <span class="hljs-built_in">len</span>(lod) <span class="hljs-comment"># 小波长度</span><br>    <span class="hljs-comment"># print(L)</span><br>    rank_max = np.log2(N) <span class="hljs-comment"># 最大层数</span><br>    rank_min = <span class="hljs-built_in">float</span>(np.int8(np.log2(L))) + <span class="hljs-number">1</span> <span class="hljs-comment"># 最小层数</span><br>    res = <span class="hljs-number">1</span> <span class="hljs-comment"># result</span><br>    <span class="hljs-keyword">for</span> jj <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">int</span>(rank_min),<span class="hljs-built_in">int</span>(rank_max)+<span class="hljs-number">1</span>):<br>        nn = <span class="hljs-number">2</span> ** jj<br>        p1_0 = np.r_[lod, np.zeros(nn-L)]<br>        p2_0 = np.r_[hid, np.zeros(nn-L)]<br>        p1 = np.zeros((nn//<span class="hljs-number">2</span>, nn))<br>        p2 = np.zeros((nn//<span class="hljs-number">2</span>, nn))<br>        <span class="hljs-keyword">for</span> ii <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nn//<span class="hljs-number">2</span>):<br>            p1[ii, :] = np.roll(p1_0.T, <span class="hljs-number">2</span>*ii, axis=<span class="hljs-number">0</span>).T<br>            p2[ii, :] = np.roll(p2_0.T, <span class="hljs-number">2</span>*ii, axis=<span class="hljs-number">0</span>).T<br>        w1 = np.r_[p1,p2]<br>        mm = <span class="hljs-built_in">int</span>(<span class="hljs-number">2</span>**rank_max - <span class="hljs-built_in">len</span>(w1))<br>        uphalf = np.c_[w1, np.zeros((<span class="hljs-built_in">len</span>(w1),mm))]<br>        downhalf = np.c_[np.zeros((mm,<span class="hljs-built_in">len</span>(w1))), np.eye(mm)]<br>        w = np.r_[uphalf,downhalf]<br>        res = np.dot(res, w)<br>        <br>    <span class="hljs-keyword">return</span> res<br></code></pre></div></td></tr></table></figure>

</details>

<p>重建代码也附上：</p>
<details>
    <summary>Matlab (Gauss Random Matrix)</summary>

<figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-comment">%  本程序实现图像LENA的压缩传感</span><br><span class="hljs-comment">%  程序作者：沙威，香港大学电气电子工程学系，wsha@eee.hku.hk</span><br><span class="hljs-comment">%  算法采用正交匹配法，参考文献 Joel A. Tropp and Anna C. Gilbert </span><br><span class="hljs-comment">%  Signal Recovery From Random Measurements Via Orthogonal Matching</span><br><span class="hljs-comment">%  Pursuit，IEEE TRANSACTIONS ON INFORMATION THEORY, VOL. 53, NO. 12,</span><br><span class="hljs-comment">%  DECEMBER 2007.</span><br><span class="hljs-comment">%  该程序没有经过任何优化</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Wavelet_OMP</span></span><br><br>clc;clear<br><br><span class="hljs-comment">%  读文件</span><br>X=imread(<span class="hljs-string">&#x27;lena256.bmp&#x27;</span>);<br>X=double(X);<br>[a,b]=<span class="hljs-built_in">size</span>(X);<br><br><span class="hljs-comment">%  小波变换矩阵生成</span><br>ww=DWT(a);<br><br><span class="hljs-comment">%  小波变换让图像稀疏化（注意该步骤会耗费时间，但是会增大稀疏度）</span><br>X1=ww*sparse(X)*ww&#x27;;<br>X1=full(X1);<br><br><br><br><span class="hljs-comment">%  随机矩阵生成</span><br>M=<span class="hljs-number">190</span>;<br>R= GaussMtx(M,a);<br>    <br><span class="hljs-comment">%  测量</span><br>Y=R*X1;<br><br><span class="hljs-comment">%  OMP算法</span><br>X2=<span class="hljs-built_in">zeros</span>(a,b);  <span class="hljs-comment">%  恢复矩阵</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:b  <span class="hljs-comment">%  列循环       </span><br>    rec=omp(Y(:,<span class="hljs-built_in">i</span>),R,a);<br>    X2(:,<span class="hljs-built_in">i</span>)=rec;<br><span class="hljs-keyword">end</span><br><br><br><span class="hljs-comment">%  原始图像</span><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">1</span>);<br>imshow(uint8(X));<br><br><br><span class="hljs-comment">%  变换图像   %小波变换后的图像</span><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">2</span>);<br>imshow(uint8(X1));<br><br><br><span class="hljs-comment">%测量值图像</span><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">3</span>);<br>imshow(uint8(Y));<br><br><br><span class="hljs-comment">%  压缩传感恢复的图像</span><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">4</span>);<br>X3=ww&#x27;*sparse(X2)*ww;  <span class="hljs-comment">%  小波反变换</span><br>X3=full(X3);<br>imshow(uint8(X3));<br><br><br><span class="hljs-comment">%  误差(PSNR)</span><br>errorx=sum(sum(<span class="hljs-built_in">abs</span>(X3-X).^<span class="hljs-number">2</span>));       <span class="hljs-comment">%  MSE误差</span><br>psnr=<span class="hljs-number">10</span>*<span class="hljs-built_in">log10</span>(<span class="hljs-number">255</span>*<span class="hljs-number">255</span>/(errorx/a/b))   <span class="hljs-comment">%  PSNR</span><br> dNMSE = nmse(uint8(X),uint8(X3))   <span class="hljs-comment">%NMSE误差</span><br><br><span class="hljs-comment">%  OMP的函数</span><br><span class="hljs-comment">%  s-测量；T-观测矩阵；N-向量大小</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hat_y</span>=<span class="hljs-title">omp</span><span class="hljs-params">(s,T,N)</span></span><br><br>Size=<span class="hljs-built_in">size</span>(T);                                     <span class="hljs-comment">%  观测矩阵大小</span><br>M=Size(<span class="hljs-number">1</span>);                                        <span class="hljs-comment">%  测量</span><br>hat_y=<span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,N);                                 <span class="hljs-comment">%  待重构的谱域(变换域)向量                     </span><br>Aug_t=[];                                         <span class="hljs-comment">%  增量矩阵(初始值为空矩阵)</span><br>r_n=s;                                            <span class="hljs-comment">%  残差值</span><br><br><span class="hljs-keyword">for</span> times=<span class="hljs-number">1</span>:M/<span class="hljs-number">4</span>;                                  <span class="hljs-comment">%  迭代次数(稀疏度是测量的1/4)</span><br>    <span class="hljs-keyword">for</span> col=<span class="hljs-number">1</span>:N;                                  <span class="hljs-comment">%  恢复矩阵的所有列向量</span><br>        product(col)=<span class="hljs-built_in">abs</span>(T(:,col)&#x27;*r_n);          <span class="hljs-comment">%  恢复矩阵的列向量和残差的投影系数(内积值) </span><br>    <span class="hljs-keyword">end</span><br>    [val,pos]=<span class="hljs-built_in">max</span>(product);                       <span class="hljs-comment">%  最大投影系数对应的位置</span><br>    Aug_t=[Aug_t,T(:,pos)];                       <span class="hljs-comment">%  矩阵扩充</span><br>    T(:,pos)=<span class="hljs-built_in">zeros</span>(M,<span class="hljs-number">1</span>);                          <span class="hljs-comment">%  选中的列置零（实质上应该去掉，为了简单我把它置零）</span><br>    aug_y=(Aug_t&#x27;*Aug_t)^(<span class="hljs-number">-1</span>)*Aug_t&#x27;*s;           <span class="hljs-comment">%  最小二乘,使残差最小</span><br>    r_n=s-Aug_t*aug_y;                            <span class="hljs-comment">%  残差</span><br>    pos_array(times)=pos;                         <span class="hljs-comment">%  纪录最大投影系数的位置</span><br>    <br>    <span class="hljs-keyword">if</span> (norm(r_n)&lt;<span class="hljs-number">9</span>)                              <span class="hljs-comment">%  残差足够小</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br>hat_y(pos_array)=aug_y;                           <span class="hljs-comment">%  重构的向量</span><br></code></pre></div></td></tr></table></figure>

</details>

<details>
    <summary>Python (Gauss Random Matrix)</summary>

<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> scipy.optimize <span class="hljs-keyword">as</span> spopt<br><span class="hljs-keyword">import</span> scipy.fftpack <span class="hljs-keyword">as</span> spfft<br><span class="hljs-keyword">import</span> scipy.ndimage <span class="hljs-keyword">as</span> spimg<br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> linalg<br><span class="hljs-keyword">from</span> DWT <span class="hljs-keyword">import</span> DWT<br><br><span class="hljs-comment"># OMP algorithm</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">OMP</span>(<span class="hljs-params">y,A,K</span>):<br>	col = A.shape[<span class="hljs-number">1</span>]<br>	residual = y<br>	ind = []<br>	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(K):<br>		prod = np.fabs(np.dot(A.T,residual))<br>		pos = np.argmax(prod)<br>		ind.append(pos)<br>		a = np.dot(np.linalg.pinv(A[:,ind]),y)<br>		residual = y-np.dot(A[:,ind],a)<br>	<br>	Res = np.zeros((col,))<br>	Res[ind] = a<br>	<span class="hljs-comment"># print(Res.shape)</span><br>	<span class="hljs-keyword">return</span> Res<br><br>img = cv2.imread(<span class="hljs-string">r&quot;E:\Graduation-Project\OMP\lena.jpg&quot;</span>)<br>img = img[<span class="hljs-number">128</span>:<span class="hljs-number">128</span>+<span class="hljs-number">256</span>, <span class="hljs-number">128</span>:<span class="hljs-number">128</span>+<span class="hljs-number">256</span>, <span class="hljs-number">0</span>]<br><br><span class="hljs-comment"># cv2.imshow(&quot;img&quot;,img)</span><br><span class="hljs-comment"># cv2.waitKey(0)</span><br><br><span class="hljs-comment"># radom gaussian matrix ----&gt; undersample</span><br>sample_rate = <span class="hljs-number">0.7</span><br>N = <span class="hljs-number">256</span><br>Phi = np.random.randn(<span class="hljs-built_in">int</span>(sample_rate*N),N)<br><span class="hljs-comment"># Phi = linalg.orth(Phi.T).T </span><br><span class="hljs-comment"># Phi /= np.linalg.norm(Phi)</span><br><br><span class="hljs-comment"># plt.imshow(Phi)</span><br><span class="hljs-comment"># plt.colorbar()</span><br><span class="hljs-comment"># plt.show()</span><br><span class="hljs-comment"># exit(0)</span><br><br><br><span class="hljs-comment"># sym8 Wavelet ----&gt; sparse base</span><br>Psi = DWT(N)<br>img = np.dot(np.dot(Psi,img),Psi.T)<br><br><span class="hljs-comment"># plt.imshow(Psi)</span><br><span class="hljs-comment"># plt.colorbar()</span><br><span class="hljs-comment"># plt.show()</span><br><span class="hljs-comment"># exit(0)</span><br><br><br><span class="hljs-comment"># measurement ----&gt; undersample image</span><br>measure_mat = np.dot(Phi,img)<br><br><span class="hljs-comment"># K coefficient for N colomns</span><br>sparse_coe = np.zeros((N,N))<br><br><span class="hljs-comment"># θ = Φ ψ</span><br><span class="hljs-comment"># Theta = np.dot(Phi,Psi)</span><br><br>Theta = Phi<br><br><br>time_consume = []<br><span class="hljs-comment"># OMP for every colomn</span><br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">10</span>):<br>	st = time.perf_counter()<br>	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):<br>		sparse_coe[:,i] = OMP(measure_mat[:,i],Theta,k)<br>	en = time.perf_counter()<br>	img_rec = np.dot(np.dot(Psi.T,sparse_coe),Psi)<br>	<span class="hljs-comment"># img_rec /= img_rec.max()</span><br>	<span class="hljs-comment"># img_rec *= 255</span><br>	img_rec = img_rec.astype(np.uint8)<br>	<span class="hljs-comment"># print(img_rec.shape)</span><br>	<span class="hljs-comment"># print(img.shape)</span><br>	<span class="hljs-comment"># cv2.imshow(&quot;img&quot;,img)</span><br>	cv2.imshow(<span class="hljs-string">&quot;rate=%.1f,k=%d&quot;</span>%(sample_rate,k),img_rec)<br>	sys.stdout.writelines(<span class="hljs-string">f&quot;rate=<span class="hljs-subst">&#123;sample_rate:<span class="hljs-number">.1</span>f&#125;</span>,k=<span class="hljs-subst">&#123;k&#125;</span> runtime:<span class="hljs-subst">&#123;en-st&#125;</span>s\n&quot;</span>)<br>	time_consume.append(en-st)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure>

</details>



<h2 id="CASSI系统TwIST算法对高光谱数据集的模拟试验"><a href="#CASSI系统TwIST算法对高光谱数据集的模拟试验" class="headerlink" title="CASSI系统TwIST算法对高光谱数据集的模拟试验"></a>CASSI系统TwIST算法对高光谱数据集的模拟试验</h2><p>在Github上下载了对应的原版CASSI源码后，花了两天时间将其改为Python版，无奈跑得太慢，只好屈服于MATLAB。。。</p>
<h3 id="重建步骤梳理"><a href="#重建步骤梳理" class="headerlink" title="重建步骤梳理"></a>重建步骤梳理</h3><h4 id="1-读取图像、构造编码孔径、预处理（shearing-amp-smash）"><a href="#1-读取图像、构造编码孔径、预处理（shearing-amp-smash）" class="headerlink" title="1. 读取图像、构造编码孔径、预处理（shearing &amp; smash）"></a>1. 读取图像、构造编码孔径、预处理（shearing &amp; smash）</h4><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-comment">%%</span><br>close all;clear all;clc;<br><br><span class="hljs-comment">% 256 x 256 x 31 的多光谱图像</span><br>R = <span class="hljs-number">256</span>;<br>C = <span class="hljs-number">256</span>;<br>L = <span class="hljs-number">31</span>;<br><br>coded_aperture = randi([<span class="hljs-number">0.</span>,<span class="hljs-number">1.</span>],[R,C]); <span class="hljs-comment">% 随机01编码孔径</span><br>coded_aperture = <span class="hljs-built_in">repmat</span>(coded_aperture,[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,L]); <span class="hljs-comment">% 补充光谱维度</span><br>coded_aperture_shift = shift(coded_aperture, <span class="hljs-number">1</span>); <span class="hljs-comment">% shearing</span><br><br><span class="hljs-comment">% 读取CAVE数据集并整合成mat</span><br>path = <span class="hljs-string">&#x27;..\CAVE_dataset\glass_tiles_ms\glass_tiles_ms\glass_tiles_ms_&#x27;</span>;<br><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:<span class="hljs-number">31</span>;<br>    tp = imread([path num2str(<span class="hljs-built_in">i</span>,<span class="hljs-string">&#x27;%02d&#x27;</span>) <span class="hljs-string">&#x27;.png&#x27;</span>]);<br>    origin_img(:,:,<span class="hljs-built_in">i</span>) = double(tp(<span class="hljs-number">128</span>:<span class="hljs-number">128</span>+R<span class="hljs-number">-1</span>,<span class="hljs-number">128</span>:<span class="hljs-number">128</span>+C<span class="hljs-number">-1</span>)); <span class="hljs-comment">% 转成double好算点积</span><br><span class="hljs-keyword">end</span><br>origin_img = origin_img/<span class="hljs-built_in">max</span>(origin_img(:)); <span class="hljs-comment">% 对原图归一化</span><br>save([<span class="hljs-string">&#x27;orig_data_1.mat&#x27;</span>],<span class="hljs-string">&#x27;origin_img&#x27;</span>);<br><br>origin_img_shift = shift(origin_img, <span class="hljs-number">1</span>); <span class="hljs-comment">% shearing</span><br>y = sum(origin_img_shift.*coded_aperture_shift, <span class="hljs-number">3</span>); <span class="hljs-comment">% smash</span><br>y = y/<span class="hljs-built_in">max</span>(y(:)); <span class="hljs-comment">% 归一化</span><br><span class="hljs-built_in">figure</span>;imagesc(y);colormap gray;axis image;colorbar;set(gcf,<span class="hljs-string">&#x27;color&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>); <span class="hljs-comment">% 作图（模拟的detector探测结果）</span><br></code></pre></div></td></tr></table></figure>
<p>其中，<code>shift</code>函数如下：</p>
<figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">y</span> = <span class="hljs-title">shift</span><span class="hljs-params">(x, step)</span></span><br>    [R,C,L] = <span class="hljs-built_in">size</span>(x);<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:L<br>        y(:,<span class="hljs-built_in">i</span>*step:<span class="hljs-built_in">i</span>*step+C<span class="hljs-number">-1</span>,<span class="hljs-built_in">i</span>) = x(:,:,<span class="hljs-built_in">i</span>);<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure>
<h4 id="2-设定正则化参数和迭代次数"><a href="#2-设定正则化参数和迭代次数" class="headerlink" title="2. 设定正则化参数和迭代次数"></a>2. 设定正则化参数和迭代次数</h4><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-comment">%%</span><br><span class="hljs-comment">%Regularization parameter</span><br>tau = <span class="hljs-number">0.05</span>; <span class="hljs-comment">% L1正则化参数，越大解越稀疏</span><br><br><span class="hljs-comment">%Number of TwIST main loop iterations</span><br>maxiterations = <span class="hljs-number">50</span>; <span class="hljs-comment">% 最大迭代次数</span><br></code></pre></div></td></tr></table></figure>
<h4 id="3-构建CASSI系统的传递模型及其转置"><a href="#3-构建CASSI系统的传递模型及其转置" class="headerlink" title="3. 构建CASSI系统的传递模型及其转置"></a>3. 构建CASSI系统的传递模型及其转置</h4><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-comment">%%</span><br><span class="hljs-comment">%Define the functional forms for the Forward and Forward^T models</span><br>A = @(x) Rfuntwist(x,coded_aperture_shift);<br>AT = @(x) RTfuntwist(x,coded_aperture_shift);<br></code></pre></div></td></tr></table></figure>
<p>其中两个函数分别为正向传递的模型和它的转置：</p>
<figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">y</span> = <span class="hljs-title">Rfuntwist</span><span class="hljs-params">(f,C)</span></span><br>    [n1,n2,m] = <span class="hljs-built_in">size</span>(C);<br>    f = <span class="hljs-built_in">reshape</span>(f,[n1,n2,m]); <span class="hljs-comment">% reshape成数据立方体格式</span><br>    gp = f.*C; <span class="hljs-comment">% 对每个光谱段图像编码</span><br>    y = sum(gp,<span class="hljs-number">3</span>); <span class="hljs-comment">% 沿光谱维度叠加投影到CCD上</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span> = <span class="hljs-title">RTfuntwist</span><span class="hljs-params">(y,C)</span></span><br>    [n1,n2,m] = <span class="hljs-built_in">size</span>(C);<br>    y=<span class="hljs-built_in">reshape</span>(y,n1,n2);<br>    yp = <span class="hljs-built_in">repmat</span>(y,[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,m]); <span class="hljs-comment">% 沿光谱维度复制m份</span><br>    f = yp.*C; <span class="hljs-comment">% 编码</span><br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure>
<h4 id="4-定义去噪函数-放弃软阈值，采用全变分去噪"><a href="#4-定义去噪函数-放弃软阈值，采用全变分去噪" class="headerlink" title="4. 定义去噪函数 (放弃软阈值，采用全变分去噪)"></a>4. 定义去噪函数 (放弃软阈值，采用全变分去噪)</h4><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-comment">%%Preparing to run TwIST</span><br><span class="hljs-comment">%Number of Chambolle iterations to perform for total variation minimization</span><br>piter = <span class="hljs-number">4</span>; <span class="hljs-comment">% 全变分去噪迭代次数</span><br><br>Psi = @(x,th) mycalltoTVnew(x,th,piter); <span class="hljs-comment">% 全变分去噪</span><br>Phi = @(x) TVnormspectralimaging(x); <span class="hljs-comment">% 定义去噪问题的正则项为光谱图像梯度和</span><br></code></pre></div></td></tr></table></figure>
<p>全变分去噪采用<code>Chambolle projection&#39;s algorithm</code></p>
<h4 id="5-TwIST重建"><a href="#5-TwIST重建" class="headerlink" title="5. TwIST重建"></a>5. TwIST重建</h4><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">tolA = <span class="hljs-number">1e-8</span>; <span class="hljs-comment">% 收敛标准</span><br><span class="hljs-comment">%Run TwIST</span><br>[x_twist_orig,dummy,obj_twist,...<br>    times_twist,dummy,mse_twist]= ...<br>    TwISTmod(y,A,tau,...<br>    <span class="hljs-string">&#x27;AT&#x27;</span>, AT, ...<br>    <span class="hljs-string">&#x27;Psi&#x27;</span>, Psi, ...<br>    <span class="hljs-string">&#x27;Phi&#x27;</span>,Phi, ...<br>    <span class="hljs-string">&#x27;Initialization&#x27;</span>,<span class="hljs-number">2</span>,...<br>    <span class="hljs-string">&#x27;Monotone&#x27;</span>,<span class="hljs-number">1</span>,...<br>    <span class="hljs-string">&#x27;StopCriterion&#x27;</span>,<span class="hljs-number">1</span>,...<br>    <span class="hljs-string">&#x27;MaxIterA&#x27;</span>,maxiterations,...<br>    <span class="hljs-string">&#x27;ToleranceA&#x27;</span>,tolA,...<br>    <span class="hljs-string">&#x27;Debias&#x27;</span>,<span class="hljs-number">0</span>,...<br>    <span class="hljs-string">&#x27;Verbose&#x27;</span>, <span class="hljs-number">1</span>);<br></code></pre></div></td></tr></table></figure>
<h4 id="6-图像复原"><a href="#6-图像复原" class="headerlink" title="6. 图像复原"></a>6. 图像复原</h4><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-comment">%x_twist is the estimate of the data cube. Prepare it to be displayed as a colored cube.</span><br>x_twist = x_twist_orig;<br>x_twist = x_twist.*(x_twist&gt;=<span class="hljs-number">0</span>); <span class="hljs-comment">% 去掉负值</span><br>x_twist = x_twist/<span class="hljs-built_in">max</span>(x_twist(:));<br>x_twist = shift_back(x_twist,<span class="hljs-number">1</span>);<br>save([<span class="hljs-string">&#x27;rec_result_1.mat&#x27;</span>],<span class="hljs-string">&#x27;x_twist&#x27;</span>);<br></code></pre></div></td></tr></table></figure>
<p>其中，<code>shift_back</code>函数如下：</p>
<figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">y</span> = <span class="hljs-title">shift_back</span><span class="hljs-params">(x, step)</span></span><br>    [R,C,L] = <span class="hljs-built_in">size</span>(x);<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:L<br>        y(:,:,<span class="hljs-built_in">i</span>) = x(:,<span class="hljs-built_in">i</span>*step:<span class="hljs-built_in">i</span>*step+R<span class="hljs-number">-1</span>,<span class="hljs-built_in">i</span>);<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure>
<h3 id="重建结果"><a href="#重建结果" class="headerlink" title="重建结果"></a>重建结果</h3><p><img src="C:\Users\wlx\Desktop\本科毕设CASSI模拟部分\my_CASSI\reconstruction_res1_img.png" alt="reconstruction_res1_img" style="zoom: 25%;" /></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210310192447973.png" alt="image-20210310192447973" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>周报</tag>
      </tags>
  </entry>
  <entry>
    <title>周报：2021-3-8~2021-3-14</title>
    <url>/2021/03/10/%E5%91%A8%E6%8A%A5%EF%BC%9A2021-3-8-2021-3-14/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<p>本周工作：</p>
<ul>
<li><p>将CASSI的TwIST算法应用在火焰高光谱图像上，并获得良好的光谱重建结果，但空间分辨率有待进一步提高</p>
</li>
<li></li>
</ul>
<h2 id="CASSI系统TwIST算法模拟火焰高光谱图像的重建"><a href="#CASSI系统TwIST算法模拟火焰高光谱图像的重建" class="headerlink" title="CASSI系统TwIST算法模拟火焰高光谱图像的重建"></a>CASSI系统TwIST算法模拟火焰高光谱图像的重建</h2><h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><p>此处，经过自身优化，将模拟参数设置如下：</p>
<ul>
<li>编码孔径设置为随机01编码孔径</li>
<li>凸优化问题的L1正则化参数设置为0.05，保证重建不失真但具有一定稀疏特性</li>
<li>最大迭代次数设置为50次</li>
<li>CASSI的Forward model从 原先的直接将编码孔径作用在测量值上形成 $N\times V\times L$ 的数据立方体 改为 <strong>将这个数据立方体中对应shear后的原先图像之外的区域元素值置零</strong>（自行改进，认为会在迭代过程中消除一部分artifacts的影响）</li>
<li>Chambolle全变分去噪迭代次数设置为4次</li>
<li>全变分去噪问题的正则化项设置为图像的总梯度之和</li>
<li>TwIST迭代的目标函数收敛判据tolerance设置为$10^{-8}$</li>
</ul>
<h3 id="重建结果"><a href="#重建结果" class="headerlink" title="重建结果"></a>重建结果</h3><center><font size=5>Detector measurement</font></center>

<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210310193958541.png" alt="image-20210310193958541" style="zoom:50%;" /></p>
<center><font size=5>Reconstruction image</font></center>

<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210310194222676.png" alt="image-20210310194222676" style="zoom:50%;" /></p>
<center><font size=5>Reconstruction results</font></center>

<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20210310194304620.png" alt="image-20210310194304620" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>周报</tag>
      </tags>
  </entry>
  <entry>
    <title>哈夫曼树</title>
    <url>/2020/04/24/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
    <content><![CDATA[<h2 id="浅析-数据结构：哈夫曼树"><a href="#浅析-数据结构：哈夫曼树" class="headerlink" title="浅析 数据结构：哈夫曼树"></a><center>浅析 数据结构：哈夫曼树</center></h2><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/d01373f082025aaff112f13f9e32d762024f1a03.jpeg" style="zoom: 33%;" /></p>
<span id="more"></span>
<p><strong>哈夫曼树</strong>是应用于编码（哈夫曼编码）的一种二叉树结构，也叫<strong>最优二叉树</strong>，哈夫曼树具有的特点为：</p>
<p>对于序列中的每一个数都作为叶子节点的权值，使得他们到根节点的<strong>带权路径和</strong>（叶子节点权值乘该节点到根节点路径长度）最小，那么很显然，如果一个叶子节点它的权值很大，那么它应该尽量离根节点近一些，才能保证整体最小    </p>
<p><strong>哈夫曼编码问题</strong>：对于一个字符序列，我们可以提前得到每个字符在序列中出现的次数（权值），现在问，如何对于序列中每一个字符，构造一个<strong>二进制数</strong>作为其编码，且满足任意一个编码不能是另一个编码的前缀（否则就编码矛盾了），且使得最终编码的整个字符序列长度最短</p>
<p>对于这样一个问题，我们可以将字符在序列中出现的次数作为权值，构造一颗哈夫曼树，将每个中间节点连出的两条边分别编码为0和1，最后就可以得出答案了，那么具体的构造过程如何实现呢？</p>
<h3 id="哈夫曼树构造过程"><a href="#哈夫曼树构造过程" class="headerlink" title="哈夫曼树构造过程"></a>哈夫曼树构造过程</h3><p>这是一个<strong>贪心</strong>的过程，我们需要用一个<strong>小根堆</strong>维护序列元素，每次取出最小的两个权值，将他们连到同一个父节点上，并且设置这个父节点的权值为两个儿子权值之和，随后将这个父节点push进小根堆中，如此循环，直到最后只有一个节点（父节点），那么哈弗曼树就构造好了，此时，<strong>所有中间节点的权值和就是最终的最短编码长度</strong></p>
<p>很简单，我这里现场手打一个</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">priority_queue&lt;<span class="hljs-type">int</span>&gt; pq;<br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(pq.<span class="hljs-built_in">size</span>()!=<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-type">int</span> temp=<span class="hljs-number">0</span>;<br>    temp+=pq.<span class="hljs-built_in">top</span>();pq.<span class="hljs-built_in">pop</span>();<br>    temp+=pq.<span class="hljs-built_in">top</span>();pq.<span class="hljs-built_in">pop</span>();<br>    ans+=temp;<br>    pq.<span class="hljs-built_in">push</span>(temp);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br></code></pre></div></td></tr></table></figure>
<p>因此，就延伸出了许多这样的题目，最典型的也就是下面这题</p>
<h3 id="P2168-荷马史诗（哈夫曼编码-优先队列）"><a href="#P2168-荷马史诗（哈夫曼编码-优先队列）" class="headerlink" title="P2168 荷马史诗（哈夫曼编码+优先队列）"></a><a href="https://www.luogu.com.cn/problem/P2168">P2168 荷马史诗</a>（哈夫曼编码+优先队列）</h3><p>这个题跟哈夫曼编码一模一样，就是把二进制数改为了k进制数，这就多出了两个需要注意的地方：</p>
<ul>
<li>每次需要从堆中取出<code>k</code>个数，然后求和作为父节点的权值</li>
<li>有可能最后不能恰好取完所有数，也就是说，有可能存在留着根节点的儿子不用的情况，这个时候我们发现：对于一棵具有<code>m</code>个中间节点的哈夫曼树，它具有<code>m*(k-1)+1</code>个叶子节点，即<code>m*(k-1)+1=n</code>,从而推出<code>(n-1)%(k-1)==0</code>，那么如果不满足这个式子，我们可以<u>聪明地</u>再堆中补0，直到满足（权值为0的节点），因为我们要尽可能让权值大的节点离父亲更近，所以补0能够产生使得所有节点都往父节点方向平移的效果</li>
</ul>
<p>除此之外，题目还要求保证总长度最短的情况下的最长字符编码的最短长度<del>（有点绕口）</del>，那么这个只需要在维护小根堆的时候，对于权值相同的节点，我们优先选高度较低的那几个点就行了</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bitset&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cassert&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cctype&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-comment">// #include&lt;bits/stdc++.h&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> All(x) (x).begin(),(x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mp make_pair</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">double</span> db;<br><span class="hljs-keyword">typedef</span> vector&lt;<span class="hljs-type">int</span>&gt; VI;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">const</span> db PI=<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<br><span class="hljs-type">const</span> db eps=<span class="hljs-number">1e-6</span>;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">2147483647</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">100005</span>;<br><span class="hljs-function">ll <span class="hljs-title">qpow</span><span class="hljs-params">(ll x,ll y)</span> </span>&#123;ll ans=<span class="hljs-number">1</span>,base=x; <span class="hljs-keyword">while</span>(y)&#123;<span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>)ans=(ans*base)%mod;base=(base*base)%mod;y&gt;&gt;=<span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">return</span> ans;&#125;<br><span class="hljs-function">ll <span class="hljs-title">gcd</span><span class="hljs-params">(ll a,ll b)</span> </span>&#123;<span class="hljs-keyword">return</span> b?<span class="hljs-built_in">gcd</span>(b,a%b):a;&#125;<br><br><span class="hljs-type">int</span> n,k;<br>ll x,ans;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br>	ll val,h;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> node&amp; rhs)<span class="hljs-type">const</span>&#123;<br>		<span class="hljs-keyword">if</span>(val==rhs.val) <span class="hljs-keyword">return</span> h&gt;rhs.h;<br>		<span class="hljs-keyword">return</span> val&gt;rhs.val;<br>	&#125;<br>&#125;;<br>priority_queue&lt;node&gt; pq;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;x),pq.<span class="hljs-built_in">push</span>(node&#123;x,<span class="hljs-number">1</span>&#125;);<br>	<span class="hljs-keyword">while</span>((n<span class="hljs-number">-1</span>)%(k<span class="hljs-number">-1</span>)!=<span class="hljs-number">0</span>) pq.<span class="hljs-built_in">push</span>(node&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;),n++;<br>	<span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">1</span>)&#123;<br>		<span class="hljs-comment">// printf(&quot;size:%d\n&quot;,pq.size());</span><br>		ll temp=<span class="hljs-number">0</span>,maxh=<span class="hljs-number">0</span>;<br>		<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,k)&#123;<br>			temp+=pq.<span class="hljs-built_in">top</span>().val;<br>			maxh=<span class="hljs-built_in">max</span>(maxh,pq.<span class="hljs-built_in">top</span>().h);<br>			pq.<span class="hljs-built_in">pop</span>();<br>		&#125;<br>		ans+=temp;<br>		pq.<span class="hljs-built_in">push</span>(node&#123;temp,maxh+<span class="hljs-number">1</span>&#125;);<br>		n-=k<span class="hljs-number">-1</span>;<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n%lld\n&quot;</span>,ans,pq.<span class="hljs-built_in">top</span>().h<span class="hljs-number">-1</span>);<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表(散列表)</title>
    <url>/2020/05/06/%E5%93%88%E5%B8%8C%E8%A1%A8-%E6%95%A3%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="Hash-Table"><a href="#Hash-Table" class="headerlink" title="Hash Table"></a><center>Hash Table</center></h2><span id="more"></span>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>图像处理のHSV变换原理及实现</title>
    <url>/2020/08/03/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E3%81%AEHSV%E5%8F%98%E6%8D%A2%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>考虑到研究生可能会研究CV领域，先学点opencv打点基础，今日成果——HSV变换算法及python实现<br><span id="more"></span></p>
<h2 id="HSV变换"><a href="#HSV变换" class="headerlink" title="HSV变换"></a>HSV变换</h2><p>参考blog：</p>
<ul>
<li><a href="https://blog.csdn.net/Ibelievesunshine/article/details/104868018?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param">CSDN RGB图像转换成HSV图像，HSV图像转换为RGB图像</a></li>
<li><a href="https://blog.csdn.net/barry_j/article/details/93859705">CSDN 从 RGB 到 HSV 的转换详细介绍</a></li>
</ul>
<p>本题来源于github opencv100题第5题：HSV变换</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>将RGB表示的图像转换为HSV表示，其中，H表示色相（Hue），S表示饱和度（Saturation），V表示明度（Value），这边贴一张上方某blog内可视化表示HSV含义的图，清晰明了</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/20180520172120828.jpg" alt="20180520172120828"></p>
<p>$\text{RGB}$的取值范围为$[0, 1]$，令： <script type="math/tex">\text{Max}=\max(R,G,B)\\ \text{Min}=\min(R,G,B)</script> </p>
<p>色相： </p>
<script type="math/tex; mode=display">
H=\begin{cases} 0&(\text{if}\ \text{Min}=\text{Max})\\ 60\ \frac{G-R}{\text{Max}-\text{Min}}+60&(\text{if}\ \text{Min}=B)\\ 60\ \frac{B-G}{\text{Max}-\text{Min}}+180&(\text{if}\ \text{Min}=R)\\ 60\ \frac{R-B}{\text{Max}-\text{Min}}+300&(\text{if}\ \text{Min}=G) \end{cases}</script><p>饱和度： <script type="math/tex">S=\text{Max}-\text{Min}</script> </p>
<p>明度： <script type="math/tex">V=\text{Max}</script> </p>
<p>从$\text{HSV}$色彩表示转换到$\text{RGB}$色彩表示通过以下方式计算： </p>
<script type="math/tex; mode=display">
C = S\\ H' = \frac{H}{60}\ X = C\ (1 - |H' \mod 2 - 1|)\\ (R,G,B)=(V-C)\ (1,1,1)+\begin{cases} (0, 0, 0)& (\text{if H is undefined})\\ (C, X, 0)& (\text{if}\quad 0 \leq H' < 1)\\ (X, C, 0)& (\text{if}\quad 1 \leq H' < 2)\\ (0, C, X)& (\text{if}\quad 2 \leq H' < 3)\\ (0, X, C)& (\text{if}\quad 3 \leq H' < 4)\\ (X, 0, C)& (\text{if}\quad 4 \leq H' < 5)\\ (C, 0, X)& (\text{if}\quad 5 \leq H' < 6) \end{cases}</script><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>请将色相反转（色相值加$180$），然后再用$\text{RGB}$色彩空间表示图片。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>PS：算法中可能出现除以0的浮点问题，我在分母上加了0.001防了一波，否则一块黑色的<code>nan</code>很难看</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rgb2hsv</span>(<span class="hljs-params">img</span>):<br>	hsv = np.zeros_like(img, dtype=np.float32)<br>	img = img/<span class="hljs-number">255.0</span><br>	R = img[...,<span class="hljs-number">2</span>]<br>	G = img[...,<span class="hljs-number">1</span>]<br>	B = img[...,<span class="hljs-number">0</span>]<br>	Max = np.<span class="hljs-built_in">max</span>(img, axis=<span class="hljs-number">2</span>)<br>	Min = np.<span class="hljs-built_in">min</span>(img, axis=<span class="hljs-number">2</span>)<br>	min_arg = np.argmin(img, axis=<span class="hljs-number">2</span>)<br><br>	hsv[...,<span class="hljs-number">0</span>][np.where(Max==Min)] = <span class="hljs-number">0</span><br><br>	ind = np.where(min_arg==<span class="hljs-number">0</span>) <span class="hljs-comment"># Min==B</span><br>	hsv[...,<span class="hljs-number">0</span>][ind] = <span class="hljs-number">60</span>*(G[ind]-R[ind])/(Max[ind]-Min[ind]+<span class="hljs-number">0.001</span>)+<span class="hljs-number">60</span><br>	<br>	ind = np.where(min_arg==<span class="hljs-number">2</span>) <span class="hljs-comment"># Min==R</span><br>	hsv[...,<span class="hljs-number">0</span>][ind] = <span class="hljs-number">60</span>*(B[ind]-G[ind])/(Max[ind]-Min[ind]+<span class="hljs-number">0.001</span>)+<span class="hljs-number">180</span><br>	<br>	ind = np.where(min_arg==<span class="hljs-number">1</span>) <span class="hljs-comment"># Min==G</span><br>	hsv[...,<span class="hljs-number">0</span>][ind] = <span class="hljs-number">60</span>*(R[ind]-B[ind])/(Max[ind]-Min[ind]+<span class="hljs-number">0.001</span>)+<span class="hljs-number">300</span><br><br><br>	hsv[...,<span class="hljs-number">1</span>] = Max-Min <span class="hljs-comment"># S</span><br>	hsv[...,<span class="hljs-number">2</span>] = Max <span class="hljs-comment"># V</span><br>	<span class="hljs-keyword">return</span> hsv<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hsv2rgb</span>(<span class="hljs-params">hsv</span>):<br>	H = hsv[...,<span class="hljs-number">0</span>]<br>	S = hsv[...,<span class="hljs-number">1</span>]<br>	V = hsv[...,<span class="hljs-number">2</span>]<br>	C = S<br>	H_ = H/<span class="hljs-number">60</span><br>	X = C*(<span class="hljs-number">1</span>-np.<span class="hljs-built_in">abs</span>(H_%<span class="hljs-number">2</span>-<span class="hljs-number">1</span>))<br>	Z = np.zeros_like(C)<br>	rgb = np.zeros_like(hsv)<br>	table = [[Z,X,C],[Z,C,X],[X,C,Z],[C,X,Z],[C,Z,X],[X,Z,C]]<br>	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>		ind = np.where((H_&gt;=i)&amp;(H_&lt;(i+<span class="hljs-number">1</span>)))<br>		rgb[...,<span class="hljs-number">0</span>][ind] = (V-C)[ind]+table[i][<span class="hljs-number">0</span>][ind]<br>		rgb[...,<span class="hljs-number">1</span>][ind] = (V-C)[ind]+table[i][<span class="hljs-number">1</span>][ind]<br>		rgb[...,<span class="hljs-number">2</span>][ind] = (V-C)[ind]+table[i][<span class="hljs-number">2</span>][ind]<br><br>	rgb = np.clip(rgb,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>	rgb = (rgb*<span class="hljs-number">255</span>).astype(np.uint8)<br>	<span class="hljs-keyword">return</span> rgb<br><br><br>img = cv2.imread(<span class="hljs-string">&quot;test.jpg&quot;</span>)<br>hsv_img = rgb2hsv(img)<br>hsv_img[...,<span class="hljs-number">0</span>] = (hsv_img[...,<span class="hljs-number">0</span>]+<span class="hljs-number">180</span>)%<span class="hljs-number">360</span><br>rgb_img = hsv2rgb(hsv_img)<br>cv2.imshow(<span class="hljs-string">&quot;img2&quot;</span>, rgb_img)<br>cv2.imshow(<span class="hljs-string">&quot;img1&quot;</span>, img)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200803183934553.png" alt="image-20200803183934553"></p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="np-zeros-like"><a href="#np-zeros-like" class="headerlink" title="np.zeros_like()"></a><code>np.zeros_like()</code></h3><p><code>np.zeros_like(mat, dtype=np.float32)</code></p>
<p>生成一个规模<code>mat</code>相同，类型为<code>np.float32</code>的<strong>全零</strong><code>ndarray</code></p>
<h3 id="np-max-np-min"><a href="#np-max-np-min" class="headerlink" title="np.max()/np.min()"></a><code>np.max()/np.min()</code></h3><p><code>np.max(mat, axis=2)</code></p>
<p>用于计算以<code>axis=2</code>轴为比较对象的最大值，即：取每<code>axis=2</code>这一维度的最大值，将其压成一维，其他维度不变，比如一个<code>4*3*2</code>的数组经过上述变换就变成了<code>4*3</code>的矩数组</p>
<h3 id="np-argmax-np-argmin"><a href="#np-argmax-np-argmin" class="headerlink" title="np.argmax()/np.argmin()"></a><code>np.argmax()/np.argmin()</code></h3><p><code>np.argmin(mat, axis=2)</code></p>
<p>获得一个效果同<code>np.max()</code>规模的矩阵，元素值为<code>mat</code>在<code>axis</code>轴上最小值的索引</p>
<h3 id="np-where"><a href="#np-where" class="headerlink" title="np.where()"></a><code>np.where()</code></h3><p><code>np.where(mat1==mat2)</code></p>
<p>返回一个<code>bool</code>型矩阵，大小同<code>mat1/mat2</code>，比较两矩阵对应位置元素值是否相等，当满足条件时返回<code>True</code>，否则返回<code>False</code></p>
]]></content>
      <categories>
        <category>opencv</category>
      </categories>
      <tags>
        <tag>HSV变换</tag>
      </tags>
  </entry>
  <entry>
    <title>图像处理の各种滤波方法</title>
    <url>/2020/08/07/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E3%81%AE%E5%90%84%E7%A7%8D%E6%BB%A4%E6%B3%A2%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>前几天“衣 紧 还 乡”，今天还是得把滤波算法补一下了<br><span id="more"></span></p>
<h2 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h2><p>参考blog：</p>
<ul>
<li><a href="https://blog.csdn.net/jiandanjinxin/article/details/51281828">CSDN 高斯模糊算法（高斯权重）</a></li>
</ul>
<p>小学的时候看我妈搞PS，有个叫“高斯模糊”的东西，今天终于明白了，这个高斯模糊，其实学名叫“高斯滤波”，是一种图像滤波算法，好神奇诶~</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>对于通常的二维图像，高斯滤波使用<strong>二维正态分布函数（高斯函数）</strong>作为权重分配，函数形式如下</p>
<script type="math/tex; mode=display">
f(x,y) = \frac{1}{2\pi\sigma^2} e^{-\frac{x^2+y^2}{2\sigma^2}}</script><p>其实这就是之前在学CNN时的<strong>图像卷积</strong>操作（所以滤波器也叫做<strong>卷积核</strong>），通过构造一个卷积核，不断对原图的每个像素点进行卷积计算，对于一个<code>3*3</code>的滤波器来说，就是<strong>将指定像素与周围8个像素点乘以<code>3*3</code>的高斯权重分布再求和</strong>得到该像素点的输出值</p>
<ul>
<li>求高斯权重分布的方法：将滤波器中心点视为原点<code>(0,0)</code>，可以得到滤波器函数值的分布，最后一定要再<strong>除以矩阵所有值之和</strong>，因为需要满足权重和为1，这是归一化操作所必需要有的步骤</li>
</ul>
<p>PS：由于要保持滤波后的图像尺寸与原图相同，需要有$zero-padding$，即在矩阵周围补零，经过简单的数学推导，容易得出，在滤波器步长为1且滤波器为方阵的情况下，$pad$大小与滤波器尺寸$size$须满足如下关系：</p>
<script type="math/tex; mode=display">
size = 2\cdot pad+1</script><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img referrer="no-referrer" src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200809183530008.png" alt="image-20200809183530008"  /></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><details>
    <summary>code</summary>

<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gauss_func</span>(<span class="hljs-params">x,y,sigma</span>): <span class="hljs-comment"># 高斯函数计算</span><br>	<span class="hljs-keyword">return</span> np.exp(-(x*x+y*y)/(<span class="hljs-number">2</span>*sigma*sigma))/(<span class="hljs-number">2</span>*np.pi*sigma*sigma)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gauss_filter</span>(<span class="hljs-params">image,Size=<span class="hljs-number">3</span>,sigma=<span class="hljs-number">1.3</span></span>):<br>	img = image.copy()<br>	H,W,C = image.shape<br>	pad = Size//<span class="hljs-number">2</span> <span class="hljs-comment"># pad大小</span><br>	pad_img = np.zeros((H+pad*<span class="hljs-number">2</span>,W+pad*<span class="hljs-number">2</span>,C),dtype=np.<span class="hljs-built_in">float</span>)<br>	pad_img[pad:pad+H,pad:pad+W] = img.copy().astype(np.<span class="hljs-built_in">float</span>)<br><br>	Filter = np.zeros((Size,Size),dtype=np.<span class="hljs-built_in">float</span>)<br>	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(-pad,-pad+Size):<br>		<span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(-pad,-pad+Size):<br>			Filter[i+pad,j+pad] = gauss_func(j,i,sigma)<br>	Filter /= Filter.<span class="hljs-built_in">sum</span>() <span class="hljs-comment"># 切记</span><br><br>	out = np.zeros_like(img,dtype=np.<span class="hljs-built_in">float</span>)<br>	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(H):<br>		<span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(W):<br>			<span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(C):<br>				out[i,j,c] = np.<span class="hljs-built_in">sum</span>(Filter * pad_img[i:i+Size,j:j+Size,c])<br><br>	out = np.clip(out,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>)<br>	out = out.astype(np.uint8)<br><br>	<span class="hljs-keyword">return</span> out<br><br><br>img = cv2.imread(<span class="hljs-string">&quot;test.jpg&quot;</span>)<br>img2 = gauss_filter(img,Size=<span class="hljs-number">13</span>,sigma=<span class="hljs-number">3</span>)<br><br><span class="hljs-built_in">print</span>(img.shape)<br>cv2.imshow(<span class="hljs-string">&quot;img2&quot;</span>, img2)<br>cv2.imshow(<span class="hljs-string">&quot;img1&quot;</span>, img)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure>

</details>

<h2 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h2><p>其实就是利用滤波器大小区域的原图对应元素的<strong>中位数</strong>作为该像素点的输出值，那么代码只需要把高斯滤波模板稍微改改就行了（利用<code>np.median()</code>）求中位数</p>
<h3 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h3><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200809183820910.png" alt="image-20200809183820910"></p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><details>
    <summary>code</summary>

<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mid_filter</span>(<span class="hljs-params">image,Size=<span class="hljs-number">3</span></span>):<br>	img = image.copy()<br>	H,W,C = image.shape<br>	pad = Size//<span class="hljs-number">2</span><br>	pad_img = np.zeros((H+pad*<span class="hljs-number">2</span>,W+pad*<span class="hljs-number">2</span>,C),dtype=np.<span class="hljs-built_in">float</span>)<br>	pad_img[pad:pad+H,pad:pad+W] = img.copy().astype(np.<span class="hljs-built_in">float</span>)<br><br>	out = np.zeros_like(img,dtype=np.<span class="hljs-built_in">float</span>)<br>	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(H):<br>		<span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(W):<br>			<span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(C):<br>				out[i,j,c] = np.median(pad_img[i:i+Size,j:j+Size,c])<br><br>	out = np.clip(out,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>)<br>	out = out.astype(np.uint8)<br><br>	<span class="hljs-keyword">return</span> out<br><br><br>img = cv2.imread(<span class="hljs-string">&quot;test.jpg&quot;</span>)<br>img2 = mid_filter(img,Size=<span class="hljs-number">13</span>)<br><br><span class="hljs-built_in">print</span>(img.shape)<br>cv2.imshow(<span class="hljs-string">&quot;img2&quot;</span>, img2)<br>cv2.imshow(<span class="hljs-string">&quot;img1&quot;</span>, img)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure>

</details>

<h2 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h2><p>同上，不过这次是<strong>均值</strong>，代码就不放了</p>
<h3 id="效果-2"><a href="#效果-2" class="headerlink" title="效果"></a>效果</h3><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200809184308820.png" alt="image-20200809184308820"></p>
<h2 id="Motion-滤波"><a href="#Motion-滤波" class="headerlink" title="Motion 滤波"></a>Motion 滤波</h2><p>取对角线方向像素的平均值作为输出，即 滤波器矩阵为（以3阶为例）:</p>
<script type="math/tex; mode=display">
\frac{1}{3}\pmatrix{1 \ 0 \ 0\\0 \ 1 \ 0\\0 \ 0 \ 1}</script><h3 id="效果-3"><a href="#效果-3" class="headerlink" title="效果"></a>效果</h3><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200809184201428.png" alt="image-20200809184201428"></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><ul>
<li>用<code>np.diag()</code>方法生成对角阵，传入对角元素值作为参数即可</li>
</ul>
<details>
    <summary>code</summary>

<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">motion_filter</span>(<span class="hljs-params">image,Size=<span class="hljs-number">3</span></span>):<br>	img = image.copy()<br>	H,W,C = image.shape<br>	pad = Size//<span class="hljs-number">2</span><br>	pad_img = np.zeros((H+pad*<span class="hljs-number">2</span>,W+pad*<span class="hljs-number">2</span>,C),dtype=np.<span class="hljs-built_in">float</span>)<br>	pad_img[pad:pad+H,pad:pad+W] = img.copy().astype(np.<span class="hljs-built_in">float</span>)<br><br>	Filter = np.diag([<span class="hljs-number">1</span>] * Size).astype(np.<span class="hljs-built_in">float</span>)<br>	Filter /= Size<br><br>	out = np.zeros_like(img,dtype=np.<span class="hljs-built_in">float</span>)<br>	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(H):<br>		<span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(W):<br>			<span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(C):<br>				out[i,j,c] = np.<span class="hljs-built_in">sum</span>(Filter * pad_img[i:i+Size,j:j+Size,c])<br><br>	out = np.clip(out,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>)<br>	out = out.astype(np.uint8)<br><br>	<span class="hljs-keyword">return</span> out<br><br><br>img = cv2.imread(<span class="hljs-string">&quot;test.jpg&quot;</span>)<br>img2 = motion_filter(img,Size=<span class="hljs-number">5</span>)<br><br><span class="hljs-built_in">print</span>(img.shape)<br>cv2.imshow(<span class="hljs-string">&quot;img2&quot;</span>, img2)<br>cv2.imshow(<span class="hljs-string">&quot;img1&quot;</span>, img)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure>

</details>

<h2 id="MIN-MAX-滤波"><a href="#MIN-MAX-滤波" class="headerlink" title="MIN-MAX 滤波"></a>MIN-MAX 滤波</h2><p>MAX-MIN滤波器使用网格内像素的<strong>最大值和最小值的差值</strong>对网格内像素重新赋值。通常用于<strong>边缘检测</strong>。</p>
<p>边缘检测用于检测图像中的线。像这样提取图像中的信息的操作被称为<strong>特征提取</strong>。</p>
<p>边缘检测通常在灰度图像上进行。</p>
<h3 id="效果-4"><a href="#效果-4" class="headerlink" title="效果"></a>效果</h3><p>这里用<code>filter_size = 3</code>的滤波器进行特征提取</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200809191738889.png" alt="image-20200809191738889"></p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><details>
    <summary>code</summary>

<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">minmax_filter</span>(<span class="hljs-params">image,Size=<span class="hljs-number">3</span></span>):<br>	img = image.copy()<br>	H,W,C = image.shape<br>	pad = Size//<span class="hljs-number">2</span><br>	pad_img = np.zeros((H+pad*<span class="hljs-number">2</span>,W+pad*<span class="hljs-number">2</span>,C),dtype=np.<span class="hljs-built_in">float</span>)<br>	pad_img[pad:pad+H,pad:pad+W] = img.copy().astype(np.<span class="hljs-built_in">float</span>)<br><br>	out = np.zeros_like(img,dtype=np.<span class="hljs-built_in">float</span>)<br>	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(H):<br>		<span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(W):<br>			<span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(C):<br>				out[i,j,c] = np.<span class="hljs-built_in">max</span>(pad_img[i:i+Size,j:j+Size,c])-np.<span class="hljs-built_in">min</span>(pad_img[i:i+Size,j:j+Size,c])<br><br>	out = np.clip(out,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>)<br>	out = out.astype(np.uint8)<br><br>	<span class="hljs-keyword">return</span> out<br><br><br>img = cv2.imread(<span class="hljs-string">&quot;test.jpg&quot;</span>)<br>img2 = minmax_filter(img,Size=<span class="hljs-number">5</span>)<br><br><span class="hljs-built_in">print</span>(img.shape)<br>cv2.imshow(<span class="hljs-string">&quot;img2&quot;</span>, img2)<br>cv2.imshow(<span class="hljs-string">&quot;img1&quot;</span>, img)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure>

</details>

<h2 id="差分滤波"><a href="#差分滤波" class="headerlink" title="差分滤波"></a>差分滤波</h2><p>差分滤波器对图像亮度急剧变化的边缘有提取效果，可以获得邻接像素的差值。</p>
<p>纵向： <script type="math/tex">K=\left[ \begin{matrix} 0&-1&0\\ 0&1&0\\ 0&0&0 \end{matrix} \right]</script> 横向： <script type="math/tex">K=\left[ \begin{matrix} 0&0&0\\ -1&1&0\\ 0&0&0 \end{matrix} \right]</script></p>
<p>因此，差分滤波有横向和纵向两种方式，分别能提取对应的边缘特征</p>
<h3 id="效果-5"><a href="#效果-5" class="headerlink" title="效果"></a>效果</h3><p><code>vout</code>为纵向，<code>hout</code>为横向</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200809192454076.png" alt="image-20200809192454076"></p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><details>
    <summary>code</summary>

<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">differential_filter</span>(<span class="hljs-params">image,Size=<span class="hljs-number">3</span></span>):<br>	img = image.copy()<br>	H,W,C = image.shape<br>	pad = Size//<span class="hljs-number">2</span><br>	pad_img = np.zeros((H+pad*<span class="hljs-number">2</span>,W+pad*<span class="hljs-number">2</span>,C),dtype=np.<span class="hljs-built_in">float</span>)<br>	pad_img[pad:pad+H,pad:pad+W] = img.copy().astype(np.<span class="hljs-built_in">float</span>)<br><br>	vFilter = np.array([[<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]])<br>	hFilter = np.array([[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]])<br><br>	vout = np.zeros_like(img,dtype=np.<span class="hljs-built_in">float</span>)<br>	hout = vout.copy()<br><br>	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(H):<br>		<span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(W):<br>			<span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(C):<br>				vout[i,j,c] = np.<span class="hljs-built_in">sum</span>(vFilter * pad_img[i:i+Size,j:j+Size,c])<br>				hout[i,j,c] = np.<span class="hljs-built_in">sum</span>(hFilter * pad_img[i:i+Size,j:j+Size,c])<br><br>	vout = np.clip(vout,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>)<br>	vout = vout.astype(np.uint8)<br>	hout = np.clip(hout,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>)<br>	hout = hout.astype(np.uint8)<br><br>	<span class="hljs-keyword">return</span> hout,vout<br><br><br>img = cv2.imread(<span class="hljs-string">&quot;test2.jpg&quot;</span>)<br>hout,vout = differential_filter(img,Size=<span class="hljs-number">3</span>)<br>out = hout+vout<br><br>cv2.imshow(<span class="hljs-string">&quot;vout&quot;</span>, vout)<br>cv2.imshow(<span class="hljs-string">&quot;hout&quot;</span>, hout)<br>cv2.imshow(<span class="hljs-string">&quot;out&quot;</span>, out)<br>cv2.imshow(<span class="hljs-string">&quot;img&quot;</span>, img)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure>

</details>

<h2 id="Sobel-滤波"><a href="#Sobel-滤波" class="headerlink" title="Sobel 滤波"></a>Sobel 滤波</h2><p>Sobel滤波器可以提取特定方向（纵向或横向）的边缘，滤波器按下式定义：</p>
<p>纵向： <script type="math/tex">K=\left[ \begin{matrix} 1&2&1\\ 0&0&0\\ -1&-2&-1 \end{matrix} \right]</script> 横向： <script type="math/tex">K=\left[ \begin{matrix} 1&0&-1\\ 2&0&-2\\ 1&0&-1 \end{matrix} \right]</script></p>
<p>PS：从矩阵就可以看出来，这其实就是类似于差分滤波的一种滤波方式，加剧图像差别大的边缘的差别，从而达到特征提取的效果。代码实现上，只要把差分滤波的滤波器矩阵换掉就行了</p>
<h3 id="效果-6"><a href="#效果-6" class="headerlink" title="效果"></a>效果</h3><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200809192939813.png" alt="image-20200809192939813"></p>
<h2 id="Prewitt-滤波"><a href="#Prewitt-滤波" class="headerlink" title="Prewitt 滤波"></a>Prewitt 滤波</h2><p>Prewitt滤波器是用于边缘检测的一种滤波器，使用下式定义：</p>
<p>纵向： <script type="math/tex">K=\left[ \begin{matrix} -1&-1&-1\\ 0&0&0\\ 1&1&1 \end{matrix} \right]</script> 横向： <script type="math/tex">K=\left[ \begin{matrix} -1&0&-1\\ -1&0&1\\ -1&0&1 \end{matrix} \right]</script></p>
<p>PS：也类似于上面两种</p>
<h3 id="效果-7"><a href="#效果-7" class="headerlink" title="效果"></a>效果</h3><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200809193112759.png" alt="image-20200809193112759"></p>
<h2 id="Laplacian-滤波"><a href="#Laplacian-滤波" class="headerlink" title="Laplacian 滤波"></a>Laplacian 滤波</h2><p>Laplacian滤波器是对图像亮度进行二次微分从而检测边缘的滤波器。由于数字图像是离散的，$x$方向和$y$方向的一次微分分别按照以下式子计算：</p>
<script type="math/tex; mode=display">
I_x(x,y)=\frac{I(x+1,y)-I(x,y)}{(x+1)-x}=I(x+1,y)-I(x,y)\\I_y(x,y) =\frac{I(x, y+1) - I(x,y)}{(y+1)-y}= I(x, y+1) - I(x,y)</script><p> 因此二次微分按照以下式子计算： </p>
<script type="math/tex; mode=display">
\begin{align*} &I_{xx}(x,y) \\ =& \frac{I_x(x,y) - I_x(x-1,y)}{(x+1)-x} \\ =& I_x(x,y) - I_x(x-1,y)\\ =&[I(x+1, y) - I(x,y)] - [I(x, y) - I(x-1,y)]\\ =& I(x+1,y) - 2\ I(x,y) + I(x-1,y) \end{align*}</script><p>同理： <script type="math/tex">I_{yy}(x,y)=I(x,y+1)-2\ I(x,y)+I(x,y-1)</script> </p>
<p>特此，Laplacian 表达式如下：</p>
<script type="math/tex; mode=display">
\begin{align*} &\nabla^2\ I(x,y)\\ =&I_{xx}(x,y)+I_{yy}(x,y)\\ =&I(x-1,y) + I(x,y-1) - 4 * I(x,y) + I(x+1,y) + I(x,y+1) \end{align*}</script><p>如果把这个式子表示为卷积核是下面这样的： <script type="math/tex">K= \left[ \begin{matrix} 0&1&0\\ 1&-4&1\\ 0&1&0 \end{matrix} \right]</script></p>
<p>PS：代码其实也就是把上面的矩阵换掉即可</p>
<h3 id="效果-8"><a href="#效果-8" class="headerlink" title="效果"></a>效果</h3><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200809193417506.png" alt="image-20200809193417506"></p>
<h2 id="Emboss-滤波"><a href="#Emboss-滤波" class="headerlink" title="Emboss 滤波"></a>Emboss 滤波</h2><p>Emboss滤波器可以使物体轮廓更加清晰，按照以下式子定义： <script type="math/tex">K= \left[ \begin{matrix} -2&-1&0\\ -1&1&1\\ 0&1&2 \end{matrix} \right]</script></p>
<p>PS：类似PS里面的浮雕效果，</p>
<h3 id="效果-9"><a href="#效果-9" class="headerlink" title="效果"></a>效果</h3><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200809193610956.png" alt="image-20200809193610956"></p>
<h2 id="LoG滤波"><a href="#LoG滤波" class="headerlink" title="LoG滤波"></a>LoG滤波</h2><p>LoG即高斯-拉普拉斯（Laplacian of Gaussian）的缩写，使用高斯滤波器使图像平滑化之后再使用拉普拉斯滤波器使图像的轮廓更加清晰。</p>
<p>为了防止拉普拉斯滤波器计算二次微分会使得图像噪声更加明显，所以我们首先使用高斯滤波器来抑制噪声。</p>
<p>LoG 滤波器使用以下式子定义： <script type="math/tex">\text{LoG}(x,y)=\frac{x^2 + y^2 - s^2}{2 \ \pi \ s^6} \ e^{-\frac{x^2+y^2}{2\ s^2}}</script></p>
<p>PS：即 先降噪，再提取轮廓特征</p>
<h3 id="效果-10"><a href="#效果-10" class="headerlink" title="效果"></a>效果</h3><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200809194231934.png" alt="image-20200809194231934"></p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><details>
    <summary>code</summary>

<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">LoG_func</span>(<span class="hljs-params">x,y,sigma=<span class="hljs-number">1.3</span></span>):<br>	<span class="hljs-keyword">return</span> (x*x+y*y-sigma*sigma)/(<span class="hljs-number">2</span>*np.pi*sigma**<span class="hljs-number">6</span>)*np.exp(-(x*x+y*y)/(<span class="hljs-number">2</span>*sigma*sigma))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">LoG_filter</span>(<span class="hljs-params">image,Size=<span class="hljs-number">3</span>,sigma=<span class="hljs-number">1.3</span></span>):<br>	img = image.copy()<br>	H,W,C = image.shape<br>	pad = Size//<span class="hljs-number">2</span><br>	pad_img = np.zeros((H+pad*<span class="hljs-number">2</span>,W+pad*<span class="hljs-number">2</span>,C),dtype=np.<span class="hljs-built_in">float</span>)<br>	pad_img[pad:pad+H,pad:pad+W] = img.copy().astype(np.<span class="hljs-built_in">float</span>)<br><br>	Filter = np.zeros((Size,Size), dtype=np.<span class="hljs-built_in">float</span>)<br>	<span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(-pad,-pad+Size):<br>		<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(-pad,-pad+Size):<br>			Filter[y+pad,x+pad] = LoG_func(x,y,sigma)<br>	Filter /= Filter.<span class="hljs-built_in">sum</span>()<br><br>	out = np.zeros_like(img,dtype=np.<span class="hljs-built_in">float</span>)<br><br>	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(H):<br>		<span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(W):<br>			<span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(C):<br>				out[i,j,c] = np.<span class="hljs-built_in">sum</span>(Filter * pad_img[i:i+Size,j:j+Size,c])<br>				<br>	out = np.clip(out,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>)<br>	out = out.astype(np.uint8)<br>	<span class="hljs-keyword">return</span> out<br><br><br>img = cv2.imread(<span class="hljs-string">&quot;test2.jpg&quot;</span>)<br>out = LoG_filter(img)<br><br>cv2.imshow(<span class="hljs-string">&quot;out&quot;</span>, out)<br>cv2.imshow(<span class="hljs-string">&quot;img&quot;</span>, img)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>opencv</category>
      </categories>
      <tags>
        <tag>滤波算法</tag>
      </tags>
  </entry>
  <entry>
    <title>图论の建图练习</title>
    <url>/2020/03/16/%E5%9B%BE%E8%AE%BA%E3%81%AE%E5%BB%BA%E5%9B%BE%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<p>图论题：<strong>建图</strong>很重要！<strong>建图</strong>很重要！<strong>建图</strong>很重要！也是难点，因此要多加练习！！！</p>
<hr>
<h3 id="POJ-1062-昂贵的聘礼"><a href="#POJ-1062-昂贵的聘礼" class="headerlink" title="POJ 1062 昂贵的聘礼"></a><a href="https://vjudge.net/problem/POJ-1062">POJ 1062 昂贵的聘礼</a></h3><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>你需要到一个人（编号为1）那里买一个昂贵的东西，但你可以通过在其他人那里买别的东西来使它降价，其他人的东西也是这个道理，除此之外，每个人都有阶级，规定<strong>你不能在两个阶级差超过m的人那里买东西</strong>，最后问你买到这个东西所花费的最少价格</p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>建图过程：先将你设置为0号节点，然后从0往每件物品连边，边权为这件物品的原始价格，每次输入替代品时，从该物品的替代品往该物品连边，边权为买了替代品后这件物品的优惠价格，这样这张图就建好了，如果没有阶级要求，那么答案就是从0到1的最短路</p>
<p>处理阶级问题：核心思想就是你最后必须要买到1号点的物品，因此1号点的阶级是核心，可以通过枚举在m范围内能到达1号点的阶级范围，每次枚举时跑一遍最短路，最后取这些最短路的最小值即可</p>
<h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> u,v,w,next;<br>&#125;e[<span class="hljs-number">10005</span>];<br><span class="hljs-type">int</span> n,m,cnt=<span class="hljs-number">0</span>,head[<span class="hljs-number">10005</span>],sta[<span class="hljs-number">10005</span>],vis[<span class="hljs-number">10005</span>];<br><span class="hljs-type">int</span> dis[<span class="hljs-number">10005</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w=<span class="hljs-number">0</span>)</span></span>&#123;<br>	e[++cnt]=Edge&#123;u,v,w,head[u]&#125;;<br>	head[u]=cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> high)</span></span>&#123;<br>	<span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f3f3f</span>,<span class="hljs-built_in">sizeof</span>(dis));<br>	<span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<br>	queue&lt;<span class="hljs-type">int</span>&gt; q;<br>	vis[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>	q.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>	dis[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>		<span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>		vis[u]=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];i;i=e[i].next)&#123;<br>			<span class="hljs-type">int</span> v=e[i].v,w=e[i].w;<br>			<span class="hljs-keyword">if</span>(sta[v]&lt;low||sta[v]&gt;high) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//阶级范围之外的pass</span><br>			<span class="hljs-keyword">if</span>(dis[v]&gt;dis[u]+w)&#123;<br>				dis[v]=dis[u]+w;<br>				<span class="hljs-keyword">if</span>(vis[v]==<span class="hljs-number">0</span>)&#123;<br>					vis[v]=<span class="hljs-number">1</span>;<br>					q.<span class="hljs-built_in">push</span>(v);<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> dis[<span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);<br>	<span class="hljs-type">int</span> p,l,x,t,v;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;p,&amp;l,&amp;x);<br>		<span class="hljs-built_in">addedge</span>(<span class="hljs-number">0</span>,i,p); <span class="hljs-comment">//建图</span><br>		sta[i]=l;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=x;++j)&#123;<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;t,&amp;v);<br>			<span class="hljs-built_in">addedge</span>(t,i,v); <span class="hljs-comment">//建图</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-type">int</span> ans=inf;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=sta[<span class="hljs-number">1</span>]-m;i&lt;=sta[<span class="hljs-number">1</span>];++i)&#123;<br>		ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">spfa</span>(i,i+m));<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="LightOJ-1074-Extended-Traffic"><a href="#LightOJ-1074-Extended-Traffic" class="headerlink" title="LightOJ 1074 Extended Traffic"></a><a href="https://vjudge.net/problem/LightOJ-1074">LightOJ 1074 Extended Traffic</a></h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给出一张有向（有环）图，节点具有权值，若两点可达，则边权为$(终点-起点)^3$，给出若干次询问，每次询问两个点之间的最短路（如果&lt;3或者不可达则输出“？”）</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>注意了啊，这题他喵的<strong>有环</strong>！！！，而且权值可能为负！！！没跑了，一定是spfa跑负环的题，我们可以想到，所有能通过负环出去的节点都不可达（因为我在负环上已经可以无限次减小权值了），因此找到负环后dfs把负环所连的所有点全部设置为不可达就行了</p>
<p>后来发现，这题数据居然可以判完负环之后直接return回来（我寻思其他点也不一定更新完了啊？<del>太水了</del>）</p>
<h4 id="AC代码（正常向）"><a href="#AC代码（正常向）" class="headerlink" title="AC代码（正常向）"></a>AC代码（正常向）</h4><details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1ll</span>&lt;&lt;<span class="hljs-number">60</span>;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123; <br>	ll kk=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>; <br>	<span class="hljs-type">char</span> cc=<span class="hljs-built_in">getchar</span>(); <br>	<span class="hljs-keyword">while</span>(cc&lt;<span class="hljs-string">&#x27;0&#x27;</span>||cc&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<span class="hljs-keyword">if</span>(cc==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;cc=<span class="hljs-built_in">getchar</span>();&#125; <br>	<span class="hljs-keyword">while</span>(cc&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;cc&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;kk=(kk&lt;&lt;<span class="hljs-number">1</span>)+(kk&lt;&lt;<span class="hljs-number">3</span>)+cc-<span class="hljs-string">&#x27;0&#x27;</span>;cc=<span class="hljs-built_in">getchar</span>();&#125; <br>	<span class="hljs-keyword">return</span> kk*f; <br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> u,v,w,next;<br>&#125;e[<span class="hljs-number">1000005</span>];<br><br><span class="hljs-type">int</span> t,n,m,q,head[<span class="hljs-number">10005</span>],cnt,vis[<span class="hljs-number">10005</span>],ring[<span class="hljs-number">10005</span>],reach[<span class="hljs-number">10005</span>];<br>ll dis[<span class="hljs-number">10005</span>],val[<span class="hljs-number">10005</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w=<span class="hljs-number">0</span>)</span></span>&#123;<br>	e[++cnt]=Edge&#123;u,v,w,head[u]&#125;;<br>	head[u]=cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123; <span class="hljs-comment">//dfs找到所有负环的连点</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(reach[v]==<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>		reach[v]=<span class="hljs-number">0</span>;<br>		<span class="hljs-built_in">dfs</span>(v);<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<br>	<span class="hljs-built_in">memset</span>(ring,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(ring));<br>	<span class="hljs-built_in">memset</span>(reach,<span class="hljs-number">1</span>,<span class="hljs-built_in">sizeof</span>(reach));<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) dis[i]=inf;<br>	queue&lt;<span class="hljs-type">int</span>&gt; q;<br>	vis[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>	ring[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>	dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>	q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>		<span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>		vis[u]=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">if</span>(reach[u]==<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//如果不可达直接continue</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];i;i=e[i].next)&#123;<br>			<span class="hljs-type">int</span> v=e[i].v;<br>			ll cha=val[v]-val[u];<br>			<span class="hljs-keyword">if</span>(dis[u]+cha*cha*cha&lt;dis[v])&#123;<br>				dis[v]=dis[u]+cha*cha*cha;<br>				ring[v]=ring[u]+<span class="hljs-number">1</span>;<br>				<span class="hljs-keyword">if</span>(ring[v]&gt;n)&#123; <span class="hljs-comment">//出现负环，开始dfs</span><br>					<span class="hljs-built_in">dfs</span>(v);<br>					<span class="hljs-keyword">continue</span>;<br>				&#125;<br>				<span class="hljs-keyword">if</span>(vis[v]==<span class="hljs-number">0</span>)&#123;<br>					vis[v]=<span class="hljs-number">1</span>;<br>					q.<span class="hljs-built_in">push</span>(v);<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	t=<span class="hljs-built_in">read</span>();<br>	<span class="hljs-type">int</span> orz=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(t--)&#123;<br>		cnt=<span class="hljs-number">0</span>;<br>		<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(head));<br>		n=<span class="hljs-built_in">read</span>();<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) val[i]=<span class="hljs-built_in">read</span>();<br>		m=<span class="hljs-built_in">read</span>();<br>		<span class="hljs-type">int</span> u,v;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)&#123;<br>			u=<span class="hljs-built_in">read</span>(),v=<span class="hljs-built_in">read</span>();<br>			<span class="hljs-built_in">addedge</span>(u,v);<br>		&#125;<br>		<span class="hljs-built_in">spfa</span>();<br>		q=<span class="hljs-built_in">read</span>();<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case %d:\n&quot;</span>,++orz);<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;++i)&#123;<br>			v=<span class="hljs-built_in">read</span>();<br>			<span class="hljs-keyword">if</span>(dis[v]&lt;<span class="hljs-number">3</span>||dis[v]==inf||reach[v]==<span class="hljs-number">0</span>)&#123;<br>				<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;?\n&quot;</span>);<br>			&#125;<span class="hljs-keyword">else</span>&#123;<br>				<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,dis[v]);<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="POJ-1860-Currency-Exchange"><a href="#POJ-1860-Currency-Exchange" class="headerlink" title="POJ 1860 Currency Exchange"></a><a href="https://vjudge.net/problem/POJ-1860">POJ 1860 Currency Exchange</a></h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>你手上有x块钱，给一个无向图，从某个节点出发，你可以到别的节点那里换钱，换的钱是（x-C）*R，其中C是手续费，R是利率，且来回的手续费和利率不一定一样，问可否通过一波换钱回到出发点使得自己手上的钱增加？</p>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>先考虑建图，每个节点除了存序号之外，还需要存一下手续费和利率</p>
<p>我们很容易想到，要使得此回路钱增加，不就是找一个正权环嘛，利用spfa找负环的思路，初始化所有距离为0，更新的时候取较大值更新，最后如果出现了能无限增大的环路就说明存在，否则不存在</p>
<h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> u,v,next;<br>	<span class="hljs-type">double</span> R,C;<br>&#125;e[<span class="hljs-number">1005</span>];<br><span class="hljs-type">int</span> n,m,st,cnt,head[<span class="hljs-number">1005</span>],vis[<span class="hljs-number">1005</span>],ring[<span class="hljs-number">1005</span>];<br><span class="hljs-type">double</span> dis[<span class="hljs-number">1005</span>];<br><span class="hljs-type">double</span> sm;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">double</span> R,<span class="hljs-type">double</span> C)</span></span>&#123;<br>	e[++cnt]=Edge&#123;u,v,head[u],R,C&#125;;<br>	head[u]=cnt;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dis));<br>	vis[st]=<span class="hljs-number">1</span>;<br>	dis[st]=sm;<br>	queue&lt;<span class="hljs-type">int</span>&gt; q;<br>	q.<span class="hljs-built_in">push</span>(st);<br>	ring[st]=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>		<span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>		vis[u]=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];i;i=e[i].next)&#123;<br>			<span class="hljs-type">int</span> v=e[i].v;<br>			<span class="hljs-type">double</span> R=e[i].R,C=e[i].C;<br>			<span class="hljs-keyword">if</span>((dis[u]-C)*R&gt;dis[v])&#123;<br>				dis[v]=(dis[u]-C)*R;<br>				ring[v]=ring[u]+<span class="hljs-number">1</span>;<br>				<span class="hljs-keyword">if</span>(ring[v]&gt;n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>				<span class="hljs-keyword">if</span>(vis[v]==<span class="hljs-number">0</span>)&#123;<br>					vis[v]=<span class="hljs-number">1</span>;<br>					q.<span class="hljs-built_in">push</span>(v);<br>				&#125; <br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%lf&quot;</span>,&amp;n,&amp;m,&amp;st,&amp;sm);<br>	<span class="hljs-type">int</span> x1,x2;<br>	<span class="hljs-type">double</span> rab,cab,rba,cba;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%lf%lf%lf%lf&quot;</span>,&amp;x1,&amp;x2,&amp;rab,&amp;cab,&amp;rba,&amp;cba);<br>		<span class="hljs-built_in">addedge</span>(x1,x2,rab,cab);<br>		<span class="hljs-built_in">addedge</span>(x2,x1,rba,cba);<br>	&#125;<br>	<span class="hljs-keyword">if</span>(<span class="hljs-built_in">spfa</span>()) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;YES\n&quot;</span>);<br>	<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="HDU-4370-0-or-1（好题）"><a href="#HDU-4370-0-or-1（好题）" class="headerlink" title="HDU 4370 0 or 1（好题）"></a><a href="https://vjudge.net/problem/HDU-4370">HDU 4370 0 or 1</a>（好题）</h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>给你一个n*n的矩阵A，构造一个同维度的01矩阵B，满足</p>
<script type="math/tex; mode=display">
\begin{cases}
B_{12}+B_{13}+...+B_{1n}=1\\
B_{1n}+B_{2n}+...+B_{n-1n}=1\\
\\
对于所有i(1<i<n)满足\\\sum{A_{ki}}(1\leq k\leq n)=\sum{B_{ij}}(1\leq j\leq n)
\end{cases}</script><p>求最小的$\sum{A<em>{ij}*B\</em>{ij}}$</p>
<h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>这尼玛谁想得到是图论<strong>最短路</strong>的题？？？</p>
<p>首先我们可以考虑把原矩阵视为原图的邻接矩阵（第一行为起点1，最后一行为终点n），考虑题目的要求，对应了以下三条要求：</p>
<ol>
<li>起点的出度为1</li>
<li>终点的入度为1</li>
<li>除了起点终点之外的点，出入度相同（可以为0）</li>
</ol>
<p>那么题目就转化为了求一条从1到n的最短路</p>
<p>桥豆麻袋，中间节点出入度为零的情况呢？此时的答案应该是从起点到起点的一条环路和从终点到终点的一条环路的和，这个怎么求呢？？？</p>
<h5 id="新姿势：SPFA求指定点的最小环"><a href="#新姿势：SPFA求指定点的最小环" class="headerlink" title="新姿势：SPFA求指定点的最小环"></a>新姿势：SPFA求指定点的最小环</h5><p>就起点来说，考虑<strong>初始将<code>dis[1]</code>设置为<code>inf</code>，然后把他的出边所连的点全部<code>push</code>进队列里，然后就正常跑一遍SPFA</strong>就行啦！（这样就能在跑spfa的时候把1到1的最短路也更新了，是不是很神奇？其实这就是在<code>while</code>循环之前自己先模拟一遍第一轮从起点连出边的更新过程罢了，这是为了满足1点在一开始不被更新的要求）好好想想就会明白，跑完spfa之后如果1点的<code>dis</code>更新了，那么这肯定是1点所连的最小环的权值和了，同理n点也一样，不再赘述</p>
<p>于是，这题的答案就是<code>min(dis[1~n],minring[1]+minring[n])</code></p>
<h4 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h4><details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1ll</span>&lt;&lt;<span class="hljs-number">60</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> u,v,w,next;<br>&#125;e[<span class="hljs-number">1000005</span>];<br><br><span class="hljs-type">int</span> n,m,head[<span class="hljs-number">10005</span>],cnt,vis[<span class="hljs-number">10005</span>];<br>ll dis[<span class="hljs-number">10005</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w=<span class="hljs-number">0</span>)</span></span>&#123;<br>	e[++cnt]=Edge&#123;u,v,w,head[u]&#125;;<br>	head[u]=cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> st)</span></span>&#123;<br>	<span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<br>	queue&lt;<span class="hljs-type">int</span>&gt; q;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) dis[i]=inf;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[st];i;i=e[i].next)&#123; <span class="hljs-comment">//遍历指定点的出边</span><br>		<span class="hljs-keyword">if</span>(e[i].v==st) <span class="hljs-keyword">continue</span>;<br>		vis[e[i].v]=<span class="hljs-number">1</span>;<br>		dis[e[i].v]=e[i].w; <span class="hljs-comment">//初始值都更新好</span><br>		q.<span class="hljs-built_in">push</span>(e[i].v); <span class="hljs-comment">//push进队列</span><br>	&#125;<br>	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123; <span class="hljs-comment">//正常spfa</span><br>		<span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>		vis[u]=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];i;i=e[i].next)&#123;<br>			<span class="hljs-type">int</span> v=e[i].v,w=e[i].w;<br>			<span class="hljs-keyword">if</span>(dis[u]+w&lt;dis[v])&#123;<br>				dis[v]=dis[u]+w;<br>				<span class="hljs-keyword">if</span>(vis[v]==<span class="hljs-number">0</span>)&#123;<br>					vis[v]=<span class="hljs-number">1</span>;<br>					q.<span class="hljs-built_in">push</span>(v);<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n))&#123;<br>		cnt=<span class="hljs-number">0</span>;<br>		<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(head)); <br>		<span class="hljs-type">int</span> x;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>				<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>				<span class="hljs-built_in">addedge</span>(i,j,x);<br>			&#125;<br>		&#125;<br>		<span class="hljs-built_in">spfa</span>(<span class="hljs-number">1</span>);<br>		<span class="hljs-type">int</span> ans=dis[n],d1=dis[<span class="hljs-number">1</span>];<br>		<span class="hljs-built_in">spfa</span>(n);<br>		<span class="hljs-type">int</span> d2=dis[n];<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">min</span>(ans,d1+d2));<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="POJ-3660-Cow-Contest"><a href="#POJ-3660-Cow-Contest" class="headerlink" title="POJ 3660 Cow Contest"></a><a href="https://vjudge.net/problem/POJ-3660">POJ 3660 Cow Contest</a></h3><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>有n头牛，给出若干对牛的相对等级，问有几头牛的等级排名是确定的？</p>
<h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><p>如果存在a&gt;b且b&gt;c，则一定有a&gt;c，因此可以利用floyd的思想将牛之间的相对关系更新出来，如果排名可以确定的话，那么这头牛一定和其余n-1头牛存在关系，否则确定不出来</p>
<h4 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h4><details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">bool</span> mm[<span class="hljs-number">125</span>][<span class="hljs-number">125</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>				<span class="hljs-keyword">if</span>(mm[i][k]&amp;&amp;mm[k][j])&#123;<br>					mm[i][j]=<span class="hljs-number">1</span>;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>	<span class="hljs-type">int</span> x,y;<br>	<span class="hljs-built_in">memset</span>(mm,<span class="hljs-literal">false</span>,<span class="hljs-built_in">sizeof</span>(mm));<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<br>		mm[x][y]=<span class="hljs-literal">true</span>;<br>	&#125;<br>	<span class="hljs-built_in">floyd</span>();<br>	<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-type">bool</span> f=<span class="hljs-literal">true</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>			<span class="hljs-keyword">if</span>(i==j) <span class="hljs-keyword">continue</span>;<br>			<span class="hljs-keyword">if</span>(!mm[i][j]&amp;&amp;!mm[j][i])&#123;<br>				f=<span class="hljs-literal">false</span>;<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(f) ans++;<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="POJ-3259-Wormholes"><a href="#POJ-3259-Wormholes" class="headerlink" title="POJ 3259 Wormholes"></a><a href="https://vjudge.net/problem/POJ-3259">POJ 3259 Wormholes</a></h3><h4 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h4><p>翻译过来就是：一张图，有若干正权双向道路和若干负权单向道路，问是否存在负权环？</p>
<h4 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h4><p>裸的spfa判负环，需要针对每个点都要判断一次，全部都没有才能算没有负环</p>
<h4 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码"></a>AC代码</h4><details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll; <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">1e8</span>;<br><span class="hljs-type">int</span> n,m,k;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> u,v,w,next;<br>&#125;e[<span class="hljs-number">50005</span>];<br><span class="hljs-type">int</span> cnt,head[<span class="hljs-number">555</span>],vis[<span class="hljs-number">555</span>],ring[<span class="hljs-number">555</span>];<br>ll dis[<span class="hljs-number">555</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w=<span class="hljs-number">0</span>)</span></span>&#123;<br>	e[++cnt]=Edge&#123;u,v,w,head[u]&#125;;<br>	head[u]=cnt;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> st)</span></span>&#123;<br>	<span class="hljs-built_in">memset</span>(ring,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(ring));<br>	<span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) dis[i]=inf;<br>	queue&lt;<span class="hljs-type">int</span>&gt; q;<br>	dis[st]=<span class="hljs-number">0</span>;<br>	ring[st]=<span class="hljs-number">1</span>;<br>	vis[st]=<span class="hljs-number">1</span>;<br>	q.<span class="hljs-built_in">push</span>(st);<br>	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>		<span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>		vis[u]=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];i;i=e[i].next)&#123;<br>			<span class="hljs-type">int</span> v=e[i].v,w=e[i].w;<br>			<span class="hljs-keyword">if</span>(dis[v]&gt;dis[u]+w)&#123;<br>				dis[v]=dis[u]+w;<br>				ring[v]=ring[u]+<span class="hljs-number">1</span>;<br>				<span class="hljs-keyword">if</span>(ring[v]&gt;n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>				<span class="hljs-keyword">if</span>(vis[v]==<span class="hljs-number">0</span>)&#123;<br>					vis[v]=<span class="hljs-number">1</span>;<br>					q.<span class="hljs-built_in">push</span>(v);<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> t;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<br>	<span class="hljs-keyword">while</span>(t--)&#123;<br>		cnt=<span class="hljs-number">0</span>;<br>		<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(head));<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);<br>		<span class="hljs-type">int</span> u,v,w;<br>		<span class="hljs-keyword">while</span>(m--)&#123;<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);<br>			<span class="hljs-built_in">addedge</span>(u,v,w);<br>			<span class="hljs-built_in">addedge</span>(v,u,w);<br>		&#125;<br>		<span class="hljs-keyword">while</span>(k--)&#123;<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);<br>			<span class="hljs-built_in">addedge</span>(u,v,-w);<br>		&#125;<br>		<span class="hljs-type">bool</span> f=<span class="hljs-literal">false</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-keyword">if</span>(f) <span class="hljs-keyword">break</span>;<br>			<span class="hljs-keyword">if</span>(<span class="hljs-built_in">spfa</span>(i))&#123;<br>				f=<span class="hljs-literal">true</span>;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(!f) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);<br>		<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;YES\n&quot;</span>);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="POJ-2240-Arbitrage"><a href="#POJ-2240-Arbitrage" class="headerlink" title="POJ 2240 Arbitrage"></a><a href="https://vjudge.net/problem/POJ-2240">POJ 2240 Arbitrage</a></h3><h4 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h4><p>翻译过来：一个有向图，问是否存在一条回路，这条回路上所有权值乘积大于1?</p>
<h4 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h4><p>利用spfa判负环的思想，初始化所有dis为1，然后判是否存在正权环即可</p>
<h4 id="AC代码-4"><a href="#AC代码-4" class="headerlink" title="AC代码"></a>AC代码</h4><details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,t;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> u,v,next;<br>	<span class="hljs-type">double</span> w;<br>&#125;e[<span class="hljs-number">4005</span>];<br><span class="hljs-type">int</span> cnt,head[<span class="hljs-number">4005</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">double</span> w)</span></span>&#123;<br>	e[++cnt]=Edge&#123;u,v,head[u],w&#125;;<br>	head[u]=cnt;<br>&#125;<br><span class="hljs-type">int</span> vis[<span class="hljs-number">4005</span>],ring[<span class="hljs-number">4005</span>];<br><span class="hljs-type">double</span> dis[<span class="hljs-number">4005</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> st)</span></span>&#123;<br>	<span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<br>	<span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">1</span>,<span class="hljs-built_in">sizeof</span>(dis));<br>	<span class="hljs-built_in">memset</span>(ring,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(ring));<br>	queue&lt;<span class="hljs-type">int</span>&gt; q;<br>	vis[st]=<span class="hljs-number">1</span>;<br>	ring[st]=<span class="hljs-number">1</span>;<br>	q.<span class="hljs-built_in">push</span>(st);<br>	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>		<span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>();<br>		q.<span class="hljs-built_in">pop</span>();<br>		vis[u]=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];i;i=e[i].next)&#123;<br>			<span class="hljs-type">int</span> v=e[i].v;<br>			<span class="hljs-type">double</span> w=e[i].w;<br>			<span class="hljs-keyword">if</span>(dis[v]&lt;dis[u]*w)&#123;<br>				dis[v]=dis[u]*w;<br>				ring[v]=ring[u]+<span class="hljs-number">1</span>;<br>				<span class="hljs-keyword">if</span>(ring[v]&gt;n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>				<span class="hljs-keyword">if</span>(vis[v]==<span class="hljs-number">0</span>)&#123;<br>					vis[v]=<span class="hljs-number">1</span>;<br>					q.<span class="hljs-built_in">push</span>(v);<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>	<span class="hljs-type">int</span> ccnt=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(cin&gt;&gt;n&amp;&amp;n)&#123;<br>		cnt=<span class="hljs-number">0</span>;<br>		<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(head));<br>		map&lt;string,<span class="hljs-type">int</span>&gt; ma;<br>		string s,ss;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			cin&gt;&gt;s;<br>			ma[s]=i;<br>		&#125;<br>		cin&gt;&gt;t;<br>		<span class="hljs-type">double</span> giao;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=t;i++)&#123;<br>			cin&gt;&gt;s&gt;&gt;giao&gt;&gt;ss;<br>			<span class="hljs-built_in">addedge</span>(ma[s],ma[ss],giao);<br>		&#125;<br>		cout&lt;&lt;<span class="hljs-string">&quot;Case &quot;</span>&lt;&lt;++ccnt&lt;&lt;<span class="hljs-string">&quot;: &quot;</span>;<br>		<span class="hljs-type">bool</span> f=<span class="hljs-literal">false</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-keyword">if</span>(f) <span class="hljs-keyword">break</span>;<br>			<span class="hljs-keyword">if</span>(<span class="hljs-built_in">spfa</span>(i))&#123;<br>				f=<span class="hljs-literal">true</span>;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(f) cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>		<span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>图论习题1</title>
    <url>/2020/02/02/%E5%9B%BE%E8%AE%BA%E4%B9%A0%E9%A2%981/</url>
    <content><![CDATA[<h2 id="刷题记录-图论习题1（floyd应用）"><a href="#刷题记录-图论习题1（floyd应用）" class="headerlink" title="[刷题记录]图论习题1（floyd应用）"></a><center>[刷题记录]图论习题1（floyd应用）</center></h2><span id="more"></span>
<ul>
<li>搞了三道<strong>图论</strong>入门题，全是$floyd$，记录一下。</li>
</ul>
<hr>
<h2 id="洛谷-P1364-医院设置"><a href="#洛谷-P1364-医院设置" class="headerlink" title="洛谷 P1364 医院设置"></a><a href="https://www.luogu.com.cn/problem/P1364">洛谷 P1364 医院设置</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><ul>
<li>有一棵二叉树，每个节点代表一个地方的人数，相邻节点之间距离为1，现在要在某个节点设置医院，要求所有人到医院的路程之和最小，求最小路程和。</li>
</ul>
<p>Sample Input</p>
<figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">5</span>	//<span class="hljs-number">5</span>个节点					<br><span class="hljs-symbol">13 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> //第i个节点的人数 左儿子是<span class="hljs-number">2</span> 右儿子是<span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span>  // <span class="hljs-number">0</span>代表没有这个儿子<br><span class="hljs-symbol">12 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">20 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">40 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">81<br></code></pre></div></td></tr></table></figure>
<h3 id="思路-amp-题解"><a href="#思路-amp-题解" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><ul>
<li>先$floyd$预处理出每两个节点之间的距离，然后遍历每一个节点，在该节点上设置医院并求出路程和，更新最小路程和。</li>
</ul>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>],num[<span class="hljs-number">105</span>];<br><span class="hljs-type">int</span> ans=<span class="hljs-number">1e9</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gao</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>				dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j],dp[i][k]+dp[k][j]); <br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;n;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>			<span class="hljs-keyword">if</span>(i==j) <span class="hljs-keyword">continue</span>;<br>			<span class="hljs-keyword">else</span> dp[i][j]=<span class="hljs-number">1e9</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		cin&gt;&gt;num[i];<br>		<span class="hljs-type">int</span> x;<br>		cin&gt;&gt;x;<br>		<span class="hljs-keyword">if</span>(x!=<span class="hljs-number">0</span>)&#123;<br>			dp[i][x]=<span class="hljs-number">1</span>;<br>			dp[x][i]=<span class="hljs-number">1</span>;<br>		&#125;<br>		cin&gt;&gt;x;<br>		<span class="hljs-keyword">if</span>(x!=<span class="hljs-number">0</span>)&#123;<br>			dp[i][x]=<span class="hljs-number">1</span>;<br>			dp[x][i]=<span class="hljs-number">1</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">gao</span>();<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;<br>		<span class="hljs-type">int</span> temp = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-keyword">if</span>(i==k) <span class="hljs-keyword">continue</span>;<br>			temp+=dp[k][i]*num[i];<br>		&#125;<br>		ans = <span class="hljs-built_in">min</span>(ans,temp);<br>	&#125;<br>	cout&lt;&lt;ans&lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-comment">//https://www.luogu.com.cn/problem/P1364</span><br></code></pre></div></td></tr></table></figure>
<h2 id="vijos-p1446-最短路上的统计"><a href="#vijos-p1446-最短路上的统计" class="headerlink" title="vijos p1446 最短路上的统计"></a><a href="https://vijos.org/p/1446">vijos p1446 最短路上的统计</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><ul>
<li>一个<strong>无向无环图</strong>，边权都为1，有$n$次询问，每次询问一个点对$(a,b)$，要求输出$a$与$b$之间所有最短路上的点的总个数（注意：可能有多条最短路）。</li>
</ul>
<h3 id="思路-amp-题解-1"><a href="#思路-amp-题解-1" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><ul>
<li>$floyd$过后，针对每次询问，开始遍历所有点作为中间节点，判断是否有$dp[a][b] == dp[a][i]+dp[i][b]$即可。</li>
</ul>
<h3 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> n,m;<br>	cin&gt;&gt;n&gt;&gt;m;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>			<span class="hljs-keyword">if</span>(i==j) dp[i][j]=<span class="hljs-number">0</span>;<br>			<span class="hljs-keyword">else</span> dp[i][j]=<span class="hljs-number">1e9</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>		<span class="hljs-type">int</span> x,y;<br>		cin&gt;&gt;x&gt;&gt;y;<br>		dp[x][y]=dp[y][x]=<span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>				dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j],dp[i][k]+dp[k][j]);<br>			&#125;<br>		&#125;<br>	<span class="hljs-type">int</span> p;<br>	cin&gt;&gt;p;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=p;i++)&#123;<br>		<span class="hljs-type">int</span> x,y;<br>		cin&gt;&gt;x&gt;&gt;y;<br>		<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-keyword">if</span>(dp[x][y]==dp[x][i]+dp[i][y])<br>				cnt++;<br>		&#125;<br>		cout&lt;&lt;cnt&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-comment">//https://vijos.org/p/1446</span><br></code></pre></div></td></tr></table></figure>
<h2 id="vijos-p1046-观光旅游"><a href="#vijos-p1046-观光旅游" class="headerlink" title="vijos p1046 观光旅游"></a><a href="https://vijos.org/p/1046">vijos p1046 观光旅游</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><ul>
<li>解释过来就是：有一个<strong>无向无环有权图</strong>（可能有重边），求图中的<strong>最小环</strong>。（注意：无向图的最小环最小为3个节点组成的环）</li>
</ul>
<h3 id="思路-amp-题解-2"><a href="#思路-amp-题解-2" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><ul>
<li>经典的<strong>无向图最小环问题</strong>，思路是：在$floyd$求解过程中，在<strong>枚举到$k$节点为中间节点时，所有点以第$1…k-1$的作为中间节点的最短路都已经算好了</strong>，它们都是不经过$k$节点的最短路，因此可以利用这一点，在更新本次以$k$节点为中间节点的最短路之前，<strong>枚举$k$节点之前的所有节点</strong>来求最小环大小，状态转移方程：<script type="math/tex; mode=display">
ans=min(ans,dis[i][j]+mm[i][k]+mm[k][j])</script>其中，$dis[i][j]$为更新过的$i$到$j$的最短路，$mm$数组为原始图的邻接矩阵。</li>
</ul>
<h3 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll dp[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>];<br>ll n,m;<br>ll ans[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>];<br>ll anss=<span class="hljs-number">1e9</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;k;i++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;k;j++)&#123; <span class="hljs-comment">//核心代码</span><br>					anss = <span class="hljs-built_in">min</span>(anss,dp[i][j]+ans[i][k]+ans[k][j]);<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123; <span class="hljs-comment">//floyd</span><br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>				dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j],dp[i][k]+dp[k][j]);<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)&#123;<br>		anss=<span class="hljs-number">1e9</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>				<span class="hljs-keyword">if</span>(i!=j) ans[i][j]=dp[i][j]=<span class="hljs-number">1e9</span>; <br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">while</span>(m--)&#123;<br>			ll x,y,d;<br>			cin&gt;&gt;x&gt;&gt;y&gt;&gt;d;<br>			dp[x][y]=dp[y][x]=ans[x][y]=ans[y][x]=<span class="hljs-built_in">min</span>(dp[x][y],d);<br>		&#125;	<br>		<span class="hljs-built_in">floyd</span>();<br>		<span class="hljs-keyword">if</span>(anss==<span class="hljs-number">1e9</span>) cout&lt;&lt;<span class="hljs-string">&quot;No solution.&quot;</span>&lt;&lt;endl;<br>		<span class="hljs-keyword">else</span> cout&lt;&lt;anss&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-comment">//https://vijos.org/p/1046</span><br></code></pre></div></td></tr></table></figure>
<hr>
<ul>
<li>$floyd$代码还是比较好理解的，主要是<strong>最小环</strong>算法比较巧妙orz，继续加油！</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>图论</tag>
        <tag>数据结构</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>Dijkstra &amp; SPFA</title>
    <url>/2020/02/11/%E5%9B%BE%E8%AE%BA%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="两个图论最短路算法板子"><a href="#两个图论最短路算法板子" class="headerlink" title="两个图论最短路算法板子"></a><center>两个图论最短路算法板子</center></h2><span id="more"></span>
<ul>
<li>$Dijkstra$和$SPFA$（优化$Bellman-Ford$）的<strong>板子+优化+个人理解</strong></li>
<li><a href="https://www.luogu.com.cn/problem/P3371">弱化版 单源最短路径</a> 可$SPFA$</li>
<li><a href="https://www.luogu.com.cn/problem/P4779">标准版 单源最短路径</a> 不可$SPFA$</li>
</ul>
<hr>
<h2 id="SPFA-（优化-Bellman-Ford-）"><a href="#SPFA-（优化-Bellman-Ford-）" class="headerlink" title="$SPFA$（优化$Bellman-Ford$）"></a>$SPFA$（优化$Bellman-Ford$）</h2><p>至于$Bellman-Ford$这里就不提了，毕竟已经淘汰了（复杂度满了$O(nm)$）</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>大致思路：利用队列$bfs$优化$Bellman-Ford$，从当前点（第一次就是起点）开始，<strong>遍历每一个</strong>出边，更新到这条边终点的最短路径（如果可以更新的话），如果这个点未标记过，则把这个终点push进队列，并标记（表明更新过），之后每次从队首取出元素并将其<strong>置为未标记</strong>（目的是<strong>可重复更新</strong>），对当前点重复上述步骤即可得出答案</p>
<p><strong>核心点：</strong></p>
<ul>
<li>每次取出队首元素后<strong>一定要去标记</strong></li>
<li>“可重复更新”是该算法的核心</li>
<li>复杂度为$O(ke)$，$k$是个常数（通常等于2左右），然而会有毒瘤题卡$SPFA$，使其复杂度达到满的$O(nm)$，因而在不含负权图中尽量使用$Dijkstra$</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">2147483647</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123; <span class="hljs-comment">//边结构体</span><br>	<span class="hljs-type">int</span> u,v,w,next;<br>&#125;e[<span class="hljs-number">1000005</span>];<br><br><span class="hljs-type">int</span> n,m,s,ans,cnt,vis[<span class="hljs-number">1000005</span>],head[<span class="hljs-number">1000005</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w)</span></span>&#123; <span class="hljs-comment">//前向星加边</span><br>	e[++cnt].u=u;<br>	e[cnt].v=v;<br>	e[cnt].w=w;<br>	e[cnt].next=head[u];<br>	head[u]=cnt;<br>&#125;<br><span class="hljs-type">int</span> dis[<span class="hljs-number">1000005</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">SPFA</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//核心</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123; <span class="hljs-comment">//最短路初始化为inf</span><br>		dis[i]=inf;<br>	&#125;<br>	queue&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">//存入每个点的队列</span><br>	q.<span class="hljs-built_in">push</span>(s); <span class="hljs-comment">//起点入队</span><br>	dis[s]=<span class="hljs-number">0</span>; <span class="hljs-comment">//到起点的最短路为0</span><br>	vis[s]=<span class="hljs-number">1</span>; <span class="hljs-comment">//起点标记过</span><br>	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123; <span class="hljs-comment">//bfs</span><br>		<span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>(); <br>		q.<span class="hljs-built_in">pop</span>();<br>		vis[u]=<span class="hljs-number">0</span>; <span class="hljs-comment">//很重要，去标记，表明可以重复更新</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];i;i=e[i].next)&#123; <span class="hljs-comment">//遍历相连的每下一条边</span><br>			<span class="hljs-type">int</span> v=e[i].v,w=d[i].w;<br>			<span class="hljs-keyword">if</span>(dis[v]&gt;dis[u]+w)&#123; <span class="hljs-comment">//如果满足更新条件</span><br>				dis[v]=dis[u]+w; <span class="hljs-comment">//更新最短路</span><br>				<span class="hljs-keyword">if</span>(vis[v]==<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//如果没有标记过</span><br>					vis[v]=<span class="hljs-number">1</span>; <span class="hljs-comment">//则标记，表明更新了</span><br>					q.<span class="hljs-built_in">push</span>(v); <span class="hljs-comment">//并入队</span><br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>		<span class="hljs-type">int</span> u,v,w;<br>		cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br>		<span class="hljs-built_in">addedge</span>(u,v,w);<br>	&#125;<br>	<span class="hljs-built_in">SPFA</span>();<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		cout&lt;&lt;dis[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="$Dijkstra$"></a>$Dijkstra$</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>大致思路：同$SPFA$的操作，但不同的是：思路类似于$Prim$算法，并<strong>不用重复更新某一个点</strong>，而是采用每次更新答案之前通过一顿循环，把当前情况下的到起点的最短路所对应的节点取出来，对这个节点的所有出边遍历并更新答案，然后重复上述过程，直到所有点都完成更新，复杂度是$O(n^2)$，显然不够给力，因此通常我们会采取<strong>堆优化</strong></p>
<p><strong>堆优化：</strong>由于每次需要去除当前情况下的最短路对应的节点，我们可以利用<strong>小根堆</strong>的特点，每次取出最小元素所需复杂度为$O(logn)$，因此算法的复杂度可以优化为$O((n+m)logn)$</p>
<p><strong>核心点：</strong></p>
<ul>
<li>每次更新答案前取出当前情况下最短路径所对应的的节点，以此更新</li>
<li>大部分情况下不会被卡，十分好用</li>
</ul>
<h3 id="代码（堆优化）"><a href="#代码（堆优化）" class="headerlink" title="代码（堆优化）"></a>代码（堆优化）</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">2147483647</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123; <br>	<span class="hljs-type">int</span> u,v,w,next;<br>&#125;e[<span class="hljs-number">1000005</span>];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123; <span class="hljs-comment">//采用堆优化，需要开一个结构体存入终点边和对应的最短路</span><br>	<span class="hljs-type">int</span> u,dis;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> node&amp;rhs)<span class="hljs-type">const</span>&#123; <span class="hljs-comment">//重载小于号，因为要用小根堆</span><br>		<span class="hljs-keyword">return</span> dis&gt;rhs.dis;<br>	&#125;<br>&#125;;<br><br><span class="hljs-type">int</span> n,m,s,ans,cnt,now,head[<span class="hljs-number">1000005</span>],dis[<span class="hljs-number">1000005</span>]; <span class="hljs-comment">//dis是答案数组</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w)</span></span>&#123; <span class="hljs-comment">//加边</span><br>	e[++cnt].u=u;<br>	e[cnt].v=v;<br>	e[cnt].w=w;<br>	e[cnt].next=head[u];<br>	head[u]=cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) dis[i]=inf; <span class="hljs-comment">//初始化</span><br>	priority_queue&lt;node&gt; q; <span class="hljs-comment">//开小根堆</span><br>	dis[s]=<span class="hljs-number">0</span>; <span class="hljs-comment">//到起点的最短路为0</span><br>	q.<span class="hljs-built_in">push</span>((node)&#123;s,<span class="hljs-number">0</span>&#125;); <span class="hljs-comment">//把起点push进去</span><br>	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123; <span class="hljs-comment">//bfs</span><br>		node q1=q.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">//取出队首的点（当前情况最短路对应的点）</span><br>		q.<span class="hljs-built_in">pop</span>();<br>		<span class="hljs-type">int</span> u=q1.u;<br>        <br>        <span class="hljs-comment">//这一步很重要，比较难理解</span><br>        <span class="hljs-comment">//因为有可能 这一次更新的点（点，最短路）入了队（先入队），</span><br>        <span class="hljs-comment">//但是下一次又更新了一次（还是这个点，新的最短路）（后入队）</span><br>        <span class="hljs-comment">//如果出现了</span><br>        <span class="hljs-comment">//先入队的这个点的最短路 大于 最新情况下（即最后一次入队）时的最短路</span><br>        <span class="hljs-comment">//那么就说明这次这个已经不是最短路了</span><br>        <span class="hljs-comment">//就可以舍弃了，因此continue</span><br>		<span class="hljs-keyword">if</span>(q1.dis&gt;dis[u]) <span class="hljs-keyword">continue</span>; <br>        <br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];i;i=e[i].next)&#123; <span class="hljs-comment">//遍历每一个出边</span><br>			<span class="hljs-type">int</span> v=e[i].v,w=e[i].w;<br>			<span class="hljs-keyword">if</span>(dis[v]&gt;dis[u]+w)&#123; <span class="hljs-comment">//如果满足最短路要求</span><br>				dis[v]=dis[u]+w; <span class="hljs-comment">//更新答案</span><br>				q.<span class="hljs-built_in">push</span>((node)&#123;v,dis[v]&#125;); <span class="hljs-comment">//把（点，最短路）push进堆</span><br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>		<span class="hljs-type">int</span> u,v,w;<br>		cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br>		<span class="hljs-built_in">addedge</span>(u,v,w);<br>	&#125;<br>	<span class="hljs-built_in">dijkstra</span>();<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		cout&lt;&lt;dis[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>数据结构</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>图论习题2</title>
    <url>/2020/02/13/%E5%9B%BE%E8%AE%BA%E4%B9%A0%E9%A2%982/</url>
    <content><![CDATA[<h2 id="刷题记录-图论习题2（最短路综合应用）"><a href="#刷题记录-图论习题2（最短路综合应用）" class="headerlink" title="[刷题记录]图论习题2（最短路综合应用）"></a><center>[刷题记录]图论习题2（最短路综合应用）</center></h2><span id="more"></span>
<ul>
<li>图论中<strong>最短路算法</strong>（包括$SPFA$和$Dijkstra$）的一部分基础习题，也结合了许多其他知识点，如$dp$、贪心等</li>
</ul>
<h3 id="Vijos-P1635-城市链接"><a href="#Vijos-P1635-城市链接" class="headerlink" title="Vijos P1635 城市链接"></a><a href="https://vijos.org/p/1635">Vijos P1635 城市链接</a></h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><ul>
<li>简化：给一个有向有权图，要求输出<strong>最短路径经过的点</strong>和<strong>最短路长度</strong></li>
</ul>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><ul>
<li>裸一个$SPFA$或者$Dijkstra$，开一个$pre$数组在每次节点更新时记录一下（记录方式为$pre[v]=u$，意思是记录每一个节点的前驱），最后从$pre[n]$倒序拷贝到一个数组里然后顺序输出即可</li>
</ul>
<h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">2147483647</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> u,v,w,next;<br>&#125;e[<span class="hljs-number">1000005</span>];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>	<span class="hljs-type">int</span> u,dis;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> node&amp; rhs)<span class="hljs-type">const</span>&#123;<br>		<span class="hljs-keyword">return</span> dis&gt;rhs.dis;<br>	&#125;<br>&#125;;<br><br><span class="hljs-type">int</span> n,s=<span class="hljs-number">1</span>,cnt,head[<span class="hljs-number">1000005</span>],pre[<span class="hljs-number">1000005</span>],ans[<span class="hljs-number">1000005</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w)</span></span>&#123;<br>	e[++cnt].u=u;<br>	e[cnt].v=v;<br>	e[cnt].w=w;<br>	e[cnt].next=head[u];<br>	head[u]=cnt;<br>&#125;<br><span class="hljs-type">int</span> dis[<span class="hljs-number">1000005</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		dis[i]=inf;<br>	&#125;<br>	priority_queue&lt;node&gt; q;<br>	dis[s]=<span class="hljs-number">0</span>;<br>	q.<span class="hljs-built_in">push</span>(node&#123;s,<span class="hljs-number">0</span>&#125;);<br>	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>		node q1=q.<span class="hljs-built_in">top</span>();<br>		q.<span class="hljs-built_in">pop</span>();<br>		<span class="hljs-type">int</span> u=q1.u,d=q1.dis;<br>		<span class="hljs-keyword">if</span>(d&gt;dis[u]) <span class="hljs-keyword">continue</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];i;i=e[i].next)&#123;<br>			<span class="hljs-type">int</span> v=e[i].v,w=e[i].w;<br>			<span class="hljs-keyword">if</span>(dis[v]&gt;dis[u]+w)&#123;<br>				dis[v]=dis[u]+w;<br>				pre[v]=u;<br>				q.<span class="hljs-built_in">push</span>(node&#123;v,dis[v]&#125;);<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i;i=pre[i])&#123;<br>		ans[++t]=i;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=t;i&gt;=<span class="hljs-number">1</span>;i--) cout&lt;&lt;ans[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;n;<br>	<span class="hljs-type">int</span> x;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>			cin&gt;&gt;x;<br>			<span class="hljs-keyword">if</span>(x!=<span class="hljs-number">0</span>) <span class="hljs-built_in">addedge</span>(i,j,x);<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">dijkstra</span>();<br>	cout&lt;&lt;endl;<br>	cout&lt;&lt;dis[n]&lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<br>&#125;<span class="hljs-comment">//https://vijos.org/p/1635</span><br></code></pre></div></td></tr></table></figure>
<h3 id="NOIP-2009-提高组-T3-最优贸易"><a href="#NOIP-2009-提高组-T3-最优贸易" class="headerlink" title="NOIP 2009 提高组 T3 最优贸易"></a><a href="https://www.luogu.com.cn/problem/P1073">NOIP 2009 提高组 T3 最优贸易</a></h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><ul>
<li>简化：给一个有向无权图，每个节点有一个数值（代表商品价格），现在有一个商人从起点经过若干点（可重复经过）到达终点，途中可以选择一个点的价格买入商品，再在之后经过的某一个卖出商品（买入卖出操作只能有一次），问最大利润是多少？</li>
</ul>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><ul>
<li>题目的意思很清楚了，就是要求你从起点出发到一个点以价格1买入，再到这个点之后以价格2卖出，求这两个价格的最大差值</li>
<li>我们可以想到$SPFA$，它可以求出从起点到每一个点的最短路，那么这里是无权图，所以我们的“最短”可以定义为节点的价格最小，这样过一遍$SPFA$就可以求出到达每个节点买入价格的最小值</li>
<li>还剩下从每一个节点到所有之后的节点的最大值，怎么求呢？</li>
<li><strong>逆向思维</strong>：我们从该点出发往下一个点走，就相当于下一个点往我们这边走，因此我们可以<strong>反向建图</strong>，再从终点开始往起点过一遍$SPFA$（但这里是求“最长”，即每个点的最大价格）就可以求出从每个点出发到终点能够卖出的最大价格</li>
<li><p>这样，我们已经求出了以下两部分：</p>
<ol>
<li>从起点出发到每个点买入的最小价格</li>
<li>从每个点出发到终点卖出的最大价格</li>
</ol>
</li>
<li><p>然后只需要对每个点求出这两者的最大差值即可</p>
</li>
</ul>
<h4 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">2147483647</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> u,v,w,next;<br>&#125;e1[<span class="hljs-number">1000005</span>],e2[<span class="hljs-number">1000005</span>];<br><br><span class="hljs-type">int</span> n,m,s=<span class="hljs-number">1</span>,cnt1,cnt2,head1[<span class="hljs-number">1000005</span>],head2[<span class="hljs-number">1000005</span>],jia[<span class="hljs-number">1000005</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge1</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w)</span></span>&#123;<br>	e1[++cnt1].u=u;<br>	e1[cnt1].v=v;<br>	e1[cnt1].w=w;<br>	e1[cnt1].next=head1[u];<br>	head1[u]=cnt1;<br>&#125;<br><span class="hljs-type">int</span> dis1[<span class="hljs-number">1000005</span>],dis2[<span class="hljs-number">1000005</span>],vis1[<span class="hljs-number">1000005</span>],vis2[<span class="hljs-number">1000005</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge2</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w)</span></span>&#123;<br>	e2[++cnt2].u=u;<br>	e2[cnt2].v=v;<br>	e2[cnt2].w=w;<br>	e2[cnt2].next=head2[u];<br>	head2[u]=cnt2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">spfa1</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">memset</span>(vis1,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis1));<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) dis1[i]=inf;<br>	vis1[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>	dis1[<span class="hljs-number">1</span>]=jia[<span class="hljs-number">1</span>];<br>	queue&lt;<span class="hljs-type">int</span>&gt; q;<br>	q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>		<span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>();<br>		q.<span class="hljs-built_in">pop</span>();<br>		vis1[u]=<span class="hljs-number">0</span>;<br>		dis1[u]=<span class="hljs-built_in">min</span>(dis1[u],jia[u]); <span class="hljs-comment">//求每个点最小值</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head1[u];i;i=e1[i].next)&#123;<br>			<span class="hljs-type">int</span> v=e1[i].v;<br>			<span class="hljs-keyword">if</span>(dis1[v]&gt;dis1[u])&#123;<br>				dis1[v]=dis1[u];<br>				<span class="hljs-keyword">if</span>(vis1[v]==<span class="hljs-number">0</span>)&#123;<br>					vis1[v]=<span class="hljs-number">1</span>;<br>					q.<span class="hljs-built_in">push</span>(v);<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">spfa2</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">memset</span>(vis2,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis2));<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) dis2[i]=<span class="hljs-number">0</span>;<br>	vis2[n]=<span class="hljs-number">1</span>;<br>	dis2[n]=jia[n];<br>	queue&lt;<span class="hljs-type">int</span>&gt; q;<br>	q.<span class="hljs-built_in">push</span>(n);<br>	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>		<span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>();<br>		q.<span class="hljs-built_in">pop</span>();<br>		vis2[u]=<span class="hljs-number">0</span>;<br>		dis2[u]=<span class="hljs-built_in">max</span>(dis2[u],jia[u]); <span class="hljs-comment">//求每个点最大值</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head2[u];i;i=e2[i].next)&#123;<br>			<span class="hljs-type">int</span> v=e2[i].v;<br>			<span class="hljs-keyword">if</span>(dis2[v]&lt;dis2[u])&#123;<br>				dis2[v]=dis2[u];<br>				<span class="hljs-keyword">if</span>(vis2[v]==<span class="hljs-number">0</span>)&#123;<br>					vis2[v]=<span class="hljs-number">1</span>;<br>					q.<span class="hljs-built_in">push</span>(v);<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>	cin&gt;&gt;n&gt;&gt;m;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;jia[i];<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>		<span class="hljs-type">int</span> u,v,z;<br>		cin&gt;&gt;u&gt;&gt;v&gt;&gt;z;<br>		<span class="hljs-built_in">addedge1</span>(u,v,<span class="hljs-number">1</span>); <span class="hljs-comment">//正反建图</span><br>		<span class="hljs-built_in">addedge2</span>(v,u,<span class="hljs-number">1</span>);<br>		<span class="hljs-keyword">if</span>(z==<span class="hljs-number">2</span>)&#123;<br>			<span class="hljs-built_in">addedge1</span>(v,u,<span class="hljs-number">1</span>);<br>			<span class="hljs-built_in">addedge2</span>(u,v,<span class="hljs-number">1</span>);<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-built_in">spfa1</span>(); <span class="hljs-comment">//正反spfa</span><br>	<span class="hljs-built_in">spfa2</span>();<br>	<span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		sum=<span class="hljs-built_in">max</span>(sum,dis2[i]-dis1[i]); <span class="hljs-comment">//取最大差值</span><br>	&#125;<br>	cout&lt;&lt;sum&lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-comment">//https://www.luogu.com.cn/problem/P1073</span><br><br></code></pre></div></td></tr></table></figure>
<h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h3>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>图论</tag>
        <tag>数据结构</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>风能预测学习</title>
    <url>/2020/02/18/%E5%9F%BA%E4%BA%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%A3%8E%E8%83%BD%E9%A2%84%E6%B5%8B%E6%96%B9%E9%9D%A2%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="基于机器学习-深度学习的风能预测方面的学习"><a href="#基于机器学习-深度学习的风能预测方面的学习" class="headerlink" title="基于机器学习&深度学习的风能预测方面的学习"></a><center>基于机器学习&深度学习的风能预测方面的学习</center></h2><span id="more"></span>
<h3 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h3><ul>
<li><p>阅读神经网络相关文献，尝试使用keras搭建合适的NN模型（尝试LSTM的RNN网络）预测</p>
</li>
<li><p>阅读facebook论文<a href="https://peerj.com/preprints/3190/">Forcasting at Scale</a>，搞清楚fbprophet原理（时间序列分解+机器学习拟合），尝试使用facebook开源第三方库（有R和python两个接口）fbprophet预测风能时间序列</p>
<p>参考文献&amp;网址：<a href="https://www.jiqizhixin.com/articles/2019-02-19-11">机器之心 Facebook时间序列预测算法Prophet的研究</a></p>
</li>
</ul>
<h3 id="日程记录"><a href="#日程记录" class="headerlink" title="日程记录"></a>日程记录</h3><h4 id="2020-2-15"><a href="#2020-2-15" class="headerlink" title="2020.2.15"></a>2020.2.15</h4><ul>
<li>搞明白了神经网络的基本原理、发展和分类</li>
<li>搞明白了BP反向传播算法（链式求导法则）</li>
<li>搞明白了CNN基本原理（卷积层+池化层+Flatten层）</li>
<li>搞明白了RNN基本原理（tanh激活函数）</li>
<li>搞明白了LSTM（长短时记忆网络）基本原理，及其如何解决RNN的梯度发散问题（使用“门”结构）</li>
<li><p>明确了时间序列问题处理的合适模型（RNN、LSTM、机器学习拟合 等）</p>
</li>
<li><p>明天开始实战keras</p>
</li>
</ul>
<h4 id="2020-2-16："><a href="#2020-2-16：" class="headerlink" title="2020.2.16："></a>2020.2.16：</h4><ul>
<li><p>花了一上午时间安装TensorFlow，真是太麻烦了，就目前我的情况来看，一定不要安装2.1.0版本的，用notebook会报<code>ERROR:root:Internal Python error in the inspect module.</code>的error（还有一堆找不到模块的error），因此暂时使用2.0.0版本的tf，安装代码如下</p>
<figure class="highlight node-repl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">pip uninstall tensorflow</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">pip install -i <span class="hljs-attr">https</span>:<span class="hljs-comment">//pypi.tuna.tsinghua.edu.cn/simple tensorflow==2.0.0</span></span><br></code></pre></div></td></tr></table></figure>
</li>
<li><p>下午：学习keras基本操作</p>
<ul>
<li><p><a href="[https://github.com/b4158813/AiLearning/blob/master/docs/TensorFlow2.x/Keras%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.md#%E5%9B%9E%E5%BD%92](https://github.com/b4158813/AiLearning/blob/master/docs/TensorFlow2.x/Keras快速入门.md#回归">keras快速入门</a>)</p>
</li>
<li><p><a href="https://blog.csdn.net/jiangpeng59/article/details/77533309">keras.layers.embedding层原理</a></p>
</li>
<li>照着教程的三个小项目手打了一遍代码（学会了使用keras给神经网络添加正则化，包括权重正则化和dropout正则化）</li>
<li>学习TensorFlow的官方教程<a href="https://tensorflow.google.cn/tutorials/structured_data/time_series">time_series</a></li>
</ul>
</li>
<li><p>晚上：学习将时间序列数据转化为监督学习数据</p>
</li>
<li><p>非常重要的操作步骤：<a href="https://machinelearningmastery.com/convert-time-series-supervised-learning-problem-python/">How to Convert a Time Series to a Supervised Learning Problem in Python</a></p>
</li>
</ul>
<p>思考：根据数据集所具有的特征，我接下来要做：</p>
<ol>
<li><p>利用风能的多维度的数据（如气候、温度、湿度、发电量等）构建LSTM网络（需转化为监督学习数据），并预测单一指标（如发电量）</p>
<p>个人认为老师的要求为：给出小时线、日线、周线做出趋势预测，因此首先攻克该目标，实战练习：<a href="https://blog.csdn.net/m0_37324740/article/details/80913497">LSTM实战</a>，做到一半，明天继续。</p>
</li>
</ol>
<h4 id="2020-2-17"><a href="#2020-2-17" class="headerlink" title="2020.2.17"></a>2020.2.17</h4><ul>
<li><p>上午：完成实战练手，效果如下</p>
<ul>
<li><p>（红色为预测趋势，蓝色为原始数据）<img src="https://i.loli.net/2020/02/17/9XmQIiUS5GlHE1Z.png" alt="下载.png"></p>
</li>
<li><p>evaluate效果：<img src="https://i.loli.net/2020/02/17/fytMma5dpF7ZGIA.png" alt="image.png"></p>
</li>
<li><p>反归一化之后和原数据对比，比较给力：<img src="https://i.loli.net/2020/02/17/2DtInZFfxRYdaAc.png" alt="image.png"></p>
</li>
</ul>
</li>
<li><p>下午：总结步骤+继续练习</p>
<ul>
<li><p>步骤总结写入博客中</p>
</li>
<li><p>完成air_line_predict 练手，并尝试不同参数作简要比较</p>
</li>
</ul>
</li>
<li><p>晚间：</p>
<ul>
<li><p>已完成air_line_predict项目练手，经过一番折腾，得出如下结果</p>
<p>这里使用前60%数据为训练集，中间20%为验证集，最后20%为测试集进行训练和预测，实验效果较好的为( input -&gt; 8 -&gt; 4-&gt; output(1) )的四层LSTM网络（因为数据量实在太小），如下图</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/02/17/FqPNESMsTRpJcWr.png" alt="image.png"></p>
<ul>
<li>evaluate结果</li>
</ul>
<p><img src="https://i.loli.net/2020/02/17/3I2Q9GCT5liLh1K.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/02/17/1VKSHT9DmksQXp3.png" alt="image.png"></p>
<ul>
<li>总体趋势出现了滞后，调了很久都没有缓解，查阅相关资料得出，可能是由于<strong>数据量过小</strong>的原因（只有100+），LSTM对于过小数据量总是有<strong>滞后</strong>现象，到目前为止我仍未查到相关解决方法，但在反归一化后得出的结果还算凑合？（如下图）</li>
</ul>
<p><img src="https://i.loli.net/2020/02/17/USoHr57ROL9EZCb.png" alt="image.png"></p>
<ul>
<li>测试集的趋势差不多预测对了，幅度偏大</li>
</ul>
<p><img src="https://i.loli.net/2020/02/17/s4bi62UyMa3mjTZ.png" alt="image.png"></p>
</li>
</ul>
<h4 id="2020-2-18"><a href="#2020-2-18" class="headerlink" title="2020.2.18"></a>2020.2.18</h4><ul>
<li><p>上午：进行<a href="https://archive.ics.uci.edu/ml/datasets/Beijing+PM2.5+Data">beijing_air_quality数据集</a>的预测练习（数据集见链接），利用维数较多的数据（11维）预测后期趋势，具体情况如下</p>
<ul>
<li><p>数据集中有一栏“风向”为categorical数据，观察发现仅4个类别，于是采用OneHot编码</p>
</li>
<li><p>采用 利用过去1个时间点的数据预测未来1个时间点的数据（seq2seq） 的思想</p>
</li>
<li><p>LSTM网络采用如下结构（输入 -&gt; 隐含层50个神经元 -&gt; 输出层1个神经元）</p>
<p><img src="https://i.loli.net/2020/02/18/aSpDB6i7ZQbf28E.png" alt="image.png"></p>
</li>
<li><p>训练参数为（epoch=50, batch_size=72）（训练集：验证集：测试集=3：1：1）并且实验初期发现似乎出现过拟合现象（val_loss不降反增），于是采用（patience=10）的回调</p>
</li>
<li><p>loss对比如下</p>
<p><img src="https://i.loli.net/2020/02/18/Xiu81wZAHOFzqNf.png" alt="image.png"></p>
</li>
<li><p>在测试集上的对比<img src="https://i.loli.net/2020/02/18/h5Qc9fSu6iVNtEo.png" alt="image.png"></p>
</li>
<li><p>反归一化后对比</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2020/02/18/GWOrY3SoFyKDHea.png" alt="image.png"><img src="https://i.loli.net/2020/02/18/CZLAonEqy71P5aU.png" alt="image.png"></p>
<ul>
<li><p>中午：仍旧使用上午那组数据，利用其它数据预测<strong>风速</strong>，可以间接达到预测风力的目的（先做一次尝试），结果如下</p>
<ul>
<li><p>采用相同的LSTM模型（加回调，无正则化），直接进行预测，发现使用mse评估测试集的loss特别低，效果非常好<img src="https://i.loli.net/2020/02/18/L9eIHW7QvA3PbV4.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/02/18/ULPeNkF2ZDAorJQ.png" alt="image.png"></p>
</li>
<li><p>由于数据集范围较广，数据是以 数据/1h的形式给出，所以无法预测1小时线，下面给出了此模型对测试集的 四小时线、日线、周线 的预测图（数据范围随机抽取）</p>
<p><img src="https://i.loli.net/2020/02/18/ZBQuSXlcCEdDrqJ.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/02/18/nwqMBysub3P2pUA.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/02/18/RgNnueETCl7Zcvq.png" alt="image.png"></p>
</li>
<li><p>可以看出，由于数据间隔叫大，4小时线预测较为不准确，但趋势正确，而日线预测数据和原始数据几乎重合，周线数据除了个别数值有抖动现象，其他也吻合得非常好</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
        <tag>风能预测</tag>
      </tags>
  </entry>
  <entry>
    <title>线性数据结构&amp;堆</title>
    <url>/2020/01/31/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="刷题记录-线性数据结构-二叉堆"><a href="#刷题记录-线性数据结构-二叉堆" class="headerlink" title="[刷题记录]线性数据结构&二叉堆"></a><center>[刷题记录]线性数据结构&二叉堆</center></h2><span id="more"></span>
<p>这两天刷了一些简单的线性数据结构和二叉堆（优先队列）的题目，学会了一些STL的骚操作，简单记录一下。</p>
<hr>
<h2 id="洛谷-P1168-中位数"><a href="#洛谷-P1168-中位数" class="headerlink" title="洛谷 P1168 中位数"></a><a href="https://www.luogu.com.cn/problem/P1168">洛谷 P1168 中位数</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><ul>
<li>给出一个长度为$N$的非负整数序列$A<em>i$，对于所有$1 \leq k \leq \frac{N+1}{2}$，输出$A_1, A_3, …, A</em>{2k - 1}$的中位数。即前$1,3,5,…$个数的中位数。</li>
</ul>
<p>Sample Input</p>
<figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">7</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span> <span class="hljs-number">11</span> <span class="hljs-number">6</span><br></code></pre></div></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">1<br>3<br>5<br>6<br></code></pre></div></td></tr></table></figure>
<p>数据范围：$N\leq 1e5$</p>
<h3 id="思路-amp-题解"><a href="#思路-amp-题解" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><ul>
<li><u>思考1</u>：首先我们发现如果这个序列是有序的，那就太简单了，直接用数组存储，然后每隔一个数用下标访问输出中间那一个数就好了，因此想到每输入两个数的时候sort一次，复杂度是$O(n^2logn)$然而数据范围是100000，必爆炸，因此考虑其他做法；</li>
<li><u>思考2</u>：有没有可能边输入边排序呢？当然可以，我们可以使用priority_queue，<strong>堆</strong>插入的复杂度只有$O(logn)$，然而，排序是解决了，但怎么访问中位数呢？我们知道，<strong>优先队列只能访问队首元素</strong>，好像行不通。。</li>
<li><u>思考3</u>：又想在输入的同时排序，又想能够访问元素，对了，我们可以使用最原始的$vector$或者数组模拟这样的操作啊，因为我们<strong>有lower_bound这样的骚操作可以达到边输入边维护有序</strong>的操作，就像在模拟<strong>插入排序</strong>一样，OK，那么此题解决。</li>
</ul>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;<span class="hljs-type">int</span>&gt; a; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,x;<br>    cin&gt;&gt;n;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>		<span class="hljs-keyword">if</span>(!a.<span class="hljs-built_in">empty</span>())&#123; <span class="hljs-comment">//下面是通过二分查找来维护vector有序</span><br>			<span class="hljs-type">int</span> pos = <span class="hljs-built_in">lower_bound</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),x)-a.<span class="hljs-built_in">begin</span>();<br>			a.<span class="hljs-built_in">insert</span>(a.<span class="hljs-built_in">begin</span>()+pos,x);<br>		<span class="hljs-comment">//	cout&lt;&lt;pos&lt;&lt;&quot; &quot;;	</span><br>		&#125;<span class="hljs-keyword">else</span> a.<span class="hljs-built_in">push_back</span>(x);<br>		<span class="hljs-keyword">if</span>((i+<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>) cout&lt;&lt;a[(i+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>]&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="洛谷-P1631-序列合并"><a href="#洛谷-P1631-序列合并" class="headerlink" title="洛谷 P1631 序列合并"></a><a href="https://www.luogu.com.cn/problem/P1631">洛谷 P1631 序列合并</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><ul>
<li><p>有两个长度都是$N$的序列$A$和$B$，在$A$和$B$中各取一个数相加可以得到$N^2$个和，求这$N^2$个和中最小的$N$个。</p>
<p>Sample Input</p>
<figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">6</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">8</span><br></code></pre></div></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">6</span> <span class="hljs-number">7</span><br></code></pre></div></td></tr></table></figure>
<p>数据范围：$1\leq N \leq 1e5$</p>
</li>
</ul>
<h3 id="思路-amp-题解-1"><a href="#思路-amp-题解-1" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><ul>
<li><p>思考1：总共$N^2$个数，我枚举出来，然后每次都push进一个<strong>小根堆</strong>里，最后输出前$N$个不就行了吗，于是看了一眼数据范围，很明显这题暴力$O(N^2)$是拿不了满分的，然而试了一下下，骗了70分,<del>我惊了，居然还能MLE</del>；</p>
<p><img src="https://i.loli.net/2020/01/31/cO7mK9Q8NrHbADM.png" alt="image.png"></p>
<p>骗分代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt; &gt; pq;<br><span class="hljs-type">int</span> a[<span class="hljs-number">100005</span>],b[<span class="hljs-number">100005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> n;<br>	cin&gt;&gt;n;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;b[i];<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123; <span class="hljs-comment">// </span><br>			pq.<span class="hljs-built_in">push</span>(a[i]+b[j]);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		cout&lt;&lt;pq.<span class="hljs-built_in">top</span>()&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>		pq.<span class="hljs-built_in">pop</span>();<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>思考2：发现这个题输入是已经排好序的了，于是想了多种办法但都处理不好每次输出最小的数这样的操作，于是看了题解，看到一个神犇绝妙的解法，<strong>只需要在上述代码上加一点点小小的优化（剪枝）就好了</strong>：内部for循环改为for(int j=1;j&lt;=n&amp;&amp;(i-1)*(j-1)&lt;=n;j++)就可以了。那么为什么要加一句(i-1)*(j-1)&lt;=n呢？</p>
<p>数学证明：对于两个有序序列$A$和$B$，如果此时想要把$A<em>i+B_i$ push进小根堆中,而$i$和$j$满足$(i-1)*(j-1)&gt;N$，那么这个数一定已经不是前N小的数了，因为对于这两个序列来说，$1…i-1$和$1…j-1$所能构成的和的总数也就是$(i-1)*(j-1)$个，**而且最大值是$A</em>{i-1}+B<em>{i-1}$**，显然$A</em>{i-1}+B<em>{i-1}&lt;A</em>{i}+B_{i}$，因此算法成立。</p>
</li>
</ul>
<h3 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt; &gt; pq;<br><span class="hljs-type">int</span> a[<span class="hljs-number">100005</span>],b[<span class="hljs-number">100005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> n;<br>	cin&gt;&gt;n;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;b[i];<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n&amp;&amp;(i<span class="hljs-number">-1</span>)*(j<span class="hljs-number">-1</span>)&lt;=n;j++)&#123; <span class="hljs-comment">//key </span><br>			pq.<span class="hljs-built_in">push</span>(a[i]+b[j]);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		cout&lt;&lt;pq.<span class="hljs-built_in">top</span>()&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>		pq.<span class="hljs-built_in">pop</span>();<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="洛谷-P2827-蚯蚓"><a href="#洛谷-P2827-蚯蚓" class="headerlink" title="洛谷 P2827 蚯蚓"></a><a href="https://www.luogu.com.cn/problem/P2827">洛谷 P2827 蚯蚓</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><ul>
<li>有若干蚯蚓，每个蚯蚓有一个长度，每一秒切开最长的那一只蚯蚓，其他蚯蚓每秒长度+q，如此重复若干秒，要求输出<strong>每次切割的蚯蚓的长度</strong>和<strong>最终每只蚯蚓的长度（从大到小排列）</strong></li>
<li>更具体的IO和数据范围点开链接看题</li>
</ul>
<h3 id="思路-amp-amp-题解"><a href="#思路-amp-amp-题解" class="headerlink" title="思路&amp;&amp;题解"></a>思路&amp;&amp;题解</h3><ul>
<li><p>思考1：这还不简单，把蚯蚓存入一个大根对里，每次取根部元素切开然后再push回去，可是，如何处理每次蚯蚓的生长呢？难不成每次都遍历一遍然后+=q？看了一眼数据范围，必爆炸，于是放弃；</p>
</li>
<li><p>看题解后思考：使用三个queue，q1、q2、q3，q1用来存储原始的蚯蚓，q2存放每次被切蚯蚓的较长段，q3存放每次被切蚯蚓的较短段，<strong>q1需要先排好序（单调递减）</strong>，这样的话，<strong>q2和q3也就都满足单调递减了</strong>，为什么呢？</p>
<p><strong>因为先切的蚯蚓被分出来的两段一定大于后切的蚯蚓被分出来的两段（较长段大于较长段，较短段大于较短段），这是因为从先切的蚯蚓开始到后切的蚯蚓结束，流逝的时间是相同的，即增长的长度是相同的，因此只要满足q1单调递减就一定能使得q2和q3单调递减</strong>；</p>
</li>
<li><p>如何处理<strong>增长</strong>？因为每过一秒，除了被切蚯蚓之外的蚯蚓都会+=q，逆向思维，等价于被切蚯蚓-=q，但每次切的时候还是要按照真实长度（即增长过后的长度）切割，那么如何处理这一过程呢？可以定义一个<strong>数tim</strong>用来记录时间过去了多少（<strong>每次切割时tim+=q</strong>）。这样，我们存放在q1、q2、q3队列中的长度都是假想的<strong>“没有增长的长度”</strong>，每次从这三个队列中中取出最长的蚯蚓时，只需要再+tim就可以复现真实的蚯蚓长度，切完之后再把切完的两段分别-=tim+q（更好的是<strong>先执行tim+=q更新增长长度，再两段分别-tim</strong>）就可以达到<strong>放回去的时候相当于被切蚯蚓缩短了q</strong>的效果。</p>
</li>
</ul>
<h3 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">0x3f3f3f3f3f</span>;<br>ll n,m,q,t,ans2[<span class="hljs-number">9000005</span>],ans[<span class="hljs-number">9000005</span>];<br><span class="hljs-type">double</span> u,v;<br>priority_queue&lt;ll&gt; q1;<br>queue&lt;ll&gt; q2,q3;<br><br><span class="hljs-function">ll <span class="hljs-title">getmax</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//从三个队列中取出最长段，对应的队列执行pop操作</span><br>	ll max1=-inf,max2=max1,max3=max1;<br>	<span class="hljs-keyword">if</span>(!q1.<span class="hljs-built_in">empty</span>()) max1 = q1.<span class="hljs-built_in">top</span>();<br>	<span class="hljs-keyword">if</span>(!q2.<span class="hljs-built_in">empty</span>()) max2 = q2.<span class="hljs-built_in">front</span>();<br>	<span class="hljs-keyword">if</span>(!q3.<span class="hljs-built_in">empty</span>()) max3 = q3.<span class="hljs-built_in">front</span>();<br>	<span class="hljs-keyword">if</span>(max1&gt;=max2&amp;&amp;max1&gt;=max3) &#123;<br>		q1.<span class="hljs-built_in">pop</span>();<br>		<span class="hljs-keyword">return</span> max1;<br>	&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(max2&gt;=max1&amp;&amp;max2&gt;=max3)&#123;<br>		q2.<span class="hljs-built_in">pop</span>();<br>		<span class="hljs-keyword">return</span> max2;<br>	&#125;<span class="hljs-keyword">else</span>&#123;<br>		q3.<span class="hljs-built_in">pop</span>();<br>		<span class="hljs-keyword">return</span> max3;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;n&gt;&gt;m&gt;&gt;q&gt;&gt;u&gt;&gt;v&gt;&gt;t;<br>	ll x;<br>	<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		cin&gt;&gt;x;<br>		q1.<span class="hljs-built_in">push</span>(x); <span class="hljs-comment">//大根堆，满足q1单调减</span><br>	&#125;<br>	ll tim=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123; <span class="hljs-comment">// 遍历每一秒的操作</span><br>		ans[i] = <span class="hljs-built_in">getmax</span>()+tim; <span class="hljs-comment">//变为真实长度（顺便记录每次切割的长度）</span><br>		ll t1=ans[i]*u/v; <br>		ll t2=ans[i]-t1;<br>		tim+=q; <span class="hljs-comment">//更新时间</span><br>		<span class="hljs-keyword">if</span>(t1&lt;t2) <span class="hljs-built_in">swap</span>(t1,t2); <span class="hljs-comment">//较长段放入q2，另一段放入q3</span><br>		q2.<span class="hljs-built_in">push</span>(t1-tim); <span class="hljs-comment">//相当于缩短了q</span><br>		q3.<span class="hljs-built_in">push</span>(t2-tim);<br>	&#125;<br>	ll cnt=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(!q1.<span class="hljs-built_in">empty</span>()||!q2.<span class="hljs-built_in">empty</span>()||!q3.<span class="hljs-built_in">empty</span>())&#123; <span class="hljs-comment">//最终每一段蚯蚓的长度</span><br>		ans2[++cnt]=<span class="hljs-built_in">getmax</span>()+tim;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(ll i=t;i&lt;=m;i+=t) cout&lt;&lt;ans[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>	cout&lt;&lt;endl;<br>	<span class="hljs-keyword">for</span>(ll i=t;i&lt;=cnt;i+=t) cout&lt;&lt;ans2[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="洛谷-P1503-鬼子进村"><a href="#洛谷-P1503-鬼子进村" class="headerlink" title="洛谷 P1503 鬼子进村"></a><a href="https://www.luogu.com.cn/problem/P1503">洛谷 P1503 鬼子进村</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><ul>
<li>有$n$个用地道相连的房子，第$i$个与第$i-1$和$i+1$个相连，随后有$m$个消息传过来，分别是以下三者中的某一种：<ol>
<li>D x：鬼子将 x 号 房子摧毁了，地道被堵上</li>
<li>R：村民将鬼子上一个被摧毁的房子修复了</li>
<li>Q x：有一名士兵被围堵在了x号房子中</li>
</ol>
</li>
</ul>
<p>现在要求输出每一个被围堵的士兵能够到达的房子有几个。</p>
<p>Sample Input</p>
<figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">7</span> <span class="hljs-number">9</span><br><span class="hljs-attribute">D</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">D</span> <span class="hljs-number">6</span><br><span class="hljs-attribute">D</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">Q</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">Q</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">R</span><br><span class="hljs-attribute">Q</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">R</span><br><span class="hljs-attribute">Q</span> <span class="hljs-number">4</span><br></code></pre></div></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">1<br>0<br>2<br>4<br></code></pre></div></td></tr></table></figure>
<p>数据范围：$n,m\leq50000$</p>
<h3 id="思路-amp-题解-2"><a href="#思路-amp-题解-2" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><ul>
<li>思考1：一开始想到链表，可是R操作比较难搞，但这个R不就是一个栈吗？于是考虑栈，但栈无法遍历每一个元素，因为我们要求每个士兵所在的区间，于是还是考虑使用$vector$模拟栈的操作（push_back和pop_back），还能遍历每个元素，岂不美哉；</li>
<li>思考2：发现如果使用$vector$，那么复杂度会有点高，因为每次求每个士兵的区间时需要对$vector$排序（按题目输入来看，它本身是无序的），看了看数据范围，感觉还OK，因此我再开一个$vector$，在每次需要查询区间的时候把原来的$vector$赋值给新$vector$然后对新$vector$排序，再对新$vector$遍历求区间就好了，复杂度应该会降不少；</li>
<li>至于怎么找士兵能到达几个房子，这个比较简单，我是直接遍历一遍排序好的$vector$，记录士兵所在区间，然后直接<strong>区间尾 - 区间头 - 1</strong>就好了，注意一下头部和尾部的处理。</li>
</ul>
<h3 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;<span class="hljs-type">int</span>&gt; vec1,vec2;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;n&gt;&gt;m;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>		<span class="hljs-type">char</span> c;<br>		cin&gt;&gt;c;<br>		<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;D&#x27;</span>)&#123; <span class="hljs-comment">//摧毁房子</span><br>			<span class="hljs-type">int</span> x;<br>			cin&gt;&gt;x;<br>			vec1.<span class="hljs-built_in">push_back</span>(x); <span class="hljs-comment">//压入vector栈中</span><br>		&#125;<br>		<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;Q&#x27;</span>)&#123;<br>			<span class="hljs-type">int</span> x;<br>			cin&gt;&gt;x;<br>			vec2.<span class="hljs-built_in">assign</span>(vec1.<span class="hljs-built_in">begin</span>(),vec1.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">//拷贝一份</span><br>			<span class="hljs-built_in">sort</span>(vec2.<span class="hljs-built_in">begin</span>(),vec2.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">//排序</span><br>			vector&lt;<span class="hljs-type">int</span>&gt;::iterator it;<br>			<span class="hljs-type">int</span> pos=<span class="hljs-number">0</span>,end=n;<br>			<span class="hljs-type">bool</span> f=<span class="hljs-literal">true</span>;<br>			<span class="hljs-keyword">for</span>(it=vec2.<span class="hljs-built_in">begin</span>();it!=vec2.<span class="hljs-built_in">end</span>();it++)&#123; <span class="hljs-comment">//找答案</span><br>				<span class="hljs-keyword">if</span>((*it)==x)&#123;<br>					cout&lt;&lt;<span class="hljs-number">0</span>&lt;&lt;endl;<br>					f=<span class="hljs-literal">false</span>;<br>					<span class="hljs-keyword">break</span>;<br>				&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((*it)&gt;x)&#123;<br>					cout&lt;&lt;*it-pos<span class="hljs-number">-1</span>&lt;&lt;endl;<br>					f=<span class="hljs-literal">false</span>;<br>					<span class="hljs-keyword">break</span>;<br>				&#125;pos=*it;<br>			&#125;<br>			<span class="hljs-keyword">if</span>(f) cout&lt;&lt;end-pos&lt;&lt;endl;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;R&#x27;</span>)&#123;<br>			vec1.<span class="hljs-built_in">pop_back</span>();<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<hr>
<ul>
<li>emm题目还是有点挑战性的，具体收获如下<ol>
<li>要善于发现题目中隐含的条件（如：单调性 等）以<strong>优化时间复杂度</strong>；</li>
<li>善于<strong>利用$vector$模拟一些线性数据结构</strong>（如：栈，小根堆也可），毕竟$vector$可以通过<strong>下标</strong>或者<strong>$iterator$</strong>遍历每个元素；</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>数据结构</tag>
        <tag>栈和队列</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>多重集组合数dp</title>
    <url>/2020/01/21/%E5%A4%9A%E9%87%8D%E9%9B%86%E7%BB%84%E5%90%88%E6%95%B0dp/</url>
    <content><![CDATA[<h2 id="经典dp：多重集组合数"><a href="#经典dp：多重集组合数" class="headerlink" title="经典dp：多重集组合数"></a><center>经典dp：多重集组合数</center></h2><span id="more"></span>
<h2 id="多重集组合数问题"><a href="#多重集组合数问题" class="headerlink" title="多重集组合数问题"></a>多重集组合数问题</h2><ul>
<li>一个有关<strong>计数</strong>的动态规划问题，含有优化的<strong>数学推导</strong>过程，蛮有意思的，就是太巧妙了，<del>蒟蒻的</del>自己肯定想不到，记录下。</li>
</ul>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><ul>
<li><p>有$n$种物品，第$i$种物品有$a_i$个，不同种类的物品可以相互区分，但相同种类的物品无法区分。现在从这些物品中取出$m$个，有多少种取法？答案需要模M。</p>
<p>Sample Input</p>
<figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">6<br></code></pre></div></td></tr></table></figure>
<p>样例解释：</p>
<p>有n=3种物品, 每种a={1,2,3}个, 取出m=3个, 取法result=6(0+0+3, 0+1+2, 0+2+1, 1+0+2, 1+1+1, 1+2+0).</p>
</li>
</ul>
<h3 id="思路-amp-解法"><a href="#思路-amp-解法" class="headerlink" title="思路&amp;解法"></a>思路&amp;解法</h3><p>很容易想到状态$dp[i][j]$表示<strong>前$i$种物品取$j$个的方法总数</strong>，状态转移方程为：</p>
<script type="math/tex; mode=display">
dp\left[i\right]\left[j\right]=\sum ^{\min \left( j,a\left[ i\right] \right) }_{k=0}dp\left[ i-1\right] \left[ j-k\right]</script><p>意思是：<strong>先从前$i-1$种物品中取$j-k$个，再从第$i$种物品种取$k$个</strong>，因此方法总数就是先从前$i-1$种物品中取$j-k$个的方法总数，这里需要注意<strong>$k$的上界是$j$和$a[i]$两者中的较小者</strong>（既要保证$j-k&gt;0$，也要保证合法）。</p>
<p><strong>时间复杂度为：$O(nm^2)$</strong>，可以开始搞了。</p>
<h3 id="AC代码（-O-nm-2-）"><a href="#AC代码（-O-nm-2-）" class="headerlink" title="AC代码（$O(nm^2)$）"></a>AC代码（$O(nm^2)$）</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m,a[<span class="hljs-number">10005</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">10005</span>][<span class="hljs-number">10005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;n&gt;&gt;m;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		cin&gt;&gt;a[i];<br>	&#125;<br>	dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		dp[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>; <span class="hljs-comment">//初始状态置1</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>			<span class="hljs-type">int</span> minx = <span class="hljs-built_in">min</span>(j,a[i]);<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=minx;k++) dp[i][j]+=dp[i<span class="hljs-number">-1</span>][j-k];<br>		&#125;<br>	&#125;<br>	cout&lt;&lt;dp[n][m]&lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>发现这个时间复杂度不是很给力，看看能不能再做点优化？</p>
<p>考虑状态转移方程：</p>
<script type="math/tex; mode=display">
dp\left[i\right]\left[j\right]=\sum ^{\min \left( j,a\left[ i\right] \right) }_{k=0}dp\left[ i-1\right] \left[ j-k\right]</script><p>将其右边展开，分类讨论：</p>
<ol>
<li>$j\leq a\left[i\right]$时：<script type="math/tex; mode=display">
dp[i][j]=dp[i-1][j]+\left(dp[i-1][j-1]+...+dp[i-1][0]\right)</script>显然，括号内就是<script type="math/tex; mode=display">
\sum^{\min \left(j-1,a\left[i\right]\right)}_{k=0}dp[i][j-1-k]=dp[i][j-1]</script>合并两式，得到：<script type="math/tex; mode=display">
dp[i][j]=dp[i-1][j]+dp[i][j-1]</script></li>
</ol>
<ol>
<li>$j&gt;a\left[i\right]$时：<script type="math/tex; mode=display">
dp[i][j]=dp[i-1][j]+dp[i-1][j-1]+...+dp[i-1][j-a[i]+1]+dp[i-1][j-a[i]]</script></li>
</ol>
<p>   于是，仿照1中的格式，写出一个类似的式子如下，方便合并：</p>
<script type="math/tex; mode=display">
   dp[i][j-1]=\sum^{\min \left(j-1,a\left[i\right]\right)}_{k=0}dp[i][j-1-k]</script><p>   我们把它展开：</p>
<script type="math/tex; mode=display">
   \sum^{\min \left(j-1,a\left[i\right]\right)}_{k=0}dp[i][j-1-k]=dp[i][j-1]+dp[i][j-2]+...+dp[i-1][j-a[i]]+dp[i][j-a[i]-1]</script><p>   发现等号右边多了一个$dp[i-1][j-a[i]-1]$，所以在合并的时候，需要在等号右边减掉，得出<strong>最终的状态转移方程</strong>如下：</p>
<script type="math/tex; mode=display">
   dp[i][j]=\begin{cases}dp[i-1][j]+dp[i][j-1]\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \   (j\leq a[i])\\dp[i-1][j]+dp[i][j-1]-dp[i-1][j-a[i]-1]\ \ \  (else)\end{cases}</script><p>   <strong>可以用$O(nm)$的时间复杂度搞它。</strong></p>
<h3 id="AC代码（-O-nm-）"><a href="#AC代码（-O-nm-）" class="headerlink" title="AC代码（$O(nm)$）"></a>AC代码（$O(nm)$）</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m,a[<span class="hljs-number">10005</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">10005</span>][<span class="hljs-number">10005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;n&gt;&gt;m;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		cin&gt;&gt;a[i];<br>	&#125;<br>	dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		dp[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>			<span class="hljs-keyword">if</span>(j&lt;=a[i]) dp[i][j]=dp[i<span class="hljs-number">-1</span>][j]+dp[i][j<span class="hljs-number">-1</span>];<br>			<span class="hljs-keyword">else</span> dp[i][j]=dp[i<span class="hljs-number">-1</span>][j]+dp[i][j<span class="hljs-number">-1</span>]-dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>-a[i]];<br>		&#125;<br>	&#125;<br>	cout&lt;&lt;dp[n][m]&lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<hr>
<ul>
<li>此题为我们提供了一条优化$dp$方程的思路，即通过对方程求和式的展开进一步探索其与之前状态的联系，从而优化了时间复杂度，值得借鉴。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>动态规划</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>字典树与AC自动机</title>
    <url>/2020/06/18/%E5%AD%97%E5%85%B8%E6%A0%91%E4%B8%8EAC%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<p>最近正直夏令营季，抽时间学了一下字符串的重要算法——“字典树Trie”和“AC自动机”，在此处记录一下，以便后续温故和复习</p>
<span id="more"></span>
<h2 id="字典树-Trie"><a href="#字典树-Trie" class="headerlink" title="字典树 Trie"></a>字典树 Trie</h2><h3 id="普通字典树"><a href="#普通字典树" class="headerlink" title="普通字典树"></a>普通字典树</h3><p><strong>字典树</strong>，也叫做<strong>前缀树、Trie</strong>，是一种用于存储大量字符串信息的树形数据结构，通常情况下形如下图</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/u=3442947730,1854572131&amp;fm=26&amp;gp=0.jpg" alt="u=3442947730,1854572131&amp;fm=26&amp;gp=0"></p>
<p>这张形象的图告诉我们，<strong>字典树都具有一个“空”的根节点</strong>，从根节点出发的一条简单路径上的字符按顺序组成的字符串就是存储的字符串，如上图中的这棵字典树，就存储了 “美利坚”、“美丽”、“金币”、“金子”、“帝王” 这五个字符串，然而有人会问：那 “美利” 这个字符串在不在这棵字典树内呢？答案是：既可以在，也可以不在。显然应该想到，确定一个字符串是否有效的方式，是<strong>在这个字符串的最后一个字符处打上标记</strong>，表示这是当前字符串的结尾，如下图中绿色节点代表了一个字符串的结尾，这样一来，就可以完美地实现字符串的插入存储操作了</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/u=2725490024,3402601292&amp;fm=26&amp;gp=0.jpg" alt="u=2725490024,3402601292&amp;fm=26&amp;gp=0"></p>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>对于具体的插入操作，可以按照如下方式实现</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string ss)</span></span>&#123;<br>	<span class="hljs-type">int</span> len=ss.<span class="hljs-built_in">size</span>();<span class="hljs-comment">// 获取字符串长度</span><br>    <span class="hljs-type">int</span> rt=<span class="hljs-number">0</span>;<span class="hljs-comment">// 从根节点0开始</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-type">int</span> id=ss[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-comment">// 获取儿子节点编号</span><br>        <span class="hljs-keyword">if</span>(!trie[rt][id]) trie[rt][id]=++tot;<span class="hljs-comment">// 如果当前字符没有分配节点，分配给他新节点</span><br>        rt=trie[rt][id];<span class="hljs-comment">// 将根节点切换成当前节点的儿子节点</span><br>    &#125;<br>    flag[rt]=<span class="hljs-number">1</span>;<span class="hljs-comment">// 标记这个节点为当前字符串结尾</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="询问操作"><a href="#询问操作" class="headerlink" title="询问操作"></a>询问操作</h4><p>最简单的情况下，如果需要询问一个字符串是否在之前的字符串中出现过，则只需要按照类似插入操作相同的方法处理即可，时间复杂度为$O(log(L)),L为字符串长度$（你会发现还不如哈希）</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">query</span><span class="hljs-params">(string ss)</span></span>&#123;<br>    <span class="hljs-type">int</span> len=ss.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> rt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-type">int</span> id=ss[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!trie[rt][id]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">// 如果当前节点不存在，字符串肯定不存在，直接返回false</span><br>        rt=trie[rt][id];<br>    &#125;<br>    <span class="hljs-keyword">if</span>(flag[rt]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">// 出现过，返回true</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">// 否则返回false</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>当然这是最简单的应用（不如hash_map快呢。。）但除此之外，还可以衍生出很多操作，具体可以通过刷题得知，有的操作可能就是哈希表无法胜任的了（当然很少）</p>
<h4 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h4><p><a href="https://www.luogu.com.cn/problem/P2580">洛谷 P2580 于是他错误的点名开始了</a>（裸Trie，用哈希表应该也行）</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">2000005</span>;<br><span class="hljs-type">int</span> n,m,tot,trie[maxn][<span class="hljs-number">30</span>],flag[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string ss)</span></span>&#123;<br>	<span class="hljs-type">int</span> len=ss.<span class="hljs-built_in">size</span>();<br>	<span class="hljs-type">int</span> rt=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>		<span class="hljs-type">int</span> id=ss[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>		<span class="hljs-keyword">if</span>(!trie[rt][id]) trie[rt][id]=++tot;<br>		rt=trie[rt][id];<br>	&#125;<br>	flag[rt]=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(string ss)</span></span>&#123;<br>	<span class="hljs-type">int</span> len=ss.<span class="hljs-built_in">size</span>();<br>	<span class="hljs-type">int</span> rt=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>		<span class="hljs-type">int</span> id=ss[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>		<span class="hljs-keyword">if</span>(!trie[rt][id]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		rt=trie[rt][id];<br>	&#125;<br>	<span class="hljs-keyword">if</span>(flag[rt]==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> flag[rt]++,<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>	cin&gt;&gt;n;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		string s;<br>		cin&gt;&gt;s;<br>		<span class="hljs-built_in">insert</span>(s);<br>	&#125;<br>	cin&gt;&gt;m;<br>	<span class="hljs-keyword">while</span>(m--)&#123;<br>		string s;<br>		cin&gt;&gt;s;<br>		<span class="hljs-type">int</span> ans=<span class="hljs-built_in">query</span>(s);<br>		<span class="hljs-keyword">if</span>(ans==<span class="hljs-number">0</span>) cout&lt;&lt;<span class="hljs-string">&quot;WRONG&quot;</span>&lt;&lt;endl;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ans==<span class="hljs-number">1</span>) cout&lt;&lt;<span class="hljs-string">&quot;OK&quot;</span>&lt;&lt;endl;<br>		<span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;REPEAT&quot;</span>&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-comment">//https://www.luogu.com.cn/problem/P2580</span><br></code></pre></div></td></tr></table></figure>

</details>

<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1251">HDU1251 统计难题</a>（Trie裸体，统计以某字符串为前缀的字符串数量）</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">2000005</span>;<br><span class="hljs-type">char</span> s[maxn];<br><span class="hljs-type">int</span> trie[maxn][<span class="hljs-number">30</span>];<br><span class="hljs-type">int</span> ci[maxn],tot;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">char</span> *ss)</span></span>&#123;<br>	<span class="hljs-type">int</span> len=<span class="hljs-built_in">strlen</span>(ss);<br>	<span class="hljs-type">int</span> rt=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>		<span class="hljs-type">int</span> id=ss[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>		<span class="hljs-keyword">if</span>(!trie[rt][id])<br>			trie[rt][id]=++tot;<br>		ci[trie[rt][id]]++;<br>		rt=trie[rt][id];<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">char</span> *ss)</span></span>&#123;<br>	<span class="hljs-type">int</span> len=<span class="hljs-built_in">strlen</span>(ss);<br>	<span class="hljs-type">int</span> rt=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>		<span class="hljs-type">int</span> id=ss[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>		<span class="hljs-keyword">if</span>(!trie[rt][id]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		rt=trie[rt][id];<br>	&#125;<br>	<span class="hljs-keyword">return</span> ci[rt];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;test.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);<br>	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">gets</span>(s))&#123;<br>		<span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;\0&#x27;</span>) <span class="hljs-keyword">break</span>;<br>		<span class="hljs-built_in">insert</span>(s);<br>	&#125;<br>	<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s))&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">query</span>(s));<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-comment">//http://acm.hdu.edu.cn/showproblem.php?pid=1251</span><br></code></pre></div></td></tr></table></figure>

</details>

<p><a href="https://vjudge.net/problem/LightOJ-1224">LOJ1224 DNA Prefix</a>（找到字符串集合中 最长公共前缀长度 乘以 字符串集合数量 最大的 子集）</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">2000005</span>;<br><span class="hljs-type">int</span> _,n;<br><span class="hljs-type">int</span> trie[maxn][<span class="hljs-number">5</span>],ci[maxn],tot,ans;<br><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> _insert(string ss)&#123;<br>	<span class="hljs-type">int</span> len=ss.<span class="hljs-built_in">size</span>();<br>	<span class="hljs-type">int</span> rt=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>		<span class="hljs-type">int</span> id=ss[i]-<span class="hljs-string">&#x27;A&#x27;</span>;<br>		<span class="hljs-keyword">if</span>(!trie[rt][id])<br>			trie[rt][id]=++tot;<br>		ci[trie[rt][id]]++;<br>		ans=<span class="hljs-built_in">max</span>(ans,ci[trie[rt][id]]*(i+<span class="hljs-number">1</span>));<br>		rt=trie[rt][id];<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>	ans=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=tot;i++)&#123;<br>		ci[i]=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">5</span>;j++)&#123;<br>			trie[i][j]=<span class="hljs-number">0</span>;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>	cin&gt;&gt;_;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> o=<span class="hljs-number">1</span>;o&lt;=_;o++)&#123;<br>		cin&gt;&gt;n;<br>		string tp;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			cin&gt;&gt;tp;<br>			_insert(tp);<br>		&#125;<br>		cout&lt;&lt;<span class="hljs-string">&quot;Case &quot;</span>&lt;&lt;o&lt;&lt;<span class="hljs-string">&quot;: &quot;</span>&lt;&lt;ans&lt;&lt;endl;<br>		<span class="hljs-built_in">init</span>();<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-comment">//http://lightoj.com/volume_showproblem.php?problem=1224</span><br></code></pre></div></td></tr></table></figure>

</details>

<p><a href="https://www.luogu.com.cn/problem/P3879">洛谷 P3879 [TJOI2010]阅读理解</a>（统计某些生词在哪几篇短文中出现过）</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m,tot[<span class="hljs-number">1005</span>],trie[<span class="hljs-number">1005</span>][<span class="hljs-number">5005</span>][<span class="hljs-number">30</span>],flag[<span class="hljs-number">1005</span>][<span class="hljs-number">5005</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string ss,<span class="hljs-type">int</span> num)</span></span>&#123;<br>	<span class="hljs-type">int</span> len=ss.<span class="hljs-built_in">size</span>();<br>	<span class="hljs-type">int</span> rt=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>		<span class="hljs-type">int</span> id=ss[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>		<span class="hljs-keyword">if</span>(!trie[num][rt][id]) trie[num][rt][id]=++tot[num];<br>		rt=trie[num][rt][id];<br>	&#125;<br>	flag[num][rt]=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">query</span><span class="hljs-params">(string ss,<span class="hljs-type">int</span> num)</span></span>&#123;<br>	<span class="hljs-type">int</span> len=ss.<span class="hljs-built_in">size</span>();<br>	<span class="hljs-type">int</span> rt=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>		<span class="hljs-type">int</span> id=ss[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>		<span class="hljs-keyword">if</span>(!trie[num][rt][id]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		rt=trie[num][rt][id];<br>	&#125;<br>	<span class="hljs-keyword">if</span>(flag[num][rt]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>	cin&gt;&gt;n;<br>	string tp;<br>	<span class="hljs-type">int</span> x;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		cin&gt;&gt;x;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=x;j++)&#123;<br>			cin&gt;&gt;tp;<br>			<span class="hljs-built_in">insert</span>(tp,i);<br>		&#125;<br>	&#125;<br>	cin&gt;&gt;m;<br>	<span class="hljs-keyword">while</span>(m--)&#123;<br>		cin&gt;&gt;tp;<br>		vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-keyword">if</span>(<span class="hljs-built_in">query</span>(tp,i))&#123;<br>				vec.<span class="hljs-built_in">push_back</span>(i);<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:vec)&#123;<br>			cout&lt;&lt;t&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>		&#125;<br>		cout&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<p><a href="http://poj.org/problem?id=2001">POJ2001 Shortest Prefix</a>（为每个字符串找到能唯一表示其的最短前缀，可暴力）</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">2000005</span>;<br>string s[<span class="hljs-number">2005</span>],tp;<br><span class="hljs-type">int</span> trie[maxn][<span class="hljs-number">30</span>],tot,ci[maxn],num;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string ss)</span></span>&#123;<br>	<span class="hljs-type">int</span> len=ss.<span class="hljs-built_in">size</span>();<br>	<span class="hljs-type">int</span> rt=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>		<span class="hljs-type">int</span> id=ss[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>		<span class="hljs-keyword">if</span>(!trie[rt][id])<br>			trie[rt][id]=++tot;<br>		ci[trie[rt][id]]++;<br>		rt=trie[rt][id];<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> string <span class="hljs-title">query</span><span class="hljs-params">(string ss)</span></span>&#123;<br>	<span class="hljs-type">int</span> len=ss.<span class="hljs-built_in">size</span>();<br>	<span class="hljs-type">int</span> rt=<span class="hljs-number">0</span>;<br>	string ans=<span class="hljs-string">&quot;&quot;</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>		<span class="hljs-type">int</span> id=ss[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>		ans+=ss[i];<br>		<span class="hljs-keyword">if</span>(ci[trie[rt][id]]==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ans; <br>		rt=trie[rt][id];<br>	&#125;<br>	<span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-comment">// freopen(&quot;test.in&quot;,&quot;r&quot;,stdin);</span><br>	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>	<span class="hljs-keyword">while</span>(cin&gt;&gt;tp)&#123;<br>		s[++num]=tp;<br>		<span class="hljs-built_in">insert</span>(tp);<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=num;i++)&#123;<br>		cout&lt;&lt;s[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-built_in">query</span>(s[i])&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-comment">//http://poj.org/problem?id=2001</span><br></code></pre></div></td></tr></table></figure>

</details>

<p><a href="http://poj.org/problem?id=2513">POJ 2513 Colored Sticks</a>（好题，Trie+欧拉路经转化+并査集）</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">2000005</span>;<br><span class="hljs-type">char</span> s1[<span class="hljs-number">15</span>],s2[<span class="hljs-number">15</span>];<br><span class="hljs-type">int</span> trie[maxn][<span class="hljs-number">30</span>],tot,vis[maxn],deg[maxn];<br><span class="hljs-type">int</span> fa[maxn];<br><span class="hljs-type">int</span> cnt;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>	<span class="hljs-keyword">return</span> x==fa[x]?x:fa[x]=<span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>	x=<span class="hljs-built_in">find</span>(x);<br>	y=<span class="hljs-built_in">find</span>(y);<br>	<span class="hljs-keyword">if</span>(x!=y)&#123;<br>		fa[x]=y;<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> _insert(<span class="hljs-type">char</span> *ss)&#123;<br>	<span class="hljs-type">int</span> len=<span class="hljs-built_in">strlen</span>(ss);<br>	<span class="hljs-type">int</span> rt=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>		<span class="hljs-type">int</span> id=ss[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>		<span class="hljs-keyword">if</span>(!trie[rt][id]) trie[rt][id]=++tot;<br>		rt=trie[rt][id];<br>	&#125;<br>	<span class="hljs-keyword">if</span>(!vis[rt]) vis[rt]=++cnt;<br>	<span class="hljs-keyword">if</span>(!fa[cnt]) fa[cnt]=cnt;<br>	<span class="hljs-keyword">return</span> vis[rt];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-comment">// freopen(&quot;test.in&quot;,&quot;r&quot;,stdin);</span><br>	<span class="hljs-comment">// for(int i=0;i&lt;=maxn;i++) fa[i]=i;</span><br>	<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s %s&quot;</span>,s1,s2))&#123;<br>		<span class="hljs-type">int</span> num1=_insert(s1);<br>		deg[num1]++;<br>		<span class="hljs-type">int</span> num2=_insert(s2);<br>		deg[num2]++;<br>		<span class="hljs-comment">// printf(&quot;num1=%d num2=%d\n&quot;,num1,num2);</span><br>		<span class="hljs-built_in">unite</span>(num1,num2);<br>	&#125;<br>	<span class="hljs-type">int</span> ff=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;i++)&#123;<br>		<span class="hljs-comment">// printf(&quot;fa[%d]=%d\n&quot;,i,find(i));</span><br>		<span class="hljs-keyword">if</span>(deg[i]&amp;<span class="hljs-number">1</span>)&#123;<br>			ff++;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(<span class="hljs-number">1</span>)!=<span class="hljs-built_in">find</span>(i))&#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Impossible\n&quot;</span>),<span class="hljs-number">0</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">if</span>(ff==<span class="hljs-number">0</span>||ff==<span class="hljs-number">2</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Possible\n&quot;</span>);<br>	<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Impossible\n&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-comment">//http://poj.org/problem?id=2513</span><br></code></pre></div></td></tr></table></figure>

</details>

<p><a href="http://poj.org/problem?id=3630">POJ3630 Phone List</a>（判断字符串集合是否有字符串是其他字符串前缀）</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">2e6</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> _,n,trie[maxn][<span class="hljs-number">10</span>],tot,ci[maxn],flag[maxn];<br>string s[<span class="hljs-number">10005</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string ss)</span></span>&#123;<br>	<span class="hljs-type">int</span> len=ss.<span class="hljs-built_in">size</span>();<br>	<span class="hljs-type">int</span> rt=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>		<span class="hljs-type">int</span> id=ss[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>		<span class="hljs-keyword">if</span>(!trie[rt][id]) trie[rt][id]=++tot;<br>		ci[trie[rt][id]]++;<br>		rt=trie[rt][id];<br>	&#125;<br>	flag[rt]=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">query</span><span class="hljs-params">(string ss)</span></span>&#123;<br>	<span class="hljs-type">int</span> len=ss.<span class="hljs-built_in">size</span>();<br>	<span class="hljs-type">int</span> rt=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len<span class="hljs-number">-1</span>;i++)&#123;<br>		<span class="hljs-type">int</span> id=ss[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>		<span class="hljs-keyword">if</span>(flag[trie[rt][id]]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>		rt=trie[rt][id];<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=tot;i++)&#123;<br>		flag[i]=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">10</span>;j++)&#123;<br>			trie[i][j]=<span class="hljs-number">0</span>;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>	cin&gt;&gt;_;<br>	<span class="hljs-keyword">while</span>(_--)&#123;<br>		<span class="hljs-built_in">init</span>();<br>		cin&gt;&gt;n;<br>		<span class="hljs-type">bool</span> f=<span class="hljs-literal">true</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>			cin&gt;&gt;s[i];<br>			<span class="hljs-built_in">insert</span>(s[i]);<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>			<span class="hljs-keyword">if</span>(<span class="hljs-built_in">query</span>(s[i]))&#123;<br>				f=<span class="hljs-literal">false</span>;<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(f) cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl;<br>		<span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-comment">//http://poj.org/problem?id=3630</span><br></code></pre></div></td></tr></table></figure>

</details>

<p><a href="https://www.luogu.com.cn/problem/U83324">洛谷U83324 The Power of Face Rolling Keyboard</a>（动态插入和询问字符串是否存在，卡map）</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">2000005</span>;<br><span class="hljs-type">int</span> m,tot,trie[maxn][<span class="hljs-number">30</span>],flag[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string ss)</span></span>&#123;<br>	<span class="hljs-type">int</span> len=ss.<span class="hljs-built_in">size</span>();<br>	<span class="hljs-type">int</span> rt=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>		<span class="hljs-type">int</span> id=ss[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>		<span class="hljs-keyword">if</span>(!trie[rt][id]) trie[rt][id]=++tot;<br>		rt=trie[rt][id];<br>	&#125;<br>	flag[rt]=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">query</span><span class="hljs-params">(string ss)</span></span>&#123;<br>	<span class="hljs-type">int</span> len=ss.<span class="hljs-built_in">size</span>();<br>	<span class="hljs-type">int</span> rt=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>		<span class="hljs-type">int</span> id=ss[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>		<span class="hljs-keyword">if</span>(!trie[rt][id]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		rt=trie[rt][id];<br>	&#125;<br>	<span class="hljs-keyword">if</span>(flag[rt]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>	cin&gt;&gt;m;<br>	<span class="hljs-keyword">while</span>(m--)&#123;<br>		<span class="hljs-type">int</span> x;<br>		string tp;<br>		cin&gt;&gt;x&gt;&gt;tp;<br>		<span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>) <span class="hljs-built_in">insert</span>(tp);<br>		<span class="hljs-keyword">else</span> cout&lt;&lt;(<span class="hljs-built_in">query</span>(tp)?<span class="hljs-string">&quot;Yes&quot;</span>:<span class="hljs-string">&quot;No&quot;</span>)&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-comment">//https://www.luogu.com.cn/problem/U83324</span><br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="01字典树"><a href="#01字典树" class="headerlink" title="01字典树"></a>01字典树</h3><p>与常规处理字符串的字典树不同，01字典树用来巧妙地处理<strong>二进制的位运算</strong>操作，最常见的是<strong>异或</strong>操作的处理，01字典树的每个节点（或者说边）代表了0或者1，剩余的模板和普通字典树并无差别</p>
<p>典型例题：<a href="https://www.acwing.com/problem/content/description/145/">最大异或对</a></p>
<p>题意：从N个整数中找出两个数做异或，求得出的最大异或值</p>
<p>思路：构建出01字典树，遍历每个数，对于当前数而言，从最高位开始考虑，如果当前数最高位为0，则找字典树中1的点，否则找0（因为0 xor 1 = 1是最优的），如果当前位需要找0时字典树中没有1这个节点存在，则只能找0了，这样贪心地找下去，最后的答案就是最优解</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n,a[maxn],tot,trie[maxn&lt;&lt;<span class="hljs-number">5</span>][<span class="hljs-number">2</span>];<br><span class="hljs-type">bool</span> flag[maxn&lt;&lt;<span class="hljs-number">5</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>	<span class="hljs-type">int</span> rt=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">31</span>;i&gt;=<span class="hljs-number">0</span>;--i)&#123;<br>		<span class="hljs-type">int</span> id=(x&gt;&gt;i)&amp;<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">if</span>(!trie[rt][id]) trie[rt][id]=++tot;<br>		rt=trie[rt][id];<br>	&#125;<br>	flag[rt]=<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>	<span class="hljs-type">int</span> rt=<span class="hljs-number">0</span>,res=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">31</span>;i&gt;=<span class="hljs-number">0</span>;--i)&#123;<br>		<span class="hljs-type">int</span> id=(x&gt;&gt;i)&amp;<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">if</span>(trie[rt][!id]) rt=trie[rt][!id],res|=(<span class="hljs-number">1</span>&lt;&lt;i);<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(trie[rt][id]) rt=trie[rt][id];<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">read</span>(n);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">read</span>(a[i]),<span class="hljs-built_in">insert</span>(a[i]);<br>	<span class="hljs-type">int</span> ans=-inf;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) ans=<span class="hljs-built_in">max</span>(ans,<span class="hljs-built_in">query</span>(a[i]));<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<p>练习题：<a href="https://www.luogu.com.cn/problem/P4551">洛谷P4551 最长异或路径</a></p>
<p>题意：给定一棵带边权的树，寻找两个节点使得这两个节点的简单路径异或和最大，求出最大异或值</p>
<p>思路：首先，需要想到$a,b$节点的异或路径为 <strong>根节点到a的异或和 异或上 根尖点到b的异或和</strong>，想到了这一点这题就转化成了裸的上一题，直接跑01字典树就行了</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">vector&lt;PII&gt; e[maxn];<br><span class="hljs-type">int</span> n,trie[maxn*<span class="hljs-number">50</span>][<span class="hljs-number">2</span>],tot;<br>ll wt[maxn],ans;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fath)</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-type">int</span>)e[u].<span class="hljs-built_in">size</span>();++i)&#123;<br>		<span class="hljs-type">int</span> v=e[u][i].first,w=e[u][i].second;<br>		<span class="hljs-keyword">if</span>(v!=fath)&#123;<br>			wt[v]=wt[u]^(ll)w;<br>			<span class="hljs-built_in">dfs</span>(v,u);<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(ll x)</span></span>&#123;<br>	<span class="hljs-type">int</span> rt=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">50</span>;i&gt;=<span class="hljs-number">0</span>;--i)&#123;<br>		<span class="hljs-type">int</span> id=(x&gt;&gt;i)&amp;<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">if</span>(!trie[rt][id]) trie[rt][id]=++tot;<br>		rt=trie[rt][id];<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">query</span><span class="hljs-params">(ll x)</span></span>&#123;<br>	<span class="hljs-type">int</span> rt=<span class="hljs-number">0</span>;<br>	ll res=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">50</span>;i&gt;=<span class="hljs-number">0</span>;--i)&#123;<br>		<span class="hljs-type">int</span> id=(x&gt;&gt;i)&amp;<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">if</span>(trie[rt][!id]) rt=trie[rt][!id],res|=(<span class="hljs-number">1</span>&lt;&lt;i);<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(trie[rt][id]) rt=trie[rt][id];<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">read</span>(n);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>)&#123;<br>		<span class="hljs-type">int</span> u,v,w;<br>		<span class="hljs-built_in">read</span>(u),<span class="hljs-built_in">read</span>(v),<span class="hljs-built_in">read</span>(w);<br>		e[u].<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">mp</span>(v,w));<br>		e[v].<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">mp</span>(u,w));<br>	&#125;<br>	<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">insert</span>(wt[i]);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) ans=<span class="hljs-built_in">max</span>(ans,<span class="hljs-built_in">query</span>(wt[i]));<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>字典树</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>差分约束算法</title>
    <url>/2020/03/20/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<ul>
<li>参考博客<a href="https://www.cnblogs.com/wjhstudy/p/9757046.html">差分约束算法总结</a></li>
</ul>
<h2 id="差分约束系统"><a href="#差分约束系统" class="headerlink" title="差分约束系统"></a>差分约束系统</h2><p>如果一个系统由$n$个变量和$m$个约束条件组成，形成$m$个形如$a_i-a_j\leq k$的不等式（$i,j\in [1,n],k为常数$），则称之为<strong>差分约束系统</strong></p>
<h3 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h3><p>给定$n$个变量和$m$个不等式，不等式形式为$x[i]-x[j]\leq a[k](0\leq i,j \leq n,0\eq k\leq m,a[k]已知)$，求某个$x[i]-x[j]$的最大值</p>
<p>例如当$n=4,m=5$，给出如下不等式组：</p>
<script type="math/tex; mode=display">
x_1-x_0\leq1（1）\\
x_2-x_0\leq2（2）\\
x_3-x_0\leq4（3）\\
x_2-x_1\leq3（4）\\
x_3-x_2\leq1（5）\\
求max(x_3-x_0)</script><p>一般的解法是：把这些不等式拼拼凑凑最后得出我们要的式子，然后取一个最小值就行了，比如上例中：</p>
<script type="math/tex; mode=display">
(3)\Rightarrow x_3-x_0\leq4\\
(1)+(4)+(5)\Rightarrow x_3-x_0\leq5\\
(2)+(5)\Rightarrow x_3-x_0\leq 3\\
\Rightarrow max(x_3-x_0)=3</script><p>然而，谁能想到求解这个系统的过程却和我们学过的<strong>最短路算法</strong>有着密切的联系？！</p>
<h3 id="与最短路的联系"><a href="#与最短路的联系" class="headerlink" title="与最短路的联系"></a>与最短路的联系</h3><p>我们对$x[i]-x[j]\leq a[k]$这样一个式子进行移项，得到$x[i]\leq x[j]+a[k]$，令$a[k]=w(j,i),dis[i]=x[i]=x[v],dis[j]=x[j]=x[u]$，原式变为$dis[u]+w(u,v)\geq dis[v]$，这TM不就是求最短路里的<strong>松弛操作</strong>嘛！</p>
<p>但好像符号反了，实际上并不矛盾，对于$x[i]-x[j]\leq a[k]$这样的不等式，我们考虑建图如下：从$j$往$i$连边，边权为$a[k]$，求$x[n-1]-x[0]$的最大值就是求$0到n-1$的最短路，两者刚好吻合，至此，<strong>差分约束问题被转化为了最短路问题</strong></p>
<h3 id="特殊情况的讨论"><a href="#特殊情况的讨论" class="headerlink" title="特殊情况的讨论"></a>特殊情况的讨论</h3><h4 id="1-存在负环"><a href="#1-存在负环" class="headerlink" title="1. 存在负环"></a>1. 存在负环</h4><p>负环就是最短路可以无限小，所以就不存在最短路，那么上式就表示为$x[n-1]-x[0]\leq T$中的$T$可以无限小，即不存在这样的最大值</p>
<h4 id="2-终点不可达"><a href="#2-终点不可达" class="headerlink" title="2. 终点不可达"></a>2. 终点不可达</h4><p>如果出现了$dis[n-1]=inf$的情况，说明终点不可达到，此时对应的不等式意义就是$x[n-1]和x[0]$之间没有约束关系，任意取值都行，即取值有无限多种</p>
<h4 id="3-不等式组转化"><a href="#3-不等式组转化" class="headerlink" title="3. 不等式组转化"></a>3. 不等式组转化</h4><p>对于不等号不相同的情况，可以考虑转化：</p>
<script type="math/tex; mode=display">
\begin{aligned}
x[n-1]-x[0]\geq T&\Rightarrow x[0]-x[n-1]\leq -T\\
x[n-1]-x[0]<T&\Rightarrow x[n-1]-x[0]\leq T-1\\
x[n-1]-x[0]=T&\Rightarrow x[n-1]-x[0]\leq T\&\&x[n-1]-x[0]\geq T
\end{aligned}</script><h4 id="4-其他问法-amp-应用"><a href="#4-其他问法-amp-应用" class="headerlink" title="4. 其他问法&amp;应用"></a>4. 其他问法&amp;应用</h4><p>如果是问$x[n-1]-x[0]$的<strong>最小值</strong>呢？那么只需要把不等号全部改为$\geq$，然后泡一下从$0到n-1$的最长路就行啦</p>
<p>另外会有一些类似于求$max(\frac{x[n-1]}{x[0]})$，此时需要做一些数学变换（比如取对数）就可以将其转换为差分约束系统开始搞了</p>
<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p>通常这种题的问法都比较绕口。。（导致读题跟阅读理解一样）</p>
<h4 id="POJ-3159-Candies"><a href="#POJ-3159-Candies" class="headerlink" title="POJ 3159 Candies"></a><a href="https://vjudge.net/problem/POJ-3159">POJ 3159 Candies</a></h4><p>题意：</p>
<p>给出若干组 同学B永远不会比同学A多拥有的糖果数量（即最大值），n号同学和1号同学拥有糖果数的最大差异（保证差异有限）</p>
<p>题解：</p>
<p>把题目翻译成数学语言就是给了一堆$x_B-x_A\leq W$的式子，求$max(x_n-x_1)$，差分约束走起，由于题目给了一定存在，因此不需要再判是否存在</p>
<p>注：此题会卡时间，请用堆优化Dijkstra</p>
<p>AC代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">1e8</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> cnt,head[<span class="hljs-number">30005</span>],dis[<span class="hljs-number">30005</span>];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> u,v,w,next;<br>&#125;e[<span class="hljs-number">150005</span>];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>	<span class="hljs-type">int</span> u,dis;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> node &amp;rhs)<span class="hljs-type">const</span>&#123;<br>		<span class="hljs-keyword">return</span> dis&gt;rhs.dis;<br>	&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w)</span></span>&#123;<br>	e[++cnt]=Edge&#123;u,v,w,head[u]&#125;;<br>	head[u]=cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) dis[i]=inf;<br>	priority_queue&lt;node&gt; q;<br>	q.<span class="hljs-built_in">push</span>(node&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;);<br>	dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>		node q1=q.<span class="hljs-built_in">top</span>();q.<span class="hljs-built_in">pop</span>();<br>		<span class="hljs-type">int</span> u=q1.u;<br>		<span class="hljs-keyword">if</span>(q1.dis&gt;dis[u]) <span class="hljs-keyword">continue</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];i;i=e[i].next)&#123;<br>			<span class="hljs-type">int</span> v=e[i].v,w=e[i].w;<br>			<span class="hljs-keyword">if</span>(dis[v]&gt;dis[u]+w)&#123;<br>				dis[v]=dis[u]+w;<br>				q.<span class="hljs-built_in">push</span>(node&#123;v,dis[v]&#125;);<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>	<span class="hljs-type">int</span> x,y,z;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);<br>		<span class="hljs-built_in">addedge</span>(x,y,z);<br>	&#125;<br>	<span class="hljs-built_in">spfa</span>();<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,dis[n]);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="POJ-3169-Layout"><a href="#POJ-3169-Layout" class="headerlink" title="POJ 3169 Layout"></a><a href="https://vjudge.net/problem/POJ-3169">POJ 3169 Layout</a></h4><p>题意：</p>
<p>给出若干组两头牛之间的最大距离和最小距离，求1号牛和n号牛的最大可能距离（如果不存在输出-1，如果可以随便取值输出-2）</p>
<p>题解：</p>
<p>翻译过来就是给出若干组小于等于和大于等于的约数，求$max(x_n-x_1)$，差分约束</p>
<p>注：需要考虑负环和终点不可达的情况</p>
<p>AC代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">1e8</span>;<br><span class="hljs-type">int</span> n,m,k;<br>ll cnt,head[<span class="hljs-number">30005</span>],dis[<span class="hljs-number">30005</span>],ring[<span class="hljs-number">30005</span>],vis[<span class="hljs-number">30005</span>];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	ll u,v,w,next;<br>&#125;e[<span class="hljs-number">150005</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(ll u,ll v,ll w)</span></span>&#123;<br>	e[++cnt]=Edge&#123;u,v,w,head[u]&#125;;<br>	head[u]=cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) dis[i]=inf;<br>	queue&lt;<span class="hljs-type">int</span>&gt; q;<br>	q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>	ring[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>	dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>	vis[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>		ll u=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>		vis[u]=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];i;i=e[i].next)&#123;<br>			ll v=e[i].v,w=e[i].w;<br>			<span class="hljs-keyword">if</span>(dis[v]&gt;dis[u]+w)&#123;<br>				dis[v]=dis[u]+w;<br>				ring[v]=ring[u]+<span class="hljs-number">1</span>;<br>				<span class="hljs-keyword">if</span>(ring[v]&gt;n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>				<span class="hljs-keyword">if</span>(vis[v]==<span class="hljs-number">0</span>)&#123;<br>					vis[v]=<span class="hljs-number">1</span>;<br>					q.<span class="hljs-built_in">push</span>(v);<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);<br>	ll x,y,z;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>,&amp;x,&amp;y,&amp;z);<br>		<span class="hljs-built_in">addedge</span>(x,y,z);<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;i++)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>,&amp;x,&amp;y,&amp;z);<br>		<span class="hljs-built_in">addedge</span>(y,x,-z);<br>	&#125;<br>	<span class="hljs-keyword">if</span>(<span class="hljs-built_in">spfa</span>()) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);<br>	<span class="hljs-keyword">else</span>&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,dis[n]&gt;=inf?<span class="hljs-number">-2</span>:dis[n]);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="POJ-1716-Integer-Intervals"><a href="#POJ-1716-Integer-Intervals" class="headerlink" title="POJ 1716 Integer Intervals"></a><a href="https://vjudge.net/problem/POJ-1716">POJ 1716 Integer Intervals</a></h4><p>题意：</p>
<p>给出若干区间，求一个点集满足所有区间都至少有两个点在这个点集里，求这样的点集的最小大小</p>
<p>题解：</p>
<p>关键在于转化为差分约束问题，可以考虑$dis[x]表示[0,x]这个区间在点集内的点的个数$，那么题目就可以转化为（加一是为了防止数组下标有-1出现）</p>
<script type="math/tex; mode=display">
dis[r_i+1]-dis[l_i]\geq 2\\</script><p>除此之外，还有非常关键的题目隐含条件（都是整数点）</p>
<script type="math/tex; mode=display">
0\leq dis[i+1]-dis[i]\leq1</script><p>现在就可以建图+跑最短路了</p>
<p>AC代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll maxn=<span class="hljs-number">10005</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">1e8</span>;<br><span class="hljs-type">int</span> n,m,k;<br>ll Max,cnt,head[<span class="hljs-number">30005</span>],dis[<span class="hljs-number">30005</span>],ring[<span class="hljs-number">30005</span>],vis[<span class="hljs-number">30005</span>];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	ll u,v,w,next;<br>&#125;e[<span class="hljs-number">150005</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(ll u,ll v,ll w)</span></span>&#123;<br>	e[++cnt]=Edge&#123;u,v,w,head[u]&#125;;<br>	head[u]=cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=Max;i++) dis[i]=-inf;<br>	queue&lt;<span class="hljs-type">int</span>&gt; q;<br>	q.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>	dis[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>	vis[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>		ll u=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>		vis[u]=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];i;i=e[i].next)&#123;<br>			ll v=e[i].v,w=e[i].w;<br>			<span class="hljs-keyword">if</span>(dis[v]&lt;dis[u]+w)&#123;<br>				dis[v]=dis[u]+w;<br>				<span class="hljs-keyword">if</span>(vis[v]==<span class="hljs-number">0</span>)&#123;<br>					vis[v]=<span class="hljs-number">1</span>;<br>					q.<span class="hljs-built_in">push</span>(v);<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>	ll x,y;<br>	Max=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;x,&amp;y);<br>		<span class="hljs-built_in">addedge</span>(x,y+<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>		Max=<span class="hljs-built_in">max</span>(Max,y+<span class="hljs-number">1</span>);<span class="hljs-comment">//存区间最大值</span><br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=Max;i++)&#123;<br>		<span class="hljs-built_in">addedge</span>(i,i+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>		<span class="hljs-built_in">addedge</span>(i+<span class="hljs-number">1</span>,i,<span class="hljs-number">-1</span>);<br>	&#125;<br>	<span class="hljs-built_in">spfa</span>();<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,dis[Max]);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="HDU-3666-THE-MATRIX-PROBLEM"><a href="#HDU-3666-THE-MATRIX-PROBLEM" class="headerlink" title="HDU 3666 THE MATRIX PROBLEM"></a><a href="https://vjudge.net/problem/HDU-3666">HDU 3666 THE MATRIX PROBLEM</a></h4><p><del><strong>这真是一道TMD无敌宇宙霹雳巨恶心的题，甚至还带点玄学算法，搞得我半夜十二点不能睡觉</strong></del></p>
<p>题意：</p>
<p>给出一个$n*m$的矩阵，要求构造两个数列$a<em>n,b_m$使矩阵第$i$行元素乘上$a_i$，第$j$列元素除以$b_j$得到一个新矩阵$C$，且需要满足$C</em>{i,j}\in [L,U]$，问能否构造成功？</p>
<p>题解：</p>
<p>这TM？？第一眼看到：神仙题？</p>
<p>考虑将题目条件转换为数学文字：</p>
<script type="math/tex; mode=display">
L\leq \frac{x_{i,j}\cdot A_i}{B_j}\leq U\Rightarrow \frac{L}{x_{i,j}}\leq \frac{A_i}{B_j}\leq\frac{U}{x_{i,j}}\\
两边取对数，得出\\
log(\frac{L}{x_{i,j}})\leq log(A_i)-log(B_i)\leq log(\frac{U}{x_{i,j}})</script><p>可以差分约束+判负环搞起来了</p>
<p>什么？？TLE了！什么？传统判负环方法不行了？？</p>
<p>于是上网找到这道题TMD居然会卡时间卡得这么紧？？！</p>
<h5 id="MARK-新姿势"><a href="#MARK-新姿势" class="headerlink" title="MARK 新姿势"></a>MARK 新姿势</h5><p>于是查到有两种方案（玄学剪枝法）：</p>
<ol>
<li><p>一个节点更新次数大于$\sqrt{n}$就判定位负环（无法证明？有什么办法，这题只能这么胡搞）</p>
</li>
<li><p>所有节点更新总次数大于$k*n$就判定为负环（一般k取2，然并卵，也是个玄学方法）</p>
</li>
</ol>
<p>除此之外，我还发现我一直使用的判负环方法会WA？？</p>
<p>因此我得出结论：</p>
<p>对于此类题，先用我自己的判负环方法，如果WA了，改为更强的方法，如果还TLE，那么就用上面的玄学剪枝法</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> inf=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> n,m,k;<br><span class="hljs-type">double</span> l,r;<br>ll cnt,head[<span class="hljs-number">600005</span>],ring[<span class="hljs-number">600005</span>],vis[<span class="hljs-number">600005</span>];<br><span class="hljs-type">double</span> dis[<span class="hljs-number">600005</span>];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	ll u,v,next;<br>	<span class="hljs-type">double</span> w;<br>&#125;e[<span class="hljs-number">3500005</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(ll u,ll v,<span class="hljs-type">double</span> w)</span></span>&#123;<br>	e[++cnt]=Edge&#123;u,v,head[u],w&#125;;<br>	head[u]=cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> st)</span></span>&#123;<br>	<span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<br>	<span class="hljs-built_in">memset</span>(ring,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(ring));<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+m+<span class="hljs-number">10</span>;i++) dis[i]=inf;<br>	queue&lt;<span class="hljs-type">int</span>&gt; q;<br>	q.<span class="hljs-built_in">push</span>(st);<br>	dis[st]=<span class="hljs-number">0</span>;<br>	vis[st]=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>		ll u=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>		vis[u]=<span class="hljs-number">0</span>;<br>		ring[u]++; <span class="hljs-comment">//新判法</span><br>		<span class="hljs-keyword">if</span>(ring[u]&gt;<span class="hljs-built_in">sqrt</span>(n+m)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//超级玄学搞法</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];i!=<span class="hljs-number">-1</span>;i=e[i].next)&#123;<br>			ll v=e[i].v;<br>			<span class="hljs-type">double</span> w=e[i].w;<br>			<span class="hljs-keyword">if</span>(dis[v]&gt;dis[u]+w)&#123;<br>				dis[v]=dis[u]+w;<br>				<span class="hljs-keyword">if</span>(vis[v]==<span class="hljs-number">0</span>)&#123;<br>					vis[v]=<span class="hljs-number">1</span>;<br>					q.<span class="hljs-built_in">push</span>(v);<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%lf%lf&quot;</span>,&amp;n,&amp;m,&amp;l,&amp;r))&#123;<br>		cnt=<span class="hljs-number">0</span>;<br>		l=<span class="hljs-built_in">log2</span>(l);<br>		r=<span class="hljs-built_in">log2</span>(r);<br>		<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br>		<span class="hljs-type">double</span> x;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>				<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,&amp;x);<br>				<span class="hljs-type">double</span> temp=<span class="hljs-built_in">log2</span>(x);<br>				<span class="hljs-built_in">addedge</span>(n+j,i,r-temp);<br>				<span class="hljs-built_in">addedge</span>(i,n+j,temp-l);<br>			&#125;<br>		&#125;<br><span class="hljs-comment">//		for(int i=1;i&lt;=n+m;i++) addedge(0,i,0);</span><br>		<span class="hljs-keyword">if</span>(<span class="hljs-built_in">spfa</span>(<span class="hljs-number">1</span>)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);<br>		<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;YES\n&quot;</span>);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂&amp;矩阵快速幂</title>
    <url>/2020/02/06/%E5%BF%AB%E9%80%9F%E5%B9%82&amp;%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p><a href="https://www.luogu.com.cn/problem/P1226">模板题链接</a></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>对于普通的求（整数次）幂运算，如求$a^b$，需要将$a$连乘$b$次，复杂度为$O(b)$</li>
<li>使用<strong>快速幂</strong>能使得复杂度降为$O(logb)$，大大优化了计算时间</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>为方便理解，这里直接给出实例：</p>
<p>求整数次幂时，比如：$3^{11}$，首先我们将指数$11$写成二进制形式$1011$，那么计算式就可以写成$3^{(1011)_2}$，再将其拆开写成</p>
<script type="math/tex; mode=display">
3^{(1011)_2}=3^8*3^0*3^2*3^1=3^{1*2^3}*3^{0*2^2}*3^{1*2^1}3^{1*2^0}</script><p>为什么要写成这样的形式呢？</p>
<p>我们发现，从右往左看上面的计算式，最右边是$3^1$，将它<strong>自乘</strong>一次，就会得到$3^2$，将$3^2$自乘一次得到$3^4$，然后得到$3^8$，是不是发现规律了？</p>
<p>没错，在指数的二进制表示法中，从低位向高位遍历，遇到$1$则自乘一次，再<strong>乘以答案（更新答案）</strong>，遇到$0$也自乘一次，但<strong>不更新答案</strong>，即可在$O(logb)$的复杂度内完成幂运算。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123; <span class="hljs-comment">//计算x^y</span><br>  <span class="hljs-type">int</span> base=x,ans=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(y&gt;<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>)&#123; <span class="hljs-comment">//如果y这一位为1，则需要更新答案</span><br>      ans*=base; <span class="hljs-comment">//更新答案</span><br>            ans%=mod;<br>        &#125;<br>        base*=base; <span class="hljs-comment">//无论如何都需要自乘</span><br>        base%=mod;<br>        y&gt;&gt;=<span class="hljs-number">1</span>; <span class="hljs-comment">//y右移</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p><a href="https://www.luogu.com.cn/problem/P3390">模板题链接</a></p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>矩阵乘法 + 快速幂</p>
<p><del>完</del></p>
<ul>
<li>实现过程只需要造一个结构体，里面存矩阵，然后重载一下乘法运算即可</li>
<li>重载矩阵乘法是<strong>三重循环</strong>（超级慢）</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">M</span>&#123; <span class="hljs-comment">//矩阵结构体</span><br>  ll mat[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>];<br>&#125;a;<br>ll n,k;<br>M <span class="hljs-keyword">operator</span>*(M x1,M x2)&#123; <span class="hljs-comment">//重载乘法</span><br>  M res;<br>  <span class="hljs-built_in">memset</span>(res.mat,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(res.mat));<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;<br>        res.mat[i][j]+=(x1.mat[i][k]*x2.mat[k][j])%mod;<br>        res.mat[i][j]%=mod; <span class="hljs-comment">//多模多模很重要</span><br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> M <span class="hljs-title">qpow</span><span class="hljs-params">(M x,ll y)</span></span>&#123; <span class="hljs-comment">//快速幂</span><br>  M base=x,ans;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123; <span class="hljs-comment">//构造一个单位阵（相当于快速幂里面的ans=1）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>      <span class="hljs-keyword">if</span>(i==j) ans.mat[i][j]=<span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">else</span> ans.mat[i][j]=<span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">while</span>(y&gt;<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//下面不解释了</span><br>    <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) ans=ans*base; <span class="hljs-comment">//有的题目需要注意左乘右乘</span><br>    base=base*base;<br>    y&gt;&gt;=<span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  cin&gt;&gt;n&gt;&gt;k;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>      cin&gt;&gt;a.mat[i][j];<br>    &#125;<br>  &#125;<br>  M ans=<span class="hljs-built_in">qpow</span>(a,k);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>      cout&lt;&lt;ans.mat[i][j]%mod&lt;&lt;<span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">//输出也要多模</span><br>    &#125;<br>    cout&lt;&lt;endl;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>矩阵运算</tag>
      </tags>
  </entry>
  <entry>
    <title>并査集</title>
    <url>/2020/02/07/%E5%B9%B6%E6%9F%BB%E9%9B%86/</url>
    <content><![CDATA[<h2 id="并査集板子-习题"><a href="#并査集板子-习题" class="headerlink" title="并査集板子&习题"></a><center>并査集板子&习题</center></h2><span id="more"></span>
<p>[toc]</p>
<h2 id="并査集"><a href="#并査集" class="headerlink" title="并査集"></a>并査集</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>并査集是一种用来管理元素分组的数据结构，可以高效地进行如下操作：<ul>
<li>查询元素$a$和元素$b$是否属于同一组</li>
<li>合并元素$a$和元素$b$所在的组</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2020/02/07/hPEf9WbrKakYJOn.png" alt="image.png" style="zoom:80%;" /></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>并査集采用普通的<strong>树结构</strong>（非二叉树）实现</li>
</ul>
<p>步骤：</p>
<ol>
<li><p>初始化：准备$n$个节点来表示$n$个元素（没有边，每个元素都是独立的）</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>     fa[i]=i;<br>     ran[i]=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
<li><p>查询元素所在的组：从元素开始沿着树向上走到根部，判断两个根是否相同即可</p>
<p>优化：采用<strong>路径压缩</strong>，即把每个元素都连向根节点</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br> <span class="hljs-keyword">return</span> f[x]==x?x:fa[x]=<span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>查询两元素是否在同一组：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x)==<span class="hljs-built_in">find</span>(y);<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
<li><p>合并两元素所在组：从一个组的根向另一个组的根连边</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    fa[<span class="hljs-built_in">find</span>(x)]=<span class="hljs-built_in">find</span>(y);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>优化：<strong>按秩合并</strong>，用一个数组$ran$记录每组的深度（秩），每次连边让<strong>深度小的向深度大的连边</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x,inty)</span></span>&#123;<br> x=<span class="hljs-built_in">find</span>(x); <span class="hljs-comment">//找到x和y的根</span><br>    y=<span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//若根相同，说明在同一组内</span><br>    <span class="hljs-keyword">if</span>(ran[x]&lt;ran[y])&#123; <span class="hljs-comment">//深度小的向深度大的连边</span><br>   fa[x]=y;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>   fa[y]=x;<br>        <span class="hljs-keyword">if</span>(ran[x]==ran[y]) ran[x]++; <span class="hljs-comment">//若深度相同,秩+1</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>或者：一般情况下，<strong>直接不考虑深度的按秩合并就够用了</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    x=<span class="hljs-built_in">find</span>(x);<br>    y=<span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span>(x!=y)&#123;<br>        fa[x]=y;<br>        ran[y]+=x;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
</ol>
<h2 id="并査集扩展应用"><a href="#并査集扩展应用" class="headerlink" title="并査集扩展应用"></a>并査集扩展应用</h2><h3 id="二维并査集"><a href="#二维并査集" class="headerlink" title="二维并査集"></a>二维并査集</h3><p>其实就是在普通的一维并査集基础上加了一个维度罢了，没什么稀奇的，有的题目可能会有好几种不同的集合需要维护，这个时候开一个二维的并査集来维护就可以啦</p>
<p>例题：<a href="https://vjudge.net/problem/CodeForces-505B">CF 505B</a></p>
<h3 id="带权并査集"><a href="#带权并査集" class="headerlink" title="带权并査集"></a>带权并査集</h3><p>顾名思义，带权并査集就是并査集中点的“连线”（或者节点）具有<strong>权值和方向</strong>，此时并査集更像是<strong>一颗树</strong>，通常<strong>用来维护元素之间的相对关系（如：相对大小、类别 等）</strong>下面是一些模板操作</p>
<ul>
<li>查询（路径压缩），可以发现代码中先存了当前父节点的编号，递归完成后，所有父节点都连到了根节点，那么当前节点的权值就应该是自己和父节点权值的和，而对于父节点也是一样，递归操作就能达到这样的效果</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x!=fa[x])&#123;<br>        <span class="hljs-type">int</span> t=fa[x];<br>        fa[x]=<span class="hljs-built_in">find</span>(fa[x]);<br>        <span class="hljs-comment">//视具体问题而定，维护种类关系通常需要取模</span><br>        val[x]=(val[x]+val[t])%k;<br>    &#125;<br>    <span class="hljs-keyword">return</span> fa[x];<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>合并</li>
</ul>
<p>通常情况下是按照<strong>同一点通过不同路线连到根节点的权值相同</strong>的原理来合并权值</p>
<p>但具体情况视题目而定</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> value)</span></span>&#123;<br>    <span class="hljs-type">int</span> px=<span class="hljs-built_in">find</span>(x);<br>    <span class="hljs-type">int</span> py=<span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span>(px!=py)&#123;<br>        fa[px]=py;<span class="hljs-comment">//x根节点连到y根节点上</span><br>        <span class="hljs-comment">//按权值之和合并,维护种类关系时通常需要取模运算</span><br>        val[px]=(value+val[y]-val[x])%k;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/04/25/cXYC5Qm6qnfvUpH.png" alt="image.png"></p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="NOI-2001-食物链"><a href="#NOI-2001-食物链" class="headerlink" title="NOI 2001 食物链"></a><a href="https://www.luogu.com.cn/problem/P2024">NOI 2001 食物链</a></h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>说实话前面两题应该放到最后的（因为最难。。）</p>
<p>见题目链接</p>
<h4 id="思路-amp-题解"><a href="#思路-amp-题解" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h4><ol>
<li>普通并査集解法（三倍空间并査集）</li>
</ol>
<ul>
<li>使用并査集，维护$ABC$三组数据（用同一个数组实现，只需要下标表示为$i,i+N,i+2N$即可），$X-A/B/C$代表$X$属于$A/B/C$类</li>
<li>若有：$1 X Y$，则先检查有没有（$X-A$且$Y-B$）或（$X-A$且$Y-C$），若无误则同时令$X-A\ Y-A$， $X-B\ Y-B$，$X-C\ Y-C$，这样就可以确保所有情况都考虑到</li>
<li>若有：$2 X Y$，则先检查有没有（$X-A$且$Y-A$）或（$X-A$且$Y-C$），若无误则同时令$X-A\ Y-B$，$X-B\ Y-C$，$X-C\ Y-A$</li>
</ul>
<ol>
<li>带权并査集解法（维护三个种类，并査权值时取模）</li>
</ol>
<h4 id="AC代码（三倍空间并査集）"><a href="#AC代码（三倍空间并査集）" class="headerlink" title="AC代码（三倍空间并査集）"></a>AC代码（三倍空间并査集）</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> par[<span class="hljs-number">500005</span>];<br><span class="hljs-type">int</span> rank[<span class="hljs-number">500005</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123; <span class="hljs-comment">//初始化并査集 </span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    par[i]=i;<br>    rank[i]=<span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123; <span class="hljs-comment">//查询x在哪个组里 </span><br>  <span class="hljs-keyword">if</span>(par[x]==x) <span class="hljs-keyword">return</span> x;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> par[x]=<span class="hljs-built_in">find</span>(par[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123; <span class="hljs-comment">//合并x和y所在的组 </span><br>  x=<span class="hljs-built_in">find</span>(x);<br>  y=<span class="hljs-built_in">find</span>(y);<br>  <span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">if</span>(rank[x]&lt;rank[y]) par[x]=y;<br>  <span class="hljs-keyword">else</span>&#123;<br>    par[y]=x;<br>    <span class="hljs-keyword">if</span>(rank[x]==rank[y]) rank[x]++;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123; <span class="hljs-comment">//判断x和y是否在同一组 </span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x)==<span class="hljs-built_in">find</span>(y);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-type">int</span> n,k;<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;n,&amp;k);<br>  <span class="hljs-built_in">init</span>(<span class="hljs-number">3</span>*n);<br>  <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;i++)&#123;<br>    <span class="hljs-type">int</span> x,a,b;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;x,&amp;a,&amp;b);<br>    a=a<span class="hljs-number">-1</span>,b=b<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(a&gt;=n||b&gt;=n)&#123;<br>      ans++;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">1</span>)&#123;<br>      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">same</span>(a,b+n)||<span class="hljs-built_in">same</span>(a,b+<span class="hljs-number">2</span>*n))&#123;<br>        ans++;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">unite</span>(a,b);<br>        <span class="hljs-built_in">unite</span>(a+n,b+n);<br>        <span class="hljs-built_in">unite</span>(a+<span class="hljs-number">2</span>*n,b+<span class="hljs-number">2</span>*n); <br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">2</span>)&#123;<br>      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">same</span>(a,b)||<span class="hljs-built_in">same</span>(a,b+<span class="hljs-number">2</span>*n))&#123;<br>        ans++;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">unite</span>(a,b+n);<br>        <span class="hljs-built_in">unite</span>(a+n,b+<span class="hljs-number">2</span>*n);<br>        <span class="hljs-built_in">unite</span>(a+<span class="hljs-number">2</span>*n,b);<br>      &#125;<br>    &#125;<br>  &#125; <br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="NOI-2015-程序自动分析"><a href="#NOI-2015-程序自动分析" class="headerlink" title="NOI 2015 程序自动分析"></a><a href="https://www.luogu.com.cn/problem/P1955">NOI 2015 程序自动分析</a></h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>见题目链接</p>
<h4 id="思路-amp-题解-1"><a href="#思路-amp-题解-1" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h4><ul>
<li>一开始看是个<strong>并査集</strong>裸题，对$e$排序把合并操作（$e==1$的情况）放在前面先做好，然后开始遍历$e==0$的情况判断是否矛盾即可，然后做的时候发现数组范围是$1e9$<del>（可以骗70分左右）</del>，开不了这么大的数组怎么办？</li>
<li><p>考虑<strong>离散化</strong>，三部曲：</p>
<ol>
<li>对原数组排序</li>
<li>$unique$函数去重</li>
<li>lower_bound更新原数组位置</li>
</ol>
</li>
<li><p>这样数组规模就可以压缩到$2n$大小，足够了</p>
</li>
</ul>
<h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>  <span class="hljs-type">int</span> x,y,e;<br>&#125;a[<span class="hljs-number">1000005</span>];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node x1,node x2)</span></span>&#123;<br>  <span class="hljs-keyword">return</span> x1.e&gt;x2.e;<br>&#125;<br><br><span class="hljs-type">int</span> fa[<span class="hljs-number">1000005</span>],b[<span class="hljs-number">5000005</span>];<br>set&lt;<span class="hljs-type">int</span>&gt; se; <br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>  <span class="hljs-keyword">return</span> x==fa[x]?x:fa[x]=<span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>  fa[<span class="hljs-built_in">find</span>(x)]=<span class="hljs-built_in">find</span>(y);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    fa[i]=i;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  cin&gt;&gt;n;<br>  <span class="hljs-keyword">while</span>(n--)&#123;<br>    <span class="hljs-type">bool</span> f=<span class="hljs-literal">true</span>;<br>    <span class="hljs-type">int</span> m;<br>    cin&gt;&gt;m;<br>    <span class="hljs-type">int</span> tot=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>      cin&gt;&gt;a[i].x&gt;&gt;a[i].y&gt;&gt;a[i].e;<br>      b[++tot]=a[i].x;<br>      b[++tot]=a[i].y;<br>    &#125;<br>        <span class="hljs-comment">//离散化三部曲</span><br>    <span class="hljs-built_in">sort</span>(b+<span class="hljs-number">1</span>,b+tot+<span class="hljs-number">1</span>); <span class="hljs-comment">//排序</span><br>    <span class="hljs-type">int</span> unq = <span class="hljs-built_in">unique</span>(b+<span class="hljs-number">1</span>,b+tot+<span class="hljs-number">1</span>)-b<span class="hljs-number">-1</span>; <span class="hljs-comment">//去重</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123; <span class="hljs-comment">//lower_bound 更新</span><br>      a[i].x = <span class="hljs-built_in">lower_bound</span>(b+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>+unq,a[i].x)-b;<br>      a[i].y = <span class="hljs-built_in">lower_bound</span>(b+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>+unq,a[i].y)-b;<br>    &#125;<br>    <span class="hljs-built_in">init</span>(unq);<br>    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">1</span>+m,cmp);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>      <span class="hljs-keyword">if</span>(a[i].e==<span class="hljs-number">1</span>) <span class="hljs-built_in">unite</span>(a[i].x,a[i].y);<br>      <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(a[i].x)==<span class="hljs-built_in">find</span>(a[i].y))&#123;<br>          f=<span class="hljs-literal">false</span>;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(f) cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="CF-505B-Mr-Kitayuta’s-Colorful-Graph"><a href="#CF-505B-Mr-Kitayuta’s-Colorful-Graph" class="headerlink" title="CF 505B Mr. Kitayuta’s Colorful Graph"></a><a href="https://vjudge.net/problem/CodeForces-505B">CF 505B Mr. Kitayuta’s Colorful Graph</a></h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>给个无向图，每条边用一个整数表示一种颜色，有若干次询问，每次询问一对节点之间<strong>能通过一种颜色连通的种类数</strong></p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>开一个二维并査集，第一维维护每种颜色，第二维维护每种颜色对应的集合，询问时只需遍历第一维找对应两节点的根是不是同一个即可</p>
<h4 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m,q,fa[<span class="hljs-number">125</span>][<span class="hljs-number">125</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">105</span>;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">105</span>;j++)&#123;<br>			fa[i][j]=j;<br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> c,<span class="hljs-type">int</span> y)</span></span>&#123;<br>	<span class="hljs-keyword">return</span> fa[c][y]==y?y:fa[c][y]=<span class="hljs-built_in">find</span>(c,fa[c][y]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> c)</span></span>&#123;<br>	x=<span class="hljs-built_in">find</span>(c,x);<br>	y=<span class="hljs-built_in">find</span>(c,y);<br>	<span class="hljs-keyword">if</span>(x!=y) fa[c][y]=x;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;n&gt;&gt;m;<br>	<span class="hljs-built_in">init</span>();<br>	<span class="hljs-type">int</span> u,v,w;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>		cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br>		<span class="hljs-built_in">unite</span>(u,v,w);<br>	&#125;<br>	cin&gt;&gt;q;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;i++)&#123;<br>		cin&gt;&gt;u&gt;&gt;v;<br>		<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>			<span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(j,u)==<span class="hljs-built_in">find</span>(j,v))&#123;<br>				ans++;<br>			&#125;<br>		&#125;<br>		cout&lt;&lt;ans&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="计蒜客-A1139-引爆炸弹"><a href="#计蒜客-A1139-引爆炸弹" class="headerlink" title="计蒜客 A1139 引爆炸弹"></a><a href="https://vjudge.net/problem/计蒜客-A1139">计蒜客 A1139 引爆炸弹</a></h3><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>一个矩形地图上有若干炸弹，如果引爆一颗，则其横着竖着的所有炸弹都会被引爆，产生连锁反应，问最少需要引爆几次才能炸完所有炸弹？</p>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>建立一个并査集维护行和列的关系，可以另外开辟一个空间维护列，这样只要在输入的时候把对应点的行列合并，最后处理的时候横纵坐标单独处理（如果该点对应的行、列没被标记，则标记这一行、列）</p>
<h4 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">2147483647</span>;<br><span class="hljs-type">int</span> n,m,shen[<span class="hljs-number">5005</span>],vis[<span class="hljs-number">5005</span>],fa[<span class="hljs-number">5005</span>];<br><span class="hljs-type">char</span> a[<span class="hljs-number">5005</span>][<span class="hljs-number">5005</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+m+<span class="hljs-number">2</span>;i++)&#123;<br>		fa[i]=i;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>	<span class="hljs-keyword">return</span> x==fa[x]?x:fa[x]=<span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>	x=<span class="hljs-built_in">find</span>(x);<br>	y=<span class="hljs-built_in">find</span>(y);<br>	fa[x]=y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>	<span class="hljs-built_in">init</span>();<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,a[i]);<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>			<span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>				<span class="hljs-built_in">unite</span>(i,j+n); <span class="hljs-comment">//合并行列</span><br>			&#125;<br>		&#125;<br>	&#125;<br>		<br>	<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>			<span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>				<span class="hljs-keyword">if</span>(!vis[<span class="hljs-built_in">find</span>(i)])&#123; <span class="hljs-comment">//处理点对应的行</span><br>					vis[<span class="hljs-built_in">find</span>(i)]=<span class="hljs-number">1</span>; <span class="hljs-comment">//炸掉这一行</span><br>					ans++; <span class="hljs-comment">//更新答案</span><br>				&#125;<br>				<span class="hljs-keyword">if</span>(!vis[<span class="hljs-built_in">find</span>(j+n)])&#123; <span class="hljs-comment">//处理点对应的列</span><br>					vis[<span class="hljs-built_in">find</span>(j+n)]=<span class="hljs-number">1</span>; <span class="hljs-comment">//炸掉这一列</span><br>					ans++; <span class="hljs-comment">//更新答案</span><br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="HDU-3038-How-Many-Answers-Are-Wrong"><a href="#HDU-3038-How-Many-Answers-Are-Wrong" class="headerlink" title="HDU 3038 How Many Answers Are Wrong"></a><a href="https://vjudge.net/problem/HDU-3038">HDU 3038 How Many Answers Are Wrong</a></h3><h4 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h4><p>给出若干个“区间左端点 区间右端点 区间和”的申明，问有几个申明与之前的声明冲突（错误）</p>
<h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>带权并査集的经典问题，此题有两个注意事项</p>
<ol>
<li><strong>维护开区间</strong>，因为闭区间无法维护，比如给出<code>[1,5]</code>，<code>[3,5]</code>的区间和，问<code>[1,2]</code>的区间和，并査集中根本就没有<code>2</code>这个点，所以需要考虑把区间的一端设置为开区间，上例可以改为给出<code>(0,5]</code>，<code>(2,5]</code>，问<code>(0,2]</code>的区间和</li>
<li>带权并査集的处理，连线的方向由左端点连向右端点，这样就可以用<code>val[左端点]-val[右端点]</code>的方式求出区间和</li>
</ol>
<p>PS：这东西很像前缀和</p>
<h4 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">int</span> n,m,fa[<span class="hljs-number">200005</span>],val[<span class="hljs-number">200005</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>		fa[i]=i;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(x!=fa[x])&#123;<br>		<span class="hljs-type">int</span> t=fa[x];<br>		fa[x]=<span class="hljs-built_in">find</span>(fa[x]);<br>		val[x]+=val[t];<br>	&#125;<br>	<span class="hljs-keyword">return</span> fa[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> value)</span></span>&#123;<br>	<span class="hljs-type">int</span> fx=<span class="hljs-built_in">find</span>(x);<br>	<span class="hljs-type">int</span> fy=<span class="hljs-built_in">find</span>(y);<br>	<span class="hljs-keyword">if</span>(fx!=fy)&#123;<br>		fa[fx]=fy;<br>		val[fx]=value+val[y]-val[x];<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m))&#123;<br>		<span class="hljs-built_in">memset</span>(val,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(val));<br>		<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>		<span class="hljs-built_in">init</span>();<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>			<span class="hljs-type">int</span> x,y,z;<br>			cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;<br>			--x;<br>			<span class="hljs-type">int</span> fx=<span class="hljs-built_in">find</span>(x);<br>			<span class="hljs-type">int</span> fy=<span class="hljs-built_in">find</span>(y);<br>			<span class="hljs-keyword">if</span>(fx==fy)&#123;<br>				<span class="hljs-keyword">if</span>(val[x]-val[y]!=z)&#123;<br>					ans++;<br>				&#125;<br>			&#125;<span class="hljs-keyword">else</span>&#123;<br>				<span class="hljs-built_in">unite</span>(x,y,z);<br>			&#125;<br>		&#125;<br>		cout&lt;&lt;ans&lt;&lt;endl;<br>	&#125;<br>	<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="HihoCoder-1515-分数调查"><a href="#HihoCoder-1515-分数调查" class="headerlink" title="HihoCoder 1515 分数调查"></a><a href="https://vjudge.net/problem/HihoCoder-1515">HihoCoder 1515 分数调查</a></h3><h4 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h4><p>给出若干对同学的相对得分差（A比B高xx分），然后有若干次询问，每次询问给出两个同学，问能否知道他们的相对得分差？</p>
<h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><p>带权并査集维护相对关系<del>（和上一题是重题？）</del></p>
<h4 id="AC代码-4"><a href="#AC代码-4" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">int</span> val[<span class="hljs-number">100005</span>],fa[<span class="hljs-number">100005</span>],n,m,q;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) fa[i]=i;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(x!=fa[x])&#123;<br>		<span class="hljs-type">int</span> t=fa[x];<br>		fa[x]=<span class="hljs-built_in">find</span>(fa[x]);<br>		val[x]+=val[t];<br>	&#125;<br>	<span class="hljs-keyword">return</span> fa[x];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> value)</span></span>&#123;<br>	<span class="hljs-type">int</span> fx=<span class="hljs-built_in">find</span>(x);<br>	<span class="hljs-type">int</span> fy=<span class="hljs-built_in">find</span>(y);<br>	<span class="hljs-keyword">if</span>(fx!=fy)&#123;<br>		fa[fx]=fy;<br>		val[fx]=val[y]+value-val[x];<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);<br>	<span class="hljs-built_in">init</span>();<br>	<span class="hljs-type">int</span> x,y,z;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);<br>		<span class="hljs-built_in">unite</span>(x,y,z);<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;++i)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<br>		<span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(x)!=<span class="hljs-built_in">find</span>(y))&#123;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,val[x]-val[y]);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-comment">//https://vjudge.net/problem/HihoCoder-1515</span><br></code></pre></div></td></tr></table></figure>
<h3 id="SPOJ-Bug’s-Life"><a href="#SPOJ-Bug’s-Life" class="headerlink" title="SPOJ Bug’s Life"></a><a href="https://vjudge.net/problem/SPOJ-BUGLIFE">SPOJ Bug’s Life</a></h3><h4 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h4><p>给出若干对昆虫的性别关系（两个两个给出，每一对都互为异性），求给出的这些数据中有没有冲突</p>
<h4 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h4><p>带权并査集维护种类关系，权值为1代表异性，0代表同性，找规律易得合并和查询时权值更新只需求和再对2取模即可</p>
<h4 id="AC代码-5"><a href="#AC代码-5" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">int</span> val[<span class="hljs-number">2005</span>],fa[<span class="hljs-number">2005</span>],n,m,t;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">memset</span>(val,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(val));<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) fa[i]=i;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(x!=fa[x])&#123;<br>		<span class="hljs-type">int</span> t=fa[x];<br>		fa[x]=<span class="hljs-built_in">find</span>(fa[x]);<br>		val[x]=(val[x]+val[t])%<span class="hljs-number">2</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> fa[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> o=<span class="hljs-number">1</span>;o&lt;=t;++o)&#123;<br>		<span class="hljs-type">bool</span> f=<span class="hljs-literal">true</span>;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>		<span class="hljs-built_in">init</span>();<br>		<span class="hljs-type">int</span> x,y;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)&#123;<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<br>			<span class="hljs-type">int</span> fx=<span class="hljs-built_in">find</span>(x),fy=<span class="hljs-built_in">find</span>(y);<br>			<span class="hljs-keyword">if</span>(fx!=fy)&#123;<br>				fa[fx]=fy;<br>				val[fx]=(val[y]+<span class="hljs-number">1</span>-val[x]+<span class="hljs-number">2</span>)%<span class="hljs-number">2</span>;<br>                <span class="hljs-comment">//防一波负数（其实没必要）</span><br>			&#125;<span class="hljs-keyword">else</span>&#123;<br>				<span class="hljs-keyword">if</span>((val[x]-val[y]+<span class="hljs-number">2</span>)%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>					f=<span class="hljs-literal">false</span>;<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Scenario #%d:\n&quot;</span>,o);<br>		<span class="hljs-keyword">if</span>(f) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No suspicious bugs found!\n&quot;</span>);<br>		<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Suspicious bugs found!\n&quot;</span>);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>并査集</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑排序</title>
    <url>/2020/02/21/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="图论算法の拓扑排序"><a href="#图论算法の拓扑排序" class="headerlink" title="图论算法の拓扑排序"></a><center>图论算法の拓扑排序</center></h2><span id="more"></span>
<h3 id="拓扑序定义"><a href="#拓扑序定义" class="headerlink" title="拓扑序定义"></a>拓扑序定义</h3><p>对于一个$DAG$（有向无环图）$G$，它的拓扑序是该图所有节点的一个线性序列，该序列必须满足<strong>使得图中的任意一对顶点$u$和$v$，若边$ (u,v) \in E(G) $，则$u$在线性序列中出现在$v$之前</strong></p>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>对于一个$DAG$：</p>
<ol>
<li>将所有<strong>入度</strong>为0的节点加入队列中</li>
<li>每次将队首元素（节点）出队并将其所有的出边砍掉（即 把该出边所连节点的入度减一），这样以后如果出现了新的入度为0的节点，那么把他们加入队列，重复该步骤，直到队列为空</li>
<li>每次出队的队首元素的顺序就是该图的一种拓扑序（答案不唯一，因为可能会同时存在好几个入度为0的节点，他们互不影响）</li>
</ol>
<p>举个例子，如下一张图</p>
<p>我们首先将入度为0的点入队（1、4），此时拓扑序还未构建</p>
<p><img src="https://i.loli.net/2020/02/21/LNc1TyQf7IEqRoX.png" alt="image.png"></p>
<p>然后删去他们的出边，并判断出边所连节点是否入度为0</p>
<p>此时拓扑序为：1 4</p>
<p><img src="https://i.loli.net/2020/02/21/QkuP7yGKiBLresE.png" alt="image.png"></p>
<p>发现2、5节点的入度变为0了，于是入队，重复上一步操作</p>
<p><img src="https://i.loli.net/2020/02/21/W4rhwLa5KJd9YoF.png" alt="image.png"></p>
<p>此时拓扑序为：1 4 2 5</p>
<p>删去2 5节点的出边后，发现3 6节点入度变为0，于是入队</p>
<p><img src="https://i.loli.net/2020/02/21/2t1pQrsViKwhH4F.png" alt="image.png"></p>
<p>取出3 6之后，拓扑序为：1 4 2 5 3 6</p>
<p>这时发现7入度为0，于是入队</p>
<p><img src="https://i.loli.net/2020/02/21/rkGytZxNswPv1Xi.png" alt="image.png"></p>
<p>最后结束，拓扑排序最终结果为：1 4 2 5 3 6 7（答案不止这一种，可以很容易算出此题答案有8种）</p>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123; <span class="hljs-comment">//边结构体</span><br>	<span class="hljs-type">int</span> u,v,next;<br>&#125;e[<span class="hljs-number">100005</span>];<br><br><span class="hljs-type">int</span> n,m,cnt,head[<span class="hljs-number">100005</span>],indeg[<span class="hljs-number">100005</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123; <span class="hljs-comment">//链式前向星加边</span><br>	e[++cnt].u=u;<br>	e[cnt].v=v;<br>	e[cnt].next=head[u];<br>	head[u]=cnt;<br>&#125;<br><span class="hljs-type">int</span> ans[<span class="hljs-number">100005</span>],ccnt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">topo_sort</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//拓扑排序</span><br>	queue&lt;<span class="hljs-type">int</span>&gt; q;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123; <span class="hljs-comment">//将所有入度为0的点入队</span><br>		<span class="hljs-keyword">if</span>(indeg[i]==<span class="hljs-number">0</span>)&#123;<br>			q.<span class="hljs-built_in">push</span>(i);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123; <br>		<span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>();<br>		q.<span class="hljs-built_in">pop</span>();<br>		ans[++ccnt]=u; <span class="hljs-comment">//记录拓扑序</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];i;i=e[i].next)&#123; <span class="hljs-comment">//遍历所有出边</span><br>			<span class="hljs-type">int</span> v=e[i].v;<br>			<span class="hljs-keyword">if</span>(indeg[v])&#123; <span class="hljs-comment">//如果入度不为零</span><br>				indeg[v]--; <span class="hljs-comment">// 出边所连节点入度-1</span><br>				<span class="hljs-keyword">if</span>(indeg[v]==<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//如果出现了入度=0</span><br>					q.<span class="hljs-built_in">push</span>(v); <span class="hljs-comment">//加入队列</span><br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>		<span class="hljs-type">int</span> u,v;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;u,&amp;v);<br>		<span class="hljs-built_in">addedge</span>(u,v);<br>		indeg[v]++; <span class="hljs-comment">//记录所有节点的入度</span><br>	&#125;<br>	<span class="hljs-built_in">topo_sort</span>();<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=ccnt;i++)&#123; <span class="hljs-comment">//output答案</span><br>		cout&lt;&lt;ans[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="习题：Vijos-P1790-拓扑编号"><a href="#习题：Vijos-P1790-拓扑编号" class="headerlink" title="习题：Vijos P1790 拓扑编号"></a>习题：<a href="https://vijos.org/p/1790">Vijos P1790 拓扑编号</a></h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><ul>
<li>给一个DAG图重新编号并排序，使得对于该序列中任意的两点$i$$j$且$i&lt;j$，满足新编号$a[i]&lt;a[j]$</li>
</ul>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><ul>
<li>考虑反向建图做一个逆拓扑排序，并且使用优先队列维护每次出队的都是最大的编号的节点，同时逆向编号即可得出答案</li>
</ul>
<h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> u,v,next;<br>&#125;e[<span class="hljs-number">1000005</span>];<br><span class="hljs-type">int</span> n,m,cnt,head[<span class="hljs-number">1000005</span>],indeg[<span class="hljs-number">1000005</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;<br>	e[++cnt].u=u;<br>	e[cnt].v=v;<br>	e[cnt].next=head[u];<br>	head[u]=cnt;<br>&#125;<br><span class="hljs-type">int</span> ans[<span class="hljs-number">1000005</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">tpsort</span><span class="hljs-params">()</span></span>&#123;<br>	priority_queue&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">//维护优先队列</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">if</span>(indeg[i]==<span class="hljs-number">0</span>)&#123;<br>			q.<span class="hljs-built_in">push</span>(i);<br>		&#125;<br>	&#125;<br>	<span class="hljs-type">int</span> num=n;<br>	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>		<span class="hljs-type">int</span> u=q.<span class="hljs-built_in">top</span>();<br>		q.<span class="hljs-built_in">pop</span>();<br>		ans[u]=num--; <span class="hljs-comment">//倒着编号</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];i;i=e[i].next)&#123;<br>			<span class="hljs-type">int</span> v=e[i].v;<br>			<span class="hljs-keyword">if</span>(indeg[v])&#123;<br>				indeg[v]--;<br>				<span class="hljs-keyword">if</span>(indeg[v]==<span class="hljs-number">0</span>)&#123;<br>					q.<span class="hljs-built_in">push</span>(v);<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>		<span class="hljs-type">int</span> u,v;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;u,&amp;v);<br>		<span class="hljs-built_in">addedge</span>(v,u);<br>		indeg[u]++;<br>	&#125;<br>	<span class="hljs-built_in">tpsort</span>();<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,ans[i]);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<br>&#125; <span class="hljs-comment">//https://vijos.org/p/1790</span><br></code></pre></div></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>拉格朗日插值</title>
    <url>/2020/08/01/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/</url>
    <content><![CDATA[<p>出于强迫症，想完成一下这个专题，其实就是我们工科生日常常用的插值方法，这里主要介绍一下它的原理与优势。<br><span id="more"></span></p>
<h2 id="拉格朗日插值"><a href="#拉格朗日插值" class="headerlink" title="拉格朗日插值"></a>拉格朗日插值</h2><p>参考blog：</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/solution/P4781">P4781 【模板】拉格朗日插值 题解</a></li>
<li><a href="https://blog.csdn.net/cold_chair/article/details/78165818">CSDN 自然数幂和（拉格朗日插值法）</a></li>
</ul>
<p>拉格朗日插值（Lagrange Interpolation）是数值分析常用的插值方法，是对给定$n+1$个点坐标拟合出$n$次拉格朗日多项式，然后计算给定点值的数值计算方法</p>
<p>给出模板例题：<a href="https://www.luogu.com.cn/problem/P4781">P4781 【模板】拉格朗日插值</a></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200801212502385.png" alt="image-20200801212502385"></p>
<p>其实很容易想到，可以通过高斯消元解一个$n-1$元的线性方程组得出系数，然后计算结果，看到数据范围是$n\le2000$，高斯消元复杂度为$O(n^3)$，立即放弃，由此产生了拉格朗日插值</p>
<h3 id="原理-amp-公式"><a href="#原理-amp-公式" class="headerlink" title="原理 &amp; 公式"></a>原理 &amp; 公式</h3><p>对$n$个点，可以构造出如下的$n-1$次多项式，从而计算出$f(k)$：</p>
<script type="math/tex; mode=display">
f(k)=\sum_{i=1}^n\left(y_i\prod_{j=1\\i\neq j}^{n}\frac{k-x_j}{x_i-x_j}\right)</script><p>容易发现，内部的连乘式在$k=x_i$时取值为$1$，满足所有的点坐标，因此这个式子是符合题意的多项式，显然复杂度为：$O(n^2)$，可以开始搞了</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">Larange</span><span class="hljs-params">()</span></span>&#123;<br>    ll ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        ll tp=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(i!=j)&#123;<br>                tp=tp*(k-x[j])%mod*<span class="hljs-built_in">qpow</span>(x[i]-x[j],mod<span class="hljs-number">-2</span>,mod)%mod;<br>            &#125;<br>        &#125;<br>        ans=(ans+y[i]*tp)%mod;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (ans+mod)%mod;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="在-x-取值连续时的优化"><a href="#在-x-取值连续时的优化" class="headerlink" title="在$x$取值连续时的优化"></a>在$x$取值连续时的优化</h3><p>在$x$取值连续时，可以通过预处理前缀/后缀积和阶乘的方式优化方程，把复杂度降为$O(n)$</p>
<p>通常情况下，我们取$x$值为$[1,n]$共$n$个整数值，则上述多项式变为：</p>
<script type="math/tex; mode=display">
f(k)=\sum_{i=1}^n\left(y_i\prod_{j=1\\i\neq j}^{n}\frac{k-j}{i-j}\right)</script><p>对于分子，$j\neq i$，因此需要维护分子的前缀积和后缀积如下：</p>
<script type="math/tex; mode=display">
pre[i]=\prod_{j=1}^i(k-j)\\
suf[i]=\prod_{j=i}^n(k-j)</script><p>对于分母，手推一下发现是两个阶乘相乘的形式，如下：</p>
<script type="math/tex; mode=display">
fac[i-1]*fac[n-i]</script><p>注意：上式中如果$n-i$为奇数则为负</p>
<p>那么整个式子就变为：</p>
<script type="math/tex; mode=display">
f(k)=\sum_{i=1}^{n}y_i\frac{pre[i-1]*suf[i+1]}{fac[i-1]*fac[n-i]}</script><h3 id="自然数幂次方和"><a href="#自然数幂次方和" class="headerlink" title="自然数幂次方和"></a>自然数幂次方和</h3><p>例题：<a href="https://www.luogu.com.cn/problem/CF622F">CF622F The Sum of the k-th Powers</a></p>
<p>题意十分简单，就是让计算 $\sum_{i=1}^ni^k \mod (10^9+7)$</p>
<p>数据范围：$1\le n\le 10^9, 0\le k\le 10^6$</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>显然这题裸的$O(n\log k)$会T飞，需要考虑优化，根据数学知识，<del>容易</del>知道答案必然是一个$k+1$次多项式，那么联想到拉格朗日差值，我们只需要代入$k+2$个点，就可以拟合出这个多项式然后代入$n$求出答案，代入的点值可以连续，因此复杂度为$O(k)$</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n,k;<br>ll pre[maxn],suf[maxn],fac[maxn],f[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">qpow</span><span class="hljs-params">(ll x,ll y,ll Mod)</span></span>&#123;<br>	ll res=<span class="hljs-number">1</span>,base=x%Mod;<br>	<span class="hljs-keyword">while</span>(y)&#123;<br>		<span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) res=(res*base)%Mod;<br>		y&gt;&gt;=<span class="hljs-number">1</span>;<br>		base=(base*base)%Mod;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>	ll ans=<span class="hljs-number">0</span>;<br>	pre[<span class="hljs-number">0</span>]=suf[k+<span class="hljs-number">3</span>]=fac[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k+<span class="hljs-number">2</span>;i++)<span class="hljs-comment">// 预处理前缀积</span><br>		pre[i]=(pre[i<span class="hljs-number">-1</span>]*(n-i))%mod;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=k+<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">1</span>;i--)<span class="hljs-comment">// 预处理后缀积</span><br>		suf[i]=(suf[i+<span class="hljs-number">1</span>]*(n-i))%mod;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k+<span class="hljs-number">2</span>;i++)<br>		fac[i]=(fac[i<span class="hljs-number">-1</span>]*i)%mod,<span class="hljs-comment">// 预处理阶乘</span><br>		f[i]=(f[i<span class="hljs-number">-1</span>]+<span class="hljs-built_in">qpow</span>(i,k,mod))%mod;<span class="hljs-comment">// 求出k+2个点</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k+<span class="hljs-number">2</span>;i++)&#123;<span class="hljs-comment">// Lagrange插值</span><br>		ll tp=(f[i]*pre[i<span class="hljs-number">-1</span>]%mod*suf[i+<span class="hljs-number">1</span>]%mod*<span class="hljs-built_in">qpow</span>(fac[i<span class="hljs-number">-1</span>]*fac[k+<span class="hljs-number">2</span>-i]%mod,mod<span class="hljs-number">-2</span>,mod)%mod+mod)%mod;<br>		<span class="hljs-keyword">if</span>((k+<span class="hljs-number">2</span>-i)&amp;<span class="hljs-number">1</span>) ans-=tp;<span class="hljs-comment">// 注意一下正负</span><br>		<span class="hljs-keyword">else</span> ans+=tp;<br>		ans=(ans+mod)%mod;<br>	&#125;<br>	<span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">solve</span>());<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>插值法</tag>
      </tags>
  </entry>
  <entry>
    <title>数论在算法方面的基础应用</title>
    <url>/2020/02/25/%E6%95%B0%E8%AE%BA%E5%9C%A8%E7%BC%96%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="数论基础"><a href="#数论基础" class="headerlink" title="数论基础"></a><center>数论基础</center></h2><span id="more"></span>
<h2 id="模运算-amp-算数基本定理"><a href="#模运算-amp-算数基本定理" class="headerlink" title="模运算&amp;算数基本定理"></a>模运算&amp;算数基本定理</h2><h3 id="模运算常用恒等式-amp-符号"><a href="#模运算常用恒等式-amp-符号" class="headerlink" title="模运算常用恒等式&amp;符号"></a>模运算常用恒等式&amp;符号</h3><script type="math/tex; mode=display">
\begin{aligned}
&a\%b=a-[\frac{a}{b}]\cdot b\\
&a\%b=0\rightarrow b|a\\\\
&(a+b)\%c=(a\%c+b\%c)\%c\\
&(a*b)\%c=(a\%c*b\%c)\%c\\
&(a-b)\%c=((a\%c-b\%c)\%c+c)\%c
\end{aligned}</script><p>注：除法取模要使用逆元</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> a,b,c;<br>a %= c,b %= c;<br><span class="hljs-type">int</span> ans1 = (a + b) % c;<br><span class="hljs-type">int</span> ans2 = ((a - b) % c + c) % c; <span class="hljs-comment">//三步走：模 加 模</span><br><span class="hljs-type">int</span> ans3 = ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>) a * b) % c; <span class="hljs-comment">//一定要记得开成longlong</span><br></code></pre></div></td></tr></table></figure>
<h3 id="算数基本定理"><a href="#算数基本定理" class="headerlink" title="算数基本定理"></a>算数基本定理</h3><p>任何一个大于$1$的自然数$N$，如果$N$不是质数，那么它一定可以<strong>唯一分解</strong>成有限个质数，即</p>
<script type="math/tex; mode=display">
N=P_1^{a_1}P_2^{a_2}...P_n^{a_n}\\
其中P_1<P_2<...<P_n,P_i均为质数,a_i均为正整数</script><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><ul>
<li><p><strong>约数倍数的特征</strong>：如果一个数字$x=P_1^{b_1}P_2^{b_2}…P_n^{b_n}$是N的约数，那么一定有$\forall b_i\leq a_1$，同理如果x是N的倍数，那么一定有$\forall b_i\geq a_i$</p>
</li>
<li><p><strong>素因数求法</strong>：模拟短除法</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">prime_factor</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)&#123;<br>            ++cnt;<br>            prime_fac[cnt]=i;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(n%i==<span class="hljs-number">0</span>) n/=i;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(n!=<span class="hljs-number">1</span>)&#123;<br>        ++cnt;<br>        prime_fac[++cnt]=n;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<p>关于<strong>快速分解质因数</strong>，见<strong>欧拉函数</strong>部分</p>
<h2 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>如果对于两个数字$a,b$，对于一个数字$m$的余数相等，则这两个数对于$m$同余</p>
<p>在数学上的标准定义：设$m$施给定的一个正整数，$a,b$是整数，若满足$m|(a-b)$，则称$a$与$b$对模$m$同余，记作$a\equiv b(mod\ m)$</p>
<h2 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h2><ul>
<li>对于$\frac{7}{3} \% 2$的结果怎么求呢？（注意：这里不是整除）</li>
</ul>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>乘法逆元：对于一个数字$a$，在膜$p$意义下如果存在一个数字$b$，满足$a*b\equiv 1(mod\ p)$，我们就称$b$是模$p$意义下$a$的乘法逆元，记作$a^{-1}$。容易发现</p>
<script type="math/tex; mode=display">
a^{-1}=(a+p)^{-1}\\
\frac{a}{b}=a*b^{-1}</script><p>于是，我们就可以把除法取模转换成乘法取模啦！</p>
<p>接下来就是各种<strong>求逆元</strong>的方法</p>
<h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><h4 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a>前置知识：</h4><p>欧拉函数（在下方素数筛法里面有讲）</p>
<h4 id="定理："><a href="#定理：" class="headerlink" title="定理："></a>定理：</h4><p>如果$gcd(a,p)=1$，即$a,p$互质，则有$a^{\varphi (p)}\equiv 1(mod\ p)$</p>
<h4 id="求逆元："><a href="#求逆元：" class="headerlink" title="求逆元："></a>求逆元：</h4><p>对于数字$a$，我所需要寻找的$a^{-1}$需要满足$a*a^{-1}\equiv 1(mod\ p)$，而$a^{\varphi (p)}\equiv 1(mod\ p)$，因此有$a* a^{\varphi (p)-1}\equiv 1(mod\ p)$，因此，$a^{-1}=a^{\varphi (p)-1}$，因此只要用一次快速幂求出逆元就可以了</p>
<h4 id="费马小定理："><a href="#费马小定理：" class="headerlink" title="费马小定理："></a>费马小定理：</h4><p>如果$p$是一个质数，则一定有$a^{p-1}\equiv 1(mod\ p)$</p>
<h4 id="其他用法："><a href="#其他用法：" class="headerlink" title="其他用法："></a>其他用法：</h4><p>在$a,p$互质的前提下，计算$a^b(mod\ p)$，其中$b$可以大到$10^{10^7}$级别</p>
<p>方法：令$b=k*\varphi (p)+m$，原式转化为$a^b(mod\ p)=(a^{\varphi (p)})^k*a^m$，由欧拉定理得$a^{\varphi (p)}\equiv 1(mod\ p)$，因此原式转化为$a^b(mod\ p)=a^m$，而$m=b\% \varphi (p)$，所以最后答案就是$a^b\equiv a^{b\% \varphi (p)}(mod\ p)$</p>
<p><u>UPD 2020.6.12</u></p>
<h3 id="扩展欧拉定理"><a href="#扩展欧拉定理" class="headerlink" title="扩展欧拉定理"></a>扩展欧拉定理</h3><p><a href="https://www.luogu.com.cn/problem/P5091">洛谷P5091 【模板】扩展欧拉定理</a></p>
<p>题意：若$a,p$不互质，计算$a^b(mod\ p)$，其中$b$可以大到$10^{10^7}$级别</p>
<p>此时，欧拉定理就不适用了，我们需要找到一个更为广泛的解法，即 对欧拉定理进行扩展，先给出结论：</p>
<script type="math/tex; mode=display">
b\ge \varphi(p)时，a^b\equiv a^{(b\mod\varphi(p))+\varphi(p)}(\mod p )\\
b<\varphi(p)时，a^b直接快速幂计算即可</script><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200612112612672.png" alt="image-20200612112612672"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">ll a,m,b,phim;<br><span class="hljs-type">bool</span> flag=<span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// a^b mod m = a^(b mod phi[m] + phi[m]) mod m &#123;if b&gt;=phi[m]&#125;</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> _read(T &amp;x) &#123;<br>	x=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> f=<span class="hljs-number">0</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br>	<span class="hljs-keyword">while</span>(ch&lt;<span class="hljs-number">48</span>||ch&gt;<span class="hljs-number">57</span>)&#123;f|=(ch==<span class="hljs-string">&#x27;-&#x27;</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<br>	<span class="hljs-keyword">while</span>(ch&gt;=<span class="hljs-number">48</span>&amp;&amp;ch&lt;=<span class="hljs-number">57</span>)&#123;<br>		x=(x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+(ch^<span class="hljs-number">48</span>);<br>		<span class="hljs-keyword">if</span>(x&gt;=phim) flag=<span class="hljs-literal">true</span>,x%=phim;<span class="hljs-comment">// 边读入边取模，并标记是否有x&gt;=phi[m]</span><br>		ch=<span class="hljs-built_in">getchar</span>();<br>	&#125;<br>	x=f?-x:x;<br>	<span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// get phi[n]</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">getphi</span><span class="hljs-params">(ll n)</span></span>&#123;<br>	ll res=n;<br>	<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">2</span>;i*i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>) res=res/i*(i<span class="hljs-number">-1</span>);<br>		<span class="hljs-keyword">while</span>(n%i==<span class="hljs-number">0</span>) n/=i;<br>	&#125;<br>	<span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">1</span>) res=res/n*(n<span class="hljs-number">-1</span>);<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">read</span>(a),<span class="hljs-built_in">read</span>(m);<br>	phim=<span class="hljs-built_in">getphi</span>(m);<span class="hljs-comment">// 求m欧拉函数</span><br>	_read(b);<br>	<span class="hljs-comment">// get a^b mod m</span><br>	ll ans=<span class="hljs-built_in">qpow</span>(a,b+(flag?phim:<span class="hljs-number">0</span>),m);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><h4 id="前置知识：-1"><a href="#前置知识：-1" class="headerlink" title="前置知识："></a>前置知识：</h4><p>裴蜀定理：对于方程$ax+by=c$有整数解当且仅当$c$是$gcd(a,b)$的倍数，即$(gcd(a,b)|c)$</p>
<h4 id="扩欧算法："><a href="#扩欧算法：" class="headerlink" title="扩欧算法："></a>扩欧算法：</h4><p>通常写作$exgcd$算法，它是用来求下面这个同余方程的一组解的</p>
<script type="math/tex; mode=display">
ax+by=gcd(a,b)</script><p>于是我们从另一个角度看逆元方程</p>
<script type="math/tex; mode=display">
\begin{aligned}
&aa^{-1}\equiv 1(mod\ p)\\&\Rightarrow ax\equiv 1(mod\ p)\\&\Rightarrow ax-py=1
\end{aligned}</script><p>因此，<strong>现在只需要找出一组$x,y$使得上式成立即可</strong>（为简单起见，可以把上式的减号换成加号），这个式子同样也印证了欧拉定理中如果想要存在$a$对$p$的逆元，必须要$gcd(a,p)=1$</p>
<p>如何找出一组解？</p>
<script type="math/tex; mode=display">
\begin{aligned}
&考虑b\neq0\Rightarrow gcd(a,b)=gcd(b,a\%b)\\
&假设有x',y'满足bx'+(a\%b)y'=gcd(b,a\%b)\\
&那么显然有ax+by=bx'+(a\%b)y'\\
&注意到a\%b=a-[\frac{a}{b}]*b\\
&所以也就有ax+by=bx'+(a-[\frac{a}{b}]*b)y'\\
&两个未知数x,y，因此这个方程显然有无穷多组解，不妨找一组特解\\
&将等号右侧的东西按照a,b分类，有\\
&ax+by=ay'+b(x'+[\frac{a}{b}]y')\\
&此时，令x=y',y=x'-[\frac{a}{b}]y'即可
\end{aligned}</script><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">ll x,y;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(ll a,ll b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)&#123;<br>        x=<span class="hljs-number">1</span>,y=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">exgcd</span>(b,a%b);<br>    ll tx=x;<br>    ll ty=y;<br>    x=ty;<br>    y=tx-a/b*ty;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>因此，求一个数$a$的逆元也可以转化为求解上述$x$的过程</p>
<p>那么，如果对于一个一般形式的二元一次不定方程（如下）</p>
<script type="math/tex; mode=display">
ax+by=c</script><p>或者一个一般的同余方程（如下）</p>
<script type="math/tex; mode=display">
ax\equiv c(mod\ p)</script><p>该如何求解呢？</p>
<script type="math/tex; mode=display">
考虑令c=k*gcd(a,b)\\
则可以先解出方程ax'+by'=gcd(a,b)\\
然后令x=kx',y=ky',即可求得ax+by=c的一组解</script><p>代码如下（exgcd的过程中顺便求出gcd(a,b)）</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">ll x,y;<br><span class="hljs-function">ll <span class="hljs-title">exgcd</span><span class="hljs-params">(ll a,ll b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)&#123;<br>        x=<span class="hljs-number">1</span>,y=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    ll t=<span class="hljs-built_in">exgcd</span>(b,a%b);<br>    ll tx=x;<br>    ll ty=y;<br>    x=ty;<br>    y=tx-a/b*ty;<br>    <span class="hljs-keyword">return</span> t<br>&#125;<span class="hljs-comment">//于是答案就是x*c/exgcd(a,b)</span><br></code></pre></div></td></tr></table></figure>
<p>除此之外，如果我们又想要所有的解，或者$x$最小或$y$最小的正整数解，这就又涉及到另外一个问题，它所有解的通式要怎么写呢？</p>
<p>这里直接给出答案（证明太复杂，略）</p>
<script type="math/tex; mode=display">
x=x_0+k\cdot\frac{b}{gcd(a,b)}\\
y=y_0-k\cdot\frac{a}{gcd(a,b)}</script><p>如果再将其转化为一般式，则有</p>
<script type="math/tex; mode=display">
x=tx_0+kt\cdot\frac{b}{gcd(a,b)}\\
y=ty_0-kt\cdot\frac{a}{gcd(a,b)}\\
其中t=\frac{c}{gcd(a,b)}</script><p>如果要求一个最小的$x$，那么一定要记得把答案$mod\frac{b}{gcd(a,b)}$</p>
<h4 id="二元一次不定方程"><a href="#二元一次不定方程" class="headerlink" title="二元一次不定方程"></a>二元一次不定方程</h4><p>因此这里有一道模板题<a href="https://www.luogu.com.cn/problem/P5656">【模板】二元一次不定方程</a>，要求求出一个一般的二元一次不定方程的根，还添加了若干要求：</p>
<ul>
<li>如果无整数解，则输出-1</li>
<li>否则如果没有正整数解，则输出最小的正整数x和最小的正整数y</li>
<li>否则输出正整数解的数量、最小的x和最小的y、最大的x和最大的y</li>
</ul>
<p>题解：</p>
<p>无整数解很简单，就是不满足裴蜀定理嘛，这里不多说</p>
<p>如何判断没有正整数解：由上面推出的公式可以发现，解x和y是此消彼长的关系，因此当x取最小正整数时，如果y非正了，那么就没有正整数解，否则就有，同理y也一样</p>
<p>如何求正整数解的个数：由上面推出的公式可以很容易得出最小的正整数x（即$把exgcd的x解mod\frac{b}{gcd(a,b)}$，但是记得如果得0了要加一个模数把它调正了），而最大正整数x就是y取最小正整数的时候的x，如法炮制一遍就行啦，最后的个数就是$\frac{x<em>{min}-x\</em>{max}}{\frac{b}{gcd(a,b)}}+1$（纸上写写就动了）</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-function">ll <span class="hljs-title">gcd</span><span class="hljs-params">(ll a,ll b)</span></span>&#123;<br>	<span class="hljs-keyword">return</span> b==<span class="hljs-number">0</span>?a:<span class="hljs-built_in">gcd</span>(b,a%b);<br>&#125;<br>ll x,y,a,b,c;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(ll a,ll b)</span></span>&#123; <span class="hljs-comment">//exgcd</span><br>	<span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)&#123;<br>		x=<span class="hljs-number">1</span>,y=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-built_in">exgcd</span>(b,a%b);<br>	ll tx=x,ty=y;<br>	x=ty;<br>	y=tx-a/b*ty;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> t;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<br>	<span class="hljs-keyword">while</span>(t--)&#123;<br>		x=<span class="hljs-number">0</span>,y=<span class="hljs-number">0</span>;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>,&amp;a,&amp;b,&amp;c);<br>		ll g=<span class="hljs-built_in">gcd</span>(a,b);<br>		<span class="hljs-keyword">if</span>(c%g!=<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//无解</span><br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);<br>			<span class="hljs-keyword">continue</span>;<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>		a/=g,b/=g,c/=g;<br>		<span class="hljs-built_in">exgcd</span>(a,b);<br>		x*=c,y*=c; <span class="hljs-comment">//求特解</span><br>		ll minx=(x%b+b)%b;<br>		<span class="hljs-keyword">if</span>(!minx) minx+=b; <span class="hljs-comment">//调正</span><br>		ll miny=(y%a+a)%a;<br>		<span class="hljs-keyword">if</span>(!miny) miny+=a; <span class="hljs-comment">//同上</span><br>		ll maxy=(c-(a*minx))/b;<br>		ll maxx=(c-(b*miny))/a;<br>		ll cnt=(maxx-minx)/b+<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">if</span>(cnt) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld %lld %lld %lld\n&quot;</span>,cnt,minx,miny,maxx,maxy);<br>		<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>,minx,miny);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="线性求逆元"><a href="#线性求逆元" class="headerlink" title="线性求逆元"></a>线性求逆元</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>给定$n,p$，求$[1,n]$中所有整数在模$p$意义下的乘法逆元</p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><script type="math/tex; mode=display">
\begin{aligned}
&枚举变量i:1\rightarrow n\\
&利用[1,i-1]的逆元去求i的逆元\\
&不妨令p=ki+b,\\
&于是有ki+b\equiv 0(mod\ p)\\
&移项得-ki\equiv b(mod\ p)\\
&左右两侧同时乘i^{-1}b^{-1}得\\
&i^{-1}\equiv -kb^{-1}(mod\ p)\\
&其中k=[\frac{p}{i}],b=p\%i< i\\
&因此b^{-1}在之前已经求完了，可以直接使用\\
&得出i^{-1}=-[\frac{p}{i}]\cdot (p\%i)^{-1}\\
&由于出现了负号,需要转正\\
&得出答案i^{-1}=(p-[\frac{p}{i}])\cdot (p\%i)^{-1}
\end{aligned}</script><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><p>对应题目<a href="https://www.luogu.com.cn/problem/P3811">【模板】乘法逆元</a></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">int</span> inv[<span class="hljs-number">3000005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> n,p;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;p);<br>	inv[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>,inv[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1\n&quot;</span>);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>		inv[i]=(ll)(p-p/i)*inv[p%i]%p;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,inv[i]);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="阶乘逆元"><a href="#阶乘逆元" class="headerlink" title="阶乘逆元"></a>阶乘逆元</h3><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>如何求出$[1,n]$各数阶乘的逆元呢？</p>
<h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><script type="math/tex; mode=display">
考虑先求出n!的逆元(n!)^{-1},则有\\
n!\cdot(n!)^{-1}=1\\
将n!展开,得到(n-1)!\cdot n\cdot(n!)^{-1}=1\\
则((n-1)!)^{-1}=n\cdot (n!)^{-1}</script><p>这样一来，就可以倒着递推一遍就可以了</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">get_inv</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-type">int</span> base=x,ans=<span class="hljs-number">1</span>;<br>    y-=<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span>(y&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) ans=(ll)ans*base%mod;<br>        base=(ll)base*base%mod;<br>        y&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> ifac[N],fac=<span class="hljs-number">1</span>,mod;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++) <br>        fac=(ll)fac*i % mod;<br>    ifac[n]=<span class="hljs-built_in">get_inv</span>(fac, mod);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) <br>        ifac[i]=(ll)ifac[i+<span class="hljs-number">1</span>]*(i+<span class="hljs-number">1</span>)%mod;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="逆元小结"><a href="#逆元小结" class="headerlink" title="逆元小结"></a>逆元小结</h3><ul>
<li>欧拉定理法（核心公式$a^{\varphi(p)}\equiv 1(mod\ p)$）<ul>
<li>衍生：$a^b=a^{b\%\varphi(p)}$（$a,p$互质）</li>
<li>扩展欧拉定理：在$b\geq \varphi(p)时,$$a^b\equiv a^{b\%\varphi(p)+\varphi(p)}(mod\ p)$</li>
</ul>
</li>
<li>拓展gcd（核心公式$ax+by=bx’+(a\%b)y’$）<ul>
<li>衍生：对任意不定方程$ax+by=c$的解法</li>
</ul>
</li>
<li>线性求逆元（对固定模p）（核心公式p=ki+b）<ul>
<li>注意转正</li>
</ul>
</li>
<li>阶乘逆元（核心公式$(n-1)!\cdot n\cdot(n!)^{-1}=1$）</li>
</ul>
<h2 id="中国剩余定理及其扩展"><a href="#中国剩余定理及其扩展" class="headerlink" title="中国剩余定理及其扩展"></a>中国剩余定理及其扩展</h2><h3 id="中国剩余定理（CRT）"><a href="#中国剩余定理（CRT）" class="headerlink" title="中国剩余定理（CRT）"></a>中国剩余定理（CRT）</h3><p><a href="https://www.luogu.com.cn/problem/P1495">洛谷P1495 【模板】中国剩余定理(CRT)/曹冲养猪</a></p>
<h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>中国剩余定理（孙子定理，Chinese remainder theorem，简称CRT）是中国古代用来求解一次同余式方程组的一种算法，一次同余方程组的数学语言表达如下：</p>
<script type="math/tex; mode=display">
\begin{cases}
    x\equiv a_1(\mod b_1)\\
    x\equiv a_2(\mod b_2)\\
    ......\\
    x\equiv a_n(\mod b_n)\\
\end{cases}</script><p>中国剩余定理成立的前提是：<strong>$b_i$两两互质</strong>，在满足此条件的前提下，可以通过构造得出该方程的解：</p>
<script type="math/tex; mode=display">
x=\left(\sum_{i=1}^{n}{a_it_iM_i}\right)\mod M\\
其中,M=\prod_{i=1}^{n}{b_i}\\
M_i=\frac{M}{b_i}\\
t_i={M_i}^{-1} \mod b_i\\</script><h4 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h4><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200612132505697.png" alt="image-20200612132505697"></p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">crt</span><span class="hljs-params">()</span></span>&#123;<br>    ll M=<span class="hljs-number">1</span>, res=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) M*=b[i];<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n)&#123;<br>        ll Mi=M/b[i];<br>        ll x,y;<br>        <span class="hljs-built_in">exgcd</span>(Mi,b[i],x,y);<br>        res=(res+a[i]*Mi*ti)%M;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (res%M+M)%M;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="扩展中国剩余定理（EXCRT）"><a href="#扩展中国剩余定理（EXCRT）" class="headerlink" title="扩展中国剩余定理（EXCRT）"></a>扩展中国剩余定理（EXCRT）</h3><p>CRT只能够解模数两两互质的情形，那么对于一般的模数不互质的情况，又如何求解呢？</p>
<h4 id="解法思路"><a href="#解法思路" class="headerlink" title="解法思路"></a>解法思路</h4><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200612133108360.png" alt="image-20200612133108360"></p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// O1快速乘</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">multi</span><span class="hljs-params">(ll x,ll y,ll Mod)</span></span>&#123;<br>	ll tmp=(x*y-(ll)((<span class="hljs-type">long</span> <span class="hljs-type">double</span>)x/Mod*y+<span class="hljs-number">1.0e-8</span>)*Mod);<br>	<span class="hljs-keyword">return</span> tmp&lt;<span class="hljs-number">0</span> ? tmp+Mod : tmp;<br>&#125;<br><br><span class="hljs-comment">// x = a[i] (mod b[i]) b[i]不互质</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">excrt</span><span class="hljs-params">()</span></span>&#123;<br>	ll ans=a[<span class="hljs-number">1</span>],M=b[<span class="hljs-number">1</span>];<span class="hljs-comment">// 特判第一个方程</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>		ll aa=M,bb=b[i];<br>		ll cc=(a[i]-ans%bb+bb)%bb;<span class="hljs-comment">// aa*x=cc(mod bb)</span><br>		ll x,y;<br>		ll g=<span class="hljs-built_in">exgcd</span>(aa,bb,x,y),bg=bb/g;<br>		<span class="hljs-keyword">if</span>(cc%g) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">// 无解</span><br>		x=<span class="hljs-built_in">multi</span>(cc/g,x,bg);<span class="hljs-comment">// 防爆long long</span><br>		ans+=x*M;<br>		M*=bg;<br>		ans=(ans%M+M)%M;<br>	&#125;<br>	<span class="hljs-keyword">return</span> (ans%M+M)%M;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="大步小步算法"><a href="#大步小步算法" class="headerlink" title="大步小步算法"></a>大步小步算法</h2><p>大步小步算法（Baby Step Giant Step，简称BSGS <del>拔山盖世</del>）是用来寻找<strong>离散对数</strong>（即模意义下的对数）的常用算法，具体来说，分为普通的BSGS算法和扩展BSGS，下面一一介绍</p>
<h3 id="BSGS"><a href="#BSGS" class="headerlink" title="BSGS"></a>BSGS</h3><p>对于形如$ax\equiv b(\mod p)$的同余方程已经有<strong>扩展欧几里得算法</strong>的通用解法了，然而，对于形如$a^x\equiv b(\mod p)$的同余方程又该如何求解呢？</p>
<p>模板题链接：<a href="https://www.luogu.com.cn/problem/P3846">洛谷P3846 [TJOI2007] 可爱的质数/【模板】BSGS</a></p>
<p>题意：求解最小的$x$，满足$a^x\equiv b(\mod p)$，其中，$2\le a,b&lt;p&lt;2^{31}$，<strong>且$p$为质数</strong></p>
<p>算法思路：看到这样的指数形式同余式，容易联想到欧拉定理，即$a^{\varphi(p)}\equiv 1(\mod p)$，其中$p$为质数，同时，又有$a^0\equiv 1(\mod p)$，因此容易得到 $a^x$ 有一个长度为$a^{\varphi(p)}$的循环节，当$x&gt;\varphi(x)$后，对应的等号右侧开始循环，因此，要求得最小解，只需要暴力枚举$x$到$\varphi(p)$即可，有因为$p$为质数，因此$\varphi(p)=p-1$，枚举范围为$[0,p-2]$，间复杂度$O(p)$，可以得零分（划掉）</p>
<p>我们发现这个数据范围线性复杂度是不够用的，需要一个根号算法，我们考虑将$x$分解开，令$x=i\cdot m-k$，上式化为$a^{i\cdot m}\equiv ba^k(\mod p)$，这样一来，可以通过预先哈希掉等号右侧的数的可能取值，然后枚举等号左侧的值找哈希表中是否存在过即可，显然这里$m$取$\sqrt p$时能够确保$i\cdot m+k$枚举到所有的$[0,p-2]$的值，因此复杂度为$O(\sqrt p)$</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// a^x = b (mod p) &lt;=&gt; a^(im) = b * a^k (mod p)</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">BSGS</span><span class="hljs-params">(ll a,ll b,ll p)</span></span>&#123;<br>	unordered_map&lt;ll,ll&gt; ma;<span class="hljs-comment">// hash table</span><br>	ll m=<span class="hljs-built_in">ceil</span>(<span class="hljs-built_in">sqrt</span>(p));<br>	<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">0</span>,cur=b%p;i&lt;=m;i++,cur=cur*a%p)<br>		ma[cur]=i;<br>	ll am=<span class="hljs-built_in">qpow</span>(a,m,p);<br>	<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>,now=am;i&lt;=m;i++,now=now*am%p)&#123;<br>		<span class="hljs-keyword">if</span>(ma.<span class="hljs-built_in">count</span>(now)) <span class="hljs-keyword">return</span> (i*m-ma[now]+p)%p;<span class="hljs-comment">// x</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">// no solution</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="EXBSGS"><a href="#EXBSGS" class="headerlink" title="EXBSGS"></a>EXBSGS</h3><p>我们可以发现，BSGS是基于欧拉定理的暴力算法的优化，因此只能够处理$\gcd(a,p)=1$的情况，对于更加一般的离散对数求法，我们需要将BSGS进行扩展，得到<strong>扩展BSGS算法</strong></p>
<p>模板题链接：<a href="https://www.luogu.com.cn/problem/P4195">洛谷P4195 【模板】扩展BSGS</a></p>
<p>题意：求满足$a^x\equiv b(\mod p)$的最小自然数$x$，其中，$a,p,b\le 10^9$</p>
<p>算法思路：此时若$\gcd(a,p)\neq 1$，就无法使用BSGS算法了，考虑令$g=\gcd(a,p)$，同时，上式可以转化为 $a\cdot a^{x-1}+p\cdot k\equiv b$，由<strong>裴蜀定理</strong>可知：这个式子有整数解当且仅当$g|b$，若有解，上式又可以转化为$a^{x-1}\cdot \frac{a}{g}+\frac{p}{g}\cdot k\equiv \frac{b}{g}$，即$a^{x-1}\cdot \frac{a}{g}\equiv \frac{b}{g}(\mod \frac{p}{g})$，令$a’=\frac{a}{g},(a’)^{-1}=(\frac{a}{g})^{-1}$，则得出$a^{x-1}\equiv \frac{b}{g}\cdot (a’)^{-1}(\mod \frac{p}{g})$，此时，可以将这个式子作为新的求解方程，用同样的方法求解，这是一个递归的过程，直到$\gcd(a,p)=1$时，就可以使用BSGS求解了</p>
<p>容易得出，最终的方程是形如下式的同余方程：</p>
<script type="math/tex; mode=display">
a^{x-k}\equiv \frac{b}{\prod_{i=1}^k{g_i}}\cdot \left(\prod_{i=1}^k{a_i'}\right)^{-1}(\mod \frac{p}{\prod_{i=1}^k{g_i}})</script><p>在得出可以用BSGS的方程后，先求出$\left(\prod_{i=1}^k{a_i’}\right)^{-1}$，然后BSGS求出对应的解，注意这里求出的解为$x’=x-k$的值，因此，如果有解则最终的解应该为$x’+k$</p>
<p>注意事项：</p>
<ul>
<li><p>在算法开始前，需要注意一下特判$b=1$的情况，直接输出$x=1$即可</p>
</li>
<li><p>在EXGSGS中，如果遇到</p>
<script type="math/tex; mode=display">
\prod_{i=1}^k{a_i'}=\frac{b}{\prod_{i=1}^k{g_i}}</script><p>则$a^{x-k}=1$，即直接输出$k$即可</p>
</li>
<li><p>好事多模（很重要）</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// a^x = b (mod p) &lt;=&gt; a^(x-k) * a/prod(g) = b/prod(g) (mod p/prod(g))</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">EXBSGS</span><span class="hljs-params">(ll a,ll b,ll p)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(b==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// a^x = 1 (mod p)</span><br>	ll g,k=<span class="hljs-number">0</span>,ag=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">while</span>((g=<span class="hljs-built_in">gcd</span>(a,p))&gt;<span class="hljs-number">1</span>)&#123;<br>		<span class="hljs-keyword">if</span>(b%g) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">// no solution</span><br>		k++,b/=g,p/=g,ag=ag*(a/g)%p;<br>		<span class="hljs-keyword">if</span>(ag==b) <span class="hljs-keyword">return</span> k;<span class="hljs-comment">// a^(x-k)=1</span><br>	&#125;<br>	ll inv,y;<br>	<span class="hljs-built_in">exgcd</span>(ag,p,inv,y);<span class="hljs-comment">// get inv of ag</span><br>	inv=(inv+p)%p;<br>	ll res=<span class="hljs-built_in">BSGS</span>(a,b*inv%p,p);<span class="hljs-comment">// BSGS</span><br>	<span class="hljs-keyword">return</span> res==<span class="hljs-number">-1</span>?res:res+k;<span class="hljs-comment">// solution + k</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="素数筛法"><a href="#素数筛法" class="headerlink" title="素数筛法"></a>素数筛法</h2><h3 id="埃氏筛法"><a href="#埃氏筛法" class="headerlink" title="埃氏筛法"></a>埃氏筛法</h3><h4 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h4><ul>
<li>从2开始枚举范围内每一个数，碰到是素数的就把他加入到素数表里，然后从这个素数开始把它的所有在范围内的倍数筛去即可</li>
<li>优化：每次筛去时可以直接从$i^2$开始枚举，因为之前的数都已经在以前的$i$的循环里被筛去了</li>
<li>时间复杂度为$O(nlogn)$，不是很给力，但够用了（至少比每次都判一遍素数那个方法靠谱）</li>
</ul>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">f[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>f[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">// 0 and 1 is not prime</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">if</span>(f[i]==<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//if i is prime number</span><br>        prime[++cnt]=i; <span class="hljs-comment">// add</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i*i;j&lt;=n;j+=i)&#123; <span class="hljs-comment">//filter</span><br>            f[j]=<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h3><h4 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>同样从2开始枚举范围内每一个数，碰到素数就加入素数表里，之后再从当前的$i$开始筛去合数，筛掉的每个合数满足的条件为</p>
<ul>
<li>最小质因数*最大因数（非自己）=这个合数</li>
<li>保证每一个合数都只会被这个方法筛掉一次</li>
</ul>
</li>
<li><p>时间复杂度为$O(n)$，非常给力</p>
</li>
</ul>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">f[<span class="hljs-number">0</span>]=f[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">if</span>(f[i]==<span class="hljs-number">0</span>)<br>        prime[++cnt]=i;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=n;j++)&#123;<br>        f[i*prime[j]]=<span class="hljs-number">1</span>; <span class="hljs-comment">//保证每个数被自己的最小质因数筛掉</span><br>        <span class="hljs-keyword">if</span>(i%prime[j]==<span class="hljs-number">0</span>) <span class="hljs-comment">//保证线性，保证只被最小质因数筛一次</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>代码中有一个最难理解的部分<code>if(i%prime[j]==0 break;</code>，这一句的意义在于保证了每个合数只被自己最小的质因数筛掉了唯一一次（保证了线性）</p>
<p>举个例子，设$i=p_1^{k_1}p_2^{k_2}…p_n^{k_n}$，如果上一步中没有及时<code>break</code>，那么<code>j</code>就会在达到$p_1$时继续往后累加，比如说打到了$p_2$，那么此时的合数的最小质因数就是$p_2$了，而$p_2&gt;p_1$，如果在此刻筛掉<code>i*prime[j]</code>，则违背了每个合数只被它的最小质因数筛去一次的原则</p>
<h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>欧拉函数$\varphi (x)$表示<strong>小于$x$的整数中与$x$互素的数的个数</strong>，特殊的$\varphi (1)=1$</p>
<h4 id="递推式"><a href="#递推式" class="headerlink" title="递推式"></a>递推式</h4><script type="math/tex; mode=display">
\varphi (x)=x\cdot\prod_{i=1}^{n}\left({1-\frac{1}{p_i}}\right)\\其中，p_1,p_2,...,p_n为x的所有质因数（不为0的整数）</script><h4 id="一些性质"><a href="#一些性质" class="headerlink" title="一些性质"></a>一些性质</h4><p>（这里只摘取一些比较简单的性质）</p>
<ol>
<li><p>如果$p$为素数，则$\varphi (p)=p-1$（很容易理解，素数除了它本身之外小于它的数都与它互素）</p>
</li>
<li><p>欧拉函数在满足一定条件下是积性函数：</p>
<p>当$m$,$n$为素数时，有$\varphi (m * n)=\varphi (m) * \varphi (n)$</p>
</li>
</ol>
<p>等等。。。</p>
<h4 id="求一个数的欧拉函数值（复杂度-O-sqrt-n-）"><a href="#求一个数的欧拉函数值（复杂度-O-sqrt-n-）" class="headerlink" title="求一个数的欧拉函数值（复杂度$O(\sqrt n)$）"></a>求一个数的欧拉函数值（复杂度$O(\sqrt n)$）</h4><p>直接根据定义求即可，给出代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// get phi[n]</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">getphi</span><span class="hljs-params">(ll n)</span></span>&#123;<br>	ll res=n;<br>	<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">2</span>;i*i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>) res=res/i*(i<span class="hljs-number">-1</span>);<br>		<span class="hljs-keyword">while</span>(n%i==<span class="hljs-number">0</span>) n/=i;<br>	&#125;<br>	<span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">1</span>) res=res/n*(n<span class="hljs-number">-1</span>);<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="利用欧拉筛法筛出区间-1-n-所有数的欧拉函数（复杂度-O-n-）"><a href="#利用欧拉筛法筛出区间-1-n-所有数的欧拉函数（复杂度-O-n-）" class="headerlink" title="利用欧拉筛法筛出区间$[1,n]$所有数的欧拉函数（复杂度$O(n)$）"></a>利用欧拉筛法筛出区间$[1,n]$所有数的欧拉函数（复杂度$O(n)$）</h4><p>在筛法中，有三种情况需要讨论：</p>
<ol>
<li><p><code>i</code>是个质数：</p>
<p>此时，<code>phi[i]=i-1</code>即可</p>
</li>
<li><p><code>i%prime[j]==0</code>：</p>
<p>此时，<code>phi[i]</code>已经有包含了<code>prime[j]</code>的所有素因数，即<code>phi[i]</code>和<code>phi[i*prime[j]]</code>的推导式内的质因子种类是一样的，只不过<code>i*prime[j]</code>会比<code>i</code>多出一个<code>prime[j]</code>作为素因数，有下式成立：</p>
<script type="math/tex; mode=display">
\varphi(i)=i*(1-\frac{1}{p_1})(1-\frac{1}{p_2})...(1-\frac{1}{p_k})\\
\varphi(i*prime[j])=i*prime[j]*(1-\frac{1}{p_1})(1-\frac{1}{p_2})...(1-\frac{1}{p_k})\\</script><p>很容易看出</p>
<script type="math/tex; mode=display">
\varphi(i*prime[j])=\varphi(i)*prime[j]</script></li>
<li><p><code>i%prime[j]!=0</code>：</p>
<p>此时，<code>phi[i]</code>中没有<code>pirme[j]</code>这个质因子，但<code>prime[j]</code>又是满足<code>i*prime[j]</code>这个合数的最小质因子，我们得到下式</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\varphi(i*prime[j])=i*prime[j]*(1-\frac{1}{p_j})(1-\frac{1}{p_1})(1-\frac{1}{p_2})...(1-\frac{1}{p_k})\\
&\Rightarrow \varphi(i*prime[j])=\varphi(i)*prime[j]*(1-\frac{1}{p_j})\\
&化简即可得出\varphi(i*prime[j])=\varphi(i)*(prime[j]-1)\\
&即\varphi(i*prime[j])=\varphi(i)*\varphi(prime[j])
\end{aligned}</script></li>
</ol>
<p>由情况3，可以得出欧拉函数是一个不完全积性函数的特性</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">euler</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    phi[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>; <span class="hljs-comment">//欧拉函数特例</span><br>    f[<span class="hljs-number">0</span>]=f[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>; <span class="hljs-comment">//0和1都不是素数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(f[i]==<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//如果该数是素数</span><br>            prime[++cnt]=i; <span class="hljs-comment">//计入素数数组</span><br>            phi[i]=i<span class="hljs-number">-1</span>; <span class="hljs-comment">//情况1</span><br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=n;j++)&#123; <span class="hljs-comment">//欧拉筛核心代码</span><br>            f[i*prime[j]]=<span class="hljs-number">1</span>; <span class="hljs-comment">//筛去</span><br>            <span class="hljs-keyword">if</span>(i%prime[j]==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">//情况2</span><br>                phi[i*prime[j]]=phi[i]*prime[j]; <br>                <span class="hljs-keyword">break</span>; <span class="hljs-comment">//核心</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//情况3，欧拉函数是对于素数的积性函数</span><br>                phi[i*prime[j]]=phi[i]*phi[prime[j]];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>快速分解质因数</p>
<p>在欧拉筛内部循环，加入如下代码</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=n;j++)&#123;<br>    from[i*prime[j]]=prime[j];<br>    ...<br>&#125;         <br></code></pre></div></td></tr></table></figure>
<p>记录每个数的最小质因数，随后查询一个数<code>x</code>的质因数时，只需要每次求出<code>from[x]</code>，然后继续求<code>from[x/from[x]]</code>，写个循环或者递归即可</p>
<h4 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h4><p><a href="https://www.luogu.com.cn/problem/P2158">洛谷 P2158 仪仗队</a></p>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><p>自己在纸上画一画会发现题目意思就是找到一个$n*n$的矩阵里面有多少个点和坐标原点连起来的斜率不同，进而又可以转换成就其中有多少个点的坐标(x,y)满足x与y互素，因为如果不互素的话，就会出现(x/gcd(x,y),y/gcd(x,y))这样的点挡住他们</p>
<p>我们把矩阵沿着对角线切一刀，去掉对角线的一个点（2，2），剩下的就是算一个三角形内部有多少这样的点对，算好之后最终答案就是（2*ans+1），于是可以想到用欧拉函数来求</p>
<p>显然答案就是$\sum_{i=1}^{n-1}(\varphi (i))$</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> f[<span class="hljs-number">40005</span>],prime[<span class="hljs-number">40005</span>],ans[<span class="hljs-number">40005</span>],cnt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  cin&gt;&gt;n;<br>  <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<br>    cout&lt;&lt;<span class="hljs-number">0</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  ans[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>  f[<span class="hljs-number">0</span>]=f[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123; <span class="hljs-comment">//欧拉筛欧拉函数</span><br>    <span class="hljs-keyword">if</span>(f[i]==<span class="hljs-number">0</span>)&#123;<br>      prime[++cnt]=i;<br>      ans[i]=i<span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=n;j++)&#123;<br>      f[i*prime[j]]=<span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">if</span>(i%prime[j]==<span class="hljs-number">0</span>)&#123;<br>        ans[i*prime[j]]=ans[i]*prime[j];<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>        ans[i*prime[j]]=ans[i]*ans[prime[j]];<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123; <span class="hljs-comment">//累加</span><br>    ans[i]=ans[i]+ans[i<span class="hljs-number">-1</span>];<br>  &#125;<br>  cout&lt;&lt;ans[n<span class="hljs-number">-1</span>]*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>&lt;&lt;endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h2 id="数论分块（整除分块）"><a href="#数论分块（整除分块）" class="headerlink" title="数论分块（整除分块）"></a>数论分块（整除分块）</h2><h3 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h3><p><strong>整除分块</strong>是用来求解形如下式的整除求和式的算法，朴素算法很容易想到，即遍历一遍$[1,n]$求解即可，时间复杂度为$O(n)$，而整除分块的处理能够使得复杂度上界优化到$O(\sqrt n)$</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{n}\lfloor\frac{k}{i}\rfloor</script><p>其实数论分块最终就是一个实用结论，其结论为：上式的整除求和式中$\lfloor\frac{k}{i}\rfloor$最多只有$O(\sqrt n)$种取值，且相同的取值总是<strong>连续地一块一块出现</strong>的，因此称之为分块，那么具体如何分块呢？</p>
<p>经过数学推导，可以知道，对于区间$[1,n]$内的一个左端点$l$，其整除值为$\lfloor\frac{k}{l}\rfloor$，那么就有一段连续的区间整除值与这一块相同，其区间右边界为$\min(n,\lfloor{\frac{k}{\lfloor\frac{k}{l}\rfloor}}\rfloor)$，当然，如果$\lfloor\frac{k}{l}\rfloor=0$，则右边界显然就是$n$（因为此后分母都比分子大了，答案就都是0）</p>
<h3 id="证明-2"><a href="#证明-2" class="headerlink" title="证明"></a>证明</h3><p>证明选自 <a href="https://www.luogu.com.cn/problem/solution/P2261">题解： P2261 [CQOI2007]余数求和</a></p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200612135223242.png" alt="image-20200612135223242"></p>
<p>（但其实这个规律打个表也能发现）</p>
<h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=,r;l&lt;=n;l=r+<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-type">int</span> tp=k/l;<br>    <span class="hljs-keyword">if</span>(tp) r=<span class="hljs-built_in">min</span>(n,k/tp);<br>    <span class="hljs-keyword">else</span> t=n;<br>   	ans+=(r-l+<span class="hljs-number">1</span>)*tp;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>就是这么简单</p>
<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p><a href="https://www.luogu.com.cn/problem/P2261">P2261 [CQOI2007]余数求和</a>（取余式转换+数论分块）</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">ll n,k,ans;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">read</span>(n),<span class="hljs-built_in">read</span>(k);<br>    <span class="hljs-keyword">for</span>(ll l=<span class="hljs-number">1</span>,r;l&lt;=n;l=r+<span class="hljs-number">1</span>)&#123;<br>        ll tp=k/l;<br>        <span class="hljs-keyword">if</span>(tp) r=<span class="hljs-built_in">min</span>(k/tp,n);<br>        <span class="hljs-keyword">else</span> r=n;<br>        ans+=(l+r)*(r-l+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>*tp;<br>    &#125;<br>    ans=n*k-ans;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<p><a href="https://www.luogu.com.cn/problem/P2260">P2260 [清华集训2012]模积和</a>（数学推导+前缀和+数论分块）</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">ll n,m,inv2,ans,inv6,x,y;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">f</span><span class="hljs-params">(ll a,ll b)</span></span>&#123;<br>	ll res=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(ll l=<span class="hljs-number">1</span>,r;l&lt;=a;l=r+<span class="hljs-number">1</span>)&#123;<br>		ll tp=b/l;<br>		<span class="hljs-keyword">if</span>(tp) r=<span class="hljs-built_in">min</span>(b/tp,a);<br>		<span class="hljs-keyword">else</span> r=a;<br>		res=(res%mod+(r-l+<span class="hljs-number">1</span>)%mod*(r+l)%mod*inv2%mod*tp%mod+mod)%mod;<br>	&#125;<br>	<span class="hljs-keyword">return</span> (res%mod+mod)%mod;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">sum</span><span class="hljs-params">(ll x)</span></span>&#123;<br>	x%=mod;<br>	<span class="hljs-keyword">return</span> (x%mod*(x+<span class="hljs-number">1</span>)%mod*((x+x)%mod+<span class="hljs-number">1</span>)%mod*inv6%mod+mod)%mod;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">exgcd</span><span class="hljs-params">(ll a,ll b,ll &amp;x,ll &amp;y)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(!b)&#123;x=<span class="hljs-number">1</span>,y=<span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> a;&#125;<br>	ll res=<span class="hljs-built_in">exgcd</span>(b,a%b,x,y);<br>	ll tx=x;x=y;y=tx-a/b*y;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> main</span><br><span class="hljs-function">	<span class="hljs-title">read</span><span class="hljs-params">(n)</span>,<span class="hljs-title">read</span><span class="hljs-params">(m)</span></span>;<br>	<span class="hljs-keyword">if</span>(n&gt;m) <span class="hljs-built_in">swap</span>(n,m);<br>	<span class="hljs-built_in">exgcd</span>(<span class="hljs-number">2</span>,mod,x,y);<br>	inv2=(x+mod)%mod;<br>	x=<span class="hljs-number">0</span>,y=<span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">exgcd</span>(<span class="hljs-number">6</span>,mod,x,y);<br>	inv6=(x+mod)%mod;<br>	<br>	ll fnn=<span class="hljs-built_in">f</span>(n,n)%mod;<br>	ll fmm=<span class="hljs-built_in">f</span>(m,m)%mod;<br>	ll fnm=<span class="hljs-built_in">f</span>(n,m)%mod;<br><br>	ll aa=(n*n%mod-fnn%mod+mod)%mod;<br>	ll bb=(m*m%mod-fmm%mod+mod)%mod;<br>	ans=aa*bb%mod;<br>	ans=(ans-n*n%mod*m%mod+mod)%mod;<br>	ans=(ans+m*fnn%mod+mod)%mod;<br>	ans=(ans+n*fnm%mod+mod)%mod;<br>	<span class="hljs-keyword">for</span>(ll l=<span class="hljs-number">1</span>,r;l&lt;=n;l=r+<span class="hljs-number">1</span>)&#123;<br>		r=<span class="hljs-built_in">min</span>(n/(n/l),m/(m/l));<br>		ll tp=(<span class="hljs-built_in">sum</span>(r)%mod-<span class="hljs-built_in">sum</span>(l<span class="hljs-number">-1</span>)%mod+mod)%mod;<br>		ans=(ans-tp*(n/l)%mod*(m/l)%mod+mod)%mod;<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans%mod);<br>    <br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-comment">// https://www.luogu.com.cn/problem/P2260</span><br></code></pre></div></td></tr></table></figure>

</details>

<p><a href="https://www.luogu.com.cn/problem/P6583">P6583 回首过去</a>（数论+数论分块+容斥）</p>
<p>题意： 给出一个正整数$n$，求有序整数对$(x,y)$的个数，满足$1\le x,y\le n$，且$\frac{x}{y}$可以表示为十进制有限小数</p>
<p>题解： 一道数论好题，首先能想到十进制有限小数的分母一定只含有$2,5$两个质因子，因此满足提议的分数一定可以写成$\frac{bc}{2^p5^qc}$的形式，这样一来，可以$[1,n]$枚举分母，然后去掉$2,5$的因子从而获得$c$，最后获得$b$即可算出答案，复杂段接近$O(n)$，只能拿80分</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-type">int</span> tp=i;<br>    <span class="hljs-keyword">while</span>(tp%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) tp/=<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span>(tp%<span class="hljs-number">5</span>==<span class="hljs-number">0</span>) tp/=<span class="hljs-number">5</span>;<br>    ans+=n/tp;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<p>进一步观察上方的式子，发现他是一个类似整除分块的式子，即</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n f(\lfloor\frac{n}{i}\rfloor)\cdot\left[\lfloor\frac{n}{i}\rfloor(i\%2\neq 0 且 i\%5\neq 0)\right]</script><p>其中，$f(x)$代表$[1,x]$中质因子只包含$2,5$的数的个数，这样一来，可以先预处理出$f(n)$，然后从小到大排个序，每次整除分块时从后往前寻找$f(\lfloor\frac{n}{i}\rfloor)$，更新答案，但是这里还需要注意一点，就是表达式中的$i$为不包含$2,5$两个因子的数，因此可以通过在整除分块时容斥来解决这一问题（减去$2,5$因子的数的个数，再加上$10$的因子的数的个数）</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">ll n,cnt,a[maxn],ans;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">read</span>(n);<br>	<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i*=<span class="hljs-number">2</span>)&#123;<br>		<span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">1</span>;i*j&lt;=n;j*=<span class="hljs-number">5</span>)&#123;<br>			a[++cnt]=i*j;<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">1</span>+cnt);<br>	ll now=cnt;<br>	<span class="hljs-keyword">for</span>(ll l=<span class="hljs-number">1</span>,r;l&lt;=n;l=r+<span class="hljs-number">1</span>)&#123;<br>		ll b=n/l;<br>		r=n/b;<br>		ll tp=r-l+<span class="hljs-number">1</span>;<br>		ll tp2=r/<span class="hljs-number">2</span>-(l<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;<br>		ll tp5=r/<span class="hljs-number">5</span>-(l<span class="hljs-number">-1</span>)/<span class="hljs-number">5</span>;<br>		ll tp10=r/<span class="hljs-number">10</span>-(l<span class="hljs-number">-1</span>)/<span class="hljs-number">10</span>;<br>		tp=tp-tp2-tp5+tp10;<br>		<span class="hljs-keyword">while</span>(a[now]&gt;b&amp;&amp;now) now--;<br>		ans+=tp*b*now;<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>最近公共祖先LCA</title>
    <url>/2020/04/28/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88LCA/</url>
    <content><![CDATA[<h2 id="最近公共祖先LCA的各种算法总结"><a href="#最近公共祖先LCA的各种算法总结" class="headerlink" title="最近公共祖先LCA的各种算法总结"></a><center>最近公共祖先LCA的各种算法总结</center></h2><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/u=1365587845,1055642733&amp;fm=26&amp;gp=0.jpg" alt="u=1365587845,1055642733&amp;fm=26&amp;gp=0"></p>
<span id="more"></span>
<h2 id="LCA（最近公共祖先）"><a href="#LCA（最近公共祖先）" class="headerlink" title="LCA（最近公共祖先）"></a>LCA（最近公共祖先）</h2><p>模板题链接：<a href="https://www.luogu.com.cn/problem/P3379">最近公共祖先（LCA）</a></p>
<p>LCA（最近公共祖先），顾名思义，就是一棵树中两个节点的一个<strong>公共的祖先</strong>，而这个祖先距离这两个节点是<strong>最近的</strong></p>
<p>关于求LCA的算法，前人已经总结出了很多种，大致分为以下几种：</p>
<ul>
<li>暴力求LCA（舍弃）</li>
<li>倍增算法求LCA</li>
<li>Tarjan算法求LCA（离线）</li>
<li>树链剖分求LCA</li>
</ul>
<p>这里逐一记录一下</p>
<h2 id="暴力求LCA"><a href="#暴力求LCA" class="headerlink" title="暴力求LCA"></a>暴力求LCA</h2><p>暴力算法不难想到，对于两个节点的LCA，我们可以先从一个节点出发，（一步一步地）标记出他到达根节点所走过的路径上的所有节点，再从另一个节点出发（一步一步地）往根节点走，走到过的第一个被标记过的节点就是他们俩的LCA，对于有n个节点和q次询问的树，时间复杂度为：$O(nq)$<del>（太鸡儿慢了）</del></p>
<h2 id="倍增求LCA"><a href="#倍增求LCA" class="headerlink" title="倍增求LCA"></a>倍增求LCA</h2><p>关于倍增算法，已经再熟悉不过了，Vector的实现、ST表 等，都是利用的倍增思想，将复杂度<strong>由线性级别转变为对数级别</strong>，是一个非常实用的优化算法思想</p>
<p>对于倍增求LCA，其实它就是暴力求LCA算法的一个优化（咱们不要一步一步往上爬，咱们一次跨$2^i$步），它是一个<strong>预处理+在线询问</strong>的算法，预处理复杂度为$O(nlogn)$，一次询问的复杂度为$O(logn)$，所以对于q次询问的操作来说，总复杂度为：$O(nlogn + qlogn)$</p>
<p>我们可以考虑开一个<code>fa[i][j]</code>数组，<strong>存储这棵树的第$i$号节点的第$2^{j}$个父亲</strong>，利用二进制的优势是倍增算法的核心，这样一来，我们可以利用一个简单的DP方程来完成这个数组的预处理过程：首先我们可以通过一趟DFS（或者BFS）得到对于每个节点$i$的对应<code>fa[i][0]</code>的值（即每个节点的直接父亲节点），以及每个节点的深度（depth）</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    vis[u]=<span class="hljs-number">1</span>;<span class="hljs-comment">//这个节点设置为走过</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>        <span class="hljs-type">int</span> v=e[i].v;<br>        <span class="hljs-keyword">if</span>(!vis[v])&#123;<br>            dep[v]=dep[u]+<span class="hljs-number">1</span>;<span class="hljs-comment">//深度+1</span><br>            fa[v][<span class="hljs-number">0</span>]=u;<span class="hljs-comment">//求出直接父亲</span><br>            <span class="hljs-built_in">dfs</span>(v);<span class="hljs-comment">//递归</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>然后通过如下转移方程即可完成状态转移<strong>（倍增求LCA的核心1）</strong>：</p>
<script type="math/tex; mode=display">
fa[i][j]=fa[fa[i][j-1]][j-1]\\
因为：2^j=2^{j-1}\cdot2^{j-1}</script><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init_lca</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">20</span>;i++)&#123;<br>    <span class="hljs-comment">//这里的20是一个上界的大致值（一般够用），其实应该等于log2(maxdepth)</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<span class="hljs-comment">//枚举树的节点数n</span><br>            fa[j][i]=fa[fa[j][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<span class="hljs-comment">//状态转移</span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure>
<p>预处理完毕了，接下来就是求LCA的操作了<strong>（倍增求LCA的核心2）</strong>：对于两个节点$x,y$来说，假设<code>dep[x]&gt;dep[y]</code>，我们需要先让两个节点的深度达到一致（先让更深的节点x不断往父节点跳，一次跳$\log_2(dep[x]-dep[y])$的距离），此时需要特判一下是否x和y就已经重合了，如果是，那说明这次询问的y就是x和y的LCA，直接返回即可，否则执行下一步：此后，再让x和y同时往上跳，只要每一刻他们的第$2^{i-1}$个父节点不一样，他们就可以跳到第$2^{i-1}$个父节点的位置成为这个父节点，循环下去，挑出循环后，由于此时x和y还未重合成为他们的LCA，但他们都只离LCA只有1个节点的距离（也就是说<strong>他们的LCA就是他们的直接父亲节点</strong>），因此最后的答案就是<code>fa[x][0]</code>（当然<code>fa[y][0]</code>也一样）</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">LCA</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(dep[x]&lt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-comment">//把x调为最深的一个</span><br>    <span class="hljs-keyword">while</span>(dep[x]&gt;dep[y])<br>        x=fa[x][<span class="hljs-built_in">int</span>(<span class="hljs-built_in">log2</span>(dep[x]-dep[y]))];<br>    <span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> x;<span class="hljs-comment">//y就是x、y的LCA</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">log2</span>(dep[x]);i&gt;=<span class="hljs-number">0</span>;i--)<span class="hljs-comment">//从x的深度的log2开始枚举</span><br>        <span class="hljs-keyword">if</span>(fa[x][i]!=fa[y][i])<span class="hljs-comment">//如果他们俩的该倍父亲不相等</span><br>            x=fa[x][i],y=fa[y][i];<span class="hljs-comment">//跳到这个父亲的位置上，继续循环下去</span><br>    <span class="hljs-keyword">return</span> fa[x][<span class="hljs-number">0</span>];<span class="hljs-comment">//返回直接父亲</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>当然，倍增LCA由于其独有的<strong>预处理</strong>操作（很像线段树的push_up操作），可以支持维护很多具有结合律的东西，如两节点间的最值、边权之和、点权之和 等，比较灵活</p>
<ul>
<li>倍增求LCA模板代码：</li>
</ul>
<details>
<summary>code</summary>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//略去头文件</span><br><span class="hljs-comment">//倍增LCA核心部分</span><br><span class="hljs-type">int</span> n,m,s,fa[maxn][<span class="hljs-number">21</span>],dep[maxn],cnt,head[maxn];<br><span class="hljs-type">bool</span> vis[maxn];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>	vis[u]=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(!vis[v])&#123;<br>			fa[v][<span class="hljs-number">0</span>]=u;<br>			dep[v]=dep[u]+<span class="hljs-number">1</span>;<br>			<span class="hljs-built_in">dfs</span>(v);<br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">LCA</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(dep[x]&lt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<br>	<span class="hljs-keyword">while</span>(dep[x]&gt;dep[y])&#123;<br>		x=fa[x][<span class="hljs-built_in">int</span>(<span class="hljs-built_in">log2</span>(dep[x]-dep[y]))];<br>	&#125;<br>	<span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> x;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">log2</span>(dep[x]);i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>		<span class="hljs-keyword">if</span>(fa[x][i]!=fa[y][i])&#123;<br>			x=fa[x][i],y=fa[y][i];<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> fa[x][<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>(),s=<span class="hljs-built_in">read</span>();<br>	<span class="hljs-built_in">init</span>();<br>	<span class="hljs-type">int</span> x,y;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>)&#123;<br>		x=<span class="hljs-built_in">read</span>(),y=<span class="hljs-built_in">read</span>();<br>		<span class="hljs-built_in">addedge</span>(x,y);<br>		<span class="hljs-built_in">addedge</span>(y,x);<br>	&#125;<br>	<span class="hljs-built_in">dfs</span>(s);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">20</span>)&#123;<br>		<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,n)&#123;<br>			fa[j][i]=fa[fa[j][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m)&#123;<br>		x=<span class="hljs-built_in">read</span>(),y=<span class="hljs-built_in">read</span>();<br>		<span class="hljs-built_in">write</span>(<span class="hljs-built_in">LCA</span>(x,y)),<span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h2 id="Tarjan算法求LCA（离线）"><a href="#Tarjan算法求LCA（离线）" class="headerlink" title="Tarjan算法求LCA（离线）"></a>Tarjan算法求LCA（离线）</h2><p>对于Tarjan算法，早在SCC（强连通分量）专题就已经有所耳闻了，但没想到的是它居然还能用来求LCA？！（Tarjan简直太巨了！%%%）</p>
<p>Tarjan求LCA是一种<strong>并査集维护+Tarjan离线处理</strong>的算法，由于并査集路径压缩具有近似于$O(1)$的复杂度，因此对于具有q次询问的操作，Tarjan求LCA的复杂度为：$O(q+n)$，可以说是非常优秀的离线算法了</p>
<p>核心思想：从根节点开始DFS每一个出边所连的节点，标记访问过，同时将u节点出边所连的节点v全部用并査集合并到其父亲u上，处理完一个节点的所有出边后，再遍历<strong>与该节点u相关联的每一个询问</strong>（用类似前向星的链表存储询问中两节点的关联，即<strong>再对询问建一个图</strong>），如果当前询问所关联的<strong>节点to已经被访问过了</strong>，则这个询问所对应的两个节点的LCA就是<code>find(to)</code>（证明略，其实就是利用的dfs回溯的特点，与Tarjan求SCC很像）</p>
<p>PS：并査集切记要初始化！！！</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">TarjanLCA</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<span class="hljs-comment">//Tarajn求LCA</span><br>	vis[u]=<span class="hljs-number">1</span>;<span class="hljs-comment">//标记过</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(!vis[v])&#123;<br>			<span class="hljs-built_in">TarjanLCA</span>(v);<span class="hljs-comment">//dfs下去</span><br>			Fa[<span class="hljs-built_in">find</span>(v)]=u;<span class="hljs-comment">//合并到父亲上</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=headq[u];~i;i=q[i].next)&#123;<span class="hljs-comment">//遍历每个相关的询问</span><br>		<span class="hljs-type">int</span> to=q[i].to;<br>		<span class="hljs-keyword">if</span>(vis[to])&#123;<span class="hljs-comment">//如果关联节点访问过</span><br>			ans[q[i].id]=<span class="hljs-built_in">find</span>(to);<span class="hljs-comment">//则LCA可直接得出，记得存到对应标号的答案里</span><br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>Tarjan求LCA模板代码</li>
</ul>
<details>
<summary>code</summary>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n,m,s,cnt,head[maxn];<br><span class="hljs-type">int</span> headq[maxn],qcnt,ans[maxn];<br><span class="hljs-type">bool</span> vis[maxn];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Q</span><span class="hljs-comment">//询问的结构体</span><br>&#123;<br>	<span class="hljs-type">int</span> to,next,id;<br>&#125;q[maxn];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">TarjanLCA</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>	vis[u]=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(!vis[v])&#123;<br>			<span class="hljs-built_in">TarjanLCA</span>(v);<br>			Fa[<span class="hljs-built_in">find</span>(v)]=u;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=headq[u];~i;i=q[i].next)&#123;<br>		<span class="hljs-type">int</span> to=q[i].to;<br>		<span class="hljs-keyword">if</span>(vis[to])&#123;<br>			ans[q[i].id]=<span class="hljs-built_in">find</span>(to);<br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>(),s=<span class="hljs-built_in">read</span>();<br>	<span class="hljs-built_in">init</span>();<br>	<span class="hljs-type">int</span> x,y;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>)&#123;<br>		x=<span class="hljs-built_in">read</span>(),y=<span class="hljs-built_in">read</span>();<br>		<span class="hljs-built_in">addedge</span>(x,y);<br>		<span class="hljs-built_in">addedge</span>(y,x);<br>	&#125;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m)&#123;<br>		x=<span class="hljs-built_in">read</span>(),y=<span class="hljs-built_in">read</span>();<br>		<span class="hljs-built_in">addask</span>(x,y,i);<br>		<span class="hljs-built_in">addask</span>(y,x,i);<br>	&#125;<br>	<span class="hljs-built_in">TarjanLCA</span>(s);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">write</span>(ans[i]),<span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>


<h2 id="树链剖分求LCA"><a href="#树链剖分求LCA" class="headerlink" title="树链剖分求LCA"></a>树链剖分求LCA</h2><p>终于轮到我们的树上操作の终极大杀器：<strong>树链剖分</strong> 登场了</p>
<p>树链剖分，顾名思义，就是将一棵树剖分成为一条一条的<strong>链</strong>（也就是序列），然后可以通过某种方式（通常为线段树）维护这一条条链的信息，那么也就成功维护了整棵树的信息了（详情见<u>我的树链剖分专题</u>，这里直接谈简单的树剖LCA）</p>
<p>树剖求LCA的方法类似于<strong>树上区间修改</strong>的操作，具体说来如下：对于一棵树上的两个点$x,y$，假设$x$<strong>所在链的顶端</strong>深度较深，则直接将$x$跳到它所在链的顶端的父亲节点，如此循环，直到$x,y$两点到达同一条链上，此时直接输出两者中深度较浅的节点的编号即可（这个节点就是$x,y$的LCA）</p>
<p>时间复杂度：$O(n)$剖分预处理，最坏$O(logn)$查询</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//略去头文件和一些模板</span><br><span class="hljs-comment">//树剖LCA</span><br><span class="hljs-type">int</span> n,m,r,x,y;<br><span class="hljs-type">int</span> dfsx,csdep[maxn],csid[maxn],csfa[maxn],csson[maxn],cstop[maxn],cssize[maxn];<br><br><span class="hljs-comment">// 第一次dfs：处理出 深度、父亲、子树大小、重儿子</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fath,<span class="hljs-type">int</span> depth)</span></span>&#123;<br>	csdep[u]=depth;<br>	csfa[u]=fath;<br>	cssize[u]=<span class="hljs-number">1</span>;<br>	<span class="hljs-type">int</span> maxsize=<span class="hljs-number">-1</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(v!=fath)&#123;<br>			<span class="hljs-built_in">dfs1</span>(v,u,depth+<span class="hljs-number">1</span>);<br>			cssize[u]+=cssize[v];<br>			<span class="hljs-keyword">if</span>(cssize[v]&gt;maxsize)<br>				maxsize=cssize[v],csson[u]=v;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// 第二次dfs：求出dfs序、dfs序对应初始值、节点所在链的顶端</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> topf)</span></span>&#123;<br>	csid[u]=++dfsx;<br>	cstop[u]=topf;<br>	<span class="hljs-keyword">if</span>(!csson[u]) <span class="hljs-keyword">return</span>;<br>	<span class="hljs-built_in">dfs2</span>(csson[u],topf);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(v!=csfa[u]&amp;&amp;v!=csson[u])&#123;<br>			<span class="hljs-built_in">dfs2</span>(v,v);<br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-comment">// 树剖LCA核心操作</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">LCA</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>	<span class="hljs-keyword">while</span>(cstop[x]!=cstop[y])&#123;<br>        <span class="hljs-comment">//每次跳所在链顶端更深的节点</span><br>		<span class="hljs-keyword">if</span>(csdep[cstop[x]]&lt;csdep[cstop[y]]) <span class="hljs-built_in">swap</span>(x,y);<br>		x=csfa[cstop[x]];<br>	&#125;<br>	<span class="hljs-keyword">return</span> csdep[x]&lt;csdep[y]?x:y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>(),r=<span class="hljs-built_in">read</span>();<br>	<span class="hljs-built_in">init</span>();<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>)&#123;<br>		x=<span class="hljs-built_in">read</span>(),y=<span class="hljs-built_in">read</span>();<br>		<span class="hljs-built_in">addedge</span>(x,y);<br>		<span class="hljs-built_in">addedge</span>(y,x);<br>	&#125;<br>    <span class="hljs-comment">//树剖预处理：两次dfs</span><br>	<span class="hljs-built_in">dfs1</span>(r,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>);<br>	<span class="hljs-built_in">dfs2</span>(r,r);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m)&#123;<br>		x=<span class="hljs-built_in">read</span>(),y=<span class="hljs-built_in">read</span>();<br>		<span class="hljs-built_in">write</span>(<span class="hljs-built_in">LCA</span>(x,y)),<span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>


<h2 id="知识点：树上差分"><a href="#知识点：树上差分" class="headerlink" title="知识点：树上差分"></a>知识点：树上差分</h2><p>参考blog：<a href="https://www.cnblogs.com/TEoS/p/11376676.html">树上差分详解</a></p>
<p>这里记录一个比较常用的树上操作：树上差分，顾名思义，就是在树上进行差分操作和DFS求前缀和操作，实现复杂度优化，具体实现如下（很好理解，就不给证明了）</p>
<h3 id="点差分"><a href="#点差分" class="headerlink" title="点差分"></a>点差分</h3><p>将两点$u,v$之间路径上所有<strong>点权</strong>增加$x$，则操作如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">diff[u]+=x,diff[v]+=x,diff[<span class="hljs-built_in">LCA</span>(u,v)]-=x,diff[fa[<span class="hljs-built_in">LCA</span>(u,v)]]-=x;<br></code></pre></div></td></tr></table></figure>
<h3 id="边差分"><a href="#边差分" class="headerlink" title="边差分"></a>边差分</h3><p>将两点$u,v$之间路径上所有<strong>边权</strong>增加$x$，则操作如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">diff[u]+=x,diff[v]+=x,diff[<span class="hljs-built_in">LCA</span>(u,v)]-=<span class="hljs-number">2</span>*x;<br></code></pre></div></td></tr></table></figure>
<h3 id="求树上前缀和"><a href="#求树上前缀和" class="headerlink" title="求树上前缀和"></a>求树上前缀和</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fath)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>        <span class="hljs-type">int</span> v=e[i].v;<br>        <span class="hljs-keyword">if</span>(v!=fath)<br>            presum[u]+=<span class="hljs-built_in">dfs</span>(v,u);<br>    &#125;<br>    <span class="hljs-keyword">return</span> presum[u];<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>树上差分模板题：<a href="https://www.luogu.com.cn/problem/P3128">P3128 Max Flow P</a></p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">500005</span>,M=<span class="hljs-number">500005</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> u,v,w,next;<br>&#125;e[M&lt;&lt;<span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> n,k,cnt,head[N],tdiff[N];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>	cnt=<span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w=<span class="hljs-number">0</span>)</span></span>&#123;<br>	e[cnt]=Edge&#123;u,v,w,head[u]&#125;;<br>	head[u]=cnt++;<br>&#125;<br><span class="hljs-type">int</span> vis[N],fa[N][<span class="hljs-number">21</span>],dep[N],ans;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lcadfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>	vis[u]=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(!vis[v])&#123;<br>			fa[v][<span class="hljs-number">0</span>]=u;<br>			dep[v]=dep[u]+<span class="hljs-number">1</span>;<br>			<span class="hljs-built_in">lcadfs</span>(v);<br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_lca</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">20</span>)&#123;<br>		<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,n)&#123;<br>			fa[j][i]=fa[fa[j][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">LCA</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(dep[x]&lt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<br>	<span class="hljs-keyword">while</span>(dep[x]&gt;dep[y]) x=fa[x][<span class="hljs-built_in">int</span>(<span class="hljs-built_in">log2</span>(dep[x]-dep[y]))];<br>	<span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> x;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">log2</span>(dep[x]);i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>		<span class="hljs-keyword">if</span>(fa[x][i]!=fa[y][i])&#123;<br>			x=fa[x][i],y=fa[y][i];<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> fa[x][<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fath)</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(v!=fath)&#123;<br>			tdiff[u]+=<span class="hljs-built_in">dfs</span>(v,u);<br>		&#125;<br>	&#125;<br>	ans=<span class="hljs-built_in">max</span>(ans,tdiff[u]);<br>	<span class="hljs-keyword">return</span> tdiff[u];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);<br>	<span class="hljs-built_in">init</span>();<br>	<span class="hljs-type">int</span> x,y;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y),<span class="hljs-built_in">addedge</span>(x,y),<span class="hljs-built_in">addedge</span>(y,x);<br>	<span class="hljs-built_in">lcadfs</span>(<span class="hljs-number">1</span>);<br>	<span class="hljs-built_in">init_lca</span>();<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,k)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<br>		<span class="hljs-type">int</span> lca=<span class="hljs-built_in">LCA</span>(x,y);<br>		tdiff[y]++;<br>		tdiff[x]++;<br>		tdiff[lca]--;<br>		tdiff[fa[lca][<span class="hljs-number">0</span>]]--;<br>	&#125;<br>	<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>



<h2 id="习题汇总"><a href="#习题汇总" class="headerlink" title="习题汇总"></a>习题汇总</h2><p><a href="https://www.luogu.com.cn/problem/P1967">P1967 货车运输</a>（最大生成树建树+LCA求最小值）</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 略去头文件</span><br><span class="hljs-type">int</span> n,m,q,Fa[maxn],fa[maxn][<span class="hljs-number">21</span>],w[maxn][<span class="hljs-number">21</span>],dep[maxn],cnt1,cnt2,head1[maxn],head2[maxn];<br><span class="hljs-type">bool</span> vis[maxn];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> x==Fa[x]?x:Fa[x]=<span class="hljs-built_in">find</span>(Fa[x]);&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span><br>&#123;<br>	<span class="hljs-type">int</span> u,v,w,next;<br>&#125;e1[maxn&lt;&lt;<span class="hljs-number">1</span>],e2[maxn&lt;&lt;<span class="hljs-number">1</span>];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Edge x1,Edge x2)</span></span>&#123;<br>	<span class="hljs-keyword">return</span> x1.w&gt;x2.w;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge1</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w=<span class="hljs-number">0</span>)</span></span>&#123;<br>	e1[++cnt1]=Edge&#123;u,v,w,head1[u]&#125;;<br>	head1[u]=cnt1;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge2</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w=<span class="hljs-number">0</span>)</span></span>&#123;<br>	e2[++cnt2]=Edge&#123;u,v,w,head2[u]&#125;;<br>	head2[u]=cnt2;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) Fa[i]=i;<br>	cnt1=cnt2=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head2[u];i;i=e2[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e2[i].v;<br>		<span class="hljs-keyword">if</span>(!vis[v])&#123;<br>			vis[v]=<span class="hljs-number">1</span>;<br>			dep[v]=dep[u]+<span class="hljs-number">1</span>;<br>			fa[v][<span class="hljs-number">0</span>]=u;<br>			w[v][<span class="hljs-number">0</span>]=e2[i].w;<br>			<span class="hljs-built_in">dfs</span>(v);<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">LCAmin</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(x)!=<span class="hljs-built_in">find</span>(y)) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>	<span class="hljs-type">int</span> ans=inf;<br>	<span class="hljs-keyword">if</span>(dep[x]&lt;dep[y]) x^=y^=x^=y;<br>	<span class="hljs-keyword">while</span>(dep[x]&gt;dep[y])&#123;<br>		ans=<span class="hljs-built_in">min</span>(ans,w[x][<span class="hljs-built_in">int</span>(<span class="hljs-built_in">log2</span>(dep[x]-dep[y]))]);<br>		x=fa[x][<span class="hljs-built_in">int</span>(<span class="hljs-built_in">log2</span>(dep[x]-dep[y]))];<br>	&#125;<br>	<span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> ans;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">log2</span>(dep[x]);i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>		<span class="hljs-keyword">if</span>(fa[x][i]!=fa[y][i])&#123;<br>			ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">min</span>(w[x][i],w[y][i]));<br>			x=fa[x][i],y=fa[y][i];<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">min</span>(w[x][<span class="hljs-number">0</span>],w[y][<span class="hljs-number">0</span>]));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">init</span>();<br>	<span class="hljs-built_in">sort</span>(e1+<span class="hljs-number">1</span>,e1+<span class="hljs-number">1</span>+m,cmp);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>		<span class="hljs-type">int</span> eu=<span class="hljs-built_in">find</span>(e1[i].u),ev=<span class="hljs-built_in">find</span>(e1[i].v);<br>		<span class="hljs-keyword">if</span>(eu!=ev)&#123;<br>			Fa[eu]=ev;<br>			<span class="hljs-built_in">addedge2</span>(e1[i].u,e1[i].v,e1[i].w);<br>			<span class="hljs-built_in">addedge2</span>(e1[i].v,e1[i].u,e1[i].w);<br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-comment">// freopen(&quot;P1967_1.in&quot;,&quot;r&quot;,stdin);</span><br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>	<span class="hljs-type">int</span> x,y,z;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);<br>		<span class="hljs-built_in">addedge1</span>(x,y,z);<br>	&#125;<br>	<span class="hljs-built_in">kruskal</span>();<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">if</span>(!vis[i])&#123;<br>			vis[i]=<span class="hljs-number">1</span>;<br>			<span class="hljs-built_in">dfs</span>(i);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">20</span>;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>			fa[j][i]=fa[fa[j][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<br>			w[j][i]=<span class="hljs-built_in">min</span>(w[j][i<span class="hljs-number">-1</span>],w[fa[j][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>]);<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,q)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">LCAmin</span>(x,y));<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<p><a href="https://www.luogu.com.cn/problem/P2680">P2680 运输计划</a>（树上差分+二分答案+树剖LCA，倍增LCA似乎会T）</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 略去头文件</span><br><span class="hljs-type">int</span> n,m,lcafa[maxn][<span class="hljs-number">25</span>],sum[maxn][<span class="hljs-number">25</span>],head[maxn],dep[maxn],LG[maxn],cnt;<br><span class="hljs-type">int</span> longest,dfscnt,treediff[maxn],sta[maxn],top;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span><br>&#123;<br>	<span class="hljs-type">int</span> u,v,w,next;<br>&#125;e[maxn&lt;&lt;<span class="hljs-number">1</span>];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Q</span><br>&#123;<br>	<span class="hljs-type">int</span> u,v,lca,routesum;<br>&#125;q[maxn];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w=<span class="hljs-number">0</span>)</span></span>&#123;<br>	e[cnt]=Edge&#123;u,v,w,head[u]&#125;;<br>	head[u]=cnt++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fath)</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v,w=e[i].w;<br>		<span class="hljs-keyword">if</span>(v!=fath)&#123;<br>			dep[v]=dep[u]+<span class="hljs-number">1</span>;<br>			lcafa[v][<span class="hljs-number">0</span>]=u;<br>			sum[v][<span class="hljs-number">0</span>]=w;<br>			<span class="hljs-built_in">dfs1</span>(v,u);<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">LCA</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> &amp;Sum)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(dep[x]&lt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<br>	<span class="hljs-keyword">while</span>(dep[x]&gt;dep[y])&#123;<br>		Sum+=sum[x][LG[dep[x]-dep[y]]];<br>		x=lcafa[x][LG[dep[x]-dep[y]]];<br>	&#125;<br>	<span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> x;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=LG[dep[x]];i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>		<span class="hljs-keyword">if</span>(lcafa[x][i]!=lcafa[y][i])&#123;<br>			Sum+=sum[x][i]+sum[y][i];<br>			x=lcafa[x][i];<br>			y=lcafa[y][i];<br>		&#125;<br>	&#125;<br>	Sum+=sum[x][<span class="hljs-number">0</span>]+sum[y][<span class="hljs-number">0</span>];<br>	<span class="hljs-keyword">return</span> lcafa[x][<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fath)</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(v!=fath)&#123;<br>			treediff[u]+=<span class="hljs-built_in">dfs2</span>(v,u);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">if</span>(treediff[u]==dfscnt)&#123;<br>		sta[++top]=sum[u][<span class="hljs-number">0</span>];<br>	&#125;<br>	<span class="hljs-keyword">return</span> treediff[u];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>	<span class="hljs-built_in">memset</span>(treediff,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(treediff));<br>	<span class="hljs-type">int</span> maxh=<span class="hljs-number">0</span>;<br>	dfscnt=<span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m)&#123;<br>		<span class="hljs-keyword">if</span>(q[i].routesum&gt;x)&#123;<span class="hljs-comment">//树上差分</span><br>			dfscnt++;<br>			treediff[q[i].u]++;<br>			treediff[q[i].v]++;<br>			treediff[q[i].lca]-=<span class="hljs-number">2</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">while</span>(top)&#123;<br>		maxh=<span class="hljs-built_in">max</span>(maxh,sta[top--]);<br>	&#125;<br>	<span class="hljs-keyword">return</span> longest-maxh&gt;x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-comment">// freopen(&quot;P2680_13.in&quot;,&quot;r&quot;,stdin);</span><br>	n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>();<br>	<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,u,v,w;i&lt;n;i++)&#123;<br>		u=<span class="hljs-built_in">read</span>(),v=<span class="hljs-built_in">read</span>(),w=<span class="hljs-built_in">read</span>();<br>		<span class="hljs-built_in">addedge</span>(u,v,w);<br>		<span class="hljs-built_in">addedge</span>(v,u,w);<br>	&#125;<br><br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) LG[i]=<span class="hljs-built_in">log2</span>(i);<br>	<span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">24</span>)&#123;<br>		<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,n)&#123;<br>			lcafa[j][i]=lcafa[lcafa[j][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<br>			sum[j][i]=sum[j][i<span class="hljs-number">-1</span>]+sum[lcafa[j][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m)&#123;<br>		q[i].u=<span class="hljs-built_in">read</span>(),q[i].v=<span class="hljs-built_in">read</span>();<br>		q[i].lca=<span class="hljs-built_in">LCA</span>(q[i].u,q[i].v,q[i].routesum);<br>		longest=<span class="hljs-built_in">max</span>(longest,q[i].routesum);<br>	&#125;<br><br>	<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=longest;<br>	<span class="hljs-keyword">while</span>(l&lt;=r)&#123;<span class="hljs-comment">//二分答案</span><br>		<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l=mid+<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;<br>	&#125;<br>	<span class="hljs-built_in">write</span>(l),<span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<p><a href="https://www.acwing.com/problem/content/description/399">逃不掉的路</a>（E-DCC缩点建树+LCA求树上两点距离）</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 忽略头文件</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">500005</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">500005</span>,M=<span class="hljs-number">2</span>*<span class="hljs-number">500005</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> u,v,w,next;<br>&#125;e1[M&lt;&lt;<span class="hljs-number">1</span>],e2[M&lt;&lt;<span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> cnt1,head1[N],cnt2,head2[N];<br><span class="hljs-type">int</span> n,m,q;<br><span class="hljs-type">int</span> low[maxn],dfn[maxn],sta[maxn],vis[maxn],color[maxn],top,scc,deep;<br><span class="hljs-type">int</span> fa[maxn][<span class="hljs-number">21</span>],dist[maxn][<span class="hljs-number">21</span>],dep[maxn];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>	cnt1=cnt2=<span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">memset</span>(head1,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head1));<br>	<span class="hljs-built_in">memset</span>(head2,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head2));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge1</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w=<span class="hljs-number">0</span>)</span></span>&#123;<br>	e1[cnt1]=Edge&#123;u,v,w,head1[u]&#125;;<br>	head1[u]=cnt1++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge2</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w=<span class="hljs-number">0</span>)</span></span>&#123;<br>	e2[cnt2]=Edge&#123;u,v,w,head2[u]&#125;;<br>	head2[u]=cnt2++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fath)</span></span>&#123;<span class="hljs-comment">//tarjan缩点</span><br>	vis[sta[++top]=u]=<span class="hljs-number">1</span>;<br>	low[u]=dfn[u]=++deep;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head1[u];~i;i=e1[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e1[i].v;<br>		<span class="hljs-keyword">if</span>(v==fath) <span class="hljs-keyword">continue</span>;<br>		<span class="hljs-comment">// if(i==(fath^1)) continue;</span><br>		<span class="hljs-keyword">if</span>(!dfn[v])&#123;<br>			<span class="hljs-built_in">tarjan</span>(v,u);<br>			low[u]=<span class="hljs-built_in">min</span>(low[u],low[v]);<br>		&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(vis[v]) low[u]=<span class="hljs-built_in">min</span>(low[u],dfn[v]);<br>	&#125;<br>	<span class="hljs-keyword">if</span>(dfn[u]==low[u])&#123;<br>		vis[u]=<span class="hljs-number">0</span>;<br>		color[u]=++scc;<br>		<span class="hljs-keyword">while</span>(sta[top]!=u)&#123;<br>			vis[sta[top]]=<span class="hljs-number">0</span>;<br>			color[sta[top--]]=scc;<br>		&#125;<br>		top--;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>	vis[u]=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head2[u];~i;i=e2[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e2[i].v;<br>		<span class="hljs-keyword">if</span>(!vis[v])&#123;<br>			dep[v]=dep[u]+<span class="hljs-number">1</span>;<br>			fa[v][<span class="hljs-number">0</span>]=u;<br>			dist[v][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>			<span class="hljs-built_in">dfs</span>(v);<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">LCA</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(dep[x]&lt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<br>	<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(dep[x]&gt;dep[y])&#123;<br>		ans+=dist[x][<span class="hljs-built_in">int</span>(<span class="hljs-built_in">log2</span>(dep[x]-dep[y]))];<br>		x=fa[x][<span class="hljs-built_in">int</span>(<span class="hljs-built_in">log2</span>(dep[x]-dep[y]))];<br>	&#125;<br>	<span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> ans;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">log2</span>(dep[x]);i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>		<span class="hljs-keyword">if</span>(fa[x][i]!=fa[y][i])&#123;<br>			ans+=dist[x][i]+dist[y][i];<br>			x=fa[x][i],y=fa[y][i];<br>		&#125;<br>	&#125;<br>	ans+=dist[x][<span class="hljs-number">0</span>]+dist[y][<span class="hljs-number">0</span>];<br>	<span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>	<span class="hljs-built_in">init</span>();<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m)&#123;<br>		<span class="hljs-type">int</span> u,v;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);<br>		<span class="hljs-built_in">addedge1</span>(u,v,<span class="hljs-number">1</span>);<br>		<span class="hljs-built_in">addedge1</span>(v,u,<span class="hljs-number">1</span>);<br>	&#125;<br><br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(!dfn[i]) <span class="hljs-built_in">tarjan</span>(i,<span class="hljs-number">-1</span>);<br><br>	<span class="hljs-built_in">rep</span>(u,<span class="hljs-number">1</span>,n)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head1[u];~i;i=e1[i].next)&#123;<br>			<span class="hljs-type">int</span> v=e1[i].v;<br>			<span class="hljs-keyword">if</span>(color[u]!=color[v])&#123;<br>				<span class="hljs-built_in">addedge2</span>(color[u],color[v],<span class="hljs-number">1</span>);<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">// rep(i,1,n) printf(&quot;%d scc:%d\n&quot;,i,color[i]);</span><br>	<span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<br>	<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">20</span>)&#123;<br>		<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,scc)&#123;<br>			fa[j][i]=fa[fa[j][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<br>			dist[j][i]=dist[j][i<span class="hljs-number">-1</span>]+dist[fa[j][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,q)&#123;<br>		<span class="hljs-type">int</span> x,y;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">LCA</span>(color[x],color[y]));<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCA</tag>
        <tag>倍增</tag>
        <tag>树链剖分</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>最长上升子序列（LIS）详解</title>
    <url>/2020/01/17/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88LIS%EF%BC%89%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="最长上升子序列（Longest-Increasing-Subsequence）解法和优化"><a href="#最长上升子序列（Longest-Increasing-Subsequence）解法和优化" class="headerlink" title="最长上升子序列（Longest Increasing Subsequence）解法和优化"></a><center>最长上升子序列（Longest Increasing Subsequence）解法和优化</center></h2><span id="more"></span>
<hr>
<p>学习动态规划的入门知识碰到的经典问题，这里记录一些我的理解</p>
<hr>
<h2 id="最长上升子序列（LIS）"><a href="#最长上升子序列（LIS）" class="headerlink" title="最长上升子序列（LIS）"></a>最长上升子序列（LIS）</h2><h3 id="两个概念"><a href="#两个概念" class="headerlink" title="两个概念"></a>两个概念</h3><p>首先，需要明确两个概念：</p>
<ol>
<li><p><strong>子串（Substring）</strong>：对应字符串从左到右的顺序摘取的片段，要求必须连续（不能有间隔字符），如：$abcde$种$bcd$就是一个子串；</p>
</li>
<li><p><strong>子序列（Subsequence）</strong>：对应字符串从左到右的顺序摘取片段，要求可以有间隔字符，如：$abcde$中$ace$是一个子序列。</p>
</li>
</ol>
<p>因此，一定有如下说法：<strong>子串一定是子序列，而子序列不一定是子串</strong>，这很好理解。</p>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote>
<p>给定一个长为n的数列，求出这个数列的最长上升子序列的长度。</p>
<p>Sample Input:</p>
<figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span><br></code></pre></div></td></tr></table></figure>
<p>Sample Output:</p>
<figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">3<br></code></pre></div></td></tr></table></figure>
<p>数据范围：$1\leq n\leq 1000; 0\leq a_i \leq 1e6$</p>
</blockquote>
<h3 id="一般解法"><a href="#一般解法" class="headerlink" title="一般解法"></a>一般解法</h3><p>具体思路：</p>
<ol>
<li><p>定义状态： $dp[i]$表示以$a_i$为末尾的最长上升子序列的长度；</p>
</li>
<li><p>状态转移： 一种是$dp[i]$本身，另一种则是在遍历过程中出现的以$a_j(a_j&lt;a_i且j&lt;i)$为结尾的LIS末尾加上$a_i$得到的子序列；</p>
</li>
<li><p>方程如下：</p>
<script type="math/tex; mode=display">
dp[i]=max(dp[i],dp[j]+1|j<i且a_j<a_i)</script><p>时间复杂度$O(n^2)$，可以开始搞了。</p>
</li>
</ol>
<h3 id="AC代码-O-n-2"><a href="#AC代码-O-n-2" class="headerlink" title="AC代码($O(n^2)$)"></a>AC代码($O(n^2)$)</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> dp[<span class="hljs-number">100005</span>],a[<span class="hljs-number">100005</span>];<br><span class="hljs-type">int</span> len,n;<br><span class="hljs-type">int</span> ans;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;n;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		cin&gt;&gt;a[i];<br>		dp[i]=<span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;j++)&#123;<br>			<span class="hljs-keyword">if</span>(a[j]&lt;a[i])<br>				dp[i] = <span class="hljs-built_in">max</span>(dp[i],dp[j]+<span class="hljs-number">1</span>);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		ans = <span class="hljs-built_in">max</span>(ans,dp[i]);<br>	&#125;<br>	cout&lt;&lt;ans&lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>上述方法看起来很巧妙，并且感觉已经足够完美了，那么能不能再完美一些（时间复杂度再低一些）呢？</p>
<p>答案是可以。</p>
<ul>
<li><p>我们定义一个新的状态：$dp[i]$表示所有数组成的LIS中，所有长度为$i$的LIS中的末尾元素最小值（orz真的很难理解）；</p>
</li>
<li><p>状态定义好了，我们需要做的就是遍历一遍$a_1$到$a_n$，并更新这个$dp$数组，具体操作如下：</p>
<ol>
<li><p>首先，$dp$数组的长度为0，我命名为len=0；</p>
</li>
<li><p>出现$a_i&gt;dp[len]$时，不管三七二十一，直接加在$dp[len]$后面，并使得len++；</p>
</li>
<li><p>出现$a_i&lt;dp[len]$时，我们需要把这个$a_i$替换掉$dp$数组从左到右第一个大于等于$a_i$的元素（注意：此时dp数组长度不变），因为我们要求最优，因而就需要$dp$数组里面元素尽可能小，这样才有更大的可能性再去往后加数。</p>
</li>
</ol>
</li>
</ul>
<p>具体思路是这样，是不是一脸懵逼？</p>
<p>没事，我们来手动模拟一下：</p>
<blockquote>
<p>以数组（4，2，3，1，5）为例：</p>
<p>首先，len = 0，dp = ｛0，0，0，0，0｝，</p>
<p>开始：</p>
<p>指向第一个元素，4 &gt; 0，因此加进dp里，dp = ｛4，0，0，0，0｝len = 1；</p>
<p>指向第二个元素，2 &lt; 4，因此替换掉4，dp = ｛2，0，0，0，0｝len = 1；</p>
<p>指向第三个元素，3 &gt; 2，因此加进dp里，dp = ｛2，3，0，0，0｝len = 2；</p>
<p>指向第四个元素，1 &gt; 3，因此替换掉2，dp = ｛1，3，0，0，0｝len=2；</p>
<p>指向第五个元素，5 &gt; 3，因此加进dp里，dp = ｛1，3，5，0，0｝len = 3;</p>
<p>结束。</p>
<p>因此 len= 3</p>
</blockquote>
<p>这样好理解多了吧？</p>
<p>但是我们可以发现，最后的dp数组它不是正确的答案（正确答案是2，3，5），但这并不影响len长度的真确性，为什么呢？因为我们在操作$a_i&lt;dp[len]$的时候，只是把更优的数（更小的数）替换掉了第一个比他大的数，而<strong>长度并没有改变</strong>，这种求最优的过程并没有影响到LIS的长度，而这个dp数组则代表了一种最可能性，代表每一步都是最优的，意思是如果后面还有数的话，这个答案就可以再接着往下更新，可能又有新的替换。（这里可能表述得不太清晰，还是需要自己多悟呀）</p>
<p>可有人会问了：这确实是个新思路，但遍历一遍a数组需要n复杂度，插入到dp也需要n复杂度，这不还是$O(n^2)$复杂度吗？</p>
<p>话是这么说，但我们的插入操作可以利用<strong>二分查找</strong>（lower_bound或者你手打）来优化呀！</p>
<p>为什么可以呢？答：因为dp数组一定是单调的（依据状态转移过程不难得出）。</p>
<h3 id="AC代码（-O-nlogn-）"><a href="#AC代码（-O-nlogn-）" class="headerlink" title="AC代码（$O(nlogn)$）"></a>AC代码（$O(nlogn)$）</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> ll inf = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>;<br><br>ll f[<span class="hljs-number">100005</span>],a[<span class="hljs-number">100005</span>];<br>ll n;<br>ll len;<br><br><span class="hljs-comment">//int bound(int x)&#123;</span><br><span class="hljs-comment">//	int l=1,r=len;</span><br><span class="hljs-comment">//	while(l&lt;r)&#123;</span><br><span class="hljs-comment">//		int mid = (l+r)&gt;&gt;1;</span><br><span class="hljs-comment">//		if(f[mid]&gt;x)&#123;</span><br><span class="hljs-comment">//			r=mid;</span><br><span class="hljs-comment">//		&#125;else l=mid+1;</span><br><span class="hljs-comment">//	&#125;</span><br><span class="hljs-comment">//	return l;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;n;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		cin&gt;&gt;a[i];<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">if</span>(f[len]&lt;a[i])&#123;<br>			f[++len] = a[i];<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>			<span class="hljs-type">int</span> pos = <span class="hljs-built_in">lower_bound</span>(f+<span class="hljs-number">1</span>,f+len+<span class="hljs-number">1</span>,a[i])-f;<br>			f[pos] = a[i];<br>		&#125;<br>		<span class="hljs-comment">//cout&lt;&lt;len&lt;&lt;&quot; &quot;;</span><br>	&#125;<br>	cout&lt;&lt;len&lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<hr>
<ul>
<li>第一次学这个东西可能确实需要点时间来理解，我会努力加深印象的。<br>以上。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>动态规划</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>树上启发式合并</title>
    <url>/2022/09/17/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<p>关于树上启发式合并的学习</p>
<hr>
<span id="more"></span>
<p>参考blog：</p>
<ul>
<li><a href="https://blog.csdn.net/m0_53430148/article/details/119974433">树上启发式合并（作为初学者的一点领悟）</a></li>
<li><a href="https://www.cnblogs.com/YunQianQwQ/p/dsu-on-tree.html">树上启发式合并（链分治）</a></li>
<li><a href="https://oi-wiki.org/graph/dsu-on-tree/">树上启发式合并 - OI Wiki</a></li>
</ul>
<hr>
<h2 id="启发式合并"><a href="#启发式合并" class="headerlink" title="启发式合并"></a>启发式合并</h2><p>问：何为启发式合并？</p>
<p>答：根据人们的经验和直觉，对算法进行的优化，最常见的就是并查集中的<strong>按秩合并（讲size小的合并到size大的集合中）</strong>操作了。</p>
<p>回归到我们的主题，对于一系列<strong>不带修改</strong>的树上统计问题，我们不难想到一个$O(n^2)$的暴力算法，即遍历每棵子树，对它进行一次$O(n)$的查询操作。为了优化这种做法，便有了<strong>树上启发式合并</strong>，通过人为设定一种<strong>启发式</strong>的暴力思路，使得将一些<strong>暴力</strong>的$O(n^2)$的算法优化至$O(n\log n)$。</p>
<p>树上启发式合并的前置姿势：（也正是启发式的来源）</p>
<ul>
<li>轻重链剖分</li>
</ul>
<hr>
<p>对于一种询问统计所有子树的贡献一类题，首先考虑一种暴力的思路，对于每一棵子树$O(n)$进行统计，再将统计的结果清空（因为我们要保证空间复杂度也是$O(n)$），这样算下来，总的时间复杂度是$O(n^2)$的，考虑如何优化这个暴力过程。</p>
<p>我们发现，对于一个节点$u$的1次统计来说，我们需要对$u$的所有儿子$v$对应子树进行一次统计 + 一次清空操作，然后将$u$节点的贡献算上，再统计所有子节点一次，从而更新$u$这棵子树的贡献。</p>
<p>实际上，当我们统计完了$u$的最后一个子节点$v<em>{last}$子树的贡献后，并不需要将其贡献清空，而是可以直接继承这个贡献。显然，我们需要让这个$v</em>{last}$对应子树<strong>越大越好</strong>！自然而然地，我们便想到了<strong>重儿子</strong>这个概念。</p>
<p>通常情况下，我们定义启发式合并的思路都是源自于<strong>树链剖分</strong>（重链剖分 or 长链剖分），原因是它预处理出了每个节点的<strong>重儿子</strong>！我们利用这个性质，在暴力时每次将重儿子所在子树的贡献保留并继承，对于轻儿子子树仍然采取暴力统计+清空的策略，于是便有了如下递归步骤：</p>
<ol>
<li>统计轻儿子子树贡献 + 清空贡献</li>
<li>统计重儿子子树贡献 + 保留贡献</li>
<li>暴力统计当前节点以及它的所有轻儿子，记录贡献，并更新答案</li>
</ol>
<p>我们可以简单证明一下这样操作的复杂度：</p>
<p>假设一棵树有$n$个节点，对于一个节点来说，它要么是重儿子，要么是轻儿子，在一个节点被暴力地统计贡献时，这个节点只会是轻儿子，因此一个点被统计一次当且仅当它到根的路径上有一条轻边。根据树链剖分的性质，一个节点到其根的轻边数量为$\log n$，因此总时间复杂度为$O(n\log n)$。</p>
<h2 id="通用模板代码"><a href="#通用模板代码" class="headerlink" title="通用模板代码"></a>通用模板代码</h2><p>依据上方的描述，我这里自己总结了一套<strong>树上启发式合并通用模板</strong>：（针对常规题型）</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">此处首先轻重练剖分，得到以下变量：</span><br><span class="hljs-comment">    dfn: dfs序</span><br><span class="hljs-comment">    bigson[u]: 节点u的重儿子（没有则为0）</span><br><span class="hljs-comment">    csid[u]: 节点u的dfs序</span><br><span class="hljs-comment">    sz[u]: 节点u的</span><br><span class="hljs-comment">    其他... // 例如需要维护的值</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 参数含义：当前节点u，父节点fath，当前节点是否是bigson（根节点不是）</span><br><span class="hljs-keyword">auto</span> dfs2 = [&amp;](<span class="hljs-keyword">auto</span> &amp;&amp;self, <span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fath, <span class="hljs-type">bool</span> isbig)&#123;<br>    <span class="hljs-comment">// 先暴力统计轻儿子，并清除贡献</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;&amp;v: e[u])&#123;<br>        <span class="hljs-keyword">if</span>(v == fath || v == bigson[u]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">self</span>(self, v, u, <span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 清除v子树贡献，这里因为与处理了dfs序，所以可以直接遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = csid[v]; i &lt;= csid[v] + sz[v] - <span class="hljs-number">1</span>; ++i)&#123;<br>            <span class="hljs-comment">/* 清除i贡献操作 */</span><br>        &#125;<br>        <span class="hljs-comment">/* 清除v子树贡献操作 */</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 最后统计重儿子，保留贡献</span><br>    <span class="hljs-keyword">if</span>(bigson[u]) <span class="hljs-built_in">self</span>(self, bigson[u], u, <span class="hljs-literal">true</span>);<br>    <br>    <span class="hljs-comment">// 前面属于递归逻辑，这里开始正式处理</span><br>    <span class="hljs-comment">// 暴力统计所有轻儿子，因为只有轻儿子之前被清除了</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;&amp;V: e[u])&#123;<br>        <span class="hljs-keyword">if</span>(v == fath || v == bigson[u]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">/* 添加v贡献操作 */</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 计算当前节点u贡献</span><br>    <span class="hljs-comment">/* 添加u贡献操作 */</span><br>    <span class="hljs-comment">/* 记录答案操作 */</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>
<hr>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="U41492-树上数颜色"><a href="#U41492-树上数颜色" class="headerlink" title="U41492 树上数颜色"></a><a href="https://www.luogu.com.cn/problem/U41492">U41492 树上数颜色</a></h3><p>题意：一棵有根树，带点权，<code>m</code>次询问，每次问一棵子树有多少不同权值。</p>
<p>题解：记录每种颜色的出现次数<code>cnt[]</code>和总共有多少种颜色<code>tot</code>，然后套模板。</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> pii = pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">e</span>(n+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x,y,i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;++i)&#123;<br>        cin &gt;&gt; x &gt;&gt; y;<br>        e[x].<span class="hljs-built_in">emplace_back</span>(y);<br>        e[y].<span class="hljs-built_in">emplace_back</span>(x);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin &gt;&gt; a[i];<br><br>    <span class="hljs-type">int</span> dfn = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">bigson</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>, <span class="hljs-title">sz</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>, <span class="hljs-title">csid</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>, <span class="hljs-title">csw</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">auto</span> dfs1 = [&amp;](<span class="hljs-keyword">auto</span> &amp;&amp;self, <span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fath) -&gt; <span class="hljs-type">void</span>&#123;<br>        csid[u] = ++dfn;<br>        csw[dfn] = a[u];<br>        sz[u] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;&amp;v: e[u])&#123;<br>            <span class="hljs-keyword">if</span>(v == fath) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">self</span>(self, v, u);<br>            sz[u] += sz[v];<br>            <span class="hljs-keyword">if</span>(sz[bigson[u]] &lt; sz[v])&#123;<br>                bigson[u] = v;<br>            &#125;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-built_in">dfs1</span>(dfs1, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// 每种颜色的出现次数</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>; <span class="hljs-comment">// 有多少种颜色</span><br><br>    <span class="hljs-keyword">auto</span> add = [&amp;](<span class="hljs-type">int</span> val) -&gt; <span class="hljs-type">void</span>&#123;<br>        <span class="hljs-keyword">if</span>(cnt[val]++ == <span class="hljs-number">0</span>) res ++;<br>    &#125;;<br><br>    <span class="hljs-keyword">auto</span> dfs2 = [&amp;](<span class="hljs-keyword">auto</span> &amp;&amp;self, <span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fath, <span class="hljs-type">bool</span> isbig) -&gt; <span class="hljs-type">void</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;&amp;v: e[u])&#123; <span class="hljs-comment">// 先统计轻儿子，不记贡献</span><br>            <span class="hljs-keyword">if</span>(v == fath || v == bigson[u]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">self</span>(self, v, u, <span class="hljs-literal">false</span>);<br><br>            <span class="hljs-comment">// 对于轻儿子对答案的贡献，直接清空就行了，不保留任何影响</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=csid[v];i&lt;=csid[v]+sz[v]<span class="hljs-number">-1</span>;++i)&#123;<br>                cnt[csw[i]] = <span class="hljs-number">0</span>;<br>            &#125;<br>            res = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(bigson[u])&#123; <span class="hljs-comment">// 再统计重儿子，记录贡献</span><br>            <span class="hljs-built_in">self</span>(self, bigson[u], u, <span class="hljs-literal">true</span>);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 暴力更新轻儿子贡献</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;&amp;v: e[u])&#123;<br>            <span class="hljs-keyword">if</span>(v == fath || v == bigson[u]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=csid[v];i&lt;=csid[v]+sz[v]<span class="hljs-number">-1</span>;++i)&#123;<br>                <span class="hljs-built_in">add</span>(csw[i]);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 处理u这个点的贡献</span><br>        <span class="hljs-built_in">add</span>(csw[csid[u]]);<br>        ans[u] = res; <span class="hljs-comment">// 更新答案</span><br><br>    &#125;;<br><br>    <span class="hljs-built_in">dfs2</span>(dfs2, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-literal">false</span>);<br><br>    <span class="hljs-type">int</span> m;<br>    cin &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x,i=<span class="hljs-number">0</span>;i&lt;m;++i)&#123;<br>        cin &gt;&gt; x;<br>        cout &lt;&lt; ans[x] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>)-&gt;<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <br>    <span class="hljs-type">int</span> _ = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// cin&gt;&gt;_;</span><br>    <span class="hljs-keyword">while</span>(_--)&#123;<br>        <br>        <span class="hljs-built_in">solve</span>();<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h3 id="CF600E-Lomsat-gelral"><a href="#CF600E-Lomsat-gelral" class="headerlink" title="CF600E Lomsat gelral"></a><a href="https://www.luogu.com.cn/problem/CF600E">CF600E Lomsat gelral</a></h3><p>题意：一个有根树，带点权，求出每一棵子树内，点权所有不同的众数之和。</p>
<p>题解：记录每种权值的出现次数<code>cnt[]</code>、出现次数最大的权值<code>maxh</code>、点权所有不同众数之和<code>res</code></p>
<p>对于添加贡献操作，只需要每次将出现次数++，然后判断是否与最大值相等并对应更新<code>maxh, res</code>即可</p>
<p>对于删除贡献操作，因为我们先继承了重儿子贡献，再遍历轻儿子，因此对于轻儿子子树来说，这些贡献直接清零就行了</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    https://www.luogu.com.cn/problem/CF600E</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    树上启发式合并模板题</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    题意：一个有根树，带点权，求出每一棵子树内，点权众数之和。</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">*/</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> pii = pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">e</span>(n+<span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin &gt;&gt; a[i];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x,y,i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;++i)&#123;<br>        cin &gt;&gt; x &gt;&gt; y;<br>        e[x].<span class="hljs-built_in">emplace_back</span>(y);<br>        e[y].<span class="hljs-built_in">emplace_back</span>(x);<br>    &#125;<br><br>    <span class="hljs-type">int</span> dfn = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sz</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>, <span class="hljs-title">bigson</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>, <span class="hljs-title">csid</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>, <span class="hljs-title">csw</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br><br>    <span class="hljs-keyword">auto</span> dfs1 = [&amp;](<span class="hljs-keyword">auto</span> &amp;&amp;self, <span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fath) -&gt; <span class="hljs-type">void</span>&#123;<br>        csid[u] = ++dfn;<br>        csw[dfn] = a[u];<br>        sz[u] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;&amp;v: e[u])&#123;<br>            <span class="hljs-keyword">if</span>(v == fath) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">self</span>(self, v, u);<br>            sz[u] += sz[v];<br>            <span class="hljs-keyword">if</span>(sz[bigson[u]] &lt; sz[v])&#123;<br>                bigson[u] = v;<br>            &#125;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-built_in">dfs1</span>(dfs1, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// cnt[i] 表示 i 颜色出现多少次</span><br>    <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-type">int</span> maxh = <span class="hljs-number">0</span>;<br>    ll res = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">auto</span> add = [&amp;](<span class="hljs-type">int</span> val)&#123;<br>        cnt[val]++;<br>        <span class="hljs-keyword">if</span>(cnt[val] &gt; maxh)&#123;<br>            maxh = cnt[val];<br>            res = val;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cnt[val] == maxh)&#123;<br>            res += val;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">auto</span> dfs2 = [&amp;](<span class="hljs-keyword">auto</span> &amp;&amp;self, <span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fath, <span class="hljs-type">bool</span> isbig) -&gt; <span class="hljs-type">void</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;&amp;v: e[u])&#123;<br>            <span class="hljs-keyword">if</span>(v == fath || v == bigson[u]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">self</span>(self, v, u, <span class="hljs-literal">false</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=csid[v];i&lt;=csid[v]+sz[v]<span class="hljs-number">-1</span>;++i)&#123;<br>                cnt[csw[i]] = <span class="hljs-number">0</span>;<br>            &#125;<br>            maxh = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(bigson[u])&#123;<br>            <span class="hljs-built_in">self</span>(self, bigson[u], u, <span class="hljs-literal">true</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;&amp;v: e[u])&#123;<br>            <span class="hljs-keyword">if</span>(v == fath || v == bigson[u]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=csid[v];i&lt;=csid[v]+sz[v]<span class="hljs-number">-1</span>;++i)&#123;<br>                <span class="hljs-built_in">add</span>(csw[i]);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-built_in">add</span>(csw[csid[u]]);<br>        ans[u] = res;<br>    &#125;;<br><br>    <span class="hljs-built_in">dfs2</span>(dfs2, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-literal">false</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i==n];<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>)-&gt;<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <br>    <span class="hljs-type">int</span> _ = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// cin&gt;&gt;_;</span><br>    <span class="hljs-keyword">while</span>(_--)&#123;<br>        <br>        <span class="hljs-built_in">solve</span>();<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h3 id="CF375D-Tree-and-Queries"><a href="#CF375D-Tree-and-Queries" class="headerlink" title="CF375D Tree and Queries"></a><a href="https://www.luogu.com.cn/problem/CF375D">CF375D Tree and Queries</a></h3><p>题意：一棵有根树，带点权，<code>m</code>次询问，每次问一棵子树中出现次数<code>&gt;=k</code>的权值有多少种</p>
<p>题解：首先我们将询问离线到每个节点，考虑对每个子树求贡献，我们注意到</p>
<p>又是出现次数，老套路了，对这题来说，我们需要记录每个权值出现次数<code>cnt[]</code>，以及出现次数<code>&gt;=x</code>的权值的种类数<code>sum[x]</code>，对于前者来说非常容易维护，对于后者其实也很简单：</p>
<p>我们只需要在每次添加贡献时，将对应的<code>sum[++cnt[u]]++</code></p>
<p>对于清除贡献操作，将对应的<code>sum[cnt[u]--]--</code></p>
<p>实际上，我们维护的<code>sum[]</code>数组是一个以出现次数为下标的种类数的后缀和</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> pii = pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n,m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">e</span>(n+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin &gt;&gt; a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x,y,i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;++i)&#123;<br>        cin &gt;&gt; x &gt;&gt; y;<br>        e[x].<span class="hljs-built_in">emplace_back</span>(y);<br>        e[y].<span class="hljs-built_in">emplace_back</span>(x);<br>    &#125;<br>    vector&lt;vector&lt;pii&gt;&gt; <span class="hljs-built_in">q</span>(n+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x,k,i=<span class="hljs-number">1</span>;i&lt;=m;++i)&#123;<br>        cin &gt;&gt; x &gt;&gt; k;<br>        q[x].<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">pair</span>(i, k));<br>    &#125;<br><br>    <span class="hljs-type">int</span> dfn = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sz</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>, <span class="hljs-title">bigson</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>, <span class="hljs-title">csid</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>, <span class="hljs-title">csw</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br><br>    <span class="hljs-keyword">auto</span> dfs1 = [&amp;](<span class="hljs-keyword">auto</span> &amp;&amp;self, <span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fath) -&gt; <span class="hljs-type">void</span>&#123;<br>        csid[u] = ++dfn;<br>        csw[dfn] = a[u];<br>        sz[u] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;&amp;v: e[u])&#123;<br>            <span class="hljs-keyword">if</span>(v == fath) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">self</span>(self, v, u);<br>            sz[u] += sz[v];<br>            <span class="hljs-keyword">if</span>(sz[v] &gt; sz[bigson[u]])&#123;<br>                bigson[u] = v;<br>            &#125;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-built_in">dfs1</span>(dfs1, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(m+<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">100005</span>)</span>, <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-number">100005</span>)</span></span>;<br><br>    <span class="hljs-keyword">auto</span> add = [&amp;](<span class="hljs-type">int</span> x)&#123;<br>        cnt[x]++, sum[cnt[x]]++;<br>    &#125;;<br>    <span class="hljs-keyword">auto</span> del = [&amp;](<span class="hljs-type">int</span> x)&#123;<br>        sum[cnt[x]]--, cnt[x]--;<br>    &#125;;<br>    <br>    <span class="hljs-keyword">auto</span> dfs2 = [&amp;](<span class="hljs-keyword">auto</span> &amp;&amp;self, <span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fath, <span class="hljs-type">bool</span> isbig) -&gt; <span class="hljs-type">void</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;&amp;v: e[u])&#123;<br>            <span class="hljs-keyword">if</span>(v == fath || v == bigson[u]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">self</span>(self, v, u, <span class="hljs-literal">false</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=csid[v];i&lt;=csid[v]+sz[v]<span class="hljs-number">-1</span>;++i)&#123;<br>                <span class="hljs-built_in">del</span>(csw[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(bigson[u])&#123;<br>            <span class="hljs-built_in">self</span>(self, bigson[u], u, <span class="hljs-literal">true</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;&amp;v: e[u])&#123;<br>            <span class="hljs-keyword">if</span>(v == fath || v == bigson[u]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=csid[v];i&lt;=csid[v]+sz[v]<span class="hljs-number">-1</span>;++i)&#123;<br>                <span class="hljs-built_in">add</span>(csw[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">add</span>(csw[csid[u]]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;&amp;[id, val]: q[u])&#123;<br>            ans[id] = sum[val];<br>        &#125;<br>    &#125;;<br>    <span class="hljs-built_in">dfs2</span>(dfs2, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>)-&gt;<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <br>    <span class="hljs-type">int</span> _ = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// cin&gt;&gt;_;</span><br>    <span class="hljs-keyword">while</span>(_--)&#123;<br>        <br>        <span class="hljs-built_in">solve</span>();<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

---

### [CF1009F Dominant Indices](https://www.luogu.com.cn/problem/CF1009F)

题意：一棵有根树，对每个节点，求出其子树中具有最多节点数的深度，且该深度最小

题解：同样的套路，维护每个深度的节点个数`cnt[]`、最大节点个数`maxh`、最大节点个数对应深度`res`，那么考虑添加和删除贡献操作

添加贡献时，只需要把对应`cnt[dep[u]]++`，然后判断是否超出或者等于最大节点数，注意，如果等于了，则需要更新最小深度

删除贡献时，只需要把对应`cnt[dep[v]]--`，直接将`maxh, res`清零即可

<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> pii = pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">e</span>(n+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x,y,i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;++i)&#123;<br>        cin &gt;&gt; x &gt;&gt; y;<br>        e[x].<span class="hljs-built_in">emplace_back</span>(y);<br>        e[y].<span class="hljs-built_in">emplace_back</span>(x);<br>    &#125;<br>    <span class="hljs-type">int</span> dfn = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">csid</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>, <span class="hljs-title">dep</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>, <span class="hljs-title">sz</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>, <span class="hljs-title">bigson</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>, <span class="hljs-title">csw</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>, <span class="hljs-title">ans</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-type">int</span> maxh = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">auto</span> dfs1 = [&amp;](<span class="hljs-keyword">auto</span> &amp;&amp;self, <span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fath, <span class="hljs-type">int</span> depth) -&gt; <span class="hljs-type">void</span>&#123;<br>        csid[u] = ++dfn;<br>        csw[dfn] = u;<br>        sz[u] = <span class="hljs-number">1</span>;<br>        dep[u] = depth;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;&amp;v: e[u])&#123;<br>            <span class="hljs-keyword">if</span>(v == fath) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">self</span>(self, v, u, depth+<span class="hljs-number">1</span>);<br>            sz[u] += sz[v];<br>            <span class="hljs-keyword">if</span>(sz[v] &gt; sz[bigson[u]])&#123;<br>                bigson[u] = v;<br>            &#125;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-built_in">dfs1</span>(dfs1, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">auto</span> add = [&amp;](<span class="hljs-type">int</span> u)&#123;<br>        cnt[dep[u]]++;<br>        <span class="hljs-keyword">if</span>(cnt[dep[u]] &gt; maxh)&#123;<br>            maxh = cnt[dep[u]];<br>            res = u;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cnt[dep[u]] == maxh &amp;&amp; dep[u] &lt; dep[res])&#123;<br>            res = u;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">auto</span> dfs2 = [&amp;](<span class="hljs-keyword">auto</span> &amp;&amp;self, <span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fath, <span class="hljs-type">bool</span> isbig) -&gt; <span class="hljs-type">void</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;&amp;v: e[u])&#123;<br>            <span class="hljs-keyword">if</span>(v == fath || v == bigson[u]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">self</span>(self, v, u, <span class="hljs-literal">false</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=csid[v];i&lt;=csid[v]+sz[v]<span class="hljs-number">-1</span>;++i)&#123;<br>                cnt[dep[csw[i]]]--;<br>            &#125;<br>            maxh = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(bigson[u]) <span class="hljs-built_in">self</span>(self, bigson[u], u, <span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;&amp;v: e[u])&#123;<br>            <span class="hljs-keyword">if</span>(v == fath || v == bigson[u]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=csid[v];i&lt;=csid[v]+sz[v]<span class="hljs-number">-1</span>;++i)&#123;<br>                <span class="hljs-built_in">add</span>(csw[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">add</span>(csw[csid[u]]);<br>        ans[u] = dep[res] - dep[u];<br>    &#125;;<br><br>    <span class="hljs-built_in">dfs2</span>(dfs2, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-literal">false</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>)-&gt;<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <br>    <span class="hljs-type">int</span> _ = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// cin&gt;&gt;_;</span><br>    <span class="hljs-keyword">while</span>(_--)&#123;<br>        <br>        <span class="hljs-built_in">solve</span>();<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h3 id="CF570D-Tree-Requests"><a href="#CF570D-Tree-Requests" class="headerlink" title="CF570D Tree Requests"></a><a href="https://www.luogu.com.cn/problem/CF570D">CF570D Tree Requests</a></h3><p>题意：一棵有根树，每个节点代表一个小写字母</p>
<p><code>m</code>次询问格式为<code>[x,y]</code>，每次问节点<code>x</code>为根的子树中，真实深度（到原树根的距离）为<code>y</code>的所有节点字母是否能构成回文串。</p>
<p>题解：首先把询问离线到每个不同的节点上，考虑对每个子树求贡献，我们注意到</p>
<p>能构成回文串 == 出现次数为奇数次的字母不能超过1个 == bitmask里至多有一个1</p>
<p>记<code>f(i)</code>表示深度为<code>i</code>的节点字母构成的bitmask，则<code>popcont&lt;=1</code>即是<code>&quot;Yes&quot;</code>，对于暴力添加和删除操作，只需要异或一下就行了，然后树上启发式合并就行了</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> pii = pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n,m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">e</span>(n+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x, i=<span class="hljs-number">2</span>;i&lt;=n;++i)&#123;<br>        cin &gt;&gt; x;<br>        e[x].<span class="hljs-built_in">emplace_back</span>(i);<br>        e[i].<span class="hljs-built_in">emplace_back</span>(x);<br>    &#125;<br>    <br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t, i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>        cin &gt;&gt; c;<br>        t = (c - <span class="hljs-string">&#x27;a&#x27;</span>);<br>        a[i] = <span class="hljs-number">1</span> &lt;&lt; t;<br>    &#125;<br>    <br>    vector&lt;vector&lt;pii&gt;&gt; <span class="hljs-built_in">q</span>(n+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x,y,i=<span class="hljs-number">1</span>;i&lt;=m;++i)&#123;<br>        cin &gt;&gt; x &gt;&gt; y;<br>        q[x].<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">pair</span>(i, y));<br>    &#125;<br><br>    <br>    <span class="hljs-type">int</span> dfn = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">csid</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>, <span class="hljs-title">csw</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>, <span class="hljs-title">sz</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>, <span class="hljs-title">bigson</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>, <span class="hljs-title">dep</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">stat</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">ans</span><span class="hljs-params">(m+<span class="hljs-number">1</span>)</span></span>;<br>    <br>    <span class="hljs-keyword">auto</span> dfs1 = [&amp;](<span class="hljs-keyword">auto</span> &amp;&amp;self, <span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fath, <span class="hljs-type">int</span> depth) -&gt; <span class="hljs-type">void</span>&#123;<br>        csid[u] = ++dfn;<br>        csw[dfn] = u;<br>        dep[u] = depth;<br>        sz[u] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;&amp;v: e[u])&#123;<br>            <span class="hljs-keyword">if</span>(v == fath) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">self</span>(self, v, u, depth+<span class="hljs-number">1</span>);<br>            sz[u] += sz[v];<br>            <span class="hljs-keyword">if</span>(sz[v] &gt; sz[bigson[u]])&#123;<br>                bigson[u] = v;<br>            &#125;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-built_in">dfs1</span>(dfs1, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">auto</span> dfs2 = [&amp;](<span class="hljs-keyword">auto</span> &amp;&amp;self, <span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fath, <span class="hljs-type">bool</span> isbig) -&gt; <span class="hljs-type">void</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;&amp;v: e[u])&#123;<br>            <span class="hljs-keyword">if</span>(v == fath || v == bigson[u]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">self</span>(self, v, u, <span class="hljs-literal">false</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=csid[v];i&lt;=csid[v]+sz[v]<span class="hljs-number">-1</span>;++i)&#123;<br>                stat[dep[csw[i]]] ^= a[csw[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(bigson[u]) <span class="hljs-built_in">self</span>(self, bigson[u], u, <span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;&amp;v: e[u])&#123;<br>            <span class="hljs-keyword">if</span>(v == fath || v == bigson[u]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=csid[v];i&lt;=csid[v]+sz[v]<span class="hljs-number">-1</span>;++i)&#123;<br>                stat[dep[csw[i]]] ^= a[csw[i]];<br>            &#125;<br>        &#125;<br>        stat[dep[u]] ^= a[u];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;&amp;[id, val]: q[u])&#123;<br>            ans[id] = (__builtin_popcount(stat[val])&lt;=<span class="hljs-number">1</span> ? <span class="hljs-string">&quot;Yes&quot;</span> : <span class="hljs-string">&quot;No&quot;</span>);<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-built_in">dfs2</span>(dfs2, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-literal">false</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>)-&gt;<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <br>    <span class="hljs-type">int</span> _ = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// cin&gt;&gt;_;</span><br>    <span class="hljs-keyword">while</span>(_--)&#123;<br>        <br>        <span class="hljs-built_in">solve</span>();<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title>树形DP浅析</title>
    <url>/2020/03/23/%E6%A0%91%E5%BD%A2DP%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h2 id="动态规划の树形dp"><a href="#动态规划の树形dp" class="headerlink" title="动态规划の树形dp"></a><center>动态规划の树形dp</center></h2><span id="more"></span>
<h2 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h2><p>动态规划这东西是没有模板的。。</p>
<p>因此，通过最近的刷题，我总结出了树形DP的一些套路：</p>
<p>通常情况下，<strong>树形DP是需要结合DFS和回溯一起使用的</strong>，其中的状态通常定义为一个节点的状态，它有可能受到它的儿子节点（或者父亲节点）的影响，因此就会出现多个状态，而<strong>状态转移方程</strong>通常由儿子（或父亲）的状态推得，具体问题具体分析，下面来搞几道典型例题</p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="1-POJ-2342-没有上司的舞会"><a href="#1-POJ-2342-没有上司的舞会" class="headerlink" title="1. POJ 2342 没有上司的舞会"></a>1. <a href="https://vjudge.net/problem/POJ-2342">POJ 2342 没有上司的舞会</a></h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>一棵节点有权值的树，从中取出一些节点，相邻的两节点不能同时取出，问取出节点的权值和最大值是多少？</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>定义如下两个状态</p>
<script type="math/tex; mode=display">
dp[i][0]:不取i节点时i和它的所有子树获得的最大权值和\\
dp[i][1]:取i节点时i和它的所有子树获得的最大权值和</script><p>则转移方程如下（其中<code>v</code>为<code>i</code>的子节点们）</p>
<script type="math/tex; mode=display">
\begin{aligned}
&dp[i][0]=dp[i][0]+\sum max(dp[v][0],dp[v][1])\\
&dp[i][1]=dp[i][1]+\sum dp[v][0]
\end{aligned}</script><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> v,next;<br>&#125;e[<span class="hljs-number">50005</span>];<br><span class="hljs-type">int</span> cnt,head[<span class="hljs-number">50005</span>]; <br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;<br>	e[cnt]=Edge&#123;v,head[u]&#125;;<br>	head[u]=cnt++;<br>&#125;<br><span class="hljs-type">int</span> n,indeg[<span class="hljs-number">6005</span>],val[<span class="hljs-number">6005</span>],dp[<span class="hljs-number">6005</span>][<span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>	dp[x][<span class="hljs-number">1</span>]=val[x];<span class="hljs-comment">//取的话，最小值就是本身节点的权值</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-built_in">dfs</span>(v); <span class="hljs-comment">//挖到最孙子的那一个节点</span><br>		dp[x][<span class="hljs-number">1</span>]+=dp[v][<span class="hljs-number">0</span>]; <span class="hljs-comment">//开始dp</span><br>		dp[x][<span class="hljs-number">0</span>]+=<span class="hljs-built_in">max</span>(dp[v][<span class="hljs-number">0</span>],dp[v][<span class="hljs-number">1</span>]);<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>	<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;val[i]);<br>	<span class="hljs-type">int</span> u,v;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);<br>		<span class="hljs-keyword">if</span>(u==<span class="hljs-number">0</span>&amp;&amp;v==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>		<span class="hljs-built_in">addedge</span>(v,u);<br>		indeg[u]++;<br>	&#125;<br>	<span class="hljs-type">int</span> start;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">if</span>(indeg[i]==<span class="hljs-number">0</span>)&#123;<br>			start=i; <span class="hljs-comment">//找根节点</span><br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">dfs</span>(start);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">max</span>(dp[start][<span class="hljs-number">0</span>],dp[start][<span class="hljs-number">1</span>])); <span class="hljs-comment">//取个最大值</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="POJ-1463-Strategic-game"><a href="#POJ-1463-Strategic-game" class="headerlink" title="POJ 1463 Strategic game"></a><a href="https://vjudge.net/problem/POJ-1463">POJ 1463 Strategic game</a></h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>在一棵树的节点上安放士兵，每个士兵能守卫与它相连的所有边，问最少需要几个士兵才能守卫到所有边？</p>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>跟上一题重题啊，代码只需要把DFS第一行的<code>dp[i][1]=val[i]</code>改成<code>dp[i][1]=1</code>就行了</p>
<h3 id="POJ-2378-Tree-Cutting"><a href="#POJ-2378-Tree-Cutting" class="headerlink" title="POJ 2378 Tree Cutting"></a><a href="https://vjudge.net/problem/POJ-2378">POJ 2378 Tree Cutting</a></h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>要求你删除一棵树的一些节点，使得删掉这个节点之后形成的两棵子树节点数均不超过总结点数的一半，问哪些节点可以删除，升序输出它们</p>
<h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>利用<strong>求树的重心</strong>的DP过程，在每个节点的子节点遍历完之后判断一下是否存在<code>n-Size[x]&lt;=n/2&amp;&amp;ans[x]&lt;=n/2</code>（其中<code>Size[x]</code>是以x节点为父亲的这棵树的节点总数，<code>ans[x]</code>是以x节点为父亲的这棵树的儿子中节点数最大的子树的节点数），如果可行，就标记一下这个节点，最后按顺序遍历输出就行了</p>
<h4 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h4><details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> v,next;<br>&#125;e[<span class="hljs-number">50005</span>];<br><span class="hljs-type">int</span> cnt,head[<span class="hljs-number">50005</span>]; <br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;<br>	e[cnt]=Edge&#123;v,head[u]&#125;;<br>	head[u]=cnt++;<br>&#125;<br><span class="hljs-type">int</span> n,dp[<span class="hljs-number">60005</span>][<span class="hljs-number">2</span>],Size[<span class="hljs-number">50005</span>],ans[<span class="hljs-number">50005</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>	cnt=<span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br>&#125;<br><span class="hljs-type">bool</span> giao[<span class="hljs-number">10005</span>],f;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span></span>&#123;<br>	Size[x]=<span class="hljs-number">1</span>;<br>	ans[x]=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(v==fa) <span class="hljs-keyword">continue</span>;<br>		<span class="hljs-built_in">dfs</span>(v,x);<br>		Size[x]+=Size[v];<br>		ans[x]=<span class="hljs-built_in">max</span>(ans[x],Size[v]);<br>	&#125;<br>	<span class="hljs-keyword">if</span>(ans[x]&lt;=n/<span class="hljs-number">2</span>&amp;&amp;n-Size[x]&lt;=n/<span class="hljs-number">2</span>)&#123;<br>		giao[x]=<span class="hljs-number">1</span>;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>	<span class="hljs-built_in">init</span>();<br>	<span class="hljs-type">int</span> u,v;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);<br>		<span class="hljs-built_in">addedge</span>(u,v);<br>		<span class="hljs-built_in">addedge</span>(v,u); <br>	&#125;<br>	<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">if</span>(giao[i])&#123;<br>			f=<span class="hljs-literal">true</span>;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,i);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">if</span>(!f) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NONE\n&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="ZOJ-3201-Tree-of-Tree"><a href="#ZOJ-3201-Tree-of-Tree" class="headerlink" title="ZOJ 3201 Tree of Tree"></a><a href="https://vjudge.net/problem/ZOJ-3201">ZOJ 3201 Tree of Tree</a></h3><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>给你一棵节点带权的树，要求找出指定节点数的权值和最大的子树的权值和</p>
<h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><p>树形DP+背包</p>
<p>定义状态：</p>
<script type="math/tex; mode=display">
dp[i][j]:以i为父节点的节点数为j的树的最大权值和</script><p>转移方程：</p>
<script type="math/tex; mode=display">
dp[i][j]=max(dp[i][j],dp[i][j-l]+dp[v][l])其中l\in[1,k-1]</script><p>可以先像<strong>求树的重心</strong>那样DFS到叶子节点，然后开始倒着背包（注意：枚举的时候像背包一样倒着枚举）</p>
<h4 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h4><details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> v,next;<br>&#125;e[<span class="hljs-number">50005</span>];<br><span class="hljs-type">int</span> cnt,head[<span class="hljs-number">505</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;<br>	e[cnt]=Edge&#123;v,head[u]&#125;;<br>	head[u]=cnt++;<br>&#125;<br><span class="hljs-type">int</span> n,k,val[<span class="hljs-number">505</span>],dp[<span class="hljs-number">205</span>][<span class="hljs-number">205</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>	cnt=<span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dp));<br>	<span class="hljs-built_in">memset</span>(val,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(val));<br>	<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span></span>&#123;<br>	dp[x][<span class="hljs-number">1</span>]=val[x];<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(v==fa) <span class="hljs-keyword">continue</span>;<br>		<span class="hljs-built_in">dfs</span>(v,x);<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=k;j&gt;=<span class="hljs-number">1</span>;j--)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=j<span class="hljs-number">-1</span>;l&gt;=<span class="hljs-number">1</span>;l--)&#123;<br>				dp[x][j]=<span class="hljs-built_in">max</span>(dp[x][j],dp[x][j-l]+dp[v][l]);<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k))&#123;<br>		<span class="hljs-built_in">init</span>();<br>		<span class="hljs-type">int</span> u,v;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;val[i]);<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);<br>			<span class="hljs-built_in">addedge</span>(u,v);<br>			<span class="hljs-built_in">addedge</span>(v,u);<br>		&#125;<br>		<br>		<span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>);<br>		<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>			ans=<span class="hljs-built_in">max</span>(ans,dp[i][k]);<br>		&#125;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="POJ-3659-Cell-Phone-Network"><a href="#POJ-3659-Cell-Phone-Network" class="headerlink" title="POJ 3659 Cell Phone Network"></a><a href="https://vjudge.net/problem/POJ-3659">POJ 3659 Cell Phone Network</a></h3><h4 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h4><p>有点像上面那道安防士兵的题，条件改为：每个士兵能守护到自己以及与它相连的每个节点，问最少需要安放多少士兵才能够守护到所有节点？</p>
<h4 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h4><p>似乎可以定义一个一模一样的状态：</p>
<script type="math/tex; mode=display">
dp[i][0]:i节点安放士兵时i和儿子们的最少士兵数\\
dp[i][1]:i节点不安放士兵时i和儿子们的最少士兵数</script><p>但是这样的话，会发现<code>dp[i][1]</code>的转移方程写不出来，因为如果一个点不放士兵，那么可以从他的儿子中任选一个放一个士兵就行了，但这样的话，他的父节点就又受到了影响，因此我们需要换一种状态表示</p>
<script type="math/tex; mode=display">
\begin{aligned}
&dp[i][0]:i节点放士兵\\
&dp[i][1]:i节点不放士兵，由它的父亲守护\\
&dp[i][2]:i节点不放士兵，由它的儿子守护
\end{aligned}</script><p>转移方程如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&dp[i][0]=dp[i][0]+\sum min(dp[v][0],dp[v][1],dp[v][2])\\
&dp[i][1]=dp[i][1]+\sum min(dp[v][0],dp[v][2])\\
&dp[i][2]=dp[i][2]+\sum min(dp[v][0],dp[v][2])???
\end{aligned}</script><p>我们发现，第三行这个转移方程有点问题：如果全都是由<code>dp[v][2]</code>转移过来的，那么<code>i</code>这个点就没有被守护到，那怎么办呢？</p>
<p>很简单，只需要每次遍历儿子节点的时候比较一下$dp[v][0]和dp[v][2]$的大小，如果前者比后者大了，就记录一下<strong>两者最小的差值</strong>，遍历完所有儿子后如果是前者一直都比后者大，那么就出现了上述特例，需要强行给<code>i</code>节点的值加上这个最小差值（表示强制让一个最优的儿子去守护自己，保证了最小）</p>
<h4 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码"></a>AC代码</h4><details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123; <br>	ll kk=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>; <br>	<span class="hljs-type">char</span> cc=<span class="hljs-built_in">getchar</span>(); <br>	<span class="hljs-keyword">while</span>(cc&lt;<span class="hljs-string">&#x27;0&#x27;</span>||cc&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<span class="hljs-keyword">if</span>(cc==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;cc=<span class="hljs-built_in">getchar</span>();&#125; <br>	<span class="hljs-keyword">while</span>(cc&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;cc&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;kk=(kk&lt;&lt;<span class="hljs-number">1</span>)+(kk&lt;&lt;<span class="hljs-number">3</span>)+cc-<span class="hljs-string">&#x27;0&#x27;</span>;cc=<span class="hljs-built_in">getchar</span>();&#125; <br>	<span class="hljs-keyword">return</span> kk*f; <br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> v,next;<br>&#125;e[<span class="hljs-number">500005</span>];<br><span class="hljs-type">int</span> cnt,head[<span class="hljs-number">50005</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;<br>	e[cnt]=Edge&#123;v,head[u]&#125;;<br>	head[u]=cnt++;<br>&#125;<br><span class="hljs-type">int</span> n,dp[<span class="hljs-number">500005</span>][<span class="hljs-number">3</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>	cnt=<span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br>&#125;<br><span class="hljs-type">bool</span> vis[<span class="hljs-number">500005</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span></span>&#123;<br>	dp[x][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>	<span class="hljs-type">bool</span> f=<span class="hljs-literal">false</span>;<br>	<span class="hljs-type">int</span> minh=inf;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(v==fa) <span class="hljs-keyword">continue</span>;<br>		<span class="hljs-built_in">dfs</span>(v,x);<br>		dp[x][<span class="hljs-number">0</span>]+=<span class="hljs-built_in">min</span>(dp[v][<span class="hljs-number">0</span>],<span class="hljs-built_in">min</span>(dp[v][<span class="hljs-number">1</span>],dp[v][<span class="hljs-number">2</span>]));<br>		dp[x][<span class="hljs-number">1</span>]+=<span class="hljs-built_in">min</span>(dp[v][<span class="hljs-number">0</span>],dp[v][<span class="hljs-number">2</span>]);<br>		<span class="hljs-keyword">if</span>(dp[v][<span class="hljs-number">0</span>]&lt;=dp[v][<span class="hljs-number">2</span>])&#123;<br>			f=<span class="hljs-literal">true</span>; <span class="hljs-comment">//没必要强制转换了</span><br>			dp[x][<span class="hljs-number">2</span>]+=dp[v][<span class="hljs-number">0</span>];<br>		&#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//记录最小差值</span><br>			minh=<span class="hljs-built_in">min</span>(minh,dp[v][<span class="hljs-number">0</span>]-dp[v][<span class="hljs-number">2</span>]);<br>			dp[x][<span class="hljs-number">2</span>]+=dp[v][<span class="hljs-number">2</span>];<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-keyword">if</span>(!f)&#123; <span class="hljs-comment">//如果出现了特例，就要强制把一个最好的儿子抓过来</span><br>		dp[x][<span class="hljs-number">2</span>]+=minh;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	n=<span class="hljs-built_in">read</span>();<br>	<span class="hljs-built_in">init</span>();<br>	<span class="hljs-type">int</span> u,v;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>		u=<span class="hljs-built_in">read</span>(),v=<span class="hljs-built_in">read</span>();<br>		<span class="hljs-built_in">addedge</span>(u,v);<br>		<span class="hljs-built_in">addedge</span>(v,u);<br>	&#125;<br>	<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">min</span>(dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],dp[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]));<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="HDU-2196-Computer"><a href="#HDU-2196-Computer" class="headerlink" title="HDU 2196 Computer"></a><a href="https://vjudge.net/problem/HDU-2196">HDU 2196 Computer</a></h3><h4 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h4><p>给一棵树，求到每个节点距离最远的节点之间距离</p>
<h4 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h4><p>这题让我学会了一个最最简洁优美的求<strong>树的直径</strong>的代码</p>
<p>利用求树的直径的算法，这题需要<strong>三次DFS</strong>：第一次从任意节点出发找到直径的一端；第二次从这一端出发，同时更新每个节点到这一端的距离，并找到另一端；第三次从另一端出发，更新每个节点到另一端和到这一端两者中的最远距离</p>
<p>而这三次DFS可以通过同一个函数完成：<code>dfs(int x,int fa,int len)</code></p>
<h4 id="AC代码-4"><a href="#AC代码-4" class="headerlink" title="AC代码"></a>AC代码</h4><details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	ll v,w,next;<br>&#125;e[<span class="hljs-number">500005</span>];<br>ll cnt,head[<span class="hljs-number">50005</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(ll u,ll v,ll w)</span></span>&#123;<br>	e[cnt]=Edge&#123;v,w,head[u]&#125;;<br>	head[u]=cnt++;<br>&#125;<br>ll n,vis[<span class="hljs-number">500005</span>],start;<br>ll dis[<span class="hljs-number">500005</span>],ans;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>	cnt=ans=start=<span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br>	<span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dis));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(ll x,ll fa,ll len)</span></span>&#123; <span class="hljs-comment">//核心！！！</span><br>	<span class="hljs-keyword">for</span>(ll i=head[x];~i;i=e[i].next)&#123;<br>		ll v=e[i].v,w=e[i].w;<br>		<span class="hljs-keyword">if</span>(v==fa) <span class="hljs-keyword">continue</span>;<br>		<span class="hljs-built_in">dfs</span>(v,x,len+w);<br>		dis[v]=<span class="hljs-built_in">max</span>(dis[v],len+w);<br>		<span class="hljs-keyword">if</span>(len+w&gt;=ans)&#123; <span class="hljs-comment">//一定是&gt;=,否则另一端找不到QAQ</span><br>			ans=len+w;<br>			start=v;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;n)!=EOF)&#123;<br>		<span class="hljs-built_in">init</span>();<br>		ll u,w;<br>		<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;u,&amp;w);<br>			<span class="hljs-built_in">addedge</span>(i,u,w);<br>			<span class="hljs-built_in">addedge</span>(u,i,w);<br>		&#125;<br>		<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>		<span class="hljs-built_in">dfs</span>(start,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>		<span class="hljs-built_in">dfs</span>(start,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>		<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,dis[i]);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组(BIT)专题</title>
    <url>/2020/03/30/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-BIT-%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h2 id="Binary-Indexed-Tree"><a href="#Binary-Indexed-Tree" class="headerlink" title="Binary Indexed Tree"></a><center>Binary Indexed Tree</center></h2><span id="more"></span>
<p>参考blog：</p>
<ul>
<li><a href="https://www.cnblogs.com/xenny/p/9739600.html">树状数组详解</a></li>
</ul>
<p>写的真是太好啦！！！</p>
<p>树状数组是一个比线段树常数小，码量小的数据结构，可在$O(logn)$时间内解决一写简单的<strong>单点/区间修改 和 单点/区间查询</strong>的问题</p>
<p>树状数组里最核心的操作：<code>lowbit</code>操作，作用是求出一个数最低位的1，即从右往左数第一个1所对应的二进制数，也即<code>2^k</code>其中k为从右往左数碰到第一个1之前的连续0的个数，那么它可以用一下操作实现</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x&amp;-x;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="单点更新-单点查询"><a href="#单点更新-单点查询" class="headerlink" title="单点更新+单点查询"></a>单点更新+单点查询</h3><p><del>啊、这。。。</del>传统数组不就行了嘛</p>
<h3 id="单点更新-区间查询"><a href="#单点更新-区间查询" class="headerlink" title="单点更新+区间查询"></a>单点更新+区间查询</h3><p><a href="https://www.luogu.com.cn/problem/P3374">【模板】树状数组1</a></p>
<p>这是最简单的树状数组应用，构建树状数组的方法就是：输入的时候同时<strong>利用原始数组的值完成单点更新</strong></p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<span class="hljs-comment">//求1~i区间的和</span><br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">0</span>) res+=c[i],i-=<span class="hljs-built_in">lowbit</span>(i);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> k)</span></span>&#123;<span class="hljs-comment">//在原数组i位置加上k</span><br>    <span class="hljs-keyword">while</span>(i&lt;=n) c[i]+=k,i+=<span class="hljs-built_in">lowbit</span>(i);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]),<span class="hljs-built_in">update</span>(i,a[i]);<span class="hljs-comment">//输入时同时更新</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<p>除此之外，单点更新+区间查询的<strong>异或和</strong>、<strong>乘积</strong>也是可以维护的，这里就不贴代码了（注意乘积的区间查询和单点更新需要把<strong>除法转换成乘法逆元</strong>）</p>
<p><a href="https://ac.nowcoder.com/acm/problem/17507">【模板题】单点更新+区间乘积查询</a></p>
<h3 id="区间更新-单点查询"><a href="#区间更新-单点查询" class="headerlink" title="区间更新+单点查询"></a>区间更新+单点查询</h3><p><a href="https://www.luogu.com.cn/problem/P3368">【模板】树状数组2</a></p>
<p>这是一个简单的变式，只需要利用原数组的<strong>差分</strong>构建树状数组，这样一来对于区间<code>[l,r]</code>的更新就只需要<code>update(l,k),update(r+1,-k)</code>就行了（类似于前缀和差分），而单点查询就是求一次和啦~</p>
<p>只需要把上面的输入时更新换为：<code>update(i,a[i]-a[i-1])</code></p>
<p>更新时，区间<code>[l,r]+k</code>：<code>update(l,k),update(r+1,-k)</code></p>
<p>查询<code>x</code>点的值：<code>getsum(x)</code></p>
<h3 id="区间更新-区间查询"><a href="#区间更新-区间查询" class="headerlink" title="区间更新+区间查询"></a>区间更新+区间查询</h3><p>可以很快地过了这道弱化的线段树模板题：<a href="https://www.luogu.com.cn/problem/P3372">【模板】线段树1</a></p>
<p>这是进阶版的变式，根据blog里面的推算公式，我们需要维护两个由差分构成的树状数组，满足下面的关系式，最后的答案就是<code>x*getsum1(x)-getsum2(x)</code></p>
<script type="math/tex; mode=display">
\sum_{i=1}^nA[i]=n*\sum_{i=1}^nD[i]-\sum_{i=1}^n\left(D[i]*(i-1)\right)</script><details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> k)</span></span>&#123;<span class="hljs-comment">//单点更新</span><br>    <span class="hljs-type">int</span> x=i;<br>    <span class="hljs-comment">//这里需要维护两个树状数组</span><br>    <span class="hljs-keyword">while</span>(i&lt;=n) c1[i]+=k,c2[i]+=k*(x<span class="hljs-number">-1</span>),i+=<span class="hljs-built_in">lowbit</span>(i);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<span class="hljs-comment">//前缀和</span><br>    ll res=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> x=i;<br>    <span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">0</span>) res+=x*c1[i]-c2[i],i-=<span class="hljs-built_in">lowbit</span>(i);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-built_in">update</span>(l,k),<span class="hljs-built_in">update</span>(r+<span class="hljs-number">1</span>,-k);<span class="hljs-comment">//区间更新</span><br><span class="hljs-built_in">getsum</span>(r)-<span class="hljs-built_in">getsum</span>(l<span class="hljs-number">-1</span>);<span class="hljs-comment">//区间查询</span><br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="括号法维护种类数"><a href="#括号法维护种类数" class="headerlink" title="括号法维护种类数"></a>括号法维护种类数</h3><p>例题：<a href="https://vijos.org/p/1448">校门外的树</a></p>
<p>题意：</p>
<p>区间更新：使<code>[l,r]</code>区间内增加一种新品种</p>
<p>区间查询：询问<code>[l,r]</code>区间内种类总数</p>
<p>所谓括号法，就是使用一个BIT维护区间更新时的左端点（称为左括号）个数，另一个BIT维护右端点（称为右括号）个数，这样一来上面的区间更新就变为单点更新（更新左右括号），区间查询时就是<strong>右端点左侧（包括右端点）的左括号总数-左端点左侧（不包括左端点）的右括号总数</strong>（因为只要左端点左侧的左括号没有右括号匹配，就说明匹配他的右括号在左端点右边，那么种类数+1）</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">update</span>(c1,l,<span class="hljs-number">1</span>),<span class="hljs-built_in">update</span>(c2,r,<span class="hljs-number">1</span>);<span class="hljs-comment">//c1维护左括号，c2维护右括号</span><br>ans=<span class="hljs-built_in">getsum</span>(c1,r)-<span class="hljs-built_in">getsum</span>(c2,l<span class="hljs-number">-1</span>);<span class="hljs-comment">//得到[l,r]区间种类总数</span><br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="树状数组求逆序对"><a href="#树状数组求逆序对" class="headerlink" title="树状数组求逆序对"></a>树状数组求逆序对</h3><p>模板题：<a href="https://vjudge.net/problem/POJ-2299">POJ 2299 Ultra-QuickSort</a></p>
<p>首先是离散化操作三部曲：排序、去重、二分查找更新原数组</p>
<p>离散化之后，我们就得到了<strong>每个数的相对大小位置</strong>，从1~n遍历整个数组，利用一个<strong>树状数组存储每个数出现的次数</strong>，每次利用<code>i-getsum(a[i])</code>更新答案（其中<code>getsum(a[i])</code>是从<code>1</code>到<code>a[i]</code>中的数出现的次数，即小于等于<code>a[i]</code>的数出现的次数，<code>i</code>是当前取出的数的个数，那么<code>i-getsum(a[i])</code>就是到目前为止大于<code>a[i]</code>的数出现的次数，当然这里的<code>a[i]</code>是已经离散化过后的，只保留了相对大小）</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">int</span> n;<br>ll a[<span class="hljs-number">500005</span>],c[<span class="hljs-number">500005</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">lowbit</span><span class="hljs-params">(ll x)</span></span>&#123;<span class="hljs-keyword">return</span> x&amp;-x;&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> i,ll k)</span></span>&#123;<br>	<span class="hljs-keyword">while</span>(i&lt;=n) c[i]+=k,i+=<span class="hljs-built_in">lowbit</span>(i);<br>&#125; <br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>	ll res=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">0</span>) res+=c[i],i-=<span class="hljs-built_in">lowbit</span>(i);<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n))&#123;<br>		<span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(c));<br>		<span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>		ll ans=<span class="hljs-number">0</span>;<br>		vector&lt;ll&gt; vec;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i]),vec.<span class="hljs-built_in">push_back</span>(a[i]);<br>		<span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(),vec.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//离散化三部曲</span><br>		vec.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(vec.<span class="hljs-built_in">begin</span>(),vec.<span class="hljs-built_in">end</span>()),vec.<span class="hljs-built_in">end</span>());<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-type">int</span> pos=<span class="hljs-built_in">lower_bound</span>(vec.<span class="hljs-built_in">begin</span>(),vec.<span class="hljs-built_in">end</span>(),a[i])-vec.<span class="hljs-built_in">begin</span>();<br>			<span class="hljs-built_in">update</span>(pos+<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>			ans+=i-<span class="hljs-built_in">getsum</span>(pos+<span class="hljs-number">1</span>);<span class="hljs-comment">//更新答案</span><br>		&#125;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<p><strong>练习题</strong>：</p>
<p><a href="https://vjudge.net/problem/POJ-3067">POJ 3067 Japan</a>（结构体排序+逆序对）</p>
<details>
<summary>code</summary>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">int</span> n,m,k;<br>ll c[<span class="hljs-number">500005</span>];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>	<span class="hljs-type">int</span> x,y;<br>&#125;a[<span class="hljs-number">500005</span>];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node x1,node x2)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(x1.x==x2.x) <span class="hljs-keyword">return</span> x1.y&lt;x2.y;<br>	<span class="hljs-keyword">return</span> x1.x&lt;x2.x;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>	<span class="hljs-keyword">while</span>(i&lt;=m) c[i]++,i+=i&amp;-i;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>	ll res=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">0</span>) res+=c[i],i-=i&amp;-i;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> t;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> o=<span class="hljs-number">1</span>;o&lt;=t;o++)&#123;<br>		<span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(c));<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;i++)&#123;<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a[i].x,&amp;a[i].y);<br>		&#125;<br>		<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">1</span>+k,cmp);<br>		ll ans=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;i++)&#123;<br>			<span class="hljs-built_in">update</span>(a[i].y);<br>			ans+=i-<span class="hljs-built_in">getsum</span>(a[i].y);<br>		&#125;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Test case %d: %lld\n&quot;</span>,o,ans);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<p><a href="https://vjudge.net/problem/POJ-2352">POJ 2352 Stars</a>（裸逆序对）</p>
<details>
<summary>code</summary>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">int</span> n,maxh;<br><span class="hljs-type">int</span> a[<span class="hljs-number">20005</span>],c[<span class="hljs-number">50005</span>];<br>ll ans[<span class="hljs-number">20005</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>	<span class="hljs-keyword">return</span> i&amp;-i;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>	<span class="hljs-keyword">while</span>(i&lt;=maxh) c[i]++,i+=<span class="hljs-built_in">lowbit</span>(i);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>	ll res=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(i) res+=c[i],i-=<span class="hljs-built_in">lowbit</span>(i);<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>	<span class="hljs-type">int</span> x;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a[i],&amp;x),a[i]++,maxh=<span class="hljs-built_in">max</span>(maxh,a[i]);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		ans[<span class="hljs-built_in">getsum</span>(a[i])]++;<br><span class="hljs-comment">//		printf(&quot;%d level:%d\n&quot;,a[i],getsum(a[i]));</span><br>		<span class="hljs-built_in">update</span>(a[i]);<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans[i]);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</details>


<h3 id="树状数组维护区间最值"><a href="#树状数组维护区间最值" class="headerlink" title="树状数组维护区间最值"></a>树状数组维护区间最值</h3><p>参考blog：</p>
<ul>
<li><p><a href="https://blog.csdn.net/u010598215/article/details/48206959?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2">树状数组求区间最大值</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/mypride/p/5002556.html">【进阶——树状数组】 区间求最值</a></p>
</li>
</ul>
<p>最值<strong>不具有结合律</strong>，因此不能用类似于维护前缀和一样简单的方法，那么该怎么维护区间最值呢？</p>
<p>首先，介绍一下<strong>单点更新</strong>（直接更改单点的值，同样维护的是单点最值，需配合查询最值使用），由BIT的特性可知，当要更改下标为<code>x</code>的数时，当遍历到<code>i</code>时至多只有<code>i-lowbit(i)+1 ~ i</code>这么多数受到影响，因此只需要修改这么多数即可</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<span class="hljs-comment">//将下标为x的值更改为y</span><br>    a[x]=y;<span class="hljs-comment">//原数组也得改</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&lt;=n;i+=<span class="hljs-built_in">lowbit</span>(i))&#123;<span class="hljs-comment">//枚举所有跟x有关的树状数组</span><br>        c[i]=y;<span class="hljs-comment">//</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;<span class="hljs-built_in">lowbit</span>(i);j&lt;&lt;=<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//枚举所有当前i值能影响到的所有树状数组</span><br>            c[i]=<span class="hljs-built_in">max</span>(c[i],c[i-j]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>接下来是<strong>区间最值查询</strong>：由BIT特性可知，对于要查询的区间<code>[l,r]</code>，我们不能直接用<code>c[r]</code>作为答案，因为<code>c[r]</code>的左端点不一定就恰好是<code>l</code>，因此我们要分类讨论一下：</p>
<ol>
<li><code>c[r]</code>左端点<code>i&lt;=r</code>：我们取<code>a[r]</code>更新答案，再令<code>r-=1</code>重复这个讨论过程</li>
<li><code>c[r]</code>左端点<code>i&gt;r</code>：可以直接用<code>c[r]</code>更新答案，然后用<code>[l,i]</code>区间最值重复这个讨论过程</li>
</ol>
<p>上述的<code>c[r]</code>左端点<code>i=r-lowbit(r)</code>，至此，可以得出以下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getmax</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<span class="hljs-comment">//求区间[x,y]最值</span><br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(x&lt;=y)&#123;<span class="hljs-comment">//直到x==y就退出</span><br>        ans=<span class="hljs-built_in">max</span>(ans,a[y]);<span class="hljs-comment">//拿a[y]更新</span><br>        <span class="hljs-keyword">for</span>(y--;y-<span class="hljs-built_in">lowbit</span>(y)&gt;=x;y-=<span class="hljs-built_in">lowbit</span>(y))&#123;<br>            ans=<span class="hljs-built_in">max</span>(ans,c[y]);<span class="hljs-comment">//拿c[y]更新</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>模板题：<a href="https://vjudge.net/problem/HDU-1754">HDU 1754 I Have It</a></p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m,a[<span class="hljs-number">200005</span>],c[<span class="hljs-number">200005</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> x&amp;-x;&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>	a[x]=y;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&lt;=n;i+=<span class="hljs-built_in">lowbit</span>(i))&#123;<br>		c[i]=y;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;<span class="hljs-built_in">lowbit</span>(i);j&lt;&lt;=<span class="hljs-number">1</span>)&#123;<br>			c[i]=<span class="hljs-built_in">max</span>(c[i],c[i-j]);<br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getmax</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>	<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(x&lt;=y)&#123;<br>		ans=<span class="hljs-built_in">max</span>(ans,a[y]);<br>		<span class="hljs-keyword">for</span>(--y;y-<span class="hljs-built_in">lowbit</span>(y)&gt;=x;y-=<span class="hljs-built_in">lowbit</span>(y))&#123;<br>			ans=<span class="hljs-built_in">max</span>(ans,c[y]);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m))&#123;<br>    	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    		<span class="hljs-built_in">update</span>(i,a[i]);<br>		&#125;<br>		<span class="hljs-type">char</span> c[<span class="hljs-number">2</span>];<span class="hljs-type">int</span> x,y;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%d%d&quot;</span>,c,&amp;x,&amp;y);<br>			<span class="hljs-keyword">if</span>(c[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;U&#x27;</span>) <span class="hljs-built_in">update</span>(x,y);<br>			<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">getmax</span>(x,y));<br>		&#125;<br>	&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h2 id="二维树状数组"><a href="#二维树状数组" class="headerlink" title="二维树状数组"></a><center>二维树状数组</center></h2><p>参考blog：</p>
<ul>
<li><a href="https://blog.csdn.net/qq_35885746/article/details/89247993?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task">二维树状数组</a></li>
</ul>
<p>类似于<strong>二维前缀和</strong>，我们可以维护一个二维树状数组来实现<strong>单点更新和区间查询</strong>的操作，同理，可以通过<strong>差分</strong>操作来实现<strong>区间更新和单点查询</strong>操作</p>
<h3 id="单点更新-区间查询-1"><a href="#单点更新-区间查询-1" class="headerlink" title="单点更新+区间查询"></a>单点更新+区间查询</h3><p>将二维数组中<code>[x,y]</code>的值+k</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&lt;=n;i+=<span class="hljs-built_in">lowbit</span>(i))<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=y;j&lt;=m;j+=<span class="hljs-built_in">lowbit</span>(j))<br>            c[i][j]+=k;<br>&#125;<br><span class="hljs-built_in">update</span>(x,y,k);<br></code></pre></div></td></tr></table></figure>
<p>求二维数组从<code>[1,1]</code>到<code>[x,y]</code>的元素和</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&gt;<span class="hljs-number">0</span>;i-=<span class="hljs-built_in">lowbit</span>(i))<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=y;j&gt;<span class="hljs-number">0</span>;j-=<span class="hljs-built_in">lowbit</span>(j))<br>            res+=c[i][j];<br>&#125;<br><span class="hljs-built_in">getsum</span>(x,y);<br></code></pre></div></td></tr></table></figure>
<p>求二维数组从<code>[x1,y1]</code>到<code>[x2,y2]</code>的和</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">getsum</span>(x2,y2)-<span class="hljs-built_in">getsum</span>(x2,y1<span class="hljs-number">-1</span>)-<span class="hljs-built_in">getsum</span>(x1<span class="hljs-number">-1</span>,y2)+<span class="hljs-built_in">getsum</span>(x1<span class="hljs-number">-1</span>,y1<span class="hljs-number">-1</span>)<br></code></pre></div></td></tr></table></figure>
<h3 id="区间更新-单点查询-1"><a href="#区间更新-单点查询-1" class="headerlink" title="区间更新+单点查询"></a>区间更新+单点查询</h3><p>模板题：<a href="https://vjudge.net/problem/POJ-2155">POJ 2155 Matrix</a></p>
<p>维护差分数组后：</p>
<p>将二维数组从<code>[x1,y1]</code>到<code>[x2,y2]</code>的值全部+k</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">update</span>(x1,y1,k);<br><span class="hljs-built_in">update</span>(x2+<span class="hljs-number">1</span>,y1,-k);<span class="hljs-comment">//注意两负两正</span><br><span class="hljs-built_in">update</span>(x1,y2+<span class="hljs-number">1</span>,-k);<br><span class="hljs-built_in">update</span>(x2+<span class="hljs-number">1</span>,y2+<span class="hljs-number">1</span>,k)<br></code></pre></div></td></tr></table></figure>
<p>求二维数组在<code>[x,y]</code>处的值</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">getsum</span>(x,y)<br></code></pre></div></td></tr></table></figure>
<h3 id="区间更新-区间查询-1"><a href="#区间更新-区间查询-1" class="headerlink" title="区间更新+区间查询"></a>区间更新+区间查询</h3><p>首先放一个很长的公式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1}^x\sum_{j=1}^y\sum_{h=1}^i\sum_{k=1}^jD[h][k]=&\sum_{i=1}^x\sum_{j=1}^yD[i][j](x+1-i)(y+1-j)\\
=&(x+1)(y+1)\sum_{i=1}^x\sum_{j=1}^yD[i][j]\\
&-(y+1)\sum_{i=1}^x\sum_{j=1}^yD[i][j]*i\\
&-(x+1)\sum_{i=1}^x\sum_{j=1}^yD[i][j]*j\\
&+\sum_{i=1}^x\sum_{j=1}^yD[i][j]*i*j
\end{aligned}</script><p>于是我们需要维护四个树状数组：</p>
<script type="math/tex; mode=display">
D[i][j],D[i][j]*i,D[i][j]*j,D[i][j]*i*j</script><details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> k)</span></span>&#123;<span class="hljs-comment">//单点更新</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&lt;=n;i+=<span class="hljs-built_in">lowbit</span>(i))<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=y;j&lt;=m;j+=<span class="hljs-built_in">lowbit</span>(j))&#123;<br>            c1[i][j]+=k;<br>            c2[i][j]+=k*x;<br>            c3[i][j]+=k*y;<br>            c4[i][j]+=k*x*y;<br>        &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<span class="hljs-comment">//前缀和</span><br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i;i-=<span class="hljs-built_in">lowbit</span>(i))<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=y;j;j-=<span class="hljs-built_in">lowbit</span>(j))<br>            res+=(x+<span class="hljs-number">1</span>)*(y+<span class="hljs-number">1</span>)*c1[i][j]-(y+<span class="hljs-number">1</span>)*c2[i][j]-(x+<span class="hljs-number">1</span>)*c3[i][j]+c4[i][j];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">//区间更新</span><br><span class="hljs-built_in">update</span>(x1,y1,k);<br><span class="hljs-built_in">update</span>(x1,y2+<span class="hljs-number">1</span>,-k);<br><span class="hljs-built_in">update</span>(x2+<span class="hljs-number">1</span>,y1,-k);<br><span class="hljs-built_in">update</span>(x2+<span class="hljs-number">1</span>,y2+<span class="hljs-number">1</span>,k);<br><br><span class="hljs-comment">//区间查询</span><br><span class="hljs-built_in">getsum</span>(x2,y2)-<span class="hljs-built_in">getsum</span>(x1<span class="hljs-number">-1</span>,y2)-<span class="hljs-built_in">getsum</span>(x2,y1<span class="hljs-number">-1</span>)+<span class="hljs-built_in">getsum</span>(x1<span class="hljs-number">-1</span>,y1<span class="hljs-number">-1</span>);<br></code></pre></div></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共子序列（LCS）详解</title>
    <url>/2020/01/17/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88LCS%EF%BC%89%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="最长公共子序列（Longest-Common-Subsequence）解法和优化"><a href="#最长公共子序列（Longest-Common-Subsequence）解法和优化" class="headerlink" title="最长公共子序列（Longest Common Subsequence）解法和优化"></a><center>最长公共子序列（Longest Common Subsequence）解法和优化</center></h2><span id="more"></span>
<hr>
<p>谈完LIS，下面来谈一谈LCS（最长公共子序列问题），本文主要分析一下该问题的一般解法和较优解法，基本上基于两道题目：<strong>一般的LCS问题 </strong>和 <strong><a href="https://www.luogu.com.cn/problem/P1439">洛谷P1439</a></strong>。</p>
<hr>
<h2 id="一般的LCS问题解法"><a href="#一般的LCS问题解法" class="headerlink" title="一般的LCS问题解法"></a>一般的LCS问题解法</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote>
<p>给定两个字符串$s_1s_2…s_n$和$t_1t_2…t_m$。求出这两个字符串中最长的公共子序列的长度。</p>
<p>数据范围：$1\leq n,m\leq1000$</p>
<p>Sample Input: </p>
<figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">3</span> <span class="hljs-number">5</span> <br><span class="hljs-attribute">ade</span> abcde<br></code></pre></div></td></tr></table></figure>
<p>Sample Output:</p>
<figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">3<br></code></pre></div></td></tr></table></figure>
</blockquote>
<h3 id="一般解法"><a href="#一般解法" class="headerlink" title="一般解法"></a>一般解法</h3><p>这是一道很经典的<strong>动态规划</strong>入门题，具体思路：</p>
<ol>
<li><p>定义状态：$dp[i][j]$表示字符串$s_1s_2…s_i$和$t_1t_2…t_j$的LCS长度</p>
</li>
<li><p>状态转移：我们发现，以上状态可以通过如下几种状态转移得到：</p>
<p>当$s_{i+1}=t_{j+1}$时，表明两个序列这一项出现了公共成分，那么就应该在$s<em>1s_2…s_i$和$t_1t_2…t_j$的LCS结尾追加上$s</em>{i+1}$，即$dp[i+1][j+1]=dp[i][j]+1$；</p>
<p>除上述情况之外的其他情况，都不能再原先LCS上追加，那么新状态就应该等于某一个旧状态，应当是是$dp[i+1][j]$和$dp[i][j+1]$两者中的较大者。</p>
</li>
</ol>
<p>至此，所有状态都考虑完毕了，状态转移方程可以写成如下形式：</p>
<script type="math/tex; mode=display">
dp[i+1][j+1]=\begin{cases}dp[i][j]+1\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (s_{i+1}=t_{j+1}) \\ \max(dp[i+1][j],dp[i][j+1])\ \ \ \ (else) \end{cases}</script><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">int</span> <span class="hljs-type">const</span> maxn = <span class="hljs-number">10005</span>;<br>ll dp[maxn][maxn];<br><span class="hljs-type">char</span> a[maxn],b[maxn];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> n,m;<br>	cin&gt;&gt;n&gt;&gt;m;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		cin&gt;&gt;a[i];<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>		cin&gt;&gt;b[i];<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>			<span class="hljs-keyword">if</span>(a[i]==b[j])&#123;<br>				dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>			&#125;<span class="hljs-keyword">else</span>&#123;<br>				dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>]); <br>			&#125;<br>		&#125;<br>	&#125;<br>	cout&lt;&lt;dp[n][m];<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>可以看出，上述解法的时间复杂度为$O(nm)$，对于本题数据完全可以AC，但对于较大的数据量就必然会暴毙，因此下面介绍一种更优($O(nlogn)$)的解法。</li>
</ul>
<h2 id="洛谷P1439-模板-最长公共子序列"><a href="#洛谷P1439-模板-最长公共子序列" class="headerlink" title="洛谷P1439 [模板]最长公共子序列"></a>洛谷P1439 [模板]最长公共子序列</h2><ul>
<li>当然，这道题出现在了$nlogn$数据结构的模板题里面，明摆着是要我们优化时间复杂度吧。。下面看题：</li>
</ul>
<h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote>
<p>给出1~n的两个全排列，求它们的LCS</p>
<p>数据规模：$n\leq1e5$</p>
<p>Sample Input:</p>
<figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></div></td></tr></table></figure>
<p>Sample Output:</p>
<figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">3<br></code></pre></div></td></tr></table></figure>
</blockquote>
<p>单纯的我照着一般解法搞了一下这题，混了50分。。。<br><img src="https://i.loli.net/2020/01/18/47KAc5Xi2Thuzq9.png" alt="毫无追求的我"></p>
<p>哦豁，数据量这么大，连dp数组都开不了，更别说双重循环的复杂度了，这可咋办呢？<br><del>我也是有追求的</del></p>
<h3 id="nlogn-解法"><a href="#nlogn-解法" class="headerlink" title="$nlogn$解法"></a>$nlogn$解法</h3><p>莫慌，这题明摆着需要logn的方法，那么我们想想，最简单的logn方法是什么呢？</p>
<p>对了，就是<strong>二分</strong>！</p>
<p>那么，想要二分，就必须要找到单调有序的东西，这道题看起来好像找不到单调有序的东西啊。。。</p>
<p>我们回想一下之前学过的LIS，对了，LIS的nlogn解法不就是利用的状态数组的单调性吗？那么这道LCS的题可不可以也用LIS的方法来解呢？</p>
<p>我们发现，与LIS不同的是，本体有两个数组需要考虑，求其公共，而LIS只有一个数组，求其最长上升，最长上升，最简单的上升是什么？1234567对不对？再仔细琢磨，难道不可以把求LIS想象成是求原数组和1234567…这样一个有序数组的LCS吗？</p>
<p>这么一想，这题似乎有着落了，但还剩下一个问题，就是题目的两个数组都是乱的，这该怎么办呢？</p>
<p>那还不简单，随便挑一个数组把他“编码成”（或者说“看成”，行话叫<em>哈希表</em>或者<em>map</em>或者<em>离散化</em>）类似于1234567的单调上升数组不就行了，然后再依照这个编码去找和另一个数组的LCS，于是这题就被完美地解决了。</p>
<p>附上AC代码（其中的二分可以去看LIS的那篇文章作了解，这里不加赘述）</p>
<h3 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[<span class="hljs-number">100005</span>],b[<span class="hljs-number">100005</span>],f[<span class="hljs-number">100005</span>];<br><span class="hljs-type">int</span> fun[<span class="hljs-number">100005</span>],len;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bound</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>	<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,r=len;<br>	<span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>		<span class="hljs-type">int</span> mid = (l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">if</span>(f[mid]&gt;x)&#123;<br>			r = mid;<br>		&#125;<span class="hljs-keyword">else</span> l = mid +<span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;n;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		cin&gt;&gt;a[i];<br>		fun[a[i]]=i;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		cin&gt;&gt;b[i];<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">if</span>(f[len]&lt;fun[b[i]])&#123;<br>			f[++len] = fun[b[i]];<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>			<span class="hljs-type">int</span> pos = <span class="hljs-built_in">bound</span>(fun[b[i]]);<br>			f[pos] = fun[b[i]];<br>		&#125;<br>	&#125;<br>	cout&lt;&lt;len&lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>完美！</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://i.loli.net/2020/01/18/VuH9qaDiPKL6Sdw.png" alt="追求"></h2><ul>
<li>可以看出，本题有两个关键点：<ol>
<li>找出映射关系，即编码一个数组为单调上升的；</li>
<li>利用LIS的二分思想，即要知道f数组是单调上升的，这里只是换了个形式。<br>以上。</li>
</ol>
</li>
</ul>
<hr>
<p>那么，咱来搞一道题？</p>
<h2 id="洛谷P2782-友好城市"><a href="#洛谷P2782-友好城市" class="headerlink" title="洛谷P2782 友好城市"></a>洛谷P2782 友好城市</h2><p><a href="https://www.luogu.com.cn/problem/P2782">题目链接</a></p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p><del>这难道不是裸的上一题吗？</del></p>
<p>在草稿纸上胡乱画一通，发现先把南北友好城市都绑定在一起，因为城市是按照坐标排的，于是我随便找一边sort一下，看对应的另一边，有如下规律：</p>
<ul>
<li>如果一边是 2 4，另一边对应着 6 2，那么这个航道就必相交，因为正常排的时候会把另一边也排好顺序，如果是上述这种情况，在另一边排好序的情况下是一定会有相交出现的。所以可以简单地推出如下规律：</li>
<li>这个时候，另一边的最长上升子序列（LIS）就是答案呀！</li>
</ul>
<p>才发现这个题和上面的模板题如出一辙，这个还要简单一些，因为不需要自己编码，排个序就相当于完成了编码工作。</p>
<p>废话少说</p>
<h3 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,fun[<span class="hljs-number">200005</span>];<br><span class="hljs-type">int</span> f[<span class="hljs-number">200005</span>],len;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>	<span class="hljs-type">int</span> a,b;<br>&#125;p[<span class="hljs-number">200005</span>];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node x1,node x2)</span></span>&#123;<br>	<span class="hljs-keyword">return</span> x1.a&lt;x2.a;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bound</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>	<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,r=len;<br>	<span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>		<span class="hljs-type">int</span> mid = (l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">if</span>(f[mid]&gt;x) r = mid;<br>		<span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> l;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;n;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		cin&gt;&gt;p[i].a&gt;&gt;p[i].b;<br>	&#125;<br>	<span class="hljs-built_in">sort</span>(p+<span class="hljs-number">1</span>,p+n+<span class="hljs-number">1</span>,cmp);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">if</span>(p[i].b&gt;f[len])&#123;<br>			f[++len] = p[i].b;<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>			<span class="hljs-type">int</span> pos = <span class="hljs-built_in">bound</span>(p[i].b);<br>			f[pos] = p[i].b;<br>		&#125;<br>	&#125;<br>	cout&lt;&lt;len&lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>动态规划</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>树的直径和重心</title>
    <url>/2020/03/21/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%E5%92%8C%E9%87%8D%E5%BF%83/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<h2 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h2><p><a href="https://www.luogu.com.cn/problem/SP1437">模板题1</a>  <a href="https://vjudge.net/problem/POJ-1985">模板题2</a></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>树中的两节点间最长距离</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>（树形DP可，略）</p>
<p>简述为<strong>两遍DFS（BFS）</strong>：第一遍先从任意一个节点开始DFS，找到与它相连的最长的路径所对应的的节点（<strong>这个点一定是直径的一个端点</strong>），再从这个节点开始DFS，找到的最长路径就是树的直径（证明略。。其实很简单）</p>
<p>注意：两遍DFS之前需要初始化，否则会死的很惨</p>
<h3 id="代码（很巧妙）"><a href="#代码（很巧妙）" class="headerlink" title="代码（很巧妙）"></a>代码（很巧妙）</h3><details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa,<span class="hljs-type">int</span> len)</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v,w=e[i].w;<br>		<span class="hljs-keyword">if</span>(v==fa) <span class="hljs-keyword">continue</span>;<br>		<span class="hljs-built_in">dfs</span>(v,x,len+w);<br>		dis[v]=<span class="hljs-built_in">max</span>(dis[v],len+w);<br>		<span class="hljs-keyword">if</span>(len+w&gt;=ans)&#123;<br>			ans=len+w;<br>			start=v;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>	<span class="hljs-built_in">dfs</span>(start,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h2 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h2><p><a href="https://vjudge.net/problem/POJ-3107">模板题</a>（这题需要按从小到大顺序输出树的每个重心）</p>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>树的重心定义为一个节点，其所有的子树中最大的子树节点数最少</p>
<p>注意：一棵树可能有多个重心</p>
<h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>树形DP的思想</p>
<p>任取一个节点开始DFS，递归遍历它的一颗子树，记录它本身<code>x</code>以及它的父节点<code>fa</code>，DFS过程中只有<strong>当遍历到的节点不等于本身的父节点时</strong>才会继续递归（原因是防止死循环），递归求出这颗子树的节点数<code>Size[v]</code>，经过一轮遍历找出最大值更新给<code>ans[x]</code>，那么这个<code>x</code>对应的<strong>另一颗子树的节点数就是<code>n-Size[x]</code></strong>，两者取最大值就是以这个节点为重心的最大子树的节点数</p>
<h3 id="代码（求所有点为重心的最大子树节点数）"><a href="#代码（求所有点为重心的最大子树节点数）" class="headerlink" title="代码（求所有点为重心的最大子树节点数）"></a>代码（求所有点为重心的最大子树节点数）</h3><details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span></span>&#123;<br>    Size[x]=<span class="hljs-number">1</span>;<br>    ans[x]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];~i;i=e[i].next)&#123;<br>        <span class="hljs-type">int</span> v=e[i].v;<br>        <span class="hljs-keyword">if</span>(v!=fa)&#123;<br>            <span class="hljs-built_in">dfs</span>(v,x);<br>            Size[x]+=Size[v];<br>            ans[x]=<span class="hljs-built_in">max</span>(ans[x],Size[v]);<br>        &#125;<br>    &#125;<br>    ans[x]=<span class="hljs-built_in">max</span>(ans[x],n-Size[x]);<br>    <span class="hljs-keyword">if</span>(ans[x]&gt;maxh)&#123; <span class="hljs-comment">//maxh存最大子树节点数的最小值，即答案</span><br>        maxh=ans[x];<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>树链剖分浅析</title>
    <url>/2020/05/01/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h2 id="树剖专题（长链-重链）"><a href="#树剖专题（长链-重链）" class="headerlink" title="树剖专题（长链+重链）"></a><center>树剖专题（长链+重链）</center></h2><p><img src="https://i.loli.net/2020/05/12/1Qzx2XeW9UmshA6.png" alt="1397737-20180510123640544-303874904" style="zoom:67%;" /><br><span id="more"></span></p>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P3384">P3384 轻重链剖分</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>树链剖分</strong>：顾名思义，把一棵树剖分成为一条条的<strong>链</strong>（其实就是序列），保证每个点属于且仅属于一条链，然后再通过数据结构（如：树状数组、线段树 等）来维护每一条链的信息，进而维护这一整棵树的信息 </p>
<p>那么如何进行剖分呢？ 最常见的剖分方式有两种：<strong>轻重链剖分</strong>和<strong>长链剖分</strong>，其中前者更为常用，后者在一些特殊情况下会更优，这里主要讲解前者（后者的处理方式类似）</p>
<h2 id="一些黑话（术语）"><a href="#一些黑话（术语）" class="headerlink" title="一些黑话（术语）"></a>一些黑话（术语）</h2><ul>
<li>重儿子：子树最大的儿子</li>
<li>轻儿子：除了重儿子以外的儿子</li>
<li>重边：父节点与重儿子组成的边</li>
<li>轻边：重边以外的边</li>
<li>重链：重边链接而成的链</li>
<li>轻链：轻边链接而成的链</li>
<li>链的顶部：一条链上深度最小的点</li>
</ul>
<h2 id="两次DFS的预处理（复杂度-O-n-）"><a href="#两次DFS的预处理（复杂度-O-n-）" class="headerlink" title="两次DFS的预处理（复杂度$O(n)$）"></a>两次DFS的预处理（复杂度$O(n)$）</h2><p>对于<strong>重链剖分</strong>，最核心的步骤就是需要预处理出一些东西，包括如下几项：</p>
<ol>
<li><p>每个节点的深度 <code>csdep[i]</code></p>
</li>
<li><p>每个节点的父节点 <code>csfa[i]</code></p>
</li>
<li><p>每个节点所在的子树大小 <code>cssize[i]</code>（PS：长链剖分则是 最大深度<code>csmx[i]</code>）</p>
</li>
<li><p>每个节点的<strong>重儿子</strong> <code>csson[i]</code></p>
</li>
<li><p>每条链的顶部 <code>cstop[i]</code></p>
</li>
</ol>
<p>如果需要用数据结构维护节点对应的信息，则还需要处理：</p>
<ol>
<li>每个节点的DFS序 <code>csid[i]</code></li>
<li>每个DFS序对应节点的需要维护的值 <code>wt[i]</code></li>
</ol>
<h3 id="第一次DFS（一次性处理完-1-2-3-4）"><a href="#第一次DFS（一次性处理完-1-2-3-4）" class="headerlink" title="第一次DFS（一次性处理完 1 2 3 4）"></a>第一次DFS（一次性处理完 1 2 3 4）</h3><p>这里直接给出代码（含注释）：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fath,<span class="hljs-type">int</span> depth)</span></span>&#123;<br>    csfa[u]=fath;<span class="hljs-comment">// u的父亲</span><br>    csdep[u]=depth;<span class="hljs-comment">// u的深度</span><br>    cssize[u]=<span class="hljs-number">1</span>;<span class="hljs-comment">//u子树的大小，初始为1</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>        <span class="hljs-type">int</span> v=e[i].v;<br>        <span class="hljs-keyword">if</span>(v!=fath)&#123;<br>            <span class="hljs-built_in">dfs1</span>(v,u,depth+<span class="hljs-number">1</span>);<span class="hljs-comment">//dfs下去，深度+1</span><br>            cssize[u]+=cssize[v];<span class="hljs-comment">//此时v都处理完了，加到u的大小上去</span><br>            <span class="hljs-keyword">if</span>(cssize[v]&gt;cssize[csson[u]])<span class="hljs-comment">//判断v的大小能否更新重儿子</span><br>                csson[u]=v;<span class="hljs-comment">//能就更新重儿子</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">dfs1</span>(rt,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>);<br></code></pre></div></td></tr></table></figure>
<p>如果是<strong>长链剖分</strong>，这里的<code>csize[i]</code>数组就需要换为<code>csmx[i]</code>数组，也就是<strong>重儿子</strong>的定义从 <strong>子树最大的儿子</strong> 变为 <strong>子树最大深度最深的儿子</strong>，所以对应的dfs1函数需要改为：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(...)</span></span>&#123;<br>    csmx[u]=csdep[u];<span class="hljs-comment">//初始最大深度</span><br>    ...<br>   	csmx[u]=<span class="hljs-built_in">max</span>(csmx[u],csmx[v]);<span class="hljs-comment">//维护子树最大深度</span><br>    <span class="hljs-keyword">if</span>(csmx[v]&gt;csmx[csson[u]])<span class="hljs-comment">//重儿子的定义变了</span><br>        csson[u]=v;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="第二次DFS（处理完剩下的）"><a href="#第二次DFS（处理完剩下的）" class="headerlink" title="第二次DFS（处理完剩下的）"></a>第二次DFS（处理完剩下的）</h3><p>第二次DFS有个关键的地方：</p>
<ul>
<li>需要按照先处理重儿子，再处理轻儿子的顺序</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> topf)</span></span>&#123;<br>    csid[u]=++dfsx;<span class="hljs-comment">//u的dfs序</span><br>    wt[dfsx]=w[u];<span class="hljs-comment">// 每个dfs序对应节点的需要维护的值（权值、编号 等）</span><br>    cstop][u]=topf;<span class="hljs-comment">//u的顶部</span><br>    <span class="hljs-keyword">if</span>(!csson[u]) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//如果到叶节点了，直接返回</span><br>    <span class="hljs-built_in">dfs2</span>(csson[u],topf);<span class="hljs-comment">//处理重儿子，它的顶部还是当前的顶部</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[i];~i;i=e[i].next)&#123;<br>        <span class="hljs-type">int</span> v=e[i].v;<br>        <span class="hljs-keyword">if</span>(v!=csson[u]&amp;&amp;v!=csfa[u])<span class="hljs-comment">//处理轻儿子，即除去重儿子和父亲</span><br>            <span class="hljs-built_in">dfs</span>(v,v);<span class="hljs-comment">//轻儿子本身的顶部节点就是自己</span><br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">dfs2</span>(rt,rt);<br></code></pre></div></td></tr></table></figure>
<h2 id="一些常用操作"><a href="#一些常用操作" class="headerlink" title="一些常用操作"></a>一些常用操作</h2><p>至此，树链剖分已经完成了，在不使用数据结构的情况下，我们仍然可以做一些常用操作</p>
<h3 id="求LCA（-O-logn-）"><a href="#求LCA（-O-logn-）" class="headerlink" title="求LCA（$O(logn)$）"></a>求LCA（$O(logn)$）</h3><p>可以看我的 <a href="https://b4158813.gitee.io/blog/2020/04/28/最近公共祖先LCA/">BlablaWu的blog：最近公共祖先LCA</a></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">LCA</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(cstop[x]!=cstop[y])&#123;<span class="hljs-comment">//只要两者处于不同链</span><br>        <span class="hljs-keyword">if</span>(csdep[cstop[x]]&lt;csdep[cstop[y]]) <span class="hljs-built_in">swap</span>(x,y);<br>        x=csfa[cstop[x]];<span class="hljs-comment">//不断把更深的点跳到其链顶端的父亲上</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> csdep[x]&lt;csdep[y]?x:y;<span class="hljs-comment">//返回较浅的点</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="求树上两点距离（无边权or点权）"><a href="#求树上两点距离（无边权or点权）" class="headerlink" title="求树上两点距离（无边权or点权）"></a>求树上两点距离（无边权or点权）</h3><p>答案就是：$x节点深度+y节点深度-2*LCA(x,y)的深度$</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getroute</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> csdep[x]+csdep[y]-csdep[<span class="hljs-built_in">LCA</span>(x,y)]&lt;&lt;<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="求树上两点距离（带边权or点权）"><a href="#求树上两点距离（带边权or点权）" class="headerlink" title="求树上两点距离（带边权or点权）"></a>求树上两点距离（带边权or点权）</h3><p>如果是求边权距离的，可以把边权转换为深度较深的节点的点权，并处理出每个节点到根节点的距离，这需要在<strong>dfs1</strong>过程中处理</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(...)</span></span>&#123;<br>    ...<br>   	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>        <span class="hljs-type">int</span> v=e[i].v;<br>        <span class="hljs-keyword">if</span>(v!=fath)&#123;<br>            w[v]=e[i].w;<span class="hljs-comment">//将边权转换为深度较深节点的点权</span><br>            <span class="hljs-comment">// 如果直接给点权了，那就只需要执行下一行</span><br>            wdep[v]+=w[v];<span class="hljs-comment">//处理出每个节点到根节点的距离</span><br>        &#125;<br>    &#125;<br>    ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">getroute</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<span class="hljs-comment">//求两点带权距离</span><br>    <span class="hljs-keyword">return</span> wdep[x]+wdep[y]-wdep[<span class="hljs-built_in">LCA</span>(x,y)]&lt;&lt;<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="求树上-k-级祖先"><a href="#求树上-k-级祖先" class="headerlink" title="求树上$k$级祖先"></a>求树上$k$级祖先</h3><p>模板题：<a href="https://www.luogu.com.cn/problem/P5903">P5903 【模板】树上k级祖先</a></p>
<p>每次询问给定一个$x$和$k$，求点$x$的$k$级祖先（强制在线）</p>
<p>算法：可以类比<strong>树剖LCA</strong>的思想，但这里需要求的不是最近的祖先，而是指定的$k$级祖先，因此需要一点思考，对于一个点$x$来说，如果$csdep[x]-k&lt;csdep[cstop[x]]$，也就是说这个$k$级祖先在$x$当前所在链的顶端的上方，那么我们就可以让$x$跳到它所在链顶端的父节点上，然后继续比较，重复上述操作，直到这个$k$级祖先和$x$处在同一条链上，那么又因为同一条链上的节点DFS序是连续增减的，因此可以直接通过作差得出$k$级祖先的DFS序，然后输出这个DFS对应的节点编号就行了</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getkans</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> k)</span></span>&#123;<br>    <span class="hljs-type">int</span> tp=csdep[x]-k;<br>    <span class="hljs-keyword">while</span>(tp&lt;csdep[cstop[x]]) x=csfa[cstop[x]];<br>    tp=csdep[x]-tp;<br>    <span class="hljs-keyword">return</span> wt[csid[x]-tp];<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="数据结构维护链的信息"><a href="#数据结构维护链的信息" class="headerlink" title="数据结构维护链的信息"></a>数据结构维护链的信息</h2><p>如果有的问题是既有<strong>修改</strong>，又有<strong>查询</strong>的操作，那么就只好请出我们的<strong>数据结构</strong>大法了，通常情况下，<strong>线段树</strong>足以胜任这些要求，下面针对模板题的要求，来介绍一下具体操作方法</p>
<ol>
<li>将$x$及其子树的所有节点的点权$+k$</li>
<li>求出$x$及其子树的所有节点的权值和</li>
<li>将 $x\rightarrow y$ 路径上的所有节点权值$+k$</li>
<li>求出 $x\rightarrow y$ 路径上所有点权和</li>
</ol>
<p>对于 1 2 操作，由于我们维护了每个节点的DFS序以及每个DFS序所对应节点的权值，因此对于一个节点$x$，它所在子树的所有节点的DFS序都比它大，而最大的那个节点的DFS序恰好是<code>csid[x]+cssize[x]-1</code>，中间的所有DFS序就对应了这个子树的所有节点，因此这个操作很简单，如下</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addtree</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> k)</span></span>&#123;<span class="hljs-comment">//1操作</span><br>    <span class="hljs-comment">//add是线段树的区间修改操作</span><br>    <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,csid[x],csid[x]+cssize[x]<span class="hljs-number">-1</span>,k);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">gettree</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">//2操作</span><br>    <span class="hljs-comment">//getsum是线段树区间求和操作</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">getsum</span>(<span class="hljs-number">1</span>,csid[x],csid[x]+cssize[x]<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>对于 3 4 操作，稍微复杂一些，我们可以类比<strong>树剖求LCA</strong>的思想，先不断跳动链顶较深的节点，期间同时对跳过的每一条链进行更新或求和操作，直到两点在同一条链上，最后再对这一条链上以这两点为端点的区间进行一次操作，具体实现如下</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addroute</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> k)</span></span>&#123;<span class="hljs-comment">//3操作</span><br>    <span class="hljs-keyword">while</span>(cstop[x]!=cstop[y])&#123;<br>        <span class="hljs-keyword">if</span>(csdep[cstop[x]]&lt;csdep[cstop[y]]) <span class="hljs-built_in">swap</span>(x,y);<br>        <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,csid[cstop[x]],csid[x],k);<span class="hljs-comment">//更新跳过的这条链</span><br>        x=csfa[cstop[x]];<br>    &#125;<br>    <span class="hljs-keyword">if</span>(csdep[x]&gt;csdep[y]) <span class="hljs-built_in">swap</span>(x,y);<br>    <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,csid[x],csid[y],k);<span class="hljs-comment">//更新x,y这条链上的xy区间值</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getroute</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<span class="hljs-comment">//4操作 原理同上</span><br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(cstop[x]!=cstop[y])&#123;<br>        <span class="hljs-keyword">if</span>(csdep[cstop[x]]&lt;csdep[cstop[y]]) <span class="hljs-built_in">swap</span>(x,y);<br>        res+=<span class="hljs-built_in">getsum</span>(<span class="hljs-number">1</span>,csid[cstop[x]],csid[x]);<br>        x=csfa[cstop[x]];<br>    &#125;<br>    <span class="hljs-keyword">if</span>(csdep[x]&gt;csdep[y]) <span class="hljs-built_in">swap</span>(x,y);<br>    res+=<span class="hljs-built_in">getsum</span>(<span class="hljs-number">1</span>,csid[x],csid[y]);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<hr>
<p>至此，树链剖分的基本操作就介绍完毕了，剩下的就是一堆习题了，当然我还没做，等做完了再过来补吧 Orz</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>概率DP(期望DP)</title>
    <url>/2020/05/04/%E6%A6%82%E7%8E%87DP-%E6%9C%9F%E6%9C%9BDP/</url>
    <content><![CDATA[<h2 id="概率dp学习记录"><a href="#概率dp学习记录" class="headerlink" title="概率dp学习记录"></a><center>概率dp学习记录</center></h2><span id="more"></span>
<p>参考神仙blog：</p>
<ul>
<li><a href="https://www.cnblogs.com/hua-dong/p/8166093.html">【整理】简单的数学期望和概率DP</a></li>
<li><a href="https://www.luogu.com.cn/blog/ShineEternal/mathematical-expectation">数论小白都能看懂的数学期望讲解</a></li>
</ul>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>概率（期望）DP，就是一类结合概率论中求期望的动态规划问题，通常情况下的处理方式为<strong>倒推</strong>，即定义一个状态$dp[i]$为：<strong>已经到达$i$状态（根据题目自己定义），完成剩余要求所需要的期望步数</strong>，于是显然有$dp[n]=0$（如果$n$代表了最后一个状态），从而倒推求出$dp[0]$（或$dp[1]$之类的）</p>
<p>给出了一般方法，但由于<strong>动态规划没有模板</strong>一说，剩下就是多刷题了</p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="UVA10288-优惠券-Coupons"><a href="#UVA10288-优惠券-Coupons" class="headerlink" title="UVA10288 优惠券 Coupons"></a><a href="https://www.luogu.com.cn/problem/UVA10288">UVA10288 优惠券 Coupons</a></h3><p>题意：</p>
<p>每张彩票上有一个漂亮图案，图案一共$n$种，如果你集齐了这$n$种图案就可以兑换大奖。现在请问，在理想（平均）情况下，你买多少张彩票才能获得大奖的？$n\le 33$</p>
<p>题解：</p>
<p>最经典的期望题，我们需要知道，如果买一次彩票能中$A$奖的概率为$\frac{b}{a}$，那么能中奖的期望购买彩票次数为$\frac{a}{b}$（取倒数即可），于是回到这题，定义状态$dp[i]$为：手上已有$i$种图案，兑换大奖还需要买的彩票数的期望，则答案为$dp[0]$，转移如下：</p>
<ol>
<li>如果下一张彩票出的图案是已经有的：概率为$\frac{i}{n}$，$dp[i]=\frac{i}{n}(dp[i]+1)$</li>
<li>如果下一张彩票出的图案是新的：概率为$\frac{n-i}{n}$，$dp[i]=\frac{n-i}{n}(dp[i+1]+1)$</li>
</ol>
<p>两者合并一下，得到：$dp[i]=\frac{i}{n}(dp[i]+1)+\frac{n-i}{n}(dp[i+1]+1)$</p>
<p>化简得：$dp[i]=dp[i+1]+\frac{n}{n-i}$</p>
<p>其实到这里就已经可以用动态规划A了这题，但我们再追求一下极致，从这个递推方程里推出一个公式来：</p>
<script type="math/tex; mode=display">
\begin{aligned}
dp[0]&=dp[1]+1=dp[2]+\frac{n}{n-1}+1\\
&=...=dp[n]+n*(1+\frac{1}{2}+\frac{1}{3}+...+\frac{1}{n})\\
&=n*(1+\frac{1}{2}+\frac{1}{3}+...+\frac{1}{n})
\end{aligned}</script><p>OK，很完美，接下来就是毒瘤的输出处理了，模拟通分+约分，然后输出格式处理一下就行了</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">ll <span class="hljs-title">lcm</span><span class="hljs-params">(ll a,ll b)</span> </span>&#123;<span class="hljs-keyword">return</span> a/<span class="hljs-built_in">gcd</span>(a,b)*b;&#125;<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count</span><span class="hljs-params">(ll x)</span></span>&#123;<br>	<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(x)&#123;<br>		ans++;<br>		x/=<span class="hljs-number">10</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n))&#123;<br>		ll ans1=<span class="hljs-number">1</span>,ans2=<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>			ll tp=<span class="hljs-built_in">lcm</span>(i,ans2);<br>			ll x1=tp/ans2,x2=tp/i;<br>			ans2=tp;<br>			ans1=ans1*x1+x2;<br>			ll tp2=<span class="hljs-built_in">gcd</span>(ans1,ans2);<br>			ans1/=tp2,ans2/=tp2;<br>		&#125;<br>		ans1*=n;<br>		ll tp2=<span class="hljs-built_in">gcd</span>(ans1,ans2);<br>		ans1/=tp2,ans2/=tp2;<br>		<span class="hljs-keyword">if</span>(ans2==<span class="hljs-number">1</span>)&#123;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans1);<br>			<span class="hljs-keyword">continue</span>;<br>		&#125;<br>		ll dai=ans1/ans2;<br>		<span class="hljs-keyword">if</span>(dai) ans1%=ans2;<br>		<span class="hljs-type">int</span> numfen=<span class="hljs-built_in">max</span>(<span class="hljs-built_in">count</span>(ans1),<span class="hljs-built_in">count</span>(ans2)),numdai=<span class="hljs-built_in">count</span>(dai);<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=numdai;i++)<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n%lld &quot;</span>,ans1,dai);<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;numfen;i++)<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&quot;</span>);<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=numdai;i++)<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans2);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-comment">// https://www.luogu.com.cn/problem/UVA10288</span><br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="P4316-绿豆蛙的归宿"><a href="#P4316-绿豆蛙的归宿" class="headerlink" title="P4316 绿豆蛙的归宿"></a><a href="https://www.luogu.com.cn/problem/P4316">P4316 绿豆蛙的归宿</a></h3><p>题意：</p>
<p>给一个DAG，起点为1，终点为n，每次绿豆蛙可以等概率地选择一条从这个节点出发的出边走过去，求从起点到终点的期望路径长度</p>
<p>题解：</p>
<p>设状态：$dp[i]$为已走到$i$节点，走完剩下节点所需要的期望路径长度，则转移方程为$dp[i]=\frac{1}{deg[i]}(\sum{(dp[v]+w)})$，其中$deg[i]$为$i$节点的出度，由于当前状态的转移用到了他的出边所连节点的转移，因此需要倒推，所以可以考虑<strong>反向建图</strong>然后跑一遍<strong>拓扑排序</strong>，在拓扑序上DP即可（其实<strong>大部分DAG上DP的题都需要拓扑排序</strong>，保证无后效性）</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> deg1[maxn],deg2[maxn];<br><span class="hljs-type">double</span> dp[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">toposort</span><span class="hljs-params">()</span></span>&#123;<br>	queue&lt;<span class="hljs-type">int</span>&gt; q;<br>	q.<span class="hljs-built_in">push</span>(n);<br>	<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>		<span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>();<br>		q.<span class="hljs-built_in">pop</span>();<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>			<span class="hljs-type">int</span> v=e[i].v,w=e[i].w;<br>			dp[v]+=(dp[u]+<span class="hljs-number">1.0</span>*w)/deg1[v];<span class="hljs-comment">//拓扑序上DP</span><br>			<span class="hljs-keyword">if</span>(deg2[v])&#123;<br>				deg2[v]--;<br>				<span class="hljs-keyword">if</span>(!deg2[v])<br>					q.<span class="hljs-built_in">push</span>(v);<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>	<span class="hljs-built_in">init_graph</span>();<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m)&#123;<br>		<span class="hljs-type">int</span> x,y,z;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);<br>		<span class="hljs-built_in">addedge</span>(y,x,z);<br>		deg1[x]++,deg2[x]++;<br>	&#125;<br>	<span class="hljs-built_in">toposort</span>();<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf\n&quot;</span>,dp[<span class="hljs-number">1</span>]);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="CF235B-Let’s-Play-Osu"><a href="#CF235B-Let’s-Play-Osu" class="headerlink" title="CF235B Let’s Play Osu!"></a><a href="https://www.luogu.com.cn/problem/CF235B">CF235B Let’s Play Osu!</a></h3><p>重题：<a href="https://www.luogu.com.cn/problem/P1365">P1365 WJMZBMR打osu! / Easy</a></p>
<p>题意：</p>
<p>打OSU游戏（一种音游），会出现正确(O)和失误(X)两种情况，每N次正确的连击能获得$N^2$的分数加成，现在给你每次击打取得正确概率和N次击打，问最终获得的分数的期望</p>
<p>题解：</p>
<p>典型的<strong>高次期望</strong>问题，我们可以先考虑线性的问题：每N次正确的连击能获得N的分数加成，那么考虑状态$f[i]$表示达到第$i$次期望得分，则转移如下：</p>
<script type="math/tex; mode=display">
f[i]=p[i]\cdot(f[i-1]+1)</script><p>那么如果分数加成是平方次的呢？考虑状态$F[i]$表示这一状态，则转移如下：</p>
<script type="math/tex; mode=display">
F[i]=F[i-1]+p[i]\cdot(2f[i-1]+1)</script><p>为什么呢，因为$(x+1)^2-x^2=2x+1$，即：一个平方中+1所带来的分数加成为$2*线性加成+1$</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;<br>db p[maxn],f[maxn],F[maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,&amp;p[i]);<br>	F[<span class="hljs-number">1</span>]=f[<span class="hljs-number">1</span>]=p[<span class="hljs-number">1</span>]*<span class="hljs-number">1</span>;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n)&#123;<br>		f[i]=(f[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>)*p[i];<br>		F[i]=F[i<span class="hljs-number">-1</span>]+p[i]*(<span class="hljs-number">2</span>*f[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>);<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.12lf\n&quot;</span>,F[n]);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-comment">// https://www.luogu.com.cn/problem/CF235B</span><br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="P654-OSU"><a href="#P654-OSU" class="headerlink" title="P654 OSU!"></a><a href="https://www.luogu.com.cn/problem/P1654">P654 OSU!</a></h3><p>题意：</p>
<p>跟上一道题一样，只是分数加成改为了$N^3$</p>
<p>题解：</p>
<p>那么转移方程对应改为：$Z[i]=Z[i-1]+p<a href="3F[i-1]+3f[i-1]+1">i</a>$</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;<br>db p[maxn],f[maxn],F[maxn],z[maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,&amp;p[i]);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		z[i]=z[i<span class="hljs-number">-1</span>]+(<span class="hljs-number">3</span>*f[i<span class="hljs-number">-1</span>]+<span class="hljs-number">3</span>*F[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>)*p[i];<br>		F[i]=(F[i<span class="hljs-number">-1</span>]+<span class="hljs-number">2</span>*f[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>)*p[i];<br>		f[i]=(f[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>)*p[i];<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.1lf\n&quot;</span>,z[n]);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-comment">// https://www.luogu.com.cn/problem/P1654</span><br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="UVA12230-过河-Crossing-Rivers"><a href="#UVA12230-过河-Crossing-Rivers" class="headerlink" title="UVA12230 过河 Crossing Rivers"></a><a href="https://www.luogu.com.cn/problem/UVA12230">UVA12230 过河 Crossing Rivers</a></h3><p>题意：</p>
<p>从起点到终点路上有N条河，需要坐船才能过，给出每条河的宽度和船速，走路速度恒为1，问从起点到终点的期望时间</p>
<p>题解：</p>
<p>对于过河来说，最慢的时间为$\frac{3L}{V}$（到达河边时船刚从河边离开，那么就需要等船跑完一个来回才能再乘坐），最快为$\frac{L}{V}$（到达河边时船刚好也到达，直接乘坐过去就行），又因为船速恒定，所以船出现在河内任何位置的的概率是相等的，即均匀分布，因此期望时间就是$\frac{\frac{3L}{V}+\frac{L}{V}}{2}=\frac{2L}{V}$，再加上走路的时间就是答案了</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n,D;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;D))&#123;<br>		<span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>&amp;&amp;D==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>		<span class="hljs-type">double</span> ans=<span class="hljs-number">0</span>,zuo=<span class="hljs-number">0</span>;<br>		<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n)&#123;<br>			<span class="hljs-type">int</span> p,L,v;<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;p,&amp;L,&amp;v);<br>			ans+=<span class="hljs-number">2.0</span>*L/v;<br>			ans+=<span class="hljs-number">1.0</span>*p-zuo;<br>			zuo+=<span class="hljs-number">1.0</span>*(p-zuo)+L;<br>		&#125;<br>		ans+=<span class="hljs-number">1.0</span>*D-zuo;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case %d: %.3lf\n\n&quot;</span>,++cnt,ans);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-comment">// https://www.luogu.com.cn/problem/UVA12230</span><br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="ZOJ-3640-Help-me-escape"><a href="#ZOJ-3640-Help-me-escape" class="headerlink" title="ZOJ 3640 Help me escape"></a><a href="https://zoj.pintia.cn/problem-sets/91827364500/problems/91827369307">ZOJ 3640 Help me escape</a></h3><p>题意：</p>
<p>小明被困在一个洞穴里，他有个初始战斗力$f$，他每次有$N$条道路可选择（等概率随机选择），每条道路都有一个困难值$c_i$，如果他的战斗力大于所选通道的困难值，则他可以花费对应道路的天数$t_i$逃出洞穴，否则，他就只能花一天时间来使自己的战斗力增加对应道路的困难值的大小，问小明逃出洞穴的天数的期望</p>
<p>题解：</p>
<p>设状态$dp[i]$为小明战斗力为$i$时逃出洞穴的期望天数，则转移如下：</p>
<script type="math/tex; mode=display">
dp[i]=dp[i]+
\begin{cases}
\frac{1}{n}(t[i])\ (if\ f>c[i])\\
\frac{1}{n}(dp[i+c[i]]+1)\ (if\ f\le c[i])
\end{cases}</script><p>由于可能出现大于初始战斗力的情况，所以初始时选两到三倍战斗力开始转移</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n,f,c[maxn],t[maxn];<br><span class="hljs-type">double</span> dp[maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;f))&#123;<br>		<span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dp));<br>		<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n)<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;c[i]),<br>			t[i]=<span class="hljs-built_in">floor</span>((<span class="hljs-number">1.0</span>+<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">5.0</span>))/<span class="hljs-number">2.0</span>*c[i]*c[i]);<br><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">30000</span>;i&gt;=f;i--)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>				<span class="hljs-keyword">if</span>(i&gt;c[j]) dp[i]+=<span class="hljs-number">1.0</span>*t[j]/n;<br>				<span class="hljs-keyword">else</span> dp[i]+=(<span class="hljs-number">1.0</span>+<span class="hljs-number">1.0</span>*dp[i+c[j]])/n;<br>			&#125;<br>		&#125;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.3lf\n&quot;</span>,dp[f]);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-comment">// https://vjudge.net/problem/ZOJ-3640</span><br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="HDU-3853-LOOPS"><a href="#HDU-3853-LOOPS" class="headerlink" title="HDU 3853 LOOPS"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3853">HDU 3853 LOOPS</a></h3><p>题意：</p>
<p>小明又被困住了，这次他被困在了一个$n*m$的矩阵中，初始他处于$(1,1)$（左上角），终点在$(n,m)$（右下角），每次他需要花费两点法力值然后在如下三种选择中选一种（给出三种选择的概率$p_1,p_2,p_3$，且保证$p_1+p_2+p_3=1$，且最右边一列的格子$p_2=0$，最下边一行的格子$p_1=0$）</p>
<ol>
<li>往下走一格</li>
<li>往右走一个</li>
<li>原地不动</li>
</ol>
<p>问小明到达终点的所花费法力值的期望</p>
<p>题解：</p>
<p>中规中矩的二维概率DP，考虑状态$dp[i][j]$为现在处在第$(i,j)$格子，到达终点的期望花费法力值，则转移为：</p>
<script type="math/tex; mode=display">
dp[i][j]=p_1[i][j](dp[i+1][j]+2)+p_2[i][j](dp[i][j+1]+2)+p_3[i][j](dp[i][j]+2)​</script><p>化简可得：</p>
<script type="math/tex; mode=display">
dp[i][j]=\frac{p_1[i][j]+p_2[i][j]+2}{1-p_3[i][j]}</script><p>有一个坑点，就是这个式子分母不能为0（否则就浮点错误了），所以遇到$p_3=1$就跳过</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n,m;<br>db p1[<span class="hljs-number">1015</span>][<span class="hljs-number">1015</span>],p2[<span class="hljs-number">1015</span>][<span class="hljs-number">1015</span>],p3[<span class="hljs-number">1015</span>][<span class="hljs-number">1015</span>];<br>db dp[<span class="hljs-number">1015</span>][<span class="hljs-number">1015</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)!=EOF)&#123;<br>		<span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dp));<br>		<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n)&#123;<br>			<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,m)&#123;<br>				<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf%lf%lf&quot;</span>,&amp;p1[i][j],&amp;p2[i][j],&amp;p3[i][j]);<br>				<span class="hljs-comment">// cin&gt;&gt;p1[i][j]&gt;&gt;p2[i][j]&gt;&gt;p3[i][j];</span><br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=<span class="hljs-number">1</span>;j--)&#123;<br>				<span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(p1[i][j]<span class="hljs-number">-1.0</span>)&lt;eps) <span class="hljs-keyword">continue</span>;<br>				dp[i][j]=(p2[i][j]*dp[i][j+<span class="hljs-number">1</span>]+p3[i][j]*dp[i+<span class="hljs-number">1</span>][j]+<span class="hljs-number">2.0</span>)/(<span class="hljs-number">1.0</span>-p1[i][j]);<br>			&#125;<br>		&#125;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.3lf\n&quot;</span>,dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>	&#125;<br>	<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-comment">// http://acm.hdu.edu.cn/showproblem.php?pid=3853</span><br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="P4550-收集邮票"><a href="#P4550-收集邮票" class="headerlink" title="P4550 收集邮票"></a><a href="https://www.luogu.com.cn/problem/P4550">P4550 收集邮票</a></h3><p>题意：</p>
<p>类似于优惠券那题，但难度有提高</p>
<p>有N中邮票，每次买到一种邮票的概率相等，为$\frac{1}{N}$，但是购买第$k$张邮票需要支付$k$元钱，问集齐所有N种邮票所需要花费的钱数的期望</p>
<p>题解：</p>
<p>如果是优惠券那题的题意，就是买一张邮票恒为1块钱，但现在变成了只要多买一张邮票，钱数就要+1，怎么办呢？不妨把需要买的张数和花钱数分开来考虑，先考虑怎么计算需要买的张数的期望，很简单，因为这就是优惠券那题$f[i]=f[i+1]+\frac{n}{n-i}$</p>
<p>现在来考虑钱数，由于买当前邮票所花的钱数还跟买当前邮票之前已经买了多少邮票（买的邮票张数）有关，因此转移应该为：</p>
<script type="math/tex; mode=display">
F[i]=\frac{i}{n}(F[i]+f[i]+1)+\frac{n-i}{n}(F[i+1]+f[i+1]+1)</script><p>因而化简得到：</p>
<script type="math/tex; mode=display">
F[i]=F[i+1]+f[i+1]+\frac{i}{n-i}f[i]+\frac{n}{n-i}</script><details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;<br>db f[maxn],dp[maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>		f[i]=f[i+<span class="hljs-number">1</span>]+<span class="hljs-number">1.0</span>*n/(n-i);<br>		dp[i]=<span class="hljs-number">1.0</span>*i/(n-i)*f[i]+dp[i+<span class="hljs-number">1</span>]+f[i+<span class="hljs-number">1</span>]+<span class="hljs-number">1.0</span>*n/(n-i);<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf\n&quot;</span>,dp[<span class="hljs-number">0</span>]);<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-comment">// https://www.luogu.com.cn/problem/P4550</span><br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="ZOJ-3551-Bloodsucker"><a href="#ZOJ-3551-Bloodsucker" class="headerlink" title="ZOJ 3551 Bloodsucker"></a><a href="https://zoj.pintia.cn/problem-sets/91827364500/problems/91827369029">ZOJ 3551 Bloodsucker</a></h3><p>题意：</p>
<p>村中有$1$个吸血鬼和$n-1$个村民，每天从这个$n$个里面随机选出两个，如果他俩是同类则无事发生，否则村民有$p$的概率会变成吸血鬼，问最后使得所有$n$个人都变为吸血鬼的天数的期望</p>
<p>题解：</p>
<p>经典的概率DP题，应该可以推公式，考虑定义状态$dp[i]$为现在有$i$个吸血鬼，把剩余人都变为吸血鬼的期望天数，则下一波选出的两个人为不同类的概率为：</p>
<script type="math/tex; mode=display">
\frac{C_i^1C_{n-i}^1}{C_n^2}</script><p>因此转移方程为：</p>
<script type="math/tex; mode=display">
dp[i]=\frac{C_i^1C_{n-i}^1}{C_n^2}\cdot p\cdot(dp[i+1]+1)+(1-\frac{C_i^1C_{n-i}^1}{C_n^2}\cdot p)(dp[i]+1)</script><p>令</p>
<script type="math/tex; mode=display">
P=\frac{C_i^1C_{n-i}^1}{C_n^2}\cdot p</script><p>化简得到：</p>
<script type="math/tex; mode=display">
dp[i]=dp[i+1]+\frac{1}{P}</script><details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> _,n;<br>db dp[maxn],p;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;_);_;_--)&#123;<br>		<span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dp));<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%lf&quot;</span>,&amp;n,&amp;p);<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>			db P=<span class="hljs-number">2.0</span>*i*(n-i)/(n<span class="hljs-number">-1</span>)/n*p;<br>			dp[i]=(P*dp[i+<span class="hljs-number">1</span>]+<span class="hljs-number">1.0</span>)/P;<br>		&#125;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.3lf\n&quot;</span>,dp[<span class="hljs-number">1</span>]);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-comment">// https://zoj.pintia.cn/problem-sets/91827364500/problems/91827369029</span><br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="HDU-4035-Maze（循环型概率DP）"><a href="#HDU-4035-Maze（循环型概率DP）" class="headerlink" title="HDU 4035 Maze（循环型概率DP）"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4035">HDU 4035 Maze</a>（循环型概率DP）</h3><p>题意：</p>
<p>小明被困在了一棵<strong>树</strong>中，初始时位于$1$号节点，每次随机选取与该节点相连的另一个节点走过去，有一定概率$k_i$掉入陷阱直接GG，有一定概率$e_i$被小红救走，求小明被救走之前所经过的边数的期望</p>
<p>题解：</p>
<p>首先我们可以根据题意定义出一个状态：$dp[i]$表示当前处在$i$号节点被救走所需要经过的边数的期望，则转移方程如下：</p>
<p>对于叶子节点：</p>
<script type="math/tex; mode=display">
\begin{aligned}
dp[i]&=k_i\cdot dp[1]+e_i\cdot0+(1-k_i-e_i)(dp[fa[i]]+1)\\
&=k_i\cdot dp[1]+(1-k_i-e_i)dp[fa[i]]+(1-k_i-e_i)
\end{aligned}</script><p>对于非叶子节点：</p>
<script type="math/tex; mode=display">
\begin{aligned}
dp[i]&=k_i\cdot dp[1]+e_i\cdot0+\frac{1-k_i-e_i}{m}\left(dp[fa[i]]+1+\sum{\left(dp[son[i]]+1\right)}\right)\\
&=k_i\cdot dp[1]+\frac{1-k_i-e_i}{m}dp[fa[i]]+\frac{1-k_i-e_i}{m}\sum{(dp[son[i]])}+(1-k_i-e_i)
\end{aligned}</script><p>其中，$m$为当前节点的度数</p>
<p>可以发现，一个状态不仅和他之后的状态有关，还和他之前的状态有关，那么这个问题就无法用DP解决了（因为DP的前提是无后效性），因此，到这一步还没完，还需要经过一系列的数学处理才能搞出一个无后效性的递推式，对于一个节点$i$，他的递推式可以写成 $dp[i]=A_i\cdot dp[1]+B_i\cdot dp[fa[i]]+C_i$    $(*)$</p>
<p>现在考虑将$dp[son[i]]转换一下$，设$i$的儿子点为$j$，则有：</p>
<script type="math/tex; mode=display">
dp[son[i]]=dp[j]
=A_j\cdot dp[1]+B_j\cdot dp[i]+C_j</script><p>代入到<strong>非叶子节点</strong>式子中，并化简，与$(*)$式作比较，得到三个系数如下：</p>
<script type="math/tex; mode=display">
A_i=\frac{k_i+\frac{1-k_i-e_i}{m}\cdot\sum{A_j}}{1-\frac{1-k_i-e_i}{m}\cdot \sum{B_j}}\\
B_i=\frac{\frac{1-k_i-e_i}{m}}{1-\frac{1-k_i-e_i}{m}\cdot \sum{B_j}}\\
C_i=\frac{(1-k_i-e_i)+\frac{1-k_i-e_i}{m}\cdot\sum{C_j}}{1-\frac{1-k_i-e_i}{m}\cdot \sum{B_j}}\\</script><p>而对于叶子节点，有：</p>
<script type="math/tex; mode=display">
A_i=k_i\\
B_i=1-k_i-e_i\\
C_i=1-k_i-e_i</script><p>可以发现，叶子节点的三个系数是可以直接得到的，那么我们可以从叶子节点出发，最终求得$A_1,C_1$，则答案为 $\frac{C_1}{1-A_1}$，显然当分母为$0$时无解</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> _,n;<br>vector&lt;<span class="hljs-type">int</span> &gt; E[maxn];<br>db k[maxn],e[maxn];<br>db a[maxn],b[maxn],c[maxn];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span>&#123;<br>	a[u]=k[u];<br>	b[u]=(<span class="hljs-number">1</span>-k[u]-e[u])/E[u].<span class="hljs-built_in">size</span>();<br>	c[u]=<span class="hljs-number">1</span>-k[u]-e[u];<br>	db tp=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-type">int</span>)E[u].<span class="hljs-built_in">size</span>();i++)&#123;<br>		<span class="hljs-type">int</span> v=E[u][i];<br>		<span class="hljs-keyword">if</span>(v!=fa)&#123;<br>			<span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(v,u)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>			a[u]+=(<span class="hljs-number">1</span>-k[u]-e[u])/E[u].<span class="hljs-built_in">size</span>()*a[v];<br>			c[u]+=(<span class="hljs-number">1</span>-k[u]-e[u])/E[u].<span class="hljs-built_in">size</span>()*c[v];<br>			tp+=(<span class="hljs-number">1</span>-k[u]-e[u])/E[u].<span class="hljs-built_in">size</span>()*b[v];<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(<span class="hljs-number">1</span>-tp)&lt;eps) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	a[u]/=<span class="hljs-number">1</span>-tp;<br>	b[u]/=<span class="hljs-number">1</span>-tp;<br>	c[u]/=<span class="hljs-number">1</span>-tp;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> Ca=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;_);_;_--)&#123;<br>		<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) E[i].<span class="hljs-built_in">clear</span>();<br>		<span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a));<br>		<span class="hljs-built_in">memset</span>(b,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(b));<br>		<span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(c));<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>		<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>)&#123;<br>			<span class="hljs-type">int</span> x,y;<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<br>			E[x].<span class="hljs-built_in">pb</span>(y),E[y].<span class="hljs-built_in">pb</span>(x);<br>		&#125;<br>		<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n)&#123;<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf%lf&quot;</span>,&amp;k[i],&amp;e[i]);<br>			k[i]/=<span class="hljs-number">100</span>,e[i]/=<span class="hljs-number">100</span>;<br>		&#125;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case %d: &quot;</span>,++Ca);<br>		<span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>)&amp;&amp;<span class="hljs-built_in">fabs</span>(<span class="hljs-number">1</span>-a[<span class="hljs-number">1</span>])&gt;eps) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.12lf\n&quot;</span>,c[<span class="hljs-number">1</span>]/(<span class="hljs-number">1</span>-a[<span class="hljs-number">1</span>]));<br>		<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;impossible\n&quot;</span>);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-comment">// http://acm.hdu.edu.cn/showproblem.php?pid=4035</span><br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="ZOJ3329-One-Person-Game（循环型概率DP）"><a href="#ZOJ3329-One-Person-Game（循环型概率DP）" class="headerlink" title="ZOJ3329 One Person Game（循环型概率DP）"></a><a href="https://zoj.pintia.cn/problem-sets/91827364500/problems/91827368253">ZOJ3329 One Person Game</a>（循环型概率DP）</h3><p>题意：</p>
<p>有三枚骰子，面数分别为$k_1,k_2,k_3$，规定一个值$n$，初始答案为$Ans=0$，每次掷骰子三枚骰子同时掷，掷完后将骰子面朝上的权值和加入到答案中，此时如果出现了三枚骰子的点数分别为$a,b,c$，则回到$Ans=0$重新开始，如果$Ans&gt;n$了就结束，问达到$Ans&gt;n$所需掷骰子的次数的期望</p>
<p>题解：</p>
<p>其实是类似于上面那题，也属于转移方程有后效性需要数学推导的题型，这里定义状态为：$dp[i]$为$Ans=i$时完成任务所需要掷骰子的次数的期望，则转移方程如下：</p>
<script type="math/tex; mode=display">
dp[i]=p[0]dp[0]+\sum_{k=3}^{k_1+k_2+k_3}(p[k]dp[i+k])+1</script><p>其中，$p[0]$代表掷到三个骰子分别为$a,b,c$的概率，即$\frac{1}{k<em>1k_2k_3}$，$p[k]$代表掷到骰子之和为$k$的概率，这些可以通过$O(k_1k_2k_3)$的预处理得到，下面考虑转化这个式子，令$dp[i]=A_idp[0]+B_i$，则$dp[i+k]=A</em>{i+k}dp[0]+B_{i+k}$，代入上式，得到</p>
<script type="math/tex; mode=display">
dp[i]=p[0]dp[0]+\sum(p[k]\left(A_{i+k}dp[0]+B_{i+k})\right)+1\\
=(p[0]+\sum(p[k]A_{i+k}))dp[0]+\sum(p[k]B_{i+k})+1</script><p>于是得到：</p>
<script type="math/tex; mode=display">
A_i=p[0]+\sum(p[k]A_{i+k})\\
B_i=\sum(p[k]B_{i+k})+1</script><p>最终答案为：$\frac{B_0}{1-A_0}$</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> _,n,k1,k2,k3,a,b,c;<br><span class="hljs-type">double</span> p[maxn],A[maxn],B[maxn];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(A[i]) <span class="hljs-keyword">return</span>;<br>	<span class="hljs-keyword">if</span>(i&gt;n)&#123;<br>		A[i]=B[i]=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	A[i]=p[<span class="hljs-number">0</span>],B[i]=<span class="hljs-number">1</span>;<br>	<span class="hljs-built_in">rep</span>(k,<span class="hljs-number">3</span>,k1+k2+k3)&#123;<br>		<span class="hljs-built_in">dfs</span>(i+k);<br>		A[i]+=p[k]*A[i+k];<br>		B[i]+=p[k]*B[i+k];<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;_);_;_--)&#123;<br>		<span class="hljs-built_in">memset</span>(p,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(p));<br>		<span class="hljs-built_in">memset</span>(A,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(A));<br>		<span class="hljs-built_in">memset</span>(B,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(B));<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d%d%d%d&quot;</span>,&amp;n,&amp;k1,&amp;k2,&amp;k3,&amp;a,&amp;b,&amp;c);<br>		p[<span class="hljs-number">0</span>]=<span class="hljs-number">1.0</span>/(k1*k2*k3);<br>		<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,k1)&#123;<br>			<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,k2)&#123;<br>				<span class="hljs-built_in">rep</span>(k,<span class="hljs-number">1</span>,k3)&#123;<br>					<span class="hljs-keyword">if</span>(i!=a||j!=b||k!=c)<br>						p[i+j+k]+=p[<span class="hljs-number">0</span>];<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.16lf\n&quot;</span>,B[<span class="hljs-number">0</span>]/(<span class="hljs-number">1</span>-A[<span class="hljs-number">0</span>]));<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-comment">// https://zoj.pintia.cn/problem-sets/91827364500/problems/91827368253</span><br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="CF148D-Bag-of-micde"><a href="#CF148D-Bag-of-micde" class="headerlink" title="CF148D Bag of micde"></a><a href="https://www.luogu.com.cn/problem/CF148D">CF148D Bag of micde</a></h3><p>题意：</p>
<p>袋子里有$w$只白鼠和$b$ 只黑鼠 ，$A$和$B$轮流从袋子里抓，谁先抓到白色谁就赢。$A$每次随机抓一只，$B$每次随机抓完一只之后会有另一只随机老鼠跑出来。如果两个人都没有抓到白色则$B$赢。$A$先抓，问$A$赢的概率。</p>
<p>题解：</p>
<p>状态$dp[i][j]$表示袋子里有$i$个白鼠和$j$黑鼠时$A$赢的概率，则分类讨论如下：</p>
<ol>
<li>A拿出白鼠，直接赢，概率：$\frac{i}{i+j}$</li>
<li>A拿出黑鼠，B紧接着拿出白鼠，A赢概率为：0</li>
<li><p>两个人都拿出黑鼠，跑出来一个白鼠，A赢概率：$\frac{j}{i+j}\cdot\frac{j-1}{i+j-1}\cdot\frac{i}{i+j-2}\cdot dp[i-1][j-2]$</p>
</li>
<li><p>两个人都拿出黑鼠，跑出来一个黑鼠，A赢概率：$\frac{j}{i+j}\cdot\frac{j-1}{i+j-1}\cdot\frac{j-2}{i+j-2}\cdot dp[i][j-3]$</p>
</li>
</ol>
<p>初始化：$dp[i][0]=1,dp[i][1]=\frac{i}{i+1}$，则答案为：$dp[w][b]$</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> w,b;<br><span class="hljs-type">double</span> dp[<span class="hljs-number">1005</span>][<span class="hljs-number">1005</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;w,&amp;b);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,w)&#123;<br>		dp[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>		dp[i][<span class="hljs-number">1</span>]=i*<span class="hljs-number">1.0</span>/(i+<span class="hljs-number">1</span>);<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=w;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>;j&lt;=b;j++)&#123;<br>			dp[i][j]=i*<span class="hljs-number">1.0</span>/(i+j)+j*<span class="hljs-number">1.0</span>/(i+j)*(j<span class="hljs-number">-1</span>)/(i+j<span class="hljs-number">-1</span>)*i/(i+j<span class="hljs-number">-2</span>)*dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-2</span>];<br>			<span class="hljs-keyword">if</span>(j&gt;<span class="hljs-number">2</span>) dp[i][j]+=(j*<span class="hljs-number">1.0</span>/(i+j)*(j<span class="hljs-number">-1</span>)/(i+j<span class="hljs-number">-1</span>)*(j<span class="hljs-number">-2</span>)/(i+j<span class="hljs-number">-2</span>)*dp[i][j<span class="hljs-number">-3</span>]);<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.9lf\n&quot;</span>,dp[w][b]);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="POJ-3682-King-Arthur’s-Birthday-Celebration"><a href="#POJ-3682-King-Arthur’s-Birthday-Celebration" class="headerlink" title="POJ 3682 King Arthur’s Birthday Celebration"></a><a href="http://poj.org/problem?id=3682">POJ 3682 <strong>King Arthur’s Birthday Celebration</strong></a></h3><p>题意：</p>
<p>有一个富豪，他决定每天撒钱，并且抛硬币，第一天1块钱，第二天3块钱，第三天5块，直到他抛到硬币向上的数量为K。求天数期望和钱期望。</p>
<p>题解：</p>
<p>类似于<strong>邮票收集</strong>那题，天数太简单了，$f[i]=f[i+1]+\frac{1}{p}$，对于钱数，增长是每次+2的，我们维护的$f[i]$代表天数，则$2f[i]-1$就是第$i$天花的钱，下一天如果硬币朝上，则需要花$2(f[i+1]+1)-1$的钱数，即$2f[i+1]+1$，常规递推即可</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> k;<br>db p,f[maxn],F[maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;k)&amp;&amp;k)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,&amp;p);<br>		<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(f));<br>		<span class="hljs-built_in">memset</span>(F,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(F));<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=k<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>			f[i]=f[i+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>/p;<br>			F[i]=F[i+<span class="hljs-number">1</span>]+<span class="hljs-number">2</span>*f[i+<span class="hljs-number">1</span>]+(<span class="hljs-number">2</span>*(<span class="hljs-number">1</span>-p)*f[i]+<span class="hljs-number">1.0</span>)/p;<br>		&#125;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.3lf %.3lf\n&quot;</span>,f[<span class="hljs-number">0</span>],F[<span class="hljs-number">0</span>]);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>概率DP</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉回路</title>
    <url>/2020/03/20/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<ul>
<li>参考blog<a href="https://www.cnblogs.com/Saurus/p/7077054.html">欧拉回路算法</a></li>
</ul>
<h2 id="欧拉路径-amp-欧拉回路"><a href="#欧拉路径-amp-欧拉回路" class="headerlink" title="欧拉路径&amp;欧拉回路"></a>欧拉路径&amp;欧拉回路</h2><h3 id="判定"><a href="#判定" class="headerlink" title="判定"></a>判定</h3><h4 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h4><ol>
<li>欧拉路径：可以一笔画，充要条件是<strong>度数为奇数的点的个数为0或2</strong></li>
<li>欧拉回路：欧拉路劲构成一个环，充要条件是<strong>全部是偶点</strong></li>
</ol>
<h4 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h4><ol>
<li>欧拉路径：起点出度比入度大1，终点入度比出度大1，其他全部是偶点</li>
<li>欧拉回路：每个点出入度相同（至多存在两个点出入度不同，且这两个点满足起点出度比入度大1，终点入度比出度大1），且存在一系列环可以覆盖原图</li>
</ol>
<h3 id="求路径：Fleury算法"><a href="#求路径：Fleury算法" class="headerlink" title="求路径：Fleury算法"></a>求路径：Fleury算法</h3><p>求图的欧拉回路的算法：<strong>Fleury算法</strong></p>
<p>对于<strong>无向图</strong>和<strong>有向图</strong>，求路径的方法是一样的，简单描述为：在任意可行点处进行dfs，过程中找到一条回路之后从终点开始往回删除dfs过程中的所有边（<strong>注意，这里如果是无向图的话，需要删双向边，那么可以通过异或操作完成</strong>）如果删掉这些边之后的点还能够通往别的路径的话，就继续dfs通往，直到递归结束，此时，倒着输出所有遍历的节点就行了（无向图正着倒着都一样），以上过程都可以通过dfs的特性（栈）一气呵成</p>
<h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(遍历所有u的出边)&#123;<br>        <span class="hljs-keyword">if</span>(出边没被删)&#123;<br>            删掉这条边（无向图需要删双向，可以用^运算实现）<br>            <span class="hljs-built_in">dfs</span>(这条边所连的点)<br>        &#125;<br>    &#125;<br>    把u压入栈中<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>具体代码见下方<strong>例题2、3</strong></p>
<h3 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h3><h3 id="1-HihoCoder-1176"><a href="#1-HihoCoder-1176" class="headerlink" title="1. HihoCoder 1176"></a><a href="https://vjudge.net/problem/HihoCoder-1176">1. HihoCoder 1176</a></h3><p>判断一个无向图是否有欧拉路径</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m;<br>vector&lt;<span class="hljs-type">int</span>&gt; gg[<span class="hljs-number">50005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;n&gt;&gt;m;<br>	<span class="hljs-type">int</span> u,v;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>		cin&gt;&gt;u&gt;&gt;v;<br>		gg[u].<span class="hljs-built_in">push_back</span>(v);<br>		gg[v].<span class="hljs-built_in">push_back</span>(u);<br>	&#125;<br>	<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-type">int</span> temp=<span class="hljs-number">0</span>;<br>		<span class="hljs-type">int</span> Size=gg[i].<span class="hljs-built_in">size</span>();<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;Size;i++)&#123;<br>			temp++;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(temp%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>)&#123;<br>			ans++;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">if</span>(ans==<span class="hljs-number">0</span>||ans==<span class="hljs-number">2</span>) cout&lt;&lt;<span class="hljs-string">&quot;Full&quot;</span>&lt;&lt;endl;<br>	<span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;Part&quot;</span>&lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="2-HihoCoder-1181"><a href="#2-HihoCoder-1181" class="headerlink" title="2. HihoCoder 1181"></a><a href="https://vjudge.net/problem/HihoCoder-1181">2. HihoCoder 1181</a></h3><p>重题<a href="https://vjudge.net/problem/POJ-2230">POJ 2230 Watchcow</a>（但此题用stack会RE）</p>
<p>求一个无向图的任意一条欧拉回路</p>
<p>应用Fleury算法，代码如下</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> u,v,w,next;<br>	<span class="hljs-type">bool</span> f;<br>&#125;e[<span class="hljs-number">50005</span>];<br><span class="hljs-type">int</span> cnt,head[<span class="hljs-number">50005</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br>	cnt=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w=<span class="hljs-number">0</span>)</span></span>&#123;<br>	e[cnt]=Edge&#123;u,v,w,head[u],<span class="hljs-literal">false</span>&#125;;<br>	head[u]=cnt++;<br>&#125;<br>stack&lt;<span class="hljs-type">int</span>&gt; sta;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(!e[i].f)&#123;<br>			e[i].f=e[i^<span class="hljs-number">1</span>].f=<span class="hljs-number">1</span>;<br>			<span class="hljs-built_in">dfs</span>(v);<br>		&#125;<br>	&#125;<br>	sta.<span class="hljs-built_in">push</span>(u);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;n&gt;&gt;m;<br>	<span class="hljs-type">int</span> u,v;<span class="hljs-built_in">init</span>();<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>		cin&gt;&gt;u&gt;&gt;v;<br>		<span class="hljs-built_in">addedge</span>(u,v);<br>		<span class="hljs-built_in">addedge</span>(v,u);<br>	&#125;<br>	<br>	<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">while</span>(sta.<span class="hljs-built_in">size</span>())&#123;<br>		cout&lt;&lt;sta.<span class="hljs-built_in">top</span>()&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>		sta.<span class="hljs-built_in">pop</span>(); <br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="3-Hiho-Coder-1182"><a href="#3-Hiho-Coder-1182" class="headerlink" title="3. Hiho Coder 1182"></a><a href="https://vjudge.net/problem/HihoCoder-1182">3. Hiho Coder 1182</a></h3><p>题意：</p>
<p>给出一个正整数n，求一个长度为$2^n$的01环，使得该环的每n位恰好构成$0~2^{n-1}$，例如：n=3时，答案为00010111</p>
<p>题解：</p>
<p>很有意思的一道题，考虑将其转化为<strong>图论</strong>题：例如，对于n=3的情况，抽取其中任意的长度为3的子串，如：101，将其拆分为10、01，那么就可以建图从(10)-&gt;(01)，由此，从$0~2^{n-1}-1$只要有一个数的后n-1位和另一个数的前n-1位相同，那么就可以从前一个数连一条边到后一个数，显然共有$2^n$条边，跑一次欧拉回路，用栈记录路径，最后输出时一定要倒着输出（栈&amp;1）的值</p>
<p>AC代码：</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> u,v,w,next;<br>	<span class="hljs-type">bool</span> f;<br>&#125;e[<span class="hljs-number">50005</span>];<br><span class="hljs-type">int</span> cnt,head[<span class="hljs-number">50005</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br>	cnt=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w=<span class="hljs-number">0</span>)</span></span>&#123;<br>	e[cnt]=Edge&#123;u,v,w,head[u],<span class="hljs-literal">false</span>&#125;;<br>	head[u]=cnt++;<br>&#125;<br>stack&lt;<span class="hljs-type">int</span>&gt; sta;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(!e[i].f)&#123;<br>			e[i].f=<span class="hljs-number">1</span>; <span class="hljs-comment">//删单边</span><br>			<span class="hljs-built_in">dfs</span>(v);<br>		&#125;<br>	&#125;<br>	sta.<span class="hljs-built_in">push</span>(u);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;n;<br>	<span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<br>		cout&lt;&lt;<span class="hljs-string">&quot;01&quot;</span>&lt;&lt;endl;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-built_in">init</span>();<br>	<span class="hljs-type">int</span> k=(<span class="hljs-number">1</span>&lt;&lt;n<span class="hljs-number">-2</span>)<span class="hljs-number">-1</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1</span>&lt;&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>		<span class="hljs-type">int</span> giao=i&amp;k;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">1</span>&lt;&lt;n<span class="hljs-number">-1</span>;j++)&#123;<br>			<span class="hljs-keyword">if</span>(giao==j&gt;&gt;<span class="hljs-number">1</span>)&#123;<br>				<span class="hljs-built_in">addedge</span>(i,j);<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>	sta.<span class="hljs-built_in">pop</span>();<br>	<span class="hljs-keyword">while</span>(sta.<span class="hljs-built_in">size</span>())&#123;<br>		cout&lt;&lt;(sta.<span class="hljs-built_in">top</span>()&amp;<span class="hljs-number">1</span>);<br>		sta.<span class="hljs-built_in">pop</span>();<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>欧拉回路</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析Tarjan算法&amp;常见应用</title>
    <url>/2020/03/24/%E6%B5%85%E6%9E%90Tarjan%E7%AE%97%E6%B3%95&amp;%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<center>强连通分量(Strongly Connected Components)</center>

<span id="more"></span>
<h2 id="有向图-强连通分量（SCC）"><a href="#有向图-强连通分量（SCC）" class="headerlink" title="有向图 强连通分量（SCC）"></a><center>有向图 强连通分量（SCC）</center></h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li><p>官方行话版：在有向图$G$中，如果两个顶点$v_i,v_j$间$（v_i&gt;v_j）$有一条从$v_i$到$v_j$的有向路径，同时还有一条从$v_j$到$v_i$的有向路径，则称两个顶点<strong>强连通(strongly connected)</strong>，如果有向图$G$的每两个顶点都强连通，称$G$是一个<strong>强连通图</strong>，有向图的极大强连通子图，称为<strong>强连通分量(strongly connected components)</strong></p>
</li>
<li><p>浅显易懂版：指有向图中一个最大的子图，满足<strong>这个子图中任何两个点都能互相到达</strong></p>
</li>
</ul>
<p>参考blog：</p>
<ul>
<li><p><a href="https://www.byvoid.com/zhs/blog/scc-tarjan">有向图强连通分量的Tarjan算法</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/five20/p/7594239.html">浅析强连通分量(Tarjan和kosaraju)</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/stxy-ferryman/p/7779347.html">tarjan求强连通分量+缩点+割点/割桥（点双/边双）以及一些证明 - Styx-ferryman - 博客园</a></p>
</li>
</ul>
<p>上面三个$blog$写得异常清晰易懂，让我受益匪浅，本来不想再废话了的，但还是想写几个<strong>注意事项和易混淆的地方</strong>，下面先呈上$Tarjan$的板子（由于$Kosaraju$算法没$Tarjan$好用，我就不放板子了），向发明该算法的<strong>$Robert Tarjan（美国计算机科学家）$</strong>致敬</p>
<h3 id="Tarjan-SCC模板"><a href="#Tarjan-SCC模板" class="headerlink" title="Tarjan SCC模板"></a>Tarjan SCC模板</h3><p><a href="https://www.luogu.com.cn/problem/P2863">模板题</a></p>
<p>注意事项：</p>
<ul>
<li><p>Tarjan求SCC需要开栈记录元素，再开一个<code>vis</code>数组标记元素是否在栈中</p>
</li>
<li><p>其中<code>color</code>数组标记每个点属于第几个SCC</p>
</li>
<li><p>与求割点不同的地方：</p>
<p><code>low[u]=min(low[u],dfn[v])</code>需要<code>v</code>在栈中才执行</p>
<p>不需要记录父亲节点</p>
</li>
<li><p>与求割点相同的地方：</p>
<p>都需要（务必）遍历每个点，因为图不一定连通</p>
<p>新找到一个点都必须执行<code>low[u]=min(low[u],low[v])</code></p>
<p><code>dfn和low</code>数组都是必须要有的，这是算法的核心</p>
</li>
</ul>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    vis[sta[++top]=u]=<span class="hljs-number">1</span>; <span class="hljs-comment">//初始标记入栈</span><br>    low[u]=dfn[u]=++deep; <span class="hljs-comment">//记录dfn和low的序号</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123; <span class="hljs-comment">//遍历所有出边</span><br>        <span class="hljs-type">int</span> v=e[i].v;<br>        <span class="hljs-keyword">if</span>(!dfn[v])&#123; <span class="hljs-comment">//如果没遍历过这个点</span><br>            <span class="hljs-built_in">tarjan</span>(v); <span class="hljs-comment">//就递归遍历下去</span><br>            low[u]=<span class="hljs-built_in">min</span>(low[u],low[v]); <span class="hljs-comment">//low取u和他儿子的较小值</span><br>        <span class="hljs-comment">//如果遍历过且在栈中，low[u]取low[u]和dfn[v]的较小值</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(vis[v]) low[u]=<span class="hljs-built_in">min</span>(low[u],dfn[v]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dfn[u]==low[u])&#123; <span class="hljs-comment">//如果dfn和low一样了，说明产生了一个SCC</span><br>        vis[u]=<span class="hljs-number">0</span>; <span class="hljs-comment">//u标记不在栈中</span><br>        color[u]=++num; <span class="hljs-comment">//标记u属于第num个SCC</span><br>        <span class="hljs-keyword">while</span>(sta[top]!=u)&#123; <span class="hljs-comment">//弹栈顶元素直到弹到u</span><br>            color[sta[top]]=num; <span class="hljs-comment">//所有弹出元素都属于u所在的SCC内</span><br>            vis[sta[top--]]=<span class="hljs-number">0</span>; <span class="hljs-comment">//所有弹出元素都标记不在栈中</span><br>        &#125;<br>        top--; <span class="hljs-comment">//最后需要把u弹出</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!dfn[i]) <span class="hljs-comment">//遍历到所有点（有可能不是连通图）</span><br>            <span class="hljs-built_in">tarjan</span>(i);<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="有向图-Tarjan缩点"><a href="#有向图-Tarjan缩点" class="headerlink" title="有向图 Tarjan缩点"></a>有向图 Tarjan缩点</h3><p><strong>思想就是因为强连通分量中的每两个点都是强连通的，可以将一个强连通分量当做一个超级点，而点权按题意来定</strong></p>
<h4 id="例题1-受欢迎的牛（Tarjan缩点记录SCC内节点个数）"><a href="#例题1-受欢迎的牛（Tarjan缩点记录SCC内节点个数）" class="headerlink" title="例题1. 受欢迎的牛（Tarjan缩点记录SCC内节点个数）"></a>例题1. <a href="https://www.luogu.com.cn/problem/P2341">受欢迎的牛</a>（Tarjan缩点记录SCC内节点个数）</h4><details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> v,next;<br>&#125;e[<span class="hljs-number">50005</span>];<br><span class="hljs-type">int</span> cnt,head[<span class="hljs-number">10005</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;<br>	e[cnt]=Edge&#123;v,head[u]&#125;;<br>	head[u]=cnt++; <br>&#125;<br><span class="hljs-type">int</span> n,m,num,deep,top,sta[<span class="hljs-number">10005</span>],low[<span class="hljs-number">10005</span>],dfn[<span class="hljs-number">10005</span>],vis[<span class="hljs-number">10005</span>],color[<span class="hljs-number">10005</span>];<br><span class="hljs-type">int</span> Size[<span class="hljs-number">10005</span>],chu[<span class="hljs-number">50005</span>],ccnt,ans;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>	vis[sta[++top]=u]=<span class="hljs-number">1</span>;<br>	low[u]=dfn[u]=++deep;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(!dfn[v]) <span class="hljs-built_in">tarjan</span>(v),low[u]=<span class="hljs-built_in">min</span>(low[u],low[v]);<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(vis[v]) low[u]=<span class="hljs-built_in">min</span>(low[u],dfn[v]);<br>	&#125;<br>	<span class="hljs-keyword">if</span>(dfn[u]==low[u])&#123;<br>		vis[u]=<span class="hljs-number">0</span>;<br>		color[u]=++num;<br>		<span class="hljs-keyword">while</span>(sta[top]!=u)&#123;<br>			vis[sta[top]]=<span class="hljs-number">0</span>;<br>			color[sta[top--]]=num;<br>		&#125;<br>		top--;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>	<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br>	<span class="hljs-type">int</span> u,v;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);<br>		<span class="hljs-built_in">addedge</span>(u,v);<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">if</span>(!dfn[i]) <span class="hljs-built_in">tarjan</span>(i);<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		Size[color[i]]++;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=head[i];~j;j=e[j].next)&#123;<br>			<span class="hljs-type">int</span> v=e[j].v;<br>			<span class="hljs-keyword">if</span>(color[v]!=color[i]) chu[color[i]]++;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=num;i++)&#123;<br>		<span class="hljs-keyword">if</span>(chu[i]==<span class="hljs-number">0</span>) ccnt++,ans=Size[i];<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ccnt==<span class="hljs-number">1</span>?ans:<span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>


<h4 id="例题2-【模板】缩点（Tarjan缩点-拓扑排序-记忆化搜索dp）"><a href="#例题2-【模板】缩点（Tarjan缩点-拓扑排序-记忆化搜索dp）" class="headerlink" title="例题2. 【模板】缩点（Tarjan缩点+拓扑排序+记忆化搜索dp）"></a>例题2. <a href="https://www.luogu.com.cn/problem/P3387">【模板】缩点</a>（Tarjan缩点+拓扑排序+记忆化搜索dp）</h4><details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> v,next;<br>&#125;e[<span class="hljs-number">100005</span>],ee[<span class="hljs-number">100005</span>];<br><br><span class="hljs-type">int</span> cnt,ccnt,hhead[<span class="hljs-number">10005</span>],head[<span class="hljs-number">10005</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;<br>	e[cnt]=Edge&#123;v,head[u]&#125;;<br>	head[u]=cnt++; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">aaddedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;<br>	ee[ccnt]=Edge&#123;v,hhead[u]&#125;;<br>	hhead[u]=ccnt++;<br>&#125;<br><span class="hljs-type">int</span> n,m,num,deep,top,sta[<span class="hljs-number">10005</span>],low[<span class="hljs-number">10005</span>],dfn[<span class="hljs-number">10005</span>],vis[<span class="hljs-number">10005</span>],color[<span class="hljs-number">10005</span>];<br><span class="hljs-type">int</span> val[<span class="hljs-number">10005</span>],vval[<span class="hljs-number">10005</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>	vis[sta[++top]=u]=<span class="hljs-number">1</span>;<br>	low[u]=dfn[u]=++deep;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(!dfn[v]) <span class="hljs-built_in">tarjan</span>(v),low[u]=<span class="hljs-built_in">min</span>(low[u],low[v]);<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(vis[v]) low[u]=<span class="hljs-built_in">min</span>(low[u],dfn[v]);<br>	&#125;<br>	<span class="hljs-keyword">if</span>(dfn[u]==low[u])&#123;<br>		vis[u]=<span class="hljs-number">0</span>;<br>		color[u]=++num;<br>		vval[num]+=val[u];<br>		<span class="hljs-keyword">while</span>(sta[top]!=u)&#123;<br>			vis[sta[top]]=<span class="hljs-number">0</span>;<br>			vval[num]+=val[sta[top]];<br>			color[sta[top--]]=num;<br>		&#125;<br>		top--;<br>	&#125;<br>&#125;<br><br><span class="hljs-type">int</span> indeg[<span class="hljs-number">10005</span>],tpx[<span class="hljs-number">10005</span>],tp;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">toposort</span><span class="hljs-params">()</span></span>&#123;<br>	queue&lt;<span class="hljs-type">int</span>&gt; q;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">if</span>(indeg[i]==<span class="hljs-number">0</span>)&#123;<br>			q.<span class="hljs-built_in">push</span>(i);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>		<span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>();<br>		q.<span class="hljs-built_in">pop</span>();<br>		tpx[++tp]=u;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=hhead[u];~i;i=ee[i].next)&#123;<br>			<span class="hljs-type">int</span> v=ee[i].v;<br>			<span class="hljs-keyword">if</span>(indeg[v])&#123;<br>				indeg[v]--;<br>				<span class="hljs-keyword">if</span>(indeg[v]==<span class="hljs-number">0</span>)&#123;<br>					q.<span class="hljs-built_in">push</span>(v);<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-type">int</span> dp[<span class="hljs-number">10005</span>],ans;<br><span class="hljs-type">bool</span> vvis[<span class="hljs-number">10005</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>	dp[x]=vval[x];<br>	<span class="hljs-type">int</span> temp=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=hhead[x];~i;i=ee[i].next)&#123;<br>		<span class="hljs-type">int</span> v=ee[i].v;<br>		<span class="hljs-keyword">if</span>(!vvis[v]) vvis[v]=<span class="hljs-number">1</span>,<span class="hljs-built_in">dfs</span>(v);<br>		temp=<span class="hljs-built_in">max</span>(temp,dp[v]);<br>	&#125;<br>	dp[x]+=temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>	<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br>	<span class="hljs-built_in">memset</span>(hhead,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(hhead));<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;val[i]);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)&#123;<br>		<span class="hljs-type">int</span> u,v;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);<br>		<span class="hljs-built_in">addedge</span>(u,v);<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-keyword">if</span>(!dfn[i]) <span class="hljs-built_in">tarjan</span>(i);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u=<span class="hljs-number">1</span>;u&lt;=n;++u)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>			<span class="hljs-type">int</span> v=e[i].v;<br>			<span class="hljs-keyword">if</span>(color[u]!=color[v])&#123;<br>				<span class="hljs-built_in">aaddedge</span>(color[u],color[v]);<br>				indeg[color[v]]++;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">toposort</span>();<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=num;++i)&#123;<br>		<span class="hljs-type">int</span> now=tpx[i];<br>		<span class="hljs-keyword">if</span>(!vvis[now])&#123;<br>			<span class="hljs-built_in">dfs</span>(now);<br>			ans=<span class="hljs-built_in">max</span>(ans,dp[now]);<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h2 id="无向图-割点（割顶）与-点双连通分量（V-DCC）"><a href="#无向图-割点（割顶）与-点双连通分量（V-DCC）" class="headerlink" title="无向图 割点（割顶）与 点双连通分量（V-DCC）"></a><center>无向图 割点（割顶）与 点双连通分量（V-DCC）</center></h2><p>参考blog：</p>
<ul>
<li><p><a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/stxy-ferryman/p/7779347.html">tarjan求强连通分量+缩点+割点/割桥（点双/边双）以及一些证明 - Styx-ferryman - 博客园</a></p>
</li>
<li><p><a href="https://blog.csdn.net/huzujun/article/details/81086496">双连通分量总结及例题</a></p>
</li>
<li><p><a href="https://blog.csdn.net/wjh2622075127/article/details/82701608">割点-割边（桥）模板</a></p>
</li>
<li><p><a href="https://blog.csdn.net/forever_dreams/article/details/81783697?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task">割点、割边（桥）</a></p>
</li>
</ul>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><strong>割点</strong>：</p>
<p>官方行话版（已经足够易懂了）：在一个无向图中，如果有一个顶点集合，删除这个顶点集合以及这个集合中所有顶点相关联的边以后，图的连通分量增多，就称这个点集为割点集合</p>
<p>易懂人话版：这个点维持着双连通的继续，去掉这个点，这个连通分量就无法再维持下去，分成好几个连通分量</p>
<p><strong>点双连通分量</strong>：一个极大子图，删掉其中任意一个点，图仍连通</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>讲一下核心部分吧，还是Tarjan算法的架构，我们可以把回溯过程遇到的点分为两类</p>
<ol>
<li>回溯到的点就是当前父节点：此时只需要判断自己有多少棵子树，如果超过1棵那么这个点就一定是割点（至少一定能把子树分成两半）</li>
<li>回溯到的点不是父节点：稍微麻烦一点，需要判一下是否有<code>low[v]&gt;=dfv[u]</code>，如果成立的话说明<code>v</code>没办法与他父亲<code>u</code>之前的点连成SCC，那么<code>u</code>就肯定是个割点（至少能把<code>v</code>作父亲的这棵子树给断开）</li>
</ol>
<p>除此之外，每次从一个节点产生一棵搜索树都需要先开一个<code>child</code>记录这个节点能有多少棵子树</p>
<p>至于<strong>点双</strong>，最简单的做法：只需要求出<strong>割点</strong>之后，遍历去掉每一个割点的情况，找连通分量就行了，看题目要求啦</p>
<h3 id="Tarjan-割点模板"><a href="#Tarjan-割点模板" class="headerlink" title="Tarjan 割点模板"></a>Tarjan 割点模板</h3><details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span>&#123;<br>    low[u]=dfn[u]=++deep;<br>    <span class="hljs-type">int</span> child=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>        <span class="hljs-type">int</span> v=e[i].v;<br>        <span class="hljs-keyword">if</span>(!dfn[v])&#123;<br>            <span class="hljs-built_in">tarjan</span>(v,fa);<span class="hljs-comment">//注意永远都是fa</span><br>            low[u]=<span class="hljs-built_in">min</span>(low[u],low[v]);<br>            <span class="hljs-keyword">if</span>(u!=fa&amp;&amp;low[v]&gt;=dfn[u])<span class="hljs-comment">//判不是父节点的节点属于割点</span><br>                cut[u]=<span class="hljs-number">1</span>;<br>           	<span class="hljs-keyword">if</span>(u==fa)<span class="hljs-comment">//如果连到了父亲说明多了一个儿子</span><br>                child++;<br>        &#125;<br>        low[u]=<span class="hljs-built_in">min</span>(low[u],dfn[v]);<span class="hljs-comment">//务必别忘了这一步</span><br>    &#125;<br>   	<span class="hljs-keyword">if</span>(u==fa&amp;&amp;child&gt;=<span class="hljs-number">2</span>)<span class="hljs-comment">//如果回到父亲了且儿子数多于1就是割点</span><br>        cut[u]=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-keyword">if</span>(!dfn[i]) <span class="hljs-built_in">tarjan</span>(i,i)<br>&#125;<br><br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="例题-POJ-1523-SPF（求每个割点把图分成的点双数量）"><a href="#例题-POJ-1523-SPF（求每个割点把图分成的点双数量）" class="headerlink" title="例题 POJ 1523 SPF（求每个割点把图分成的点双数量）"></a>例题 <a href="https://vjudge.net/problem/POJ-1523">POJ 1523 SPF</a>（求每个割点把图分成的点双数量）</h3><details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> v,next;<br>&#125;e[<span class="hljs-number">50005</span>];<br><br><span class="hljs-type">int</span> cnt,head[<span class="hljs-number">2005</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;<br>	e[cnt]=Edge&#123;v,head[u]&#125;;<br>	head[u]=cnt++;<br>&#125;<br><br><span class="hljs-type">int</span> dfn[<span class="hljs-number">2005</span>],low[<span class="hljs-number">2005</span>],cut[<span class="hljs-number">2005</span>],deep;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span>&#123;<br>	low[u]=dfn[u]=++deep;<br>	<span class="hljs-type">int</span> child=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(!dfn[v])&#123;<br>			<span class="hljs-built_in">tarjan</span>(v,fa);<br>			low[u]=<span class="hljs-built_in">min</span>(low[u],low[v]);<br>			<span class="hljs-keyword">if</span>(u!=fa&amp;&amp;low[v]&gt;=dfn[u]) cut[u]=<span class="hljs-number">1</span>;<br>			<span class="hljs-keyword">if</span>(u==fa) child++;<br>		&#125;<br>		low[u]=<span class="hljs-built_in">min</span>(low[u],dfn[v]);<br>	&#125;<br>	<span class="hljs-keyword">if</span>(u==fa&amp;&amp;child&gt;<span class="hljs-number">1</span>) cut[u]=<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> n,u,v,Cnt,ge[<span class="hljs-number">2005</span>],color[<span class="hljs-number">2005</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>	n=Cnt=cnt=deep=<span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br>	<span class="hljs-built_in">memset</span>(dfn,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dfn));<br>	<span class="hljs-built_in">memset</span>(low,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(low));<br>	<span class="hljs-built_in">memset</span>(cut,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(cut));<br>	<span class="hljs-built_in">memset</span>(ge,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(ge));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> gg,<span class="hljs-type">int</span> ID)</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(v!=gg&amp;&amp;color[v]==<span class="hljs-number">-1</span>)&#123;<br>			color[v]=ID;<br>			<span class="hljs-built_in">dfs</span>(v,gg,ID);<br>		&#125;<br>	&#125;<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>	<span class="hljs-built_in">init</span>();<br>	<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>	<span class="hljs-type">bool</span> f=<span class="hljs-literal">false</span>;<br>	<span class="hljs-keyword">while</span>(cin&gt;&gt;u)&#123;<br>		<span class="hljs-keyword">if</span>(u==<span class="hljs-number">0</span>&amp;&amp;f==<span class="hljs-literal">false</span>) <span class="hljs-keyword">break</span>;<br>		f=<span class="hljs-literal">true</span>;<br>		<span class="hljs-keyword">if</span>(u==<span class="hljs-number">0</span>)&#123;<br>			++t;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-keyword">if</span>(!dfn[i]) <span class="hljs-built_in">tarjan</span>(i,i);<br>			Cnt=<span class="hljs-number">0</span>;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>				<span class="hljs-keyword">if</span>(cut[i]) ge[++Cnt]=i;<br>			&#125;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Network #%d\n&quot;</span>,t);<br>			<span class="hljs-keyword">if</span>(Cnt==<span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  No SPF nodes\n\n&quot;</span>);<br>			<span class="hljs-keyword">else</span>&#123;<br>				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g=<span class="hljs-number">1</span>;g&lt;=Cnt;g++)&#123;<br>					<span class="hljs-built_in">memset</span>(color,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(color));<br>					<span class="hljs-type">int</span> CNT=<span class="hljs-number">0</span>;<br>					<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>						<span class="hljs-keyword">if</span>(i!=ge[g]&amp;&amp;color[i]==<span class="hljs-number">-1</span>)&#123;<br>							++CNT;<br>							color[i]=CNT;<br>							<span class="hljs-built_in">dfs</span>(i,ge[g],CNT);<br>						&#125;<br>					&#125;<br>					<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  SPF node %d leaves %d subnets\n&quot;</span>,ge[g],CNT);<br>				&#125;<br>				<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>			&#125;<br>			<span class="hljs-built_in">init</span>();<br>			f=<span class="hljs-literal">false</span>;<br>			<span class="hljs-keyword">continue</span>;<br>		&#125;<br>		cin&gt;&gt;v;<br>		<span class="hljs-built_in">addedge</span>(u,v);<br>		<span class="hljs-built_in">addedge</span>(v,u);<br>		n=<span class="hljs-built_in">max</span>(n,<span class="hljs-built_in">max</span>(u,v));<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h2 id="无向图-割边（桥）与-边双连通分量（E-DCC）"><a href="#无向图-割边（桥）与-边双连通分量（E-DCC）" class="headerlink" title="无向图 割边（桥）与 边双连通分量（E-DCC）"></a><center>无向图 割边（桥）与 边双连通分量（E-DCC）</center></h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p><strong>割边</strong>：边版本的割点，即去掉这条边，该图就无法维持连通</p>
<p><strong>边双连通分量</strong>：一个极大子图，删掉图中任意一条边之后，图仍连通</p>
<h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><ol>
<li><p>还是Tarjan，而且算法一模一样，可以直接利用有向图的SCC算法给无向图跑一遍（<strong>只需要注意判双向边，用异或运算解决即可</strong>），然后就知道了每个点属于哪一个边双连通分量，最后只需要遍历节点找<strong>割边</strong>就行了（<strong>割边的两节点属于不同的双连通分量中</strong>）</p>
</li>
<li><p>还有一种方法可以<strong>记录哪一条边是桥</strong>：只需要在Tarjan过程中判一下是否有<code>low[v]&gt;dfn[u]</code>，如果存在，则<code>(u,v)</code>这条边是桥（存双向边，要标记两条，异或搞定），除此之外，还需要另外判一下<code>v</code>是不是当前DFS树的根（如果要判重边，则记录一下儿子个数即可，儿子至多为1个才没有重边），如果是，就要跳过（即这条边不是桥）</p>
</li>
</ol>
<h3 id="Tarjan-无向图割边模板（求出边双同时标记割边）"><a href="#Tarjan-无向图割边模板（求出边双同时标记割边）" class="headerlink" title="Tarjan 无向图割边模板（求出边双同时标记割边）"></a>Tarjan 无向图割边模板（求出边双同时标记割边）</h3><details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span>&#123; <span class="hljs-comment">//这是传入的还是父节点</span><br>    vis[sta[++top]=u]=<span class="hljs-number">1</span>;<br>    low[u]=dfn[u]=++deep;<br>    <span class="hljs-type">int</span> precnt=<span class="hljs-number">0</span>; <span class="hljs-comment">//记录一下父节点的儿子个数，用来判重边</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>        <span class="hljs-type">int</span> v=e[i].v;<br>        <span class="hljs-keyword">if</span>(v==fa&amp;&amp;precnt==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//理论上只需要v!=fa即可判双向边</span><br>            precnt++;<span class="hljs-comment">//但如果判重边就需要这个</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!dfn[v])&#123;<br>            <span class="hljs-built_in">tarjan</span>(v,u);<br>            low[u]=<span class="hljs-built_in">min</span>(low[u],low[v]);<br>            <span class="hljs-comment">//下面这段标记割边（可不写）</span><br>            <span class="hljs-keyword">if</span>(low[v]&gt;dfn[u])&#123; <span class="hljs-comment">//判是否是桥</span><br>                e[i].cut=<span class="hljs-number">1</span>;<br>                e[i^<span class="hljs-number">1</span>].cut=<span class="hljs-number">1</span>; <span class="hljs-comment">//双向边</span><br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(vis[v]) low[u]=<span class="hljs-built_in">min</span>(low[u],dfn[v]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dfn[u]==low[u])&#123; <span class="hljs-comment">//记录每个点属于的边双</span><br>        vis[u]=<span class="hljs-number">0</span>;<br>        color[u]=++num;<br>        <span class="hljs-keyword">while</span>(sta[top]!=u)&#123;<br>            vis[sta[top]]=<span class="hljs-number">0</span>;<br>            color[sta[top--]]=num;<br>        &#125;<br>        top--;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="例题-POJ-3177-Redundant-Path（边双-缩点）"><a href="#例题-POJ-3177-Redundant-Path（边双-缩点）" class="headerlink" title="例题 POJ 3177 Redundant Path（边双+缩点）"></a>例题 <a href="https://vjudge.net/problem/POJ-3177">POJ 3177 Redundant Path</a>（边双+缩点）</h3><details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> v,next;<br>&#125;e[<span class="hljs-number">500005</span>];<br><br><span class="hljs-type">int</span> cnt,head[<span class="hljs-number">100005</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;<br>	e[cnt]=Edge&#123;v,head[u]&#125;;<br>	head[u]=cnt++; <br>&#125;<br><br><span class="hljs-type">int</span> n,m,num,deep,top,sta[<span class="hljs-number">100005</span>],low[<span class="hljs-number">100005</span>],dfn[<span class="hljs-number">100005</span>],vis[<span class="hljs-number">100005</span>],color[<span class="hljs-number">100005</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span>&#123;<br>	vis[sta[++top]=u]=<span class="hljs-number">1</span>;<br>	low[u]=dfn[u]=++deep;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(i==(fa^<span class="hljs-number">1</span>)) <span class="hljs-keyword">continue</span>;<br>		<span class="hljs-keyword">if</span>(!dfn[v]) <span class="hljs-built_in">tarjan</span>(v,i),low[u]=<span class="hljs-built_in">min</span>(low[u],low[v]);<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(vis[v]) low[u]=<span class="hljs-built_in">min</span>(low[u],dfn[v]);<br>	&#125;<br>	<span class="hljs-keyword">if</span>(dfn[u]==low[u])&#123;<br>		vis[u]=<span class="hljs-number">0</span>;<br>		color[u]=++num;<br>		<span class="hljs-keyword">while</span>(sta[top]!=u)&#123;<br>			vis[sta[top]]=<span class="hljs-number">0</span>;<br>			color[sta[top--]]=num;<br>		&#125;<br>		top--;<br>	&#125;<br>&#125;<br><br><span class="hljs-type">int</span> indeg[<span class="hljs-number">100005</span>],ans;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>	cnt=ans=deep=num=top=<span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">memset</span>(dfn,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dfn));<br>	<span class="hljs-built_in">memset</span>(low,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(low));<br>	<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br>	<span class="hljs-built_in">memset</span>(indeg,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(indeg));<br>	<span class="hljs-built_in">memset</span>(sta,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(sta));<br>	<span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<br>	<span class="hljs-built_in">memset</span>(color,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(color));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m))&#123;<br>		<span class="hljs-built_in">init</span>();<br>		<span class="hljs-type">int</span> u,v;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)&#123;<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);<br>			<span class="hljs-built_in">addedge</span>(u,v);<br>			<span class="hljs-built_in">addedge</span>(v,u);<br>		&#125;<br>		<span class="hljs-built_in">tarjan</span>(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>);<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=head[i];~j;j=e[j].next)&#123;<br>				<span class="hljs-type">int</span> v=e[j].v;<br>				<span class="hljs-keyword">if</span>(color[i]!=color[v])&#123;<br>					indeg[color[v]]++;<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=num;i++)<br>			<span class="hljs-keyword">if</span>(indeg[i]==<span class="hljs-number">1</span>)<br>				ans++;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,(ans+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>); <br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><center>总结</center></h2><ul>
<li><strong>有向图的的Tarjan算法</strong>最为核心</li>
<li>无向图的<strong>边双连通分量</strong>就是在有向图SCC基础上判一下双向边（满足<code>v!=fa</code>即可），而<strong>割边的标记</strong>需要另外加一句<code>low[v]&gt;dfn[u]</code>的判断</li>
<li>无向图的<strong>割点</strong>比较特殊，需要判两种回溯点的情况，同时还要记录儿子个数，并且<strong>递归传递的父节点永远不变</strong>，而<strong>点双连通分量</strong>的求取只需要<strong>先求割点再去除割点遍历</strong>就行了，比较灵活</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>数据结构</tag>
        <tag>割点</tag>
        <tag>SCC</tag>
      </tags>
  </entry>
  <entry>
    <title>状压DP浅析</title>
    <url>/2020/03/10/%E7%8A%B6%E5%8E%8BDP%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h2 id="动态规划の状压dp"><a href="#动态规划の状压dp" class="headerlink" title="动态规划の状压dp"></a><center>动态规划の状压dp</center></h2><span id="more"></span>
<h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><ul>
<li><p><strong>当我们有时无法用普通的dp以及一些算法表示一些状态、解决一些问题的时候，我们就可以想到状态压缩动态规划</strong></p>
</li>
<li><p>通常情况下，我们可以利用一个整数的二进制表示来表达一个状态</p>
<p>如：101(5)，其中1表示该位处理过，0表示未处理（或一些别的物理意义）</p>
<p>因此，我们便可以用一个整数来表示dp的状态，十分简便</p>
</li>
<li><p>然而，由于该状态表示法十分吃空间（如一个状态有十个决策，那么就要用$2^{10}$这么大的数来表示所有可能的状态），因此使用状压的题一般数据范围都很小（<strong>十几</strong>的样子）</p>
</li>
</ul>
<h2 id="二进制状压操作"><a href="#二进制状压操作" class="headerlink" title="二进制状压操作"></a>二进制状压操作</h2><p>可以康康下图（网上复制来的，不太严谨，有的括号没加，要记住<strong>算术运算的优先级高于移位运算</strong>）</p>
<p><img src="https://i.loli.net/2020/03/09/AsyhKmX7zH6lc9R.png" alt="image.png"></p>
<p>除此之外，一些最常用的操作如下：</p>
<ul>
<li><p>要求一行（or 一列）的状态不能有两个相邻</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">return</span> !((x&amp;(x&lt;&lt;<span class="hljs-number">1</span>))||(x&amp;(x&gt;&gt;<span class="hljs-number">1</span>)));<br></code></pre></div></td></tr></table></figure>
</li>
<li><p>要求一行（or 一列）的状态不能间隔一个相邻</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">return</span> !((x&amp;(x&lt;&lt;<span class="hljs-number">2</span>))||(x&amp;(x&gt;&gt;<span class="hljs-number">2</span>)));<br></code></pre></div></td></tr></table></figure>
</li>
<li><p>要求一行（or 一列）的状态不能连续三个相邻</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">return</span> !(((x&amp;(x&lt;&lt;<span class="hljs-number">1</span>))&amp;&amp;(x&amp;(x&lt;&lt;<span class="hljs-number">2</span>)))||((x&amp;(x&gt;&gt;<span class="hljs-number">1</span>))&amp;&amp;(x&amp;(x&gt;&gt;<span class="hljs-number">2</span>))));<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<p>以此类推。。。总之就是<strong>本身和本身左移（或右移）若干位相与</strong>之后有没有重合的部分</p>
<ul>
<li>计算一个数的二进制位总共多少个1</li>
</ul>
<p><code>__builtin_popcount()</code>当然可以，但有时候会出玄学bug，慎用</p>
<p>下面的方法要牢记</p>
 <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getnum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(x)&#123;<br>        ++ans;<br>        x-=(x&amp;(-x)); <span class="hljs-comment">//同lowbit操作</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="一般的板子-amp-优化操作"><a href="#一般的板子-amp-优化操作" class="headerlink" title="一般的板子&amp;优化操作"></a>一般的板子&amp;优化操作</h2><p>其实dp没有板子。。。</p>
<p>强行写一个最普通的吧</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123; <span class="hljs-comment">//枚举每一行</span><br>    <span class="hljs-number">1.f</span><span class="hljs-keyword">or</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt) <span class="hljs-comment">//如果预处理过状态总数，就用这个</span><br>    <span class="hljs-number">2.f</span><span class="hljs-keyword">or</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">1</span>&lt;&lt;m;j++) <span class="hljs-comment">//不担心时间复杂度的话，也可现在枚举所有状态</span><br>    &#123;<br>        ...(各种嵌套循环和条件判断)<br>        dp[][]...=max/<span class="hljs-built_in">min</span>(d[][]...,something) <span class="hljs-comment">//转移</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>优化的话，一般情况是<strong>爆空间</strong><del>（本蒟蒻只会这个）</del>，那么可以考虑预处理状态</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> cnt,sta[];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1</span>&lt;&lt;m;i++)&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">ok</span>(i)) <span class="hljs-comment">//ok函数用来判断该状态是否合理</span><br>        sta[++cnt]=i; <br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>以及<strong>滚动数组</strong>（对就是01背包里面那个滚动数组），即将一维开小，然后 <strong>根据当前状态需要前几个状态转移过来</strong> 来确定该维度大小，最后更新时只需取模即可</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">状态转移时：<span class="hljs-comment">//需要前t个状态转移过来</span><br>    dp[i%t][]...=max/<span class="hljs-built_in">min</span>(dp[i%t][]...,...)<br></code></pre></div></td></tr></table></figure>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>dp当然要多做题啦~</p>
<h3 id="洛谷-P1879-玉米地"><a href="#洛谷-P1879-玉米地" class="headerlink" title="洛谷 P1879 玉米地"></a><a href="https://www.luogu.com.cn/problem/P1879">洛谷 P1879 玉米地</a></h3><p>题意：给一个n*m的田地，有些地方可以种草地，要求种的草地不能相邻（没有公共边），求共有多少种种植方案？(答案模1e9)</p>
<p>题解：经典状压dp</p>
<p>定义<code>dp[i][j]</code>：处理到第<code>i</code>行状态为<code>j</code>时的方案总数，转移方程如下</p>
<script type="math/tex; mode=display">
dp[i][j]=(dp[i][j]+dp[i-1][k])\%mod</script><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">1e9</span>;<br><span class="hljs-type">int</span> n,m,dp[<span class="hljs-number">15</span>][<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">13</span>],a[<span class="hljs-number">15</span>][<span class="hljs-number">15</span>];<br><span class="hljs-type">int</span> f[<span class="hljs-number">15</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">ok</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>	<span class="hljs-keyword">return</span> !(x&amp;(x&lt;&lt;<span class="hljs-number">1</span>)||x&amp;(x&gt;&gt;<span class="hljs-number">1</span>)); <span class="hljs-comment">//判断状态是否满足不相邻</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]);<br>			<span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-number">1</span>) f[i]+=<span class="hljs-number">1</span>&lt;&lt;(m-j);<span class="hljs-comment">//把每行输入转为二进制状态</span><br>		&#125;<br><span class="hljs-comment">//		printf(&quot;%d:%d\n&quot;,i,f[i]);</span><br>	&#125;<br>	dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;(<span class="hljs-number">1</span>&lt;&lt;m);j++)&#123; <span class="hljs-comment">//枚举当前行状态</span><br>			<span class="hljs-keyword">if</span>(<span class="hljs-built_in">ok</span>(j)&amp;&amp;((j&amp;f[i])==j))&#123; <span class="hljs-comment">//右边这个是满足这块田可以种草地</span><br>				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;(<span class="hljs-number">1</span>&lt;&lt;m);k++)&#123;<span class="hljs-comment">//枚举前一行状态</span><br>					<span class="hljs-keyword">if</span>(<span class="hljs-built_in">ok</span>(k)&amp;&amp;((k&amp;j)==<span class="hljs-number">0</span>))&#123;<span class="hljs-comment">//同上</span><br>						dp[i][j]=(dp[i][j]+dp[i<span class="hljs-number">-1</span>][k])%mod;<br>					&#125;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1</span>&lt;&lt;m;i++) ans=(ans+dp[n][i])%mod; <br>    <span class="hljs-comment">//求所有可能方案数</span><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>	<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-comment">//https://www.luogu.com.cn/problem/P1879</span><br></code></pre></div></td></tr></table></figure>
<h3 id="HDU-1565-方格取数"><a href="#HDU-1565-方格取数" class="headerlink" title="HDU 1565 方格取数"></a><a href="https://vjudge.net/problem/HDU-1565">HDU 1565 方格取数</a></h3><p>题意：给定一个n*n的非负数矩阵，你可以从中取出不相邻（没有公共边）的若干个数，求取出的数的最大的和</p>
<p>题解：经典状压dp</p>
<p>定义<code>dp[i][j]</code>：处理到第<code>i</code>行的状态为<code>j</code>时的取出的最大的和，转移方程如下，其中<code>sum[j]</code>为<code>j</code>状态取出数的和</p>
<script type="math/tex; mode=display">
dp[i][j]=max(dp[i][j],dp[i-1][k]+sum[j])</script><p>这题数据范围有点大（&lt;=20），因此需要预处理，否则T爆</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll dp[<span class="hljs-number">21</span>][<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">17</span>];<br>ll a[<span class="hljs-number">21</span>][<span class="hljs-number">21</span>];<br>ll cnm[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">17</span>];<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">ok</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123; <span class="hljs-comment">//老骚操作了</span><br>	<span class="hljs-keyword">return</span> (!(x&amp;(x&lt;&lt;<span class="hljs-number">1</span>))&amp;&amp;(!(x&amp;(x&gt;&gt;<span class="hljs-number">1</span>))));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> row,<span class="hljs-type">int</span> sta)</span></span>&#123; <span class="hljs-comment">//获得当前行取数状态的和</span><br>	ll sum=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">if</span>(sta&amp;(<span class="hljs-number">1</span>&lt;&lt;i<span class="hljs-number">-1</span>)) sum+=a[row][n-i+<span class="hljs-number">1</span>];<br>	&#125;<br>	<span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;<br>		<span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dp));<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>				<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i][j]);<br>			&#125;<br>		&#125;<br>		<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1</span>&lt;&lt;n;i++)&#123; <span class="hljs-comment">//预处理可行状态</span><br>			<span class="hljs-keyword">if</span>(<span class="hljs-built_in">ok</span>(i)) cnm[cnt++]=i;<br>		&#125;<br>		<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cnt;j++)&#123;<br>				ll sum=<span class="hljs-built_in">getsum</span>(i,cnm[j]); <span class="hljs-comment">//获得和</span><br>				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;cnt;k++)&#123;<br>					<span class="hljs-keyword">if</span>((cnm[j]&amp;cnm[k])==<span class="hljs-number">0</span>)&#123;<br>						dp[i][j]=<span class="hljs-built_in">max</span>(dp[i][j],dp[i<span class="hljs-number">-1</span>][k]+sum);<br>					&#125;<br>				&#125;<br>			&#125;<br>		&#125;<br>		ll ans=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;i++)&#123; <span class="hljs-comment">//千万别忘了这个</span><br>			ans=<span class="hljs-built_in">max</span>(ans,dp[n][i]); <span class="hljs-comment">//取最终状态中和最大的状态的答案</span><br>		&#125;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-comment">//https://vjudge.net/problem/HDU-1565</span><br></code></pre></div></td></tr></table></figure>
<h3 id="洛谷-P1123-取数游戏"><a href="#洛谷-P1123-取数游戏" class="headerlink" title="洛谷 P1123 取数游戏"></a><a href="https://www.luogu.com.cn/problem/P1123">洛谷 P1123 取数游戏</a></h3><p>题意：跟上一题一样，只不过相邻的定义中改为 周围八个数</p>
<p>题解：同上，只不过枚举上一层时更新答案的条件需要改改了</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll dp[<span class="hljs-number">7</span>][<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">7</span>];<br>ll a[<span class="hljs-number">7</span>][<span class="hljs-number">7</span>];<br>ll cnm[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">7</span>];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">ok</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>	<span class="hljs-keyword">return</span> (!(x&amp;(x&lt;&lt;<span class="hljs-number">1</span>))&amp;&amp;(!(x&amp;(x&gt;&gt;<span class="hljs-number">1</span>))));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> row,<span class="hljs-type">int</span> sta)</span></span>&#123;<br>	ll sum=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>		<span class="hljs-keyword">if</span>(sta&amp;(<span class="hljs-number">1</span>&lt;&lt;i<span class="hljs-number">-1</span>)) sum+=a[row][m-i+<span class="hljs-number">1</span>];<br>	&#125;<br>	<span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> t;cin&gt;&gt;t;<br>	<span class="hljs-keyword">while</span>(t--)&#123;<br>		cin&gt;&gt;n&gt;&gt;m;<br>		<span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dp));<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>				<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i][j]);<br>			&#125;<br>		&#125;<br>		<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1</span>&lt;&lt;m;i++)&#123;<br>			<span class="hljs-keyword">if</span>(<span class="hljs-built_in">ok</span>(i)) cnm[cnt++]=i;<br>		&#125;<br>		<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cnt;j++)&#123;<br>				ll sum=<span class="hljs-built_in">getsum</span>(i,cnm[j]);<br>				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;cnt;k++)&#123;<br><span class="hljs-comment">// 如果当前行状态和上一行状态不移/左移/右移相与为0则合理</span><br>					<span class="hljs-keyword">if</span>((cnm[k]&amp;cnm[j])==<span class="hljs-number">0</span>&amp;&amp;((cnm[k]&lt;&lt;<span class="hljs-number">1</span>)&amp;cnm[j])==<span class="hljs-number">0</span>&amp;&amp;((cnm[k]&gt;&gt;<span class="hljs-number">1</span>)&amp;cnm[j])==<span class="hljs-number">0</span>)&#123;<br>						dp[i][j]=<span class="hljs-built_in">max</span>(dp[i][j],dp[i<span class="hljs-number">-1</span>][k]+sum);<br>					&#125;<br>				&#125;<br>			&#125;<br>		&#125;<br>		ll ans=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;i++)&#123;<br>			ans=<span class="hljs-built_in">max</span>(ans,dp[n][i]);<br>		&#125;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-comment">//https://www.luogu.com.cn/problem/P1123</span><br></code></pre></div></td></tr></table></figure>
<h3 id="洛谷-P1171-售货员的难题（旅行商问题）"><a href="#洛谷-P1171-售货员的难题（旅行商问题）" class="headerlink" title="洛谷 P1171 售货员的难题（旅行商问题）"></a><a href="https://www.luogu.com.cn/problem/P1171">洛谷 P1171 售货员的难题（旅行商问题）</a></h3><p>题意：TSP问题，即求出从起点出发访问图中所有点再回到起点的最短路</p>
<p>题解：超级经典的NP完全问题，数据量大的话只能用一些选学算法来搞，不过如果数据量小的话，就可以用强大的状压dp啦</p>
<p>定义状态<code>dp[i][j]</code>：访问情况为<code>i</code>状态时当前在<code>j</code>这个节点的最短路，其中状态用二进制整数表示，1表示该节点走过，0表示未走过，那么显然有状态转移方程（其中dis为图的邻接矩阵，值为两点间距离）</p>
<script type="math/tex; mode=display">
dp[i|(1<<(j-1))][j]=min(dp[i|(1<<(j-1))][j],dp[i][k]+dis[k][j])</script><p>那么最终答案就是</p>
<script type="math/tex; mode=display">
dp[(1<<n)-1][i]+dis[i][1]中的最小值</script><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">1e9</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>;<br><span class="hljs-type">int</span> n,dp[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>][<span class="hljs-number">25</span>];<br><span class="hljs-type">int</span> a[<span class="hljs-number">25</span>][<span class="hljs-number">25</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]);<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">67</span>,<span class="hljs-built_in">sizeof</span>(dp));<span class="hljs-comment">//求最小值，dp初始化为最大</span><br>	dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-comment">//初始状态</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1</span>&lt;&lt;n;i++)&#123;<span class="hljs-comment">//枚举当前状态</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<span class="hljs-comment">//枚举每个节点</span><br>			<span class="hljs-keyword">if</span>(!((<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))&amp;i))&#123;<span class="hljs-comment">//如果这个节点没走过</span><br>				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;<span class="hljs-comment">//枚举每个节点</span><br>					<span class="hljs-keyword">if</span>((<span class="hljs-number">1</span>&lt;&lt;(k<span class="hljs-number">-1</span>))&amp;i)<span class="hljs-comment">//如果走过，则个可用它更新j</span><br>						dp[i|(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))][j]=<span class="hljs-built_in">min</span>(dp[i|(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))][j],dp[i][k]+a[k][j]); <span class="hljs-comment">//愉快地更新j</span><br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-type">int</span> ans=inf;<br>    <span class="hljs-comment">//取所有合法状态的最短路</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++) ans=<span class="hljs-built_in">min</span>(ans,dp[(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>][i]+a[i][<span class="hljs-number">1</span>]);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;  <span class="hljs-comment">//https://www.luogu.com.cn/problem/P1171</span><br></code></pre></div></td></tr></table></figure>
<h3 id="洛谷-P2622-关灯问题Ⅱ"><a href="#洛谷-P2622-关灯问题Ⅱ" class="headerlink" title="洛谷 P2622 关灯问题Ⅱ"></a><a href="https://www.luogu.com.cn/problem/P2622">洛谷 P2622 关灯问题Ⅱ</a></h3><p>题意：见链接（已经够简洁了）</p>
<p>题解：状压dp，按照 灯的状态 、按下每个按钮、按下按钮后每个灯的变化情况枚举，就一定能枚举到所有情况，用按下按钮后的状态来更新按下之前的状态即可</p>
<p>定义<code>dp[i]</code>：灯在<code>i</code>状态下最少需要按下的按钮次数，则转移方程为</p>
<script type="math/tex; mode=display">
dp[i]=min(dp[i],dp[j]+1)</script><p>最后处理一下不存在的情况即可</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>];<br><span class="hljs-type">int</span> a[<span class="hljs-number">105</span>][<span class="hljs-number">15</span>];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]);<br>	<span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dp));<span class="hljs-comment">//初始化</span><br>	dp[(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>]=<span class="hljs-number">0</span>;<span class="hljs-comment">//一开始全开着灯，不需要按</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<span class="hljs-comment">//注意枚举顺序</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<span class="hljs-comment">//枚举按钮</span><br>			<span class="hljs-type">int</span> now=i; <span class="hljs-comment">//这个now稍后会变成按之后的状态，便于转移</span><br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;<span class="hljs-comment">//枚举处理每个灯的变化</span><br>				<span class="hljs-keyword">if</span>(a[j][k]==<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//不变</span><br>				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[j][k]==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//如果开着，把它关了</span><br>					<span class="hljs-keyword">if</span>(i&amp;(<span class="hljs-number">1</span>&lt;&lt;n-k)) now=now^(<span class="hljs-number">1</span>&lt;&lt;n-k);<span class="hljs-comment">//该位取反操作</span><br>				&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[j][k]==<span class="hljs-number">-1</span>)&#123;<span class="hljs-comment">//如果关着，把它开开</span><br>					<span class="hljs-keyword">if</span>(!(i&amp;(<span class="hljs-number">1</span>&lt;&lt;n-k))) now=now^(<span class="hljs-number">1</span>&lt;&lt;n-k);<span class="hljs-comment">//同上</span><br>				&#125;<br>			&#125;<br>			dp[now]=<span class="hljs-built_in">min</span>(dp[now],dp[i]+<span class="hljs-number">1</span>);<span class="hljs-comment">//转移</span><br>		&#125;<br>	<span class="hljs-comment">//如果不存在（这个奇怪的数就是memset 0x3f之后的数），输出-1</span><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,dp[<span class="hljs-number">0</span>]==<span class="hljs-number">1061109567</span>?<span class="hljs-number">-1</span>:dp[<span class="hljs-number">0</span>]);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="洛谷-P2704-炮兵阵地"><a href="#洛谷-P2704-炮兵阵地" class="headerlink" title="洛谷 P2704 炮兵阵地"></a><a href="https://www.luogu.com.cn/problem/P2704">洛谷 P2704 炮兵阵地</a></h3><p>题意：给一个n*m的矩阵，有些地方可以建炮塔，炮塔可以打上下左右两个格子的地方，求不误伤友军的前提下最多可以建多少炮塔</p>
<p>题解：稍微有点恶心的状压dp，恶心就恶心在每一行的状态是由前两行决定的，因此我们的dp方程需要多开一维</p>
<p>定义<code>dp[i][j][k]</code>：处理到第<code>i</code>行时第<code>i</code>行为<code>j</code>状态且第<code>i-1</code>行为<code>k</code>状态的最多炮塔总数，那么显然状态转移方程如下</p>
<script type="math/tex; mode=display">
dp[i][j][k]=max(dp[i][j][k],dp[i-1][k][l]+sum[j])</script><p>注意初始化时需要初始化第一行和第二行的所有状态，然后从第三行开始递推，虽然维数较多，预处理肯定是需要的，但亲测不用滚动数组也可AC</p>
<p>下面上代码（这个<code>for</code>循环给爷写吐了）</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m,a[<span class="hljs-number">105</span>];<br><span class="hljs-type">char</span> mm[<span class="hljs-number">105</span>][<span class="hljs-number">35</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">105</span>][<span class="hljs-number">70</span>][<span class="hljs-number">70</span>];<br><span class="hljs-type">int</span> sta[<span class="hljs-number">70</span>],cnt;<br><span class="hljs-type">int</span> num[<span class="hljs-number">300</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">ok</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">//常规操作</span><br>	<span class="hljs-keyword">if</span>(!((x&amp;x&lt;&lt;<span class="hljs-number">1</span>)||(x&amp;x&gt;&gt;<span class="hljs-number">1</span>)||(x&amp;x&lt;&lt;<span class="hljs-number">2</span>)||(x&amp;x&gt;&gt;<span class="hljs-number">2</span>))) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getnum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123; <span class="hljs-comment">//常规操作</span><br>	<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(x)&#123;<br>		ans++;<br>		x-=(x&amp;(-x));<br>	&#125;<br>	<span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>			cin&gt;&gt;mm[i][j];<br>			<span class="hljs-keyword">if</span>(mm[i][j]==<span class="hljs-string">&#x27;H&#x27;</span>) a[i]|=<span class="hljs-number">1</span>&lt;&lt;m-j; <span class="hljs-comment">//输入转状态</span><br>		&#125;<br><span class="hljs-comment">//		cout&lt;&lt;a[i]&lt;&lt;endl;</span><br>	&#125;<br>	<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1</span>&lt;&lt;m;i++)&#123;<span class="hljs-comment">//预处理状态</span><br>		<span class="hljs-keyword">if</span>(<span class="hljs-built_in">ok</span>(i))&#123;<br><span class="hljs-comment">//			cout&lt;&lt;i&lt;&lt;endl;</span><br>			sta[++cnt]=i;<br>			num[cnt]=<span class="hljs-built_in">getnum</span>(i);<span class="hljs-comment">//预处理该状态的和</span><br>		&#125;<br>	&#125;<br><span class="hljs-comment">//	cout&lt;&lt;cnt&lt;&lt;endl;</span><br>	<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;i++)&#123;<span class="hljs-comment">//初始化第一行</span><br>		<span class="hljs-keyword">if</span>((sta[i]&amp;a[<span class="hljs-number">1</span>])==<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//不与地图冲突就可</span><br>			dp[<span class="hljs-number">1</span>][i][<span class="hljs-number">0</span>]=num[i];<br><span class="hljs-comment">//			cout&lt;&lt;dp[1][i][0]&lt;&lt;endl;</span><br>		&#125;<br>	&#125;<br><span class="hljs-comment">//	exit(0);</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;i++)&#123;<span class="hljs-comment">//初始化第二行</span><br>		<span class="hljs-keyword">if</span>((sta[i]&amp;a[<span class="hljs-number">2</span>])==<span class="hljs-number">0</span>)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt;j++)&#123;<br>				<span class="hljs-keyword">if</span>((sta[j]&amp;a[<span class="hljs-number">1</span>])==<span class="hljs-number">0</span>&amp;&amp;(sta[j]&amp;sta[i])==<span class="hljs-number">0</span>)&#123;<br>					dp[<span class="hljs-number">2</span>][i][j]=num[i]+num[j];<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br><span class="hljs-comment">//	exit(0);</span><br>    <span class="hljs-comment">//这个for循环惊了</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//从第三行开始</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt;j++)&#123;<br>			<span class="hljs-keyword">if</span>((sta[j]&amp;a[i])==<span class="hljs-number">0</span>)&#123;<br>				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=cnt;k++)&#123;<br>					<span class="hljs-keyword">if</span>((sta[j]&amp;sta[k])==<span class="hljs-number">0</span>&amp;&amp;(sta[k]&amp;a[i<span class="hljs-number">-1</span>])==<span class="hljs-number">0</span>)&#123;<br>						<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>;l&lt;=cnt;l++)&#123;<br>                            <span class="hljs-comment">//这个条件判断真长</span><br>							<span class="hljs-keyword">if</span>((sta[l]&amp;sta[j])==<span class="hljs-number">0</span>&amp;&amp;(sta[l]&amp;sta[k])==<span class="hljs-number">0</span>&amp;&amp;(sta[l]&amp;a[i<span class="hljs-number">-2</span>])==<span class="hljs-number">0</span>)&#123;<br>								dp[i][j][k]=<span class="hljs-built_in">max</span>(dp[i][j][k],dp[i<span class="hljs-number">-1</span>][k][l]+num[j]);<br>							&#125;<br>						&#125;<br>					&#125; <br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br><span class="hljs-comment">//	exit(0);</span><br>	<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;i++)&#123;<span class="hljs-comment">//获取最大数目</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt;j++)&#123;<br>			ans=<span class="hljs-built_in">max</span>(ans,dp[n][i][j]);<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-comment">//https://www.luogu.com.cn/problem/P2704</span><br></code></pre></div></td></tr></table></figure>
<hr>
<p>感想：感觉没区间dp那么玄学（前提是二进制操作非常熟练），但是题目感觉可以难上天</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵加速</title>
    <url>/2020/02/27/%E7%9F%A9%E9%98%B5%E5%8A%A0%E9%80%9F/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<h2 id="矩阵加速"><a href="#矩阵加速" class="headerlink" title="矩阵加速"></a>矩阵加速</h2><p><a href="https://www.luogu.com.cn/problem/P1939">【模板】矩阵加速（数列）</a></p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>有这样一种问题，要你求<strong>斐波那契数列</strong>的第$n$项，但是这个$n$可以大到$int64$的大小（$2^{61}-1$），还会有若干次询问，这么多次询问还要你1s内出所有答案，传统的<code>for</code>循环肯定GG，于是这时候就需要<strong>矩阵加速</strong>啦（利用<strong>矩阵运算+矩阵快速幂</strong>来加速递推求解过程）</p>
<ul>
<li>那么这里就需要特别注意一点，那就是矩阵的左乘和右乘，这一点在快速幂函数中<strong>必须必须要注意</strong>，如果写反了就错了（按照个人习惯来，我比较习惯构造一个矩阵，然后让初始向量左乘它）</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>对于模板题，我们可以很容易得到这样一个矩阵，它满足</p>
<script type="math/tex; mode=display">
\begin{pmatrix}a_i&a_{i+1}&a_{i+2}\end{pmatrix}\begin{pmatrix} 0 & 0 & 1 \\ 1 & 0 & 0 \\ 0 & 1 & 1 \end{pmatrix}=\begin{pmatrix}a_{i+1}&a_{i+2}&a_{i+3}\end{pmatrix}</script><p>于是，我们观察左侧向量的第一个数，初始为$a_1$，左乘一次矩阵得到$a_2$，所以左乘$n-1$次矩阵可以得到$a_n$，应用<strong>矩阵快速幂</strong>，打出如下代码</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">M</span>&#123;<br>	ll mat[<span class="hljs-number">15</span>][<span class="hljs-number">15</span>];<br>&#125;a;<br>M <span class="hljs-keyword">operator</span>*(M x1,M x2)&#123;<br>	M res;<br>	<span class="hljs-built_in">memset</span>(res.mat,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(res));<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">3</span>;j++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">3</span>;k++)&#123;<br>				res.mat[i][j]+=(x1.mat[i][k]%mod*x2.mat[k][j]%mod)%mod;<br>				res.mat[i][j]%=mod;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> M <span class="hljs-title">qpow</span><span class="hljs-params">(M a,ll y,M ans)</span></span>&#123;<br>	M base=a;<br>	<span class="hljs-keyword">while</span>(y&gt;<span class="hljs-number">0</span>)&#123;<br>		<span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) ans=ans*base;<br>		y&gt;&gt;=<span class="hljs-number">1</span>;<br>		base=base*base;<br>	&#125;<br>	<span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> t;<br>	cin&gt;&gt;t;<br>	<span class="hljs-keyword">while</span>(t--)&#123;<br>		ll nn;<br>		cin&gt;&gt;nn;<br>		<span class="hljs-built_in">memset</span>(a.mat,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a));<br>		M b;<br>		<span class="hljs-built_in">memset</span>(b.mat,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(b));<br>		b.mat[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=b.mat[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]=b.mat[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>]=<span class="hljs-number">1</span>;<br>		a.mat[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=a.mat[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]=a.mat[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]=a.mat[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]=a.mat[<span class="hljs-number">3</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>		a.mat[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>]=a.mat[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]=a.mat[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>]=a.mat[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>]=<span class="hljs-number">1</span>;<br>		M ans=<span class="hljs-built_in">qpow</span>(a,nn<span class="hljs-number">-1</span>,b);<br>		cout&lt;&lt;ans.mat[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="洛谷-P1962-斐波那契数列"><a href="#洛谷-P1962-斐波那契数列" class="headerlink" title="洛谷 P1962 斐波那契数列"></a><a href="https://www.luogu.com.cn/problem/P1962">洛谷 P1962 斐波那契数列</a></h3><p>观察得矩阵</p>
<script type="math/tex; mode=display">
\begin{pmatrix}a_i&a_{i+1}\end{pmatrix}\begin{pmatrix} 0 & 1 \\ 1 & 1  \end{pmatrix}=\begin{pmatrix}a_{i+1}&a_{i+2}\end{pmatrix}</script><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">M</span>&#123;<br>	ll mat[<span class="hljs-number">15</span>][<span class="hljs-number">15</span>];<br>&#125;a;<br>M <span class="hljs-keyword">operator</span>*(M x1,M x2)&#123;<br>	M res;<br>	<span class="hljs-built_in">memset</span>(res.mat,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(res));<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">2</span>;j++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">2</span>;k++)&#123;<br>				res.mat[i][j]+=(x1.mat[i][k]%mod*x2.mat[k][j]%mod)%mod;<br>				res.mat[i][j]%=mod;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> M <span class="hljs-title">qpow</span><span class="hljs-params">(M a,ll y,M ans)</span></span>&#123;<br>	M base=a;<br>	<span class="hljs-keyword">while</span>(y&gt;<span class="hljs-number">0</span>)&#123;<br>		<span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) ans=ans*base;<br>		y&gt;&gt;=<span class="hljs-number">1</span>;<br>		base=base*base;<br>	&#125;<br>	<span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	ll nn;<br>	cin&gt;&gt;nn;<br>	<span class="hljs-built_in">memset</span>(a.mat,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a));<br>	M b;<br>	<span class="hljs-built_in">memset</span>(b.mat,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(b));<br>	b.mat[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=b.mat[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;<br>	a.mat[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>	a.mat[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]=a.mat[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]=a.mat[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;<br>	M ans=<span class="hljs-built_in">qpow</span>(a,nn<span class="hljs-number">-1</span>,b);<br>	cout&lt;&lt;ans.mat[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]&lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="洛谷-P1349-广义斐波那契数列"><a href="#洛谷-P1349-广义斐波那契数列" class="headerlink" title="洛谷 P1349 广义斐波那契数列"></a><a href="https://www.luogu.com.cn/problem/P1349">洛谷 P1349 广义斐波那契数列</a></h3><p>就是把系数改成了$p$和$q$而已，太简单了，矩阵转移如下</p>
<script type="math/tex; mode=display">
\begin{pmatrix}a_i&a_{i+1}\end{pmatrix}\begin{pmatrix} 0 & q \\ 1 & p  \end{pmatrix}=\begin{pmatrix}a_{i+1}&a_{i+2}\end{pmatrix}</script><h4 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll p,q,a1,a2,n,mod;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">M</span>&#123;<br>	ll mat[<span class="hljs-number">15</span>][<span class="hljs-number">15</span>];<br>&#125;a;<br>M <span class="hljs-keyword">operator</span>*(M x1,M x2)&#123;<br>	M res;<br>	<span class="hljs-built_in">memset</span>(res.mat,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(res));<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">2</span>;j++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">2</span>;k++)&#123;<br>				res.mat[i][j]+=(x1.mat[i][k]%mod*x2.mat[k][j]%mod)%mod;<br>				res.mat[i][j]%=mod;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> M <span class="hljs-title">qpow</span><span class="hljs-params">(M a,ll y,M ans)</span></span>&#123;<br>	M base=a;<br>	<span class="hljs-keyword">while</span>(y&gt;<span class="hljs-number">0</span>)&#123;<br>		<span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) ans=ans*base;<br>		y&gt;&gt;=<span class="hljs-number">1</span>;<br>		base=base*base;<br>	&#125;<br>	<span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;p&gt;&gt;q&gt;&gt;a1&gt;&gt;a2&gt;&gt;n&gt;&gt;mod;<br>	<span class="hljs-built_in">memset</span>(a.mat,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a));<br>	M b;<br>	<span class="hljs-built_in">memset</span>(b.mat,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(b));<br>	b.mat[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=a1;<br>	b.mat[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]=a2;<br>	a.mat[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>	a.mat[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]=q;<br>	a.mat[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>	a.mat[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]=p;<br>	M ans=<span class="hljs-built_in">qpow</span>(a,n<span class="hljs-number">-1</span>,b);<br>	cout&lt;&lt;ans.mat[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]&lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>矩阵运算</tag>
      </tags>
  </entry>
  <entry>
    <title>珂朵莉树ODT 浅析</title>
    <url>/2020/05/01/%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91ODT-%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h2 id="Chtholly-Tree"><a href="#Chtholly-Tree" class="headerlink" title="Chtholly Tree"></a><center>Chtholly Tree</center></h2><span id="more"></span>
<p>参考blog：</p>
<ul>
<li><a href="https://www.cnblogs.com/yzhang-rp-inf/p/9443659.html">珂朵莉树详解</a></li>
</ul>
<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p><strong>珂朵莉树</strong>（又称Old Driver Tree，简称ODT<del>或老司机树</del>），源自于CF的一道比赛原题：<a href="https://www.luogu.com.cn/problem/CF896C">CF896C Willem, Chtholly and Seniorious</a>（因为题目背景是关于珂朵莉的），题意大概就是要求你维护一个神奇数据结构，维护一个具有$n$项的序列，具有如下操作$m$次：</p>
<ol>
<li>将$[l,r]$区间所有数加上$x$</li>
<li>将$[l,r]$区间所有数改成$x$</li>
<li>输出$[l,r]$区间的第$k$小值</li>
<li>输出$[l,r]$区间的所有数的$x$次幂之和$(\sum_{i=1}^ra_i^x)\ mod \ y$</li>
</ol>
<p>数据范围：$1\le n,m \le 10^5$，且保证所有<strong>数据随机</strong>（即保证1234操作出现的概率相同）</p>
<p>我们可以发现，前两项操作可能用普通线段树就能维护，第三项操作可以用主席树维护，而唯独第四个操作无法在可接受的时间复杂度范围内维护，但是题目说<strong>数据随机</strong>，因而此刻 <strong>珂朵莉树</strong> 就华丽登场了~ <del>（面向题目编程）</del></p>
<p>PS：然而现在的出题人随随便便就能卡掉ODT</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><strong>珂朵莉树</strong>本质上是一种基于$STL$的$std::set$的一种暴力数据机构，适用场合一般具有如下特点：</p>
<ul>
<li>保证数据随机</li>
<li>需要将一个区间的所有值改为同一个值（推平操作）</li>
<li>含有区间幂次等线段树、BIT无法胜任的操作时</li>
</ul>
<p>珂朵莉树的每个节点存储的是<strong>一段值相同的区间</strong>，比如说序列：[1,2,2,2,3,4,4]，在珂朵莉树内的存储方式就是：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">L</th>
<th style="text-align:center">R</th>
<th style="text-align:center">V</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
<td style="text-align:center">4</td>
</tr>
</tbody>
</table>
</div>
<p>需要注意的是，<strong>只有在数据随机的情况下</strong>，珂朵莉树中$set$所维护的区间大小才近似于$logn$，整体时间复杂度大致为$O(mlogn)$，然而如果数据不随机，那么这个复杂度就是假的，很可能会退化成暴力($O(m*n)$)的复杂度QWQ</p>
<h3 id="ODT初始化"><a href="#ODT初始化" class="headerlink" title="ODT初始化"></a>ODT初始化</h3><p>代码实现如下（珂朵莉树初始化）：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">odtnode</span>&#123;<span class="hljs-comment">//ODT树节点</span><br>    <span class="hljs-type">int</span> l,r;<span class="hljs-comment">//左右端点</span><br>    <span class="hljs-keyword">mutable</span> ll v;<span class="hljs-comment">//区间值</span><br>    <span class="hljs-built_in">odtnode</span>(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R=<span class="hljs-number">-1</span>,ll V=<span class="hljs-number">0</span>): <span class="hljs-built_in">l</span>(L),<span class="hljs-built_in">r</span>(R),<span class="hljs-built_in">v</span>(V)&#123;&#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> odtnode &amp;rhs)<span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">return</span> l&lt;rhs.l;<span class="hljs-comment">//以左端点升序排序</span><br>    &#125;<br>&#125;;<br>set&lt;odtnode&gt; odt;<span class="hljs-comment">//set维护的一棵珂朵莉树</span><br></code></pre></div></td></tr></table></figure>
<p>接下来就是四个操作的实现了，在这之前，需要介绍一下ODT操作的核心：</p>
<h3 id="Split-操作"><a href="#Split-操作" class="headerlink" title="$Split$操作"></a><strong>$Split$操作</strong></h3><p>对于一整个区间，每次操作很可能是只需要修改区间的一部分，而另一部分不需要修改，这时，我们可以通过分割操作将区间分割开来，从而只修改需要修改的部分</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">set&lt;odtnode&gt;::<span class="hljs-function">iterator <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span></span>&#123;<br>    <span class="hljs-comment">//在pos位置一刀切开，返回右边那个块的迭代器</span><br>   	<span class="hljs-keyword">auto</span> it=odt.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-built_in">odtnode</span>(pos));<br>    <span class="hljs-comment">//首先找到第一个不小于pos位置的块</span><br>    <span class="hljs-comment">//如果该块的左端点恰好为pos位置，那太好了，直接返回</span><br>    <span class="hljs-keyword">if</span>(it!=odt.<span class="hljs-built_in">end</span>()&amp;&amp;it-&gt;l==pos)<br>        <span class="hljs-keyword">return</span> it;<br>    it--;<span class="hljs-comment">//否则pos肯定应该位于前一个块中</span><br>    <span class="hljs-type">int</span> l=it-&gt;l,r=it-&gt;r;<span class="hljs-comment">//记录这个块的信息</span><br>    ll v=it-&gt;v;<br>    odt.<span class="hljs-built_in">erase</span>(it);<span class="hljs-comment">//把这块删掉</span><br>    odt.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">odtnode</span>(l,pos<span class="hljs-number">-1</span>,v));<span class="hljs-comment">//沿pos切开后再添加回去</span><br>    <span class="hljs-keyword">return</span> odt.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">odtnode</span>(pos,r,v)).first;<br>    <span class="hljs-comment">//最后返回含有pos的右边块的迭代器</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>有了Split操作后，一切都变得好办了</p>
<h3 id="区间推平操作"><a href="#区间推平操作" class="headerlink" title="区间推平操作"></a><strong>区间推平操作</strong></h3><p>先将ODT沿区间$[l,r]$切开，然后直接删除中间部分的集合（用$std::set$的$erase$方法，很冷门的方法），再直接插入一整块的相同值的区间集合</p>
<p>这里有个十分难以发现的关键点：一定要先切右端点，再切左端点，否则很可能会玄学RE（在这上面死了好几次）</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,ll k)</span></span>&#123;<br>    <span class="hljs-keyword">auto</span> itr=<span class="hljs-built_in">split</span>(r+<span class="hljs-number">1</span>),itl=<span class="hljs-built_in">split</span>(l);<br>    odt.<span class="hljs-built_in">erase</span>(itl,itr);<br>    <span class="hljs-comment">//删除区间[itl,itr]中的所有左端点处在这段区间的set元素</span><br>    odt.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">odtnode</span>(l,r,k));<span class="hljs-comment">//直接插入一整块</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="区间加操作"><a href="#区间加操作" class="headerlink" title="区间加操作"></a><strong>区间加操作</strong></h3><p>暴力实现，先沿区间端点切开，然后直接遍历区间内的所有set元素（珂朵莉树节点），将其加上某值（即一整个区间加上某值）</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,ll k)</span></span>&#123;<br>    <span class="hljs-keyword">auto</span> itr=<span class="hljs-built_in">split</span>(r+<span class="hljs-number">1</span>),itl=<span class="hljs-built_in">split</span>(l);<br>    <span class="hljs-keyword">for</span>(;itl!=itr;itl++) itl-&gt;v+=k;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="询问区间第-k-小"><a href="#询问区间第-k-小" class="headerlink" title="询问区间第$k$小"></a><strong>询问区间第$k$小</strong></h3><p>暴力实现，先沿区间端点切开，然后直接遍历区间内所有珂朵莉树节点，将其存进一个$vector<pair<ll,int>&gt;$中（其中pair第一个值为权值，第二个值为区间大小，即出现次数），然后对$vector$排序并暴力求$k_{th}$</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">kth</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">auto</span> itr=<span class="hljs-built_in">split</span>(r+<span class="hljs-number">1</span>),itl=<span class="hljs-built_in">split</span>(l);<br>    vector&lt;pair&lt;ll,<span class="hljs-type">int</span>&gt;&gt; vec;<br>    <span class="hljs-keyword">for</span>(;itl!=itr;itl++)&#123;<br>        vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pair</span>&lt;ll,<span class="hljs-type">int</span>&gt;(itl-&gt;v,itl-&gt;r-itl-&gt;l+<span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(),vec.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//按照权值从小到大排序</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=vec.<span class="hljs-built_in">begin</span>();it!=vec.<span class="hljs-built_in">end</span>();it++)&#123;<br>        k-=it-&gt;second;<br>        <span class="hljs-keyword">if</span>(k&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> it-&gt;first;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1ll</span>;<span class="hljs-comment">//如果没有就返回-1</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="求区间-l-r-的-sum-i-l-ra-i-x-mod-y"><a href="#求区间-l-r-的-sum-i-l-ra-i-x-mod-y" class="headerlink" title="求区间$[l,r]$的$(\sum_{i=l}^ra_i^x)\ mod\ y$"></a>求区间$[l,r]$的$(\sum_{i=l}^ra_i^x)\ mod\ y$</h3><p>还是暴力实现（结合快速幂），类似于询问询问第$k$小，先切开后，遍历每一个节点，更新答案（加上 <strong>区间大小*该区间值的x次幂</strong>），累加最后返回即可</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">getxpow</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">auto</span> itr=<span class="hljs-built_in">split</span>(r+<span class="hljs-number">1</span>),itl=<span class="hljs-built_in">split</span>(l);<br>    ll res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(;itl!=itr;itl++)&#123;<br>        res=((res+(itl-&gt;r-itl-&gt;l+<span class="hljs-number">1</span>)*<span class="hljs-built_in">qpow</span>(it-&gt;v,x,y))%y+y)%y;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>至此，珂朵莉树模板题的完整操作就介绍完毕了，下面奉上完整代码</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//略去头文件</span><br><span class="hljs-comment">//CF896C ODT</span><br>ll n,m,vmax,seed;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">rnd</span><span class="hljs-params">()</span></span>&#123;<br>	ll ret=seed;<br>	seed=(seed*<span class="hljs-number">7</span>+<span class="hljs-number">13</span>)%mod;<br>	<span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">odtnode</span> <span class="hljs-comment">// ODT Tree</span><br>&#123;<br>	ll l,r;<br>	<span class="hljs-keyword">mutable</span> ll v;<br>	<span class="hljs-built_in">odtnode</span>(ll L,ll R=<span class="hljs-number">-1</span>,ll V=<span class="hljs-number">0</span>):<span class="hljs-built_in">l</span>(L),<span class="hljs-built_in">r</span>(R),<span class="hljs-built_in">v</span>(V)&#123;&#125;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> odtnode &amp;rhs)<span class="hljs-type">const</span>&#123;<br>		<span class="hljs-keyword">return</span> l&lt;rhs.l;<br>	&#125;<br>&#125;;<br><br>set&lt;odtnode&gt; odt;<br><br>set&lt;odtnode&gt;::<span class="hljs-function">iterator <span class="hljs-title">split</span><span class="hljs-params">(ll pos)</span></span>&#123;<br>	<span class="hljs-keyword">auto</span> it=odt.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-built_in">odtnode</span>(pos));<br>	<span class="hljs-keyword">if</span>(it!=odt.<span class="hljs-built_in">end</span>()&amp;&amp;it-&gt;l==pos) <span class="hljs-keyword">return</span> it;<br>	it--;<br>	ll l=it-&gt;l,r=it-&gt;r,v=it-&gt;v;<br>	odt.<span class="hljs-built_in">erase</span>(it);<br>	odt.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">odtnode</span>(l,pos<span class="hljs-number">-1</span>,v));<br>	<span class="hljs-keyword">return</span> odt.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">odtnode</span>(pos,r,v)).first;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(ll l,ll r,ll k)</span></span>&#123;<br>	<span class="hljs-keyword">auto</span> itr=<span class="hljs-built_in">split</span>(r+<span class="hljs-number">1</span>),itl=<span class="hljs-built_in">split</span>(l);<br>	<span class="hljs-keyword">for</span>(;itl!=itr;itl++) itl-&gt;v+=k;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(ll l,ll r,ll k)</span></span>&#123;<br>	<span class="hljs-keyword">auto</span> itr=<span class="hljs-built_in">split</span>(r+<span class="hljs-number">1</span>),itl=<span class="hljs-built_in">split</span>(l);<br>	odt.<span class="hljs-built_in">erase</span>(itl,itr);<br>	odt.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">odtnode</span>(l,r,k));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">kth</span><span class="hljs-params">(ll l,ll r,ll k)</span></span>&#123;<br>	<span class="hljs-keyword">auto</span> itr=<span class="hljs-built_in">split</span>(r+<span class="hljs-number">1</span>),itl=<span class="hljs-built_in">split</span>(l);<br>	vector&lt;pair&lt;ll,ll&gt;&gt; vec;<br>	vec.<span class="hljs-built_in">clear</span>();<br>	<span class="hljs-keyword">for</span>(;itl!=itr;itl++)<br>		vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pair</span>&lt;ll,ll&gt;(itl-&gt;v,itl-&gt;r-itl-&gt;l+<span class="hljs-number">1</span>));<br>	<span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(),vec.<span class="hljs-built_in">end</span>());<br>	<span class="hljs-keyword">for</span>(vector&lt;pair&lt;ll,ll&gt;&gt;::iterator it=vec.<span class="hljs-built_in">begin</span>();it!=vec.<span class="hljs-built_in">end</span>();it++)&#123;<br>		k-=it-&gt;second;<br>		<span class="hljs-keyword">if</span>(k&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> it-&gt;first;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">-1ll</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">psum</span><span class="hljs-params">(ll l,ll r,ll x,ll y)</span></span>&#123;<br>	<span class="hljs-keyword">auto</span> itr=<span class="hljs-built_in">split</span>(r+<span class="hljs-number">1</span>),itl=<span class="hljs-built_in">split</span>(l);<br>	ll res=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(;itl!=itr;itl++)&#123;<br>		res=(res+(itl-&gt;r-itl-&gt;l+<span class="hljs-number">1</span>)*<span class="hljs-built_in">qpow</span>(itl-&gt;v,x,y)%y+y)%y;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res%y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld%lld&quot;</span>,&amp;n,&amp;m,&amp;seed,&amp;vmax);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) odt.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">odtnode</span>(i,i,<span class="hljs-built_in">rnd</span>()%vmax+<span class="hljs-number">1</span>));<br>	<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m)&#123;<br>		ll x,y;<br>		ll op=(<span class="hljs-built_in">rnd</span>()%<span class="hljs-number">4</span>)+<span class="hljs-number">1</span>;<br>		ll l=(<span class="hljs-built_in">rnd</span>()%n)+<span class="hljs-number">1</span>;<br>		ll r=(<span class="hljs-built_in">rnd</span>()%n)+<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-built_in">swap</span>(l,r);<br>		<span class="hljs-keyword">if</span>(op==<span class="hljs-number">3</span>) x=(<span class="hljs-built_in">rnd</span>()%(r-l+<span class="hljs-number">1</span>))+<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">else</span> x=(<span class="hljs-built_in">rnd</span>()%vmax)+<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">if</span>(op==<span class="hljs-number">4</span>) y=(<span class="hljs-built_in">rnd</span>()%vmax)+<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>) <span class="hljs-built_in">add</span>(l,r,x);<br>		<span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>) <span class="hljs-built_in">modify</span>(l,r,x);<br>		<span class="hljs-keyword">if</span>(op==<span class="hljs-number">3</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">kth</span>(l,r,x));<br>		<span class="hljs-keyword">if</span>(op==<span class="hljs-number">4</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">psum</span>(l,r,x,y));<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><ul>
<li><a href="https://www.luogu.com.cn/problem/CF915E">CF915E Physical Education Lessons</a>（动态开点、ODT）</li>
</ul>
<details>
<summary>动态开点code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n,q,l,r,k;<br><span class="hljs-type">int</span> mtg[maxn*<span class="hljs-number">50</span>],ls[maxn*<span class="hljs-number">50</span>],rs[maxn*<span class="hljs-number">50</span>],sum[maxn*<span class="hljs-number">50</span>],rt,ncnt;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-type">int</span> o)</span></span>&#123;<br>	sum[o]=sum[ls[o]]+sum[rs[o]];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;o,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(mtg[o]==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;<br>	<span class="hljs-keyword">if</span>(!ls[o]) ls[o]=++ncnt;<br>	<span class="hljs-keyword">if</span>(!rs[o]) rs[o]=++ncnt;<br>	<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>	sum[ls[o]]=mtg[o]*(mid-l+<span class="hljs-number">1</span>);<br>	sum[rs[o]]=mtg[o]*(r-mid);<br>	mtg[ls[o]]=mtg[rs[o]]=mtg[o];<br>	mtg[o]=<span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">to_</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;o,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> k)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(!o) o=++ncnt;<br>	<span class="hljs-keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;<br>		sum[o]=k*(r-l+<span class="hljs-number">1</span>);<br>		mtg[o]=k;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-built_in">push_down</span>(o,l,r);<br>	<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span>(mid&gt;=L) <span class="hljs-built_in">to_</span>(ls[o],l,mid,L,R,k);<br>	<span class="hljs-keyword">if</span>(mid+<span class="hljs-number">1</span>&lt;=R) <span class="hljs-built_in">to_</span>(rs[o],mid+<span class="hljs-number">1</span>,r,L,R,k);<br>	<span class="hljs-built_in">push_up</span>(o);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);<br>	<span class="hljs-built_in">memset</span>(mtg,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(mtg));<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,q)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;k);<br>		<span class="hljs-keyword">if</span>(k==<span class="hljs-number">2</span>) <span class="hljs-built_in">to_</span>(rt,<span class="hljs-number">1</span>,n,l,r,<span class="hljs-number">0</span>);<br>		<span class="hljs-keyword">else</span> <span class="hljs-built_in">to_</span>(rt,<span class="hljs-number">1</span>,n,l,r,<span class="hljs-number">1</span>);<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,n-sum[rt]);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<details>
<summary>ODT code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n,q,l,r,k,sum;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">odtnode</span> <span class="hljs-comment">// ODT Tree</span><br>&#123;<br>	ll l,r;<br>	<span class="hljs-keyword">mutable</span> ll v;<br>	<span class="hljs-built_in">odtnode</span>(ll L,ll R=<span class="hljs-number">-1</span>,ll V=<span class="hljs-number">0</span>):<span class="hljs-built_in">l</span>(L),<span class="hljs-built_in">r</span>(R),<span class="hljs-built_in">v</span>(V)&#123;&#125;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> odtnode &amp;rhs)<span class="hljs-type">const</span>&#123;<br>		<span class="hljs-keyword">return</span> l&lt;rhs.l;<br>	&#125;<br>&#125;;<br><br>set&lt;odtnode&gt; odt;<br><br>set&lt;odtnode&gt;::<span class="hljs-function">iterator <span class="hljs-title">split</span><span class="hljs-params">(ll pos)</span></span>&#123;<br>	<span class="hljs-keyword">auto</span> it=odt.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-built_in">odtnode</span>(pos));<br>	<span class="hljs-keyword">if</span>(it!=odt.<span class="hljs-built_in">end</span>()&amp;&amp;it-&gt;l==pos) <span class="hljs-keyword">return</span> it;<br>	it--;<br>	ll l=it-&gt;l,r=it-&gt;r,v=it-&gt;v;<br>	odt.<span class="hljs-built_in">erase</span>(it);<br>	odt.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">odtnode</span>(l,pos<span class="hljs-number">-1</span>,v));<br>	<span class="hljs-keyword">return</span> odt.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">odtnode</span>(pos,r,v)).first;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(ll l,ll r,ll k)</span></span>&#123;<br>	<span class="hljs-keyword">auto</span> itr=<span class="hljs-built_in">split</span>(r+<span class="hljs-number">1</span>),itl=<span class="hljs-built_in">split</span>(l);<br>	<span class="hljs-keyword">auto</span> it=itl;<br>	<span class="hljs-keyword">for</span>(;it!=itr;it++)&#123;<br>		sum-=it-&gt;v*(it-&gt;r-it-&gt;l+<span class="hljs-number">1</span>);<br>	&#125;<br>	odt.<span class="hljs-built_in">erase</span>(itl,itr);<br>	odt.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">odtnode</span>(l,r,k));<br>	sum+=k*(r-l+<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);<br>	odt.<span class="hljs-built_in">insert</span>(odtnode&#123;<span class="hljs-number">1</span>,n,<span class="hljs-number">0</span>&#125;);<br>	sum=<span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,q)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;k);<br>		<span class="hljs-keyword">if</span>(k==<span class="hljs-number">1</span>) <span class="hljs-built_in">modify</span>(l,r,<span class="hljs-number">1</span>);<br>		<span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(l,r,<span class="hljs-number">0</span>);<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,n-sum);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<ul>
<li><a href="https://www.luogu.com.cn/problem/CF343D">CF343D Water Tree</a>（树剖+线段树、树剖+ODT）</li>
</ul>
<p>珂朵莉树最慢的点2s，线段树1s，本题时限4s（ODT水过了2333）</p>
<p><img src="https://i.loli.net/2020/05/02/nDulJixVyFSKXbY.png" alt="image.png"></p>
<details>
<summary>Segment Tree code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n,q;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> u,v,w,next;<br>&#125;e[maxn&lt;&lt;<span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> cnt,head[maxn];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init_graph</span><span class="hljs-params">()</span></span>&#123;<br>	cnt=<span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w=<span class="hljs-number">0</span>)</span></span>&#123;<br>	e[cnt]=Edge&#123;u,v,w,head[u]&#125;;<br>	head[u]=cnt++;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Stree</span><br>&#123;<br>	<span class="hljs-type">int</span> l,r,sum,tg;<br>&#125;tr[maxn&lt;&lt;<span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(tr[i].tg==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;<br>	<span class="hljs-type">int</span> k=tr[i].tg;<br>	tr[ls].sum=(tr[ls].r-tr[ls].l+<span class="hljs-number">1</span>)*k;<br>	tr[rs].sum=(tr[rs].r-tr[rs].l+<span class="hljs-number">1</span>)*k;<br>	tr[ls].tg=tr[rs].tg=k;<br>	tr[i].tg=<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>	tr[i].sum=tr[ls].sum+tr[rs].sum;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(tr[i].l&gt;=l&amp;&amp;tr[i].r&lt;=r)&#123;<br>		tr[i].sum=(tr[i].r-tr[i].l+<span class="hljs-number">1</span>)*k;<br>		tr[i].tg=k;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-built_in">push_down</span>(i);<br>	<span class="hljs-keyword">if</span>(tr[ls].r&gt;=l) <span class="hljs-built_in">add</span>(ls,l,r,k);<br>	<span class="hljs-keyword">if</span>(tr[rs].l&lt;=r) <span class="hljs-built_in">add</span>(rs,l,r,k);<br>	<span class="hljs-built_in">push_up</span>(i);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>	tr[i].l=l,tr[i].r=r,tr[i].tg=<span class="hljs-number">-1</span>;<br>	<span class="hljs-keyword">if</span>(l==r)&#123;<br>		tr[i].sum=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">return</span> ;<br>	&#125;<br>	<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>	<span class="hljs-built_in">build</span>(ls,l,mid);<br>	<span class="hljs-built_in">build</span>(rs,mid+<span class="hljs-number">1</span>,r);<br>	<span class="hljs-built_in">push_up</span>(i);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getval</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> pos)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(tr[i].l==tr[i].r) <span class="hljs-keyword">return</span> tr[i].sum;<br>	<span class="hljs-built_in">push_down</span>(i);<br>	<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">if</span>(tr[ls].r&gt;=pos) res=<span class="hljs-built_in">getval</span>(ls,pos);<br>	<span class="hljs-keyword">else</span> res=<span class="hljs-built_in">getval</span>(rs,pos);<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">/* Heavy Path Decomposition */</span><br><span class="hljs-comment">// dfs序、深度、子树大小、父节点、重儿子、链顶</span><br><span class="hljs-type">int</span> dfsx,csid[maxn],csdep[maxn],cssize[maxn],csfa[maxn],csson[maxn],cstop[maxn];<br><span class="hljs-comment">// value need to maintain</span><br><span class="hljs-type">int</span> csw[maxn];<br><br><span class="hljs-comment">// first dfs</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">csdfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fath,<span class="hljs-type">int</span> depth)</span></span>&#123;<br>	csfa[u]=fath;<br>	csdep[u]=depth;<br>	cssize[u]=<span class="hljs-number">1</span>;<br>	<span class="hljs-comment">/* long path dec */</span><br>	<span class="hljs-comment">// cssize[u]=csdep[u];</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(v!=fath)&#123;<br>			<span class="hljs-comment">/* edge to point */</span><br>			<span class="hljs-comment">// w[v]=e[i].w;</span><br>			<span class="hljs-comment">// wdep[v]+=w[v];</span><br>			<span class="hljs-built_in">csdfs1</span>(v,u,depth+<span class="hljs-number">1</span>);<br>			cssize[u]+=cssize[v];<br>			<span class="hljs-comment">/* long path dec */</span><br>			<span class="hljs-comment">// cssize[u]=max(cssize[u],cssize[v]);</span><br>			<span class="hljs-keyword">if</span>(cssize[v]&gt;cssize[csson[u]])<br>				csson[u]=v;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">//second dfs</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">csdfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> topf)</span></span>&#123;<br>	csid[u]=++dfsx;<br>	<span class="hljs-comment">/* value need to maintain */</span><br>	<span class="hljs-comment">// csw[dfsx]=u;</span><br>	cstop[u]=topf;<br>	<span class="hljs-keyword">if</span>(!csson[u]) <span class="hljs-keyword">return</span>;<br>	<span class="hljs-built_in">csdfs2</span>(csson[u],topf);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(v!=csfa[u]&amp;&amp;v!=csson[u])<br>			<span class="hljs-built_in">csdfs2</span>(v,v);<br>	&#125;<br>&#125;<br><span class="hljs-comment">/*--------------------------------------*/</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>	<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,csid[x],csid[x]+cssize[x]<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">droprt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>	<span class="hljs-type">int</span> y=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">while</span>(cstop[x]!=cstop[y])&#123;<br>		<span class="hljs-keyword">if</span>(csdep[cstop[x]]&lt;csdep[cstop[y]])<br>			<span class="hljs-built_in">swap</span>(x,y);<br>		<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,csid[cstop[x]],csid[x],<span class="hljs-number">0</span>);<br>		x=csfa[cstop[x]];<br>	&#125;<br>	<span class="hljs-keyword">if</span>(csdep[x]&gt;csdep[y]) <span class="hljs-built_in">swap</span>(x,y);<br>	<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,csid[x],csid[y],<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">isfull</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">getval</span>(<span class="hljs-number">1</span>,csid[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>	<span class="hljs-built_in">init_graph</span>();<br>	<span class="hljs-type">int</span> x,y;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<br>		<span class="hljs-built_in">addedge</span>(x,y),<span class="hljs-built_in">addedge</span>(y,x);<br>	&#125;<br>	<span class="hljs-built_in">csdfs1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>);<br>	<span class="hljs-built_in">csdfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>	<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q);<br>	<span class="hljs-keyword">while</span>(q--)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<br>		<span class="hljs-keyword">if</span>(x==<span class="hljs-number">1</span>) <span class="hljs-built_in">addrt</span>(y);<br>		<span class="hljs-keyword">if</span>(x==<span class="hljs-number">2</span>) <span class="hljs-built_in">droprt</span>(y);<br>		<span class="hljs-keyword">if</span>(x==<span class="hljs-number">3</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">isfull</span>(y));<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<details>
<summary>ODT code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n,q;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> u,v,w,next;<br>&#125;e[maxn&lt;&lt;<span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> cnt,head[maxn];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init_graph</span><span class="hljs-params">()</span></span>&#123;<br>	cnt=<span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w=<span class="hljs-number">0</span>)</span></span>&#123;<br>	e[cnt]=Edge&#123;u,v,w,head[u]&#125;;<br>	head[u]=cnt++;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IT set<span class="hljs-string">&lt;odtnode&gt;</span>::iterator</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">odtnode</span><br>&#123;<br>	<span class="hljs-type">int</span> l,r;<br>	<span class="hljs-keyword">mutable</span> ll v;<br>	<span class="hljs-built_in">odtnode</span>(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R=<span class="hljs-number">-1</span>,ll V=<span class="hljs-number">0</span>):<span class="hljs-built_in">l</span>(L),<span class="hljs-built_in">r</span>(R),<span class="hljs-built_in">v</span>(V)&#123;&#125;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> odtnode&amp; rhs)<span class="hljs-type">const</span>&#123;<br>		<span class="hljs-keyword">return</span> l&lt;rhs.l;<br>	&#125;<br>&#125;;<br>set&lt;odtnode&gt; odt;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> IT <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span></span>&#123;<br>	IT it=odt.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-built_in">odtnode</span>(pos));<br>	<span class="hljs-keyword">if</span>(it!=odt.<span class="hljs-built_in">end</span>()&amp;&amp;it-&gt;l==pos) <span class="hljs-keyword">return</span> it;<br>	it--;<br>	<span class="hljs-type">int</span> l=it-&gt;l,r=it-&gt;r;<br>	ll v=it-&gt;v;<br>	odt.<span class="hljs-built_in">erase</span>(it);<br>	odt.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">odtnode</span>(l,pos<span class="hljs-number">-1</span>,v));<br>	<span class="hljs-keyword">return</span> odt.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">odtnode</span>(pos,r,v)).first;<br>&#125;<br><br><span class="hljs-comment">// Assign to same value</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,ll k)</span></span>&#123;<br>	IT itr=<span class="hljs-built_in">split</span>(r+<span class="hljs-number">1</span>),itl=<span class="hljs-built_in">split</span>(l);<br>	odt.<span class="hljs-built_in">erase</span>(itl,itr);<br>	odt.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">odtnode</span>(l,r,k));<br>&#125;<br><br><span class="hljs-comment">/*------------------------------------*/</span><br><span class="hljs-comment">/* Heavy Path Decomposition */</span><br><span class="hljs-comment">// dfs序、深度、子树大小、父节点、重儿子、链顶</span><br><span class="hljs-type">int</span> dfsx,csid[maxn],csdep[maxn],cssize[maxn],csfa[maxn],csson[maxn],cstop[maxn];<br><span class="hljs-comment">// value need to maintain</span><br><span class="hljs-type">int</span> csw[maxn];<br><br><span class="hljs-comment">// first dfs</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">csdfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fath,<span class="hljs-type">int</span> depth)</span></span>&#123;<br>	csfa[u]=fath;<br>	csdep[u]=depth;<br>	cssize[u]=<span class="hljs-number">1</span>;<br>	<span class="hljs-comment">/* long path dec */</span><br>	<span class="hljs-comment">// cssize[u]=csdep[u];</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(v!=fath)&#123;<br>			<span class="hljs-comment">/* edge to point */</span><br>			<span class="hljs-comment">// w[v]=e[i].w;</span><br>			<span class="hljs-comment">// wdep[v]+=w[v];</span><br>			<span class="hljs-built_in">csdfs1</span>(v,u,depth+<span class="hljs-number">1</span>);<br>			cssize[u]+=cssize[v];<br>			<span class="hljs-comment">/* long path dec */</span><br>			<span class="hljs-comment">// cssize[u]=max(cssize[u],cssize[v]);</span><br>			<span class="hljs-keyword">if</span>(cssize[v]&gt;cssize[csson[u]])<br>				csson[u]=v;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">//second dfs</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">csdfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> topf)</span></span>&#123;<br>	csid[u]=++dfsx;<br>	<span class="hljs-comment">/* value need to maintain */</span><br>	<span class="hljs-comment">// csw[dfsx]=u;</span><br>	cstop[u]=topf;<br>	<span class="hljs-keyword">if</span>(!csson[u]) <span class="hljs-keyword">return</span>;<br>	<span class="hljs-built_in">csdfs2</span>(csson[u],topf);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(v!=csfa[u]&amp;&amp;v!=csson[u])<br>			<span class="hljs-built_in">csdfs2</span>(v,v);<br>	&#125;<br>&#125;<br><span class="hljs-comment">/*--------------------------------------*/</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>	<span class="hljs-built_in">assign</span>(csid[x],csid[x]+cssize[x]<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">droprt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>	<span class="hljs-type">int</span> y=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">while</span>(cstop[x]!=cstop[y])&#123;<br>		<span class="hljs-keyword">if</span>(csdep[cstop[x]]&lt;csdep[cstop[y]])<br>			<span class="hljs-built_in">swap</span>(x,y);<br>		<span class="hljs-built_in">assign</span>(csid[cstop[x]],csid[x],<span class="hljs-number">0</span>);<br>		x=csfa[cstop[x]];<br>	&#125;<br>	<span class="hljs-keyword">if</span>(csdep[x]&gt;csdep[y]) <span class="hljs-built_in">swap</span>(x,y);<br>	<span class="hljs-built_in">assign</span>(csid[x],csid[y],<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">isfull</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>	IT it=<span class="hljs-built_in">split</span>(csid[x]);<br>	<span class="hljs-keyword">return</span> it-&gt;v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>	<span class="hljs-built_in">init_graph</span>();<br>	<span class="hljs-type">int</span> x,y;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<br>		<span class="hljs-built_in">addedge</span>(x,y),<span class="hljs-built_in">addedge</span>(y,x);<br>	&#125;<br>	<span class="hljs-built_in">csdfs1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>);<br>	<span class="hljs-built_in">csdfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>	odt.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">odtnode</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">0</span>));<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q);<br>	<span class="hljs-keyword">while</span>(q--)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<br>		<span class="hljs-keyword">if</span>(x==<span class="hljs-number">1</span>) <span class="hljs-built_in">addrt</span>(y);<br>		<span class="hljs-keyword">if</span>(x==<span class="hljs-number">2</span>) <span class="hljs-built_in">droprt</span>(y);<br>		<span class="hljs-keyword">if</span>(x==<span class="hljs-number">3</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">isfull</span>(y));<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<ul>
<li><a href="https://www.luogu.com.cn/problem/P2787">P2787 语文1（chin1）- 理理思维</a></li>
</ul>
<p>很遗憾，此题用ODT会T掉最后一个点（因为有人造数据卡ODT），但是可以用来骗分（然而我已经是大学生了），正解是线段树</p>
<details>
<summary>ODT code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n,m,op,l,r;<br><span class="hljs-type">char</span> x,s[maxn];<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IT set<span class="hljs-string">&lt;odtnode&gt;</span>::iterator</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">odtnode</span><br>&#123;<br>	<span class="hljs-type">int</span> l,r;<br>	<span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> v;<br>	<span class="hljs-built_in">odtnode</span>(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R=<span class="hljs-number">-1</span>,<span class="hljs-type">int</span> V=<span class="hljs-number">0</span>):<span class="hljs-built_in">l</span>(L),<span class="hljs-built_in">r</span>(R),<span class="hljs-built_in">v</span>(V)&#123;&#125;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> odtnode&amp; rhs)<span class="hljs-type">const</span>&#123;<br>		<span class="hljs-keyword">return</span> l&lt;rhs.l;<br>	&#125;<br>&#125;;<br>set&lt;odtnode&gt; odt;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> IT <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span></span>&#123;<br>	IT it=odt.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-built_in">odtnode</span>(pos));<br>	<span class="hljs-keyword">if</span>(it!=odt.<span class="hljs-built_in">end</span>()&amp;&amp;it-&gt;l==pos) <span class="hljs-keyword">return</span> it;<br>	it--;<br>	<span class="hljs-type">int</span> l=it-&gt;l,r=it-&gt;r,v=it-&gt;v;<br>	odt.<span class="hljs-built_in">erase</span>(it);<br>	odt.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">odtnode</span>(l,pos<span class="hljs-number">-1</span>,v));<br>	<span class="hljs-keyword">return</span> odt.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">odtnode</span>(pos,r,v)).first;<br>&#125;<br><br><span class="hljs-comment">// Assign to same value</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<br>	IT itr=<span class="hljs-built_in">split</span>(r+<span class="hljs-number">1</span>),itl=<span class="hljs-built_in">split</span>(l);<br>	odt.<span class="hljs-built_in">erase</span>(itl,itr);<br>	odt.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">odtnode</span>(l,r,k));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">ci</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<br>	IT itr=<span class="hljs-built_in">split</span>(r+<span class="hljs-number">1</span>),itl=<span class="hljs-built_in">split</span>(l);<br>	<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(;itl!=itr;itl++)&#123;<br>		<span class="hljs-keyword">if</span>(itl-&gt;v==k) res+=itl-&gt;r-itl-&gt;l+<span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pai</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>	<span class="hljs-type">int</span> vis[<span class="hljs-number">27</span>];<br>	IT itr=<span class="hljs-built_in">split</span>(r+<span class="hljs-number">1</span>),itl=<span class="hljs-built_in">split</span>(l);<br>	<span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<br>	<span class="hljs-keyword">for</span>(IT it=itl;it!=itr;it++)&#123;<br>		vis[it-&gt;v]+=it-&gt;r-it-&gt;l+<span class="hljs-number">1</span>;<br>	&#125;<br>	odt.<span class="hljs-built_in">erase</span>(itl,itr);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">26</span>;i++)&#123;<br>		<span class="hljs-keyword">if</span>(vis[i]) odt.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">odtnode</span>(l,l+vis[i]<span class="hljs-number">-1</span>,<span class="hljs-built_in">char</span>(i))),l+=vis[i];<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<details>
<summary>Segment Tree code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">gg...<br></code></pre></div></td></tr></table></figure>

</details>



<ul>
<li><a href="https://www.luogu.com.cn/problem/P5350">P5350 序列</a>（FHQ Treap、ODT）</li>
</ul>
<p>注意：此题保证数据随机，因此可以直接用ODT轻松水过（其实也算是一道ODT的模板题了）</p>
<p><strong>千万要记住ODT的Split顺序是先大后小，用完一对指针后这对指针就废了，因此需要一个区间一个区间地处理</strong></p>
<details>
<summary>ODT code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IT set<span class="hljs-string">&lt;odtnode&gt;</span>::iterator</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">odtnode</span><br>&#123;<br>	<span class="hljs-type">int</span> l,r;<br>	<span class="hljs-keyword">mutable</span> ll v;<br>	<span class="hljs-built_in">odtnode</span>(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R=<span class="hljs-number">-1</span>,ll V=<span class="hljs-number">0</span>):<span class="hljs-built_in">l</span>(L),<span class="hljs-built_in">r</span>(R),<span class="hljs-built_in">v</span>(V)&#123;&#125;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> odtnode&amp; rhs)<span class="hljs-type">const</span>&#123;<br>		<span class="hljs-keyword">return</span> l&lt;rhs.l;<br>	&#125;<br>&#125;;<br>set&lt;odtnode&gt; odt;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> IT <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span></span>&#123;<br>	IT it=odt.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-built_in">odtnode</span>(pos));<br>	<span class="hljs-keyword">if</span>(it!=odt.<span class="hljs-built_in">end</span>()&amp;&amp;it-&gt;l==pos) <span class="hljs-keyword">return</span> it;<br>	it--;<br>	<span class="hljs-type">int</span> l=it-&gt;l,r=it-&gt;r;<br>	ll v=it-&gt;v;<br>	odt.<span class="hljs-built_in">erase</span>(it);<br>	odt.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">odtnode</span>(l,pos<span class="hljs-number">-1</span>,v));<br>	<span class="hljs-keyword">return</span> odt.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">odtnode</span>(pos,r,v)).first;<br>&#125;<br><br><span class="hljs-comment">// Assign to same value</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,ll k)</span></span>&#123;<br>	k%=mod;<br>	IT itr=<span class="hljs-built_in">split</span>(r+<span class="hljs-number">1</span>),itl=<span class="hljs-built_in">split</span>(l);<br>	odt.<span class="hljs-built_in">erase</span>(itl,itr);<br>	odt.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">odtnode</span>(l,r,k));<br>&#125;<br><br><span class="hljs-comment">// [l,r] + k</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,ll k)</span></span>&#123;<br>	k%=mod;<br>	IT itr=<span class="hljs-built_in">split</span>(r+<span class="hljs-number">1</span>),itl=<span class="hljs-built_in">split</span>(l);<br>	<span class="hljs-keyword">for</span>(;itl!=itr;itl++) itl-&gt;v=(itl-&gt;v+k)%mod;<br>&#125;<br><br><span class="hljs-comment">//区间求和</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>	IT itr=<span class="hljs-built_in">split</span>(r+<span class="hljs-number">1</span>),itl=<span class="hljs-built_in">split</span>(l);<br>	ll res=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(;itl!=itr;itl++)&#123;<br>		res=((res+itl-&gt;v*(itl-&gt;r-itl-&gt;l+<span class="hljs-number">1</span>)%mod)%mod+mod)%mod;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res%mod;<br>&#125;<br><br><span class="hljs-comment">// 区间拷贝</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">copy</span><span class="hljs-params">(<span class="hljs-type">int</span> l1,<span class="hljs-type">int</span> r1,<span class="hljs-type">int</span> l2,<span class="hljs-type">int</span> r2)</span></span>&#123;<br>	IT itr1=<span class="hljs-built_in">split</span>(r1+<span class="hljs-number">1</span>),itl1=<span class="hljs-built_in">split</span>(l1);<br>	vector&lt;pair&lt;ll,<span class="hljs-type">int</span>&gt;&gt; vec;<br>	<span class="hljs-keyword">for</span>(IT it=itl1;it!=itr1;it++)&#123;<br>		vec.<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">pair</span>&lt;ll,<span class="hljs-type">int</span>&gt;(it-&gt;v,it-&gt;r-it-&gt;l+<span class="hljs-number">1</span>));<br>	&#125;<br><br>	IT itr2=<span class="hljs-built_in">split</span>(r2+<span class="hljs-number">1</span>),itl2=<span class="hljs-built_in">split</span>(l2);<br>	odt.<span class="hljs-built_in">erase</span>(itl2,itr2);<br><br>	<span class="hljs-keyword">for</span>(vector&lt;pair&lt;ll,<span class="hljs-type">int</span>&gt;&gt;::iterator it=vec.<span class="hljs-built_in">begin</span>();it!=vec.<span class="hljs-built_in">end</span>();it++)&#123;<br>		odt.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">odtnode</span>(l2,l2+it-&gt;second<span class="hljs-number">-1</span>,it-&gt;first));<br>		l2+=it-&gt;second;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// 区间交换</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">exchange</span><span class="hljs-params">(<span class="hljs-type">int</span> l1,<span class="hljs-type">int</span> r1,<span class="hljs-type">int</span> l2,<span class="hljs-type">int</span> r2)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(l1&gt;l2) <span class="hljs-built_in">swap</span>(l1,l2),<span class="hljs-built_in">swap</span>(r1,r2);<br>	<br>	IT itr1=<span class="hljs-built_in">split</span>(r1+<span class="hljs-number">1</span>),itl1=<span class="hljs-built_in">split</span>(l1);<br>	vector&lt;pair&lt;ll,<span class="hljs-type">int</span>&gt;&gt; vec1,vec2;<br>	<span class="hljs-keyword">for</span>(IT it=itl1;it!=itr1;it++)&#123;<br>		vec1.<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">pair</span>&lt;ll,<span class="hljs-type">int</span>&gt;(it-&gt;v,it-&gt;r-it-&gt;l+<span class="hljs-number">1</span>));<br>	&#125;<br>	odt.<span class="hljs-built_in">erase</span>(itl1,itr1);<br><br>	IT itr2=<span class="hljs-built_in">split</span>(r2+<span class="hljs-number">1</span>),itl2=<span class="hljs-built_in">split</span>(l2);<br>	<span class="hljs-keyword">for</span>(IT it=itl2;it!=itr2;it++)&#123;<br>		vec2.<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">pair</span>&lt;ll,<span class="hljs-type">int</span>&gt;(it-&gt;v,it-&gt;r-it-&gt;l+<span class="hljs-number">1</span>));<br>	&#125;<br>	odt.<span class="hljs-built_in">erase</span>(itl2,itr2);<br><br>	<span class="hljs-keyword">for</span>(vector&lt;pair&lt;ll,<span class="hljs-type">int</span>&gt;&gt;::iterator it=vec1.<span class="hljs-built_in">begin</span>();it!=vec1.<span class="hljs-built_in">end</span>();it++)&#123;<br>		odt.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">odtnode</span>(l2,l2+it-&gt;second<span class="hljs-number">-1</span>,it-&gt;first));<br>		l2+=it-&gt;second;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(vector&lt;pair&lt;ll,<span class="hljs-type">int</span>&gt;&gt;::iterator it=vec2.<span class="hljs-built_in">begin</span>();it!=vec2.<span class="hljs-built_in">end</span>();it++)&#123;<br>		odt.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">odtnode</span>(l1,l1+it-&gt;second<span class="hljs-number">-1</span>,it-&gt;first));<br>		l1+=it-&gt;second;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// 区间翻转</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">updown</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-built_in">swap</span>(l,r);<br>	IT itr=<span class="hljs-built_in">split</span>(r+<span class="hljs-number">1</span>),itl=<span class="hljs-built_in">split</span>(l);<br>	vector&lt;pair&lt;ll,<span class="hljs-type">int</span>&gt;&gt; vec;<br>	<span class="hljs-keyword">for</span>(IT it=itl;it!=itr;it++)&#123;<br>		vec.<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">pair</span>&lt;ll,<span class="hljs-type">int</span>&gt;(it-&gt;v,it-&gt;r-it-&gt;l+<span class="hljs-number">1</span>));<br>	&#125;<br>	odt.<span class="hljs-built_in">erase</span>(itl,itr);<br>	<span class="hljs-built_in">reverse</span>(<span class="hljs-built_in">All</span>(vec));<br>	<span class="hljs-keyword">for</span>(vector&lt;pair&lt;ll,<span class="hljs-type">int</span>&gt;&gt;::iterator it=vec.<span class="hljs-built_in">begin</span>();it!=vec.<span class="hljs-built_in">end</span>();it++)&#123;<br>		odt.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">odtnode</span>(l,l+it-&gt;second<span class="hljs-number">-1</span>,it-&gt;first));<br>		l+=it-&gt;second;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>	<span class="hljs-type">int</span> x;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x),odt.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">odtnode</span>(i,i,x));<br>	<span class="hljs-type">int</span> op,l1,r1,l2,r2,val;<br>	<span class="hljs-keyword">while</span>(m--)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;op,&amp;l1,&amp;r1);<br>		<span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">getsum</span>(l1,r1));<br>		<span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;val),<span class="hljs-built_in">assign</span>(l1,r1,<span class="hljs-number">1ll</span>*val);<br>		<span class="hljs-keyword">if</span>(op==<span class="hljs-number">3</span>) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;val),<span class="hljs-built_in">add</span>(l1,r1,<span class="hljs-number">1ll</span>*val);<br>		<span class="hljs-keyword">if</span>(op==<span class="hljs-number">4</span>) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;l2,&amp;r2),<span class="hljs-built_in">copy</span>(l1,r1,l2,r2);<br>		<span class="hljs-keyword">if</span>(op==<span class="hljs-number">5</span>) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;l2,&amp;r2),<span class="hljs-built_in">exchange</span>(l1,r1,l2,r2);<br>		<span class="hljs-keyword">if</span>(op==<span class="hljs-number">6</span>) <span class="hljs-built_in">updown</span>(l1,r1);<br>	&#125;<br>	IT itr=<span class="hljs-built_in">split</span>(n+<span class="hljs-number">1</span>),itl=<span class="hljs-built_in">split</span>(<span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">for</span>(IT it=itl;it!=itr;it++)&#123;<br>		<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,it-&gt;r-it-&gt;l+<span class="hljs-number">1</span>)&#123;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,it-&gt;v%mod);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>珂朵莉树</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络介绍</title>
    <url>/2020/02/15/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>关于<strong>神经网络</strong>最基础的知识点</p>
<ul>
<li>关于<strong>BP反向传递</strong>的知识点：<a href="https://github.com/apachecn/AiLearning/blob/master/docs/dl/反向传递.md">BP原理</a></li>
<li>关于<strong>CNN卷积神经网络</strong>的知识点：<a href="https://github.com/apachecn/AiLearning/blob/master/docs/dl/CNN原理.md">CNN原理</a></li>
<li>关于<strong>RNN循环神经网络</strong>的知识点：<a href="https://github.com/apachecn/AiLearning/blob/master/docs/dl/RNN原理.md">RNN原理</a></li>
<li>关于<strong>LSTM长短期记忆网络</strong>的知识点：<a href="https://github.com/apachecn/AiLearning/blob/master/docs/dl/LSTM原理.md">LSTM原理</a></li>
</ul>
<hr>
<span id="more"></span>
<p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/maybe2030/p/5597716.html">神经网络基础</a></li>
</ul>
<h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><h3 id="传统神经网络的主要结构"><a href="#传统神经网络的主要结构" class="headerlink" title="传统神经网络的主要结构"></a>传统神经网络的主要结构</h3><p>（输入层 -&gt; 隐含层 -&gt; 输出层）每一层网络有多个神经元，上一层的神经元通过激活函数映射到下一层神经元，每个神经元之间有相对应的权值，输出即为我们的分类类别</p>
<ul>
<li>神经元</li>
<li>感知机</li>
<li>学习算法（如BP反向传播算法）</li>
</ul>
<h3 id="常见神经网络模型"><a href="#常见神经网络模型" class="headerlink" title="常见神经网络模型"></a>常见神经网络模型</h3><ul>
<li><p>Boltzmann机：层内+层间都相连</p>
</li>
<li><p>受限Boltzmann机（RBM）：层间相连，层间不连</p>
</li>
<li><p>RBF（Radio Basis Function）径向基函数网络</p>
<ul>
<li>单隐层前馈神经网络</li>
<li>径向基函数作为激活函数</li>
<li>输出层是对隐层神经元输出的线性组合</li>
</ul>
</li>
<li><p>ART（Adaptive Resonance Theory）自适应谐振理论网络</p>
<ul>
<li>竞争型学习</li>
<li>组成：比较层+识别层+识别层阈值+重置模块</li>
<li>可进行增量学习或在线学习</li>
</ul>
</li>
<li><p>SOM（Self-Organizing Map）自组织映射网络</p>
<ul>
<li>竞争型学习</li>
<li>无监督神经网络</li>
<li>可将高维数据映射到低维空间，同时保持高维的拓扑结构</li>
</ul>
</li>
<li><p>结构自适应网络</p>
</li>
<li><p>在训练过程中找到最符合数据特点的网络结构</p>
</li>
<li><p>RNN（Recurrent Neural Networks）递归（循环）神经网络</p>
<ul>
<li>允许网络出现环，反馈调节</li>
<li>可用于时间序列建模，在时间深度上的深度学习</li>
<li>由于时间轴上的梯度发散，因此难以学习远距离的影响<br>为解决上述问题，发展出了<strong>长短时记忆单元LSTM（Long-Short Term Memory）</strong>，通过门的开关实现时间上的记忆功能，防止梯度发散</li>
</ul>
</li>
<li><p>深度学习：深度神经网络模型，一般指网络层数在三层或三层以上的神经网络结构，如卷积神经网络CNN（Convolutional Neural Networks）</p>
</li>
</ul>
<h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><ul>
<li><p>特征提取的高效性<br>不需要像机器学习算法一样前期做十分复杂的特征工程以避免发生欠拟合或过拟合现象</p>
</li>
<li><p>数据格式的简易性<br>不需要做过多的数据处理</p>
</li>
<li><p>参数数目的少量性<br>对于调参背后的理论知识不需要过于精通，对于最简单的浅层神经网络来说，参数数目只有初始赋予的权重和偏置项</p>
</li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>科普知识：冷却塔为什么是曲面的？</title>
    <url>/2020/04/30/%E7%A7%91%E6%99%AE%E7%9F%A5%E8%AF%86%EF%BC%9A%E5%86%B7%E5%8D%B4%E5%A1%94%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E6%9B%B2%E9%9D%A2%E7%9A%84%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="冷却塔发展"><a href="#冷却塔发展" class="headerlink" title="冷却塔发展"></a><center>冷却塔发展</center></h2><span id="more"></span>
<p>参考网页链接：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Cooling_tower#Structural_stability">Wikipedia: Cooling tower</a></li>
<li><a href="https://www.zhihu.com/question/20800965">知乎问答：火电厂的冷却塔为什么是双曲面形状的？有什么优势？</a></li>
<li><a href="https://www.guokr.com/article/439344/">你拿披萨的方式，很可能是错的</a></li>
</ul>
<hr>
<p>​        根据维基百科词条内容，冷却塔的发展源自于十九世纪蒸汽引擎中<strong>凝汽器</strong>的发展，来自于凝汽器中的水会被泵到冷却塔顶端的分配装置中，然后滴落到下方由木头或者编制丝网制成的“垫子”上，这些垫子充满了塔内空间。</p>
<p>起初时它的结构形式是圆柱形或是矩形的（也有其他形状的），直到1918年荷兰工程师<strong>Frederik van Iterson</strong>发明了<strong>双曲面（Hyperboloid）</strong>型的冷却塔结构，第一座双曲面结构的冷却塔于1918年建造在荷兰的海尔伦附近，该形状的冷却塔至今仍是主流的冷却塔外形。</p>
<p><img src="https://i.loli.net/2020/04/30/rvCpaEHKiwhlWjA.jpg" alt="v2-6ade46d208260c91a238ef7a191548fb_720w.jpg" style="zoom: 50%;" /></p>
<p>至于为什么要使用<strong>双曲面型</strong>的冷却塔外形，经过资料的查阅，得出如下结果</p>
<p>产生这种形状的冷却塔，最主要的原因是：<strong>发电厂的规模在不断扩大，因此需要一种更加大规模的冷却塔，而这种大规模必然会增加成本投入，因此就需要一种最经济的形状</strong></p>
<p>对于冷却塔的性能，我们主要用<strong>抽力</strong>来衡量，计算公式如下</p>
<script type="math/tex; mode=display">
Z=H_e(\rho_1-\rho_2)g\ (Pa)\\
H_e:冷却塔通风筒有效高度\\
\rho_1,\rho_2:塔外和填料上部的空气密度,kg/m^3</script><p>因此，<strong>它只与冷却塔高度和内外气体密度差有关</strong>，那么对于一个大抽力的冷却塔来说，它的高度会很高，那么就必然导致其<strong>稳定性下降</strong>，而要让他稳定性变强就得加厚钢筋，成本特别高，因而就产生了<strong>曲面结构</strong>。</p>
<p>因为：<strong>曲面能产生强度</strong>，任何曲面的<strong>高斯曲率</strong>不为零</p>
<p>对于<strong>高斯曲率</strong>，它的定义如下：</p>
<blockquote>
<p>曲面上一点的高斯曲率是改点主曲率$k_1$和$k_2$的乘积</p>
</blockquote>
<p>学过微分几何的都知道<strong>主曲率</strong>的定义，其实就是一个曲面的极大曲率和极小曲率，而这两者的乘积就是高斯曲率，十分巧妙的是，这里有一个数学家高斯提出的定理：</p>
<blockquote>
<p>高斯绝妙定理：可以随意弯曲一个曲面，只要不拉长、压缩或者撕裂它，高斯曲率一定不会变</p>
</blockquote>
<p>这个定理十分神奇，我的理解就是：一个曲面不会因为人为的弯折而改变高斯曲率，就比如说一个矩形的纸（高斯曲率为0），你可以把它弯曲成一个圆柱体，但高斯曲率不变（还是0），因为沿着圆柱轴向的曲率永远为0，我画了个图如下</p>
<p><img src="https://i.loli.net/2020/04/30/4QqfBi7Tho2dvPA.png" alt="_88B31906-B72F-9DCD-A223-44229F2ADCBA_.png" style="zoom: 50%;" /></p>
<p>现在问题就变为：什么样曲率的曲面能够保证稳定性和经济性？答案是双曲面。</p>
<p>对于稳定性：双曲面是一种典型的<strong>负高斯曲率</strong>旋转曲面，以这样形状组成的结构的内部以压应力为主，比较适合混凝土受力特性，会产生一种“锁死”现象，这保证了稳定性</p>
<p>对于经济性：双曲面其实可以用一根直线通过绕轴连续旋转获得（直纹曲面），这是非常方便的，比如广州塔的每根主梁都是直的</p>
<p><img src="https://i.loli.net/2020/04/30/qS2PLQ4gjRefZhG.jpg" alt="v2-e65128c880af77a43dfda4d5bd19a12f_720w.jpg" style="zoom:25%;" /></p>
<hr>
<p>至此，有关当今冷却塔的结构为什么是曲面形的这个问题，我回答了一个大概（大部分借鉴与知乎问答和百科），应该比较完整了。</p>
]]></content>
      <categories>
        <category>物理</category>
      </categories>
      <tags>
        <tag>科普</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>笔记-燃气轮机原理及其应用</title>
    <url>/2020/02/25/%E7%AC%94%E8%AE%B0-%E7%87%83%E6%B0%94%E8%BD%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<h1 id="第一单元"><a href="#第一单元" class="headerlink" title="第一单元"></a>第一单元</h1><h2 id="燃气轮机"><a href="#燃气轮机" class="headerlink" title="燃气轮机"></a>燃气轮机</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li><p>以空气和燃气为工作介质，将热能转变为机械能的高速回转式动力机械</p>
</li>
<li><p>与内燃机、蒸汽轮机一样，为<strong>原动机</strong></p>
</li>
</ul>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>一般压气机、燃烧室、涡轮（透平膨胀机）、控制系统及基本辅助设备组成</p>
<ul>
<li>压气机（Compressor）：完成气体压缩过程</li>
<li>燃烧室（Burner）：完成燃烧加热过程</li>
<li>涡轮（透平膨胀机）（Turbine）：完成高温高压燃气的膨胀作功过程</li>
</ul>
<p>负荷：燃气轮机输出的机械功率用来驱动的发电机、泵、鼓风机螺旋桨或车轮等</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>压气机从外界吸入空气（吸气），压缩到一定压力，送入燃烧室中，与喷入的燃料混合，进行燃烧，生成的高温高压燃气进入透平中膨胀作功，推动涡轮，带动压气机一起旋转，并向外界输出机械功（带负荷），做功后的废气排入大气中或加以利用（排气）</p>
<p>燃料中的化学能-&gt;热能-&gt;机械功</p>
<ul>
<li><strong>燃气轮机在涡轮中所做的机械功，大约2/3用来带动压气机；其余1/3机械功则通过机组的输出轴去带动各种负荷</strong></li>
</ul>
<h4 id="理想燃气轮机循环——布雷顿循环"><a href="#理想燃气轮机循环——布雷顿循环" class="headerlink" title="理想燃气轮机循环——布雷顿循环"></a>理想燃气轮机循环——布雷顿循环</h4><p><img src="https://i.loli.net/2020/02/25/Yp7xvCGM3intFrH.png" alt="image.png"></p>
<p>1-&gt;2 等熵压缩，2-&gt;3等压吸热，3-&gt;4等熵压缩，4-&gt;1等压放热</p>
<h3 id="设备结构"><a href="#设备结构" class="headerlink" title="设备结构"></a>设备结构</h3><h4 id="压气机（轴流式）"><a href="#压气机（轴流式）" class="headerlink" title="压气机（轴流式）"></a>压气机（轴流式）</h4><ul>
<li>由转子+气缸构成，17~18级叶片，气缸分为上气缸+下气缸</li>
<li><p>可分为进气缸、压气缸、排气缸</p>
<ul>
<li>进气缸：与进气过滤装置连接（大气端）</li>
<li>排气缸：与燃烧室连接（透平端）</li>
</ul>
</li>
<li><p>空气过滤装置需要定期清洗</p>
</li>
<li>入口导叶调整进气量</li>
</ul>
<h4 id="燃烧室"><a href="#燃烧室" class="headerlink" title="燃烧室"></a>燃烧室</h4><ul>
<li>燃烧室和透平承担着1k℃以上的高温</li>
<li>机组容量不同，燃烧室数量不同</li>
<li>基本包括火焰筒、联焰管过过渡段、燃料喷嘴</li>
</ul>
<h4 id="透平"><a href="#透平" class="headerlink" title="透平"></a>透平</h4><ul>
<li>由转子+气缸组成，一般3~5级，分为上气缸+下气缸</li>
<li>气缸内部圆周上安装静止叶片（喷嘴），静叶组和动叶组构成一级</li>
</ul>
<h3 id="循环方式"><a href="#循环方式" class="headerlink" title="循环方式"></a>循环方式</h3><h4 id="开式循环"><a href="#开式循环" class="headerlink" title="开式循环"></a>开式循环</h4><ul>
<li><p>以空气为工质，用内燃的方式在燃烧室中加热，并把废气放回大气来排热（开式）</p>
</li>
<li><p>使用广泛</p>
<p>内燃：燃气作为工质做功（对燃料要求高）</p>
</li>
</ul>
<h4 id="闭式循环"><a href="#闭式循环" class="headerlink" title="闭式循环"></a>闭式循环</h4><ul>
<li><p>工质加热后，用外燃方式（空气锅炉、原子能反应堆或其他换热器）膨胀作功后，用热交换器排热（闭式）</p>
<p>外燃：工质通过换热器获得燃料燃烧的热量后做功（燃烧产物不是循环工质，对燃料要求低）</p>
</li>
<li><p>使用并不广泛，工质可采用非空气工质，如 氦气</p>
</li>
</ul>
<p><strong>蒸汽轮机</strong>可以看成闭式燃气轮机的一种变相形式</p>
<h4 id="工业过程式循环"><a href="#工业过程式循环" class="headerlink" title="工业过程式循环"></a>工业过程式循环</h4><ul>
<li>工质同其他工业设备有联系的燃机循环</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>重量轻、体积小、投资省</li>
<li>启动快、自动化程度高、操作方便</li>
<li>水、电、润滑油消耗少、少用或不用水</li>
<li>燃料适应性强、公害少</li>
<li>维修快、运行可靠</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>热效率低</li>
<li>使用的经济性和可靠性较差</li>
</ol>
]]></content>
      <categories>
        <category>本科专业课</category>
      </categories>
      <tags>
        <tag>燃气轮机</tag>
      </tags>
  </entry>
  <entry>
    <title>第十一届蓝桥杯省赛B组第二场（比赛记录）</title>
    <url>/2020/10/17/%E7%AC%AC%E5%8D%81%E4%B8%80%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%81%E8%B5%9BB%E7%BB%84%E7%AC%AC%E4%BA%8C%E5%9C%BA%EF%BC%88%E6%AF%94%E8%B5%9B%E8%AE%B0%E5%BD%95%EF%BC%89/</url>
    <content><![CDATA[<p>今天打完了蓝桥杯，估摸了一下大概80分吧，不知道能不能省一，先水一发比赛记录。</p>
<p>2020.10.26 更新： 今天出结果了，省一，嘻嘻嘻，不过因为疫情原因，不能去北京一日游了，很烦</p>
<span id="more"></span>
<h2 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h2><h3 id="A-门牌制作"><a href="#A-门牌制作" class="headerlink" title="A. 门牌制作"></a>A. 门牌制作</h3><blockquote>
<p>小蓝要为一条街的住户制作门牌号。 这条街一共有 2020 位住户，门牌号从 1 到 2020 编号。 小蓝制作门牌的方法是先制作 0 到 9 这几个数字字符，最后根据需要将字 符粘贴到门牌上，例如门牌 1017 需要依次粘贴字符 1、0、1、7，即需要 1 个 字符 0，2 个字符 1，1 个字符 7。 请问要制作所有的 1 到 2020 号门牌，总共需要多少个字符 2？</p>
</blockquote>
<p>傻逼题，算有多少个2，大概1分钟不到写完</p>
<h3 id="B-既约分数"><a href="#B-既约分数" class="headerlink" title="B. 既约分数"></a>B. 既约分数</h3><blockquote>
<p>如果一个分数的分子和分母的最大公约数是 1，这个分数称为既约分数。 例如，34 , 52 , 18 , 71 都是既约分数。 请问，有多少个既约分数，分子和分母都是 1 到 2020 之间的整数（包括 1 和 2020）？</p>
</blockquote>
<p>傻逼题，<code>__gcd()</code>搞完（我tm考试时居然脑抽手写了个gcd），大概1分钟不到写完</p>
<p>（看了一眼时间，大概过去了两分钟）</p>
<h3 id="C-蛇形填数"><a href="#C-蛇形填数" class="headerlink" title="C. 蛇形填数"></a>C. 蛇形填数</h3><blockquote>
<p>如下图所示，小明用从 1 开始的正整数“蛇形”填充无限大的矩阵。 </p>
<p>1 2 6 7 15 … </p>
<p>3 5 8 14 … </p>
<p>4 9 13 … </p>
<p>10 12 … </p>
<p>11 … … </p>
<p>(1) </p>
<p>容易看出矩阵第二行第二列中的数是 5。请你计算矩阵中第 20 行第 20 列 的数是多少？</p>
</blockquote>
<p>傻逼题，草稿纸上写写，就是+4、+8、+12，写个程序算一下就行</p>
<h3 id="D-跑步锻炼"><a href="#D-跑步锻炼" class="headerlink" title="D. 跑步锻炼"></a>D. 跑步锻炼</h3><blockquote>
<p>小蓝每天都锻炼身体。 正常情况下，小蓝每天跑 1 千米。如果某天是周一或者月初（1 日），为了 激励自己，小蓝要跑 2 千米。如果同时是周一或月初，小蓝也是跑 2 千米。 小蓝跑步已经坚持了很长时间，从 2000 年 1 月 1 日周六（含）到 2020 年 10 月 1 日周四（含）。请问这段时间小蓝总共跑步多少千米？</p>
</blockquote>
<p>艹了，日期处理啥的我最不会了，打开cmd输入<code>python</code>发现可以用，漂亮！先手算一共多少月，python算了一波一共多少天，然后excel算了一波有多少周一，然后右下角日历数了一下有多少周一和月初重合的，容斥一下解决（就这么简单一题我还整这么多花里胡哨的2333）</p>
<h3 id="E-七段码"><a href="#E-七段码" class="headerlink" title="E. 七段码"></a>E. 七段码</h3><blockquote>
<p>小蓝要用七段码数码管来表示一种特殊的文字。 上图给出了七段码数码管的一个图示，数码管中一共有 7 段可以发光的二 极管，分别标记为 a, b, c, d, e, f, g。 小蓝要选择一部分二极管（至少要有一个）发光来表达字符。在设计字符 的表达时，要求所有发光的二极管是连成一片的。 例如：b 发光，其他二极管不发光可以用来表达一种字符。 例如：c 发光，其他二极管不发光可以用来表达一种字符。这种方案与上 一行的方案可以用来表示不同的字符，尽管看上去比较相似。 例如：a, b, c, d, e 发光，f, g 不发光可以用来表达一种字符。 例如：b, f 发光，其他二极管不发光则不能用来表达一种字符，因为发光 的二极管没有连成一片。 请问，小蓝可以用七段码数码管表达多少种不同的字符？</p>
</blockquote>
<p>题意：大概就是一个 “日” 字形的灯管，可以点亮连续的一根或几根灯管，问可以形成多少种不同的图形？</p>
<p>看到题目第一反应：这题肯定要建图啊，然后dfs啥的，然而dfs不熟练，怕写错，果断手算，用了一页草稿纸写了自认为的所有情况，最后还检查了两遍，艹，还是漏了8个。。。这题没了</p>
<h2 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h2><h3 id="F-成绩统计"><a href="#F-成绩统计" class="headerlink" title="F. 成绩统计"></a>F. 成绩统计</h3><blockquote>
<p>小蓝给学生们组织了一场考试，卷面总分为 100 分，每个学生的得分都是 一个 0 到 100 的整数。 如果得分至少是 60 分，则称为及格。如果得分至少为 85 分，则称为优秀。 请计算及格率和优秀率，用百分数表示，百分号前的部分四舍五入保留整 数。</p>
</blockquote>
<p>傻逼题，四舍五入我+0.5取整处理的</p>
<h3 id="G-回文日期"><a href="#G-回文日期" class="headerlink" title="G. 回文日期"></a>G. 回文日期</h3><blockquote>
<p>2020 年春节期间，有一个特殊的日期引起了大家的注意：2020 年 2 月 2 日。因为如果将这个日期按 “yyyymmdd” 的格式写成一个 8 位数是 20200202， 恰好是一个回文数。我们称这样的日期是回文日期。 有人表示 20200202 是 “千年一遇” 的特殊日子。对此小明很不认同，因为 不到 2 年之后就是下一个回文日期：20211202 即 2021 年 12 月 2 日。 也有人表示 20200202 并不仅仅是一个回文日期，还是一个 ABABBABA 型的回文日期。对此小明也不认同，因为大约 100 年后就能遇到下一个 ABABBABA 型的回文日期：21211212 即 2121 年 12 月 12 日。算不上 “千 年一遇”，顶多算 “千年两遇”。 给定一个 8 位数的日期，请你计算该日期之后下一个回文日期和下一个 ABABBABA 型的回文日期各是哪一天。</p>
</blockquote>
<p>看到这种模拟题有点想吐，先看看下一题，好了，还是这题简单23333，总体思路就是枚举，需要判一下日期是否合法（闰年啥的）、日期是否回文、日期是否是ABABBABA回文，总体还是很简单的</p>
<h3 id="H-子串分值和"><a href="#H-子串分值和" class="headerlink" title="H. 子串分值和"></a>H. 子串分值和</h3><blockquote>
<p>对于一个字符串S ，我们定义S 的分值f (S) 为S 中出现的不同的字符个数。</p>
<p>例如f (”aba”) = 2, f (”abc”) = 3,  f (”aaa”) = 1。</p>
<p>现在给定一个字符串<script type="math/tex">S [0...n-1]</script>（长度为n），请你计算对于所有S 的非空子串$S[i…j] (0 \leq i\leq j &lt; n)$， $f (S [i…j])$ 的和是多少</p>
</blockquote>
<p>无脑先写个暴力骗50%再说，最后想倒数第二题用时过多，时间不够了555</p>
<h3 id="I-直线相交"><a href="#I-直线相交" class="headerlink" title="I. 直线相交"></a>I. 直线相交</h3><blockquote>
<p>计算n条直线将平面分成了几个部分</p>
</blockquote>
<p>无脑写了n&lt;=3的分类讨论，n&lt;=1000的，在草稿纸上手玩了几个样例，找了找规律，发现确实有规律，与每条直线和先前直线的交点数目有关，然而有点复杂，想了很久没想明白，再见吧，计算几何，一窍不通</p>
<h3 id="J-冒泡排序"><a href="#J-冒泡排序" class="headerlink" title="J. 冒泡排序"></a>J. 冒泡排序</h3><blockquote>
<p>小蓝最近学习了一些排序算法，其中冒泡排序让他印象深刻。在冒泡排序中，每次只能交换相邻的两个元素。小蓝发现，如果对一个字符串中的字符排序，只允许交换相邻的两个字符，则在所有可能的排序方案中，冒泡排序的总交换次数是最少的。</p>
<p>例如，对于字符串lan 排序，只需要1 次交换。对于字符串qiao 排序，总共需要4 次交换。小蓝的幸运数字是V，他想找到一个只包含小写英文字母的字符串，对这个串中的字符进行冒泡排序，正好需要V 次交换。请帮助小蓝找一个这样的字符串。如果可能找到多个，请告诉小蓝最短的那个。如果最短的仍然有多个，请告诉小蓝字典序最小的那个。请注意字符串中可以包含相同的字符。</p>
</blockquote>
<p>草稿纸上手模了几个案例，发现有点迷，但却是是有规律，然并卵，赛后听大佬讨论，说是从右往左，先填两个的，再填一个的，想想好像确实如此，但考场上就一步之遥，哎，还是太蒻了。。。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>思维混乱，只会模拟，不能满分，只能偏分</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>比赛记录</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树专题</title>
    <url>/2020/04/08/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h2 id="浅析：线段树（Segment-Tree）"><a href="#浅析：线段树（Segment-Tree）" class="headerlink" title="浅析：线段树（Segment Tree）"></a><center>浅析：线段树（Segment Tree）</center></h2><span id="more"></span>
<ul>
<li>可能我终于算是算法入门了，终于学到了线段树了，加油加油</li>
</ul>
<h2 id="线段树简介"><a href="#线段树简介" class="headerlink" title="线段树简介"></a>线段树简介</h2><p>说到线段树嘛，他就是形如下面这样的一颗<strong>二叉树</strong>，它一般用来<strong>维护对于一个序列的各种操作（比如让区间每个数加上一个数 等等）</strong>其中每个节点可以维护一段区间的某些值（比如最值、区间和、区间乘积、异或和 等等<strong>满足结合律的操作</strong>。。。），而<strong>每个叶子节点都是一个长度为1的区间</strong>，也就代表了序列本身对应下标的值</p>
<p><img src="https://i.loli.net/2020/04/11/FxuW6sfL45dbBkz.png" alt="image.png"></p>
<p>线段树操作的复杂度：</p>
<p>建树：$O(nlogn)$</p>
<p>一次区间操作：通常为$O(logn)$</p>
<h2 id="常规线段树"><a href="#常规线段树" class="headerlink" title="常规线段树"></a>常规线段树</h2><p>参考blog：</p>
<ul>
<li><a href="https://www.cnblogs.com/jason2003/p/9676729.html">线段树从入门到进阶</a></li>
</ul>
<h3 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h3><p>对于一般的线段树，我通常会开一个<strong>结构体</strong>来存储树的各种信息</p>
<p>注意事项：</p>
<ul>
<li><p><code>i&lt;&lt;1和1&lt;&lt;1|1</code>分别表示<strong>左儿子和右儿子</strong>，位运算能够加快速度，真香</p>
</li>
<li><p>对于区间加减之类的操作（其实乘除、开根号也要），我们都需要一个<strong>懒惰标记</strong>（lazy tag），这个稍后解释</p>
</li>
<li>需要开<strong>4倍空间</strong>，因为线段树不是一个满二叉树，但我们需要把它开满，防止溢出</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Stree</span>&#123;<br>    <span class="hljs-type">int</span> l,r,sum,lz;<span class="hljs-comment">//lz为懒惰标记</span><br>&#125;tr[N&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-comment">//</span><br></code></pre></div></td></tr></table></figure>
<p>那么开始建树</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    tr[i].l=l,tr[i].r=r,tr[i].lz=<span class="hljs-number">0</span>;<span class="hljs-comment">//加法的懒惰标记初始化为0</span><br>    <span class="hljs-keyword">if</span>(l==r)&#123;<span class="hljs-comment">//如果递归到了叶子节点</span><br>        tr[i].sum=a[l];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(i&lt;&lt;<span class="hljs-number">1</span>,l,mid);<span class="hljs-comment">//递归建左子树</span><br>    <span class="hljs-built_in">build</span>(i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-comment">//递归建右子树</span><br>    tr[i].sum=tr[i&lt;&lt;<span class="hljs-number">1</span>].sum+tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum;<span class="hljs-comment">//从叶子往根部更新区间和</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h3><p><del>是树状数组不香了吗？</del></p>
<p>这个就很简单了，直接像二分一样去找到这个下标所在的节点就好啦！</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">//下标位k的数+x</span><br>    <span class="hljs-keyword">if</span>(tr[i].l==tr[i].r)&#123;<br>        tr[i].sum+=x;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(tr[i&lt;&lt;<span class="hljs-number">1</span>].r&gt;=k) <span class="hljs-built_in">modify</span>(i&lt;&lt;<span class="hljs-number">1</span>,k,x);<span class="hljs-comment">//往哪跑？</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,k,x);<br>    tr[i].sum=tr[i&lt;&lt;<span class="hljs-number">1</span>].sum+tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum;<span class="hljs-comment">//记得改完了要更新</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="区间加法（减法）"><a href="#区间加法（减法）" class="headerlink" title="区间加法（减法）"></a>区间加法（减法）</h3><p>对于一个序列，我们需要让<code>[l,r]</code>区间内所有数+k，那么怎么操作呢？</p>
<p>显然如果我们执行（r-l+1）次单点修改的话，时间绝对会炸，因此我们需要更聪明的办法，这个办法就是之前提到的<strong>懒惰标记</strong></p>
<p>当我们需要给一个区间的数都加上k时，如果线段树的当前节点包含在这个区间里面，那么我们肯定是要先把这个节点维护的区间和加上<code>（区间长度）*k</code>的值，这是毫无疑问的，但他的儿子区间都要改啊，这太麻烦了，反正现在也不用求答案，倒不如先不对这个区间的儿子进行操作了，先给它打上一个“+k”的标记，我们之后要是要求求和再把这个标记<strong>下放</strong>到儿子们的区间，那时候再操作也不迟~</p>
<p>这个方法好聪明啊！因此我们在区间修改和查询的时候都需要<strong>把懒惰标记下放</strong>，同时要让父亲的懒惰标记清零</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[i].l&gt;=l&amp;&amp;tr[i].r&lt;=r)&#123;<br>        tr[i].sum+=(tr[i].r-tr[i].l+<span class="hljs-number">1</span>)*k;<span class="hljs-comment">//区间和需要对应加上k*(区间长度)</span><br>        tr[i].lz+=k;<span class="hljs-comment">//懒惰标记也要加k</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">push_down</span>(i); <span class="hljs-comment">//核心：下放操作</span><br>    <span class="hljs-keyword">if</span>(tr[i&lt;&lt;<span class="hljs-number">1</span>].r&gt;=l) <span class="hljs-built_in">add</span>(i&lt;&lt;<span class="hljs-number">1</span>,l,r,k);<br>    <span class="hljs-keyword">if</span>(tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].l&lt;=r) <span class="hljs-built_in">add</span>(i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r,k);<br>    tr[i].sum=tr[i&lt;&lt;<span class="hljs-number">1</span>].sum+tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum;<span class="hljs-comment">//维护区间和</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>那么这个<strong>下放操作</strong>怎么写呢？</p>
<p>对于最简单的<strong>区间加法</strong>，下放操作就是把加法标记下放给他儿子，同时更新它儿子所维护的区间和就行了</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[i].lz==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    tr[i&lt;&lt;<span class="hljs-number">1</span>].lz+=tr[i].lz;<br>    tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].lz+=tr[i].lz;<br>    tr[i&lt;&lt;<span class="hljs-number">1</span>].sum+=(tr[i&lt;&lt;<span class="hljs-number">1</span>].r-tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].l+<span class="hljs-number">1</span>)*tr[i].lz;<br>    tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum+=(tr[i&lt;&lt;<span class="hljs-number">1</span>].r-tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].l+<span class="hljs-number">1</span>)*tr[i].lz;<br>    tr[i].lz=<span class="hljs-number">0</span>;<span class="hljs-comment">//这一步别忘了，不然会死的很惨</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="询问区间和"><a href="#询问区间和" class="headerlink" title="询问区间和"></a>询问区间和</h3><p>对于询问区间和操作，其实就很简单了，如果线段树当前节点对应区间被包含在了询问的区间里，那么直接返回该节点对应的sum即可，否则，就递归地去找左子树和右子树，更新答案（对了，别忘记下放标记，因为这个标记很懒，你不手动下放他是不会动的，哈哈哈~）</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[i].l&gt;=l&amp;&amp;tr[i].r&lt;=r) <span class="hljs-keyword">return</span> tr[i].sum;<br>    <span class="hljs-built_in">push_down</span>(i);<span class="hljs-comment">//切记！！！</span><br>    ll res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(tr[i&lt;&lt;<span class="hljs-number">1</span>].r&gt;=l) res+=<span class="hljs-built_in">getsum</span>(i&lt;&lt;<span class="hljs-number">1</span>,l,r);<br>    <span class="hljs-keyword">if</span>(tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].l&lt;=r) res+=<span class="hljs-built_in">getsum</span>(i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="维护区间最值"><a href="#维护区间最值" class="headerlink" title="维护区间最值"></a>维护区间最值</h3><p>对于这个操作，我们可以像维护区间和一样维护，而修改和下放操作也需要加上对应的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<span class="hljs-comment">//建树时需要维护</span><br>    ...<br>    tr[i].mx=<span class="hljs-built_in">max</span>(tr[i&lt;&lt;<span class="hljs-number">1</span>].mx,tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].mx);<br>    tr[i].mn=<span class="hljs-built_in">min</span>(tr[i&lt;&lt;<span class="hljs-number">1</span>].mn,tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].mn);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//各种修改的时候也需要维护</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<span class="hljs-comment">//下放时需要维护</span><br>    ...<br>    tr[i&lt;&lt;<span class="hljs-number">1</span>].mx+=tr[i].lz;<br>    tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].mx+=tr[i].lz;<br>    tr[i&lt;&lt;<span class="hljs-number">1</span>].mn+=tr[i].lz;<br>    tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].mn+=tr[i].lz;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="区间乘法-加法（减法）"><a href="#区间乘法-加法（减法）" class="headerlink" title="区间乘法+加法（减法）"></a>区间乘法+加法（减法）</h3><p><a href="https://www.luogu.com.cn/problem/P3373">模板题 线段树2</a></p>
<p>单独一个区间乘法就很简单了，只需要把上面的懒惰标记改成乘，加号都改为乘号就行了，十分简单，但是如果是<strong>乘法和加法</strong>同时出现的话，就没这么简单了</p>
<p>因为，我们需要考虑到，对于懒惰标记的操作，到底是<strong>先乘再加 还是 先加再乘？</strong></p>
<p>事实表明，<strong>先乘再加</strong>是最好的解法，我们需要维护两个标记（加法标记and乘法标记），在下放标记的时候，只需要将乘法标记直接下放，而加法标记需要<strong>先乘以乘法标记再加上下放的加法标记</strong>，然后更新一下儿子们维护的区间和（同上）就行了</p>
<p>下放操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<span class="hljs-comment">//区间加乘的下放操作</span><br>    <span class="hljs-type">int</span> k1=tr[i].plz,k2=tr[i].mlz;<span class="hljs-comment">//plz:加法标记，mlz:乘法标记</span><br>    tr[i&lt;&lt;<span class="hljs-number">1</span>].sum=(tr[i&lt;&lt;<span class="hljs-number">1</span>].sum*k2+k1*(tr[i&lt;&lt;<span class="hljs-number">1</span>].r-tr[i&lt;&lt;<span class="hljs-number">1</span>].l+<span class="hljs-number">1</span>))%p;<br>    tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum=(tr[i&lt;&lt;<span class="hljs-number">1</span>].sum*k2+k1*(tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].r-tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].l+<span class="hljs-number">1</span>))%p;<span class="hljs-comment">//先乘再加</span><br>    tr[i&lt;&lt;<span class="hljs-number">1</span>].plz=(tr[i&lt;&lt;<span class="hljs-number">1</span>].plz*k2+k1)%p;<br>    tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].plz=(tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].plz*k2+k1)%p;<br>    tr[i&lt;&lt;<span class="hljs-number">1</span>].mlz=(tr[i&lt;&lt;<span class="hljs-number">1</span>].mlz*k2)%p;<br>    tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].mlz=(tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].mlz*k2)%p;<br>    tr[i].mlz=<span class="hljs-number">1</span>;<span class="hljs-comment">//乘法标记初始化一定是1</span><br>    tr[i].plz=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>对于区间修改操作，区间加法我们可以无脑直接加，而区间乘法则需要<strong>同时把加法标记乘以这个数k</strong></p>
<p>修改操作：（<code>[l,r]</code>内每个数加上、乘以k）</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<span class="hljs-comment">//区间加法</span><br>    <span class="hljs-keyword">if</span>(tr[i].l&gt;=l&amp;&amp;tr[i].r&lt;=r)&#123;<br>        tr[i].sum=(tr[i].sum+k*(tr[i].r-tr[i].l+<span class="hljs-number">1</span>))%p;<br>        tr[i].plz=(tr[i].plz+k)%p;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    ...<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<span class="hljs-comment">//区间乘法</span><br>    <span class="hljs-keyword">if</span>(tr[i].l&gt;=l&amp;&amp;tr[i].r&lt;=r)&#123;<br>        tr[i].sum=(tr[i].sum*k)%p;<br>        tr[i].plz=(tr[i].plz*k)%p;<span class="hljs-comment">//加法标记一定要要对应*k</span><br>        tr[i].mlz=(tr[i].mlz*k)%p;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="区间除法-amp-区间开根号"><a href="#区间除法-amp-区间开根号" class="headerlink" title="区间除法&amp;区间开根号"></a>区间除法&amp;区间开根号</h3><p><a href="https://www.luogu.com.cn/problem/P4145">区间开根号模板题：花神游历各国</a></p>
<p>对于这两种操作，显然他们<strong>不满足结合律</strong>，但是，这样我们就不能线段树了吗？</p>
<p>大错特错！我们来考虑除法与开根号这些运算的特性：他们都会使得一堆元素（整数）不断地减小，并且趋于一个值（除法趋于0，开根号趋于1）</p>
<p>针对除法来说：对于一个区间的所有元素而言，如果这个<strong>区间内元素最大值与他除以除数所得商的差值 等于 最小值与他除以除数所得商的差值</strong>，那么这个区间内的所有元素除以除数都会减去同一个数，于是就可以给这个区间的<strong>加法标记</strong>做一点操作，就可以把区间除法转换成区间减法啦！</p>
<p>同理，如果这个区间的<strong>最大值与它开根号的差值</strong> 等于 <strong>最小值与它开根号的差值</strong>，那么这个区间内的所有元素开根号都会减去同一个数，我们就能把开根号转换为减法啦！</p>
<p>所以说，对于区间除法和区间开根号操作，他们都可以<strong>转化为区间减法</strong>操作来优化复杂度（这十分重要，否则就是一个单纯的暴力了呀~）</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Sqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<span class="hljs-comment">//区间开根号</span><br>    <span class="hljs-keyword">if</span>(tr[i].l&gt;=l&amp;&amp;tr[i].r&lt;=r)&#123;<br>        <span class="hljs-type">int</span> k1=tr[i].mx-<span class="hljs-built_in">floor</span>(<span class="hljs-built_in">sqrt</span>(tr[i].mx));<span class="hljs-comment">//核心，转换为减法</span><br>        <span class="hljs-type">int</span> k2=tr[i].mn-<span class="hljs-built_in">floor</span>(<span class="hljs-built_in">sqrt</span>(tr[i].mn));<br>        <span class="hljs-keyword">if</span>(k1==k2)&#123;<span class="hljs-comment">//判断是否可以对整个区间操作</span><br>            tr[i].lz-=k1;<br>            tr[i].sum-=k1*(tr[i].r-tr[i].l+<span class="hljs-number">1</span>);<br>            tr[i].mx-=k1;<br>            tr[i].mn-=k1;<br>            <span class="hljs-keyword">return</span>;<span class="hljs-comment">//这个return要写在里面</span><br>        &#125;<br>    &#125;<br>	...<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<span class="hljs-comment">//区间除法</span><br>    ...<br>    <span class="hljs-keyword">if</span>(tr[i].l&gt;=l&amp;&amp;tr[i].r&lt;=r)&#123;<br>        <span class="hljs-type">int</span> k1=tr[i].mx-tr[i].mx/k;<span class="hljs-comment">//核心</span><br>        <span class="hljs-type">int</span> k2=tr[i].mn-tr[i].mn/k;<br>        <span class="hljs-keyword">if</span>(k1==k2)&#123;<br>            tr[i].sum-=k1*(tr[i].r-tr[i].l+<span class="hljs-number">1</span>);<br>            tr[i].lz-=k1;<br>            tr[i].mx-=k1;<br>            tr[i].mn-=k1;<br>        &#125;<br>    &#125;<br>    ...<span class="hljs-comment">//其他都一样</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>然而，对于区间开根号操作，还有更好的办法：对于一个很大的数，我们只要不断对其开根号，用不了几次它就会变成1，那么我们可以通过<strong>维护区间最大值是否小于等于1来判断这个区间是否有必要操作</strong>，这样就可以大大优化时间复杂度</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Sqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[i].l==tr[i].r)&#123;<br>        tr[i].sum=tr[i].mx=<span class="hljs-built_in">sqrt</span>(tr[i].sum);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">push_down</span>(i);<br>    <span class="hljs-comment">//判断是否有必要对这个区间开根号</span><br>    <span class="hljs-keyword">if</span>(tr[i&lt;&lt;<span class="hljs-number">1</span>].r&gt;=l&amp;&amp;tr[i&lt;&lt;<span class="hljs-number">1</span>].mx&gt;<span class="hljs-number">1</span>) <span class="hljs-built_in">Sqrt</span>(i&lt;&lt;<span class="hljs-number">1</span>,l,r);<br>    <span class="hljs-keyword">if</span>(tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].l&lt;=r&amp;&amp;tr[i&lt;&lt;<span class="hljs-number">1</span>|].mx&gt;<span class="hljs-number">1</span>) <span class="hljs-built_in">Sqrt</span>(i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r);<br>    tr[i].sum=tr[i&lt;&lt;<span class="hljs-number">1</span>].sum+tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum;<br>    tr[i].mx=<span class="hljs-built_in">max</span>(tr[i&lt;&lt;<span class="hljs-number">1</span>].mx,tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].mx);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>UPD 2020.6.8</p>
<p>这几天学校训练做了一道类似的题<a href="https://ac.nowcoder.com/acm/contest/6015/C">USST训练赛9 时间管理</a>，题意大概是<strong>区间gcd修改+区间求和</strong>，对于区间gcd，可以同样用线段数（或分块）维护区间的值是否相同，若相同，直接$O(1)$修改该区间和即可，因为gcd操作和开根号操作一样，总是让一段区间趋于1的</p>
<details>
<summary>线段树</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">ll a[maxn],n,m;<br><span class="hljs-comment">/* Normal Segment Tree */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegmentTree</span><br>&#123;	<br>	<span class="hljs-meta">#<span class="hljs-keyword">define</span> ls i&lt;&lt;1</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">define</span> rs i&lt;&lt;1|1</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tree</span>&#123;<br>		<span class="hljs-type">int</span> l,r;<br>		ll sum,ptg,minh,maxh;<br>	&#125;tr[maxn&lt;&lt;<span class="hljs-number">2</span>];<br><br>	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>		tr[i].sum=tr[ls].sum+tr[rs].sum;<br>		tr[i].minh=<span class="hljs-built_in">min</span>(tr[ls].minh,tr[rs].minh);<br>		tr[i].maxh=<span class="hljs-built_in">max</span>(tr[ls].maxh,tr[rs].maxh);<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>		<span class="hljs-keyword">if</span>(tr[i].ptg==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>		ll k=tr[i].ptg;<br>		tr[ls].sum+=k*(tr[ls].r-tr[ls].l+<span class="hljs-number">1</span>);<br>		tr[rs].sum+=k*(tr[rs].r-tr[rs].l+<span class="hljs-number">1</span>);<br>		tr[ls].minh+=k;<br>		tr[ls].maxh+=k;<br>		tr[rs].minh+=k;<br>		tr[rs].maxh+=k;<br>		tr[ls].ptg+=k;<br>		tr[rs].ptg+=k;<br>		tr[i].ptg=<span class="hljs-number">0</span>;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>		tr[i].l=l,tr[i].r=r;<br>		tr[i].ptg=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">if</span>(tr[i].l==tr[i].r)&#123;<br>			tr[i].sum=a[l];<br>			tr[i].minh=a[l];<br>			tr[i].maxh=a[l];<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>		<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>		<span class="hljs-built_in">build</span>(ls,l,mid);<br>		<span class="hljs-built_in">build</span>(rs,mid+<span class="hljs-number">1</span>,r);<br>		<span class="hljs-built_in">push_up</span>(i);<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,ll k)</span></span>&#123;<br>		<span class="hljs-keyword">if</span>(tr[i].l&gt;=l&amp;&amp;tr[i].r&lt;=r)&#123;<br>			<span class="hljs-keyword">if</span>(tr[i].minh==tr[i].maxh)&#123;<br>				ll tp=<span class="hljs-built_in">gcd</span>(tr[i].minh,k)-tr[i].minh;<br>				tr[i].sum+=tp*(tr[i].r-tr[i].l+<span class="hljs-number">1</span>);<br>				tr[i].ptg+=tp;<br>				tr[i].minh+=tp;<br>				tr[i].maxh+=tp;<br>				<span class="hljs-keyword">return</span>;<br>			&#125;<br>		&#125;<br>		<span class="hljs-built_in">push_down</span>(i);<br>		<span class="hljs-keyword">if</span>(tr[ls].r&gt;=l) <span class="hljs-built_in">change</span>(ls,l,r,k);<br>		<span class="hljs-keyword">if</span>(tr[rs].l&lt;=r) <span class="hljs-built_in">change</span>(rs,l,r,k);<br>		<span class="hljs-built_in">push_up</span>(i);<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>		<span class="hljs-keyword">if</span>(tr[i].l&gt;=l&amp;&amp;tr[i].r&lt;=r)<br>			<span class="hljs-keyword">return</span> tr[i].sum;<br>		<span class="hljs-built_in">push_down</span>(i);<br>		ll res=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">if</span>(tr[ls].r&gt;=l) res+=<span class="hljs-built_in">getsum</span>(ls,l,r);<br>		<span class="hljs-keyword">if</span>(tr[rs].l&lt;=r) res+=<span class="hljs-built_in">getsum</span>(rs,l,r);<br>		<span class="hljs-keyword">return</span> res;<br>	&#125;<br>&#125;T;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">read</span>(n),<span class="hljs-built_in">read</span>(m);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">read</span>(a[i]);<br>	T.<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br>	<span class="hljs-type">int</span> op,l,r,x;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m)&#123;<br>		<span class="hljs-built_in">read</span>(op),<span class="hljs-built_in">read</span>(l),<span class="hljs-built_in">read</span>(r);<br>		<span class="hljs-keyword">if</span>(op&amp;<span class="hljs-number">1</span>)&#123;<br>			<span class="hljs-built_in">read</span>(x);<br>			T.<span class="hljs-built_in">change</span>(<span class="hljs-number">1</span>,l,r,x);<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,T.<span class="hljs-built_in">getsum</span>(<span class="hljs-number">1</span>,l,r));<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<details>
    <summary>分块</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><br>ll a[maxn],n,m,blk,bel[maxn],sz[maxn],st[maxn],en[maxn],tg[maxn];<br>ll minh[maxn],maxh[maxn];<br>ll sum[maxn];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init_blk</span><span class="hljs-params">()</span></span>&#123;<br>	blk=<span class="hljs-built_in">sqrt</span>(n);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,blk)&#123;<br>		st[i]=n/blk*(i<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>;<br>		en[i]=n/blk*i;<br>		minh[i]=inf;<br>		maxh[i]=-inf;<br>	&#125;<br>	en[blk]=n;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,blk)&#123;<br>		sz[i]=en[i]-st[i]+<span class="hljs-number">1</span>;<br>		<span class="hljs-built_in">rep</span>(j,st[i],en[i])&#123;<br>			bel[j]=i;<br>			minh[i]=<span class="hljs-built_in">min</span>(minh[i],a[j]);<br>			maxh[i]=<span class="hljs-built_in">max</span>(maxh[i],a[j]);<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(ll l,ll r,ll x)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(bel[l]==bel[r])&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r;i++)&#123;<br>			a[i]=<span class="hljs-built_in">gcd</span>(a[i]+tg[bel[l]],x);<br>		&#125;<br>		minh[bel[l]]=inf,maxh[bel[l]]=-inf;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=st[bel[l]];i&lt;=en[bel[l]];i++)&#123;<br>			<span class="hljs-keyword">if</span>(i&lt;l||i&gt;r) a[i]+=tg[bel[l]];<br>			minh[bel[l]]=<span class="hljs-built_in">min</span>(minh[bel[l]],a[i]),<br>			maxh[bel[l]]=<span class="hljs-built_in">max</span>(maxh[bel[l]],a[i]);<br>		&#125;<br>		tg[bel[l]]=<span class="hljs-number">0</span>;<br>	&#125;<span class="hljs-keyword">else</span>&#123;<br>		<span class="hljs-comment">// left blk</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=en[bel[l]];i++)&#123;<br>			a[i]=<span class="hljs-built_in">gcd</span>(a[i]+tg[bel[l]],x);<br>		&#125;<br>		minh[bel[l]]=inf,maxh[bel[l]]=-inf;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=st[bel[l]];i&lt;=en[bel[l]];i++)&#123;<br>			<span class="hljs-keyword">if</span>(i&lt;l) a[i]+=tg[bel[l]];<br>			minh[bel[l]]=<span class="hljs-built_in">min</span>(minh[bel[l]],a[i]),<br>			maxh[bel[l]]=<span class="hljs-built_in">max</span>(maxh[bel[l]],a[i]);<br>		&#125;<br>		tg[bel[l]]=<span class="hljs-number">0</span>;<br>		<span class="hljs-comment">// right blk</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=st[bel[r]];i&lt;=r;i++)&#123;<br>			a[i]=<span class="hljs-built_in">gcd</span>(a[i]+tg[bel[r]],x);<br>		&#125;<br>		minh[bel[r]]=inf,maxh[bel[r]]=-inf;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=st[bel[r]];i&lt;=en[bel[r]];i++)&#123;<br>			<span class="hljs-keyword">if</span>(i&gt;r) a[i]+=tg[bel[r]];<br>			minh[bel[r]]=<span class="hljs-built_in">min</span>(minh[bel[r]],a[i]),<br>			maxh[bel[r]]=<span class="hljs-built_in">max</span>(maxh[bel[r]],a[i]);<br>		&#125;<br>		tg[bel[r]]=<span class="hljs-number">0</span>;<br>		<span class="hljs-comment">// middle whole blk</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=bel[l]+<span class="hljs-number">1</span>;i&lt;=bel[r]<span class="hljs-number">-1</span>;i++)&#123;<br>			<span class="hljs-keyword">if</span>(minh[i]==maxh[i])&#123;<br>				<span class="hljs-type">int</span> tp=<span class="hljs-built_in">gcd</span>(minh[i],x);<br>				tg[i]+=tp-minh[i];<br>				minh[i]=maxh[i]=tp;<br>			&#125;<span class="hljs-keyword">else</span>&#123;<br>				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=st[i];j&lt;=en[i];j++)&#123;<br>					a[j]=<span class="hljs-built_in">gcd</span>(a[j]+tg[i],x);<br>				&#125;<br>				minh[i]=inf,maxh[i]=-inf;<br>				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=st[i];j&lt;=en[i];j++)&#123;<br>					minh[i]=<span class="hljs-built_in">min</span>(minh[i],a[j]),<br>					maxh[i]=<span class="hljs-built_in">max</span>(maxh[i],a[j]);<br>				&#125;<br>				tg[i]=<span class="hljs-number">0</span>;<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">getsum</span><span class="hljs-params">(ll l,ll r)</span></span>&#123;<br>	ll res=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">if</span>(bel[l]==bel[r])&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r;i++)&#123;<br>			res+=(a[i]+tg[bel[l]]);<br>		&#125;<br>	&#125;<span class="hljs-keyword">else</span>&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=en[bel[l]];i++)&#123;<br>			res+=(a[i]+tg[bel[l]]);<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=st[bel[r]];i&lt;=r;i++)&#123;<br>			res+=(a[i]+tg[bel[r]]);<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=bel[l]+<span class="hljs-number">1</span>;i&lt;=bel[r]<span class="hljs-number">-1</span>;i++)&#123;<br>			<span class="hljs-keyword">if</span>(minh[i]==maxh[i])&#123;<br>				res+=(sz[i]*minh[i]);<br>			&#125;<span class="hljs-keyword">else</span>&#123;<br>				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=st[i];j&lt;=en[i];j++)&#123;<br>					res+=(a[j]+tg[i]);<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">read</span>(n),<span class="hljs-built_in">read</span>(m);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">read</span>(a[i]);<br>	<span class="hljs-built_in">init_blk</span>();<br>	<span class="hljs-type">int</span> op,l,r,x;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m)&#123;<br>		<span class="hljs-built_in">read</span>(op),<span class="hljs-built_in">read</span>(l),<span class="hljs-built_in">read</span>(r);<br>		<span class="hljs-keyword">if</span>(op&amp;<span class="hljs-number">1</span>)&#123;<br>			<span class="hljs-built_in">read</span>(x);<br>			<span class="hljs-built_in">change</span>(l,r,x);<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">getsum</span>(l,r));<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h3 id="Lazy-Tag的用途"><a href="#Lazy-Tag的用途" class="headerlink" title="Lazy Tag的用途"></a>Lazy Tag的用途</h3><p>来源于这道典型例题：<a href="https://www.luogu.com.cn/problem/UVA10587">Mayor’s posters</a>（线段树+离散化）</p>
<p>就像铺地毯一样，我们不停地在某些区间上铺一些地毯，最后问能在整个区间看到多少种颜色的地毯？</p>
<p>这题我们离线做<del>（动态开点目前没学orz）</del>，首先离散化三部曲（排序 去重 二分插入，否则你会MLE）我就不多说了，那么这个题怎么用Lzay Tag来维护呢，我们很容易想到整个区间的种类数比较好求，只要开一个vis数组记录就行了，而这个离线的区间更新怎么做呢？我们思考区间求和的懒惰标记是维护的求和的加数，但是我们这是维护一个颜色（即种类），如果一个区间的子区间的颜色在后来被修改了，那么我们就需要把这个区间的lazytag下放，直到给到那个被修改的子区间，然后把那个修改的子区间的颜色改成要修改成的颜色，这样一来，维护了这个区间其他子区间颜色没变，而只改变了这一个区间的颜色，非常巧妙</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br>ll t,n,tot,l,r,vis[N],b[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>	ll l,r;<br>&#125;a[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Stree</span>&#123;<br>	ll l,r,col;<br>&#125;tree[N&lt;&lt;<span class="hljs-number">2</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">memset</span>(b,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(b));<br>	<span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<br>	ll temp=<span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;n);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;a[i].l,&amp;a[i].r);<br>		b[++temp]=a[i].l,b[++temp]=a[i].r;<br>	&#125;<br>	<span class="hljs-built_in">sort</span>(b+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>+temp);<br>	tot=<span class="hljs-built_in">unique</span>(b+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>+temp)-b<span class="hljs-number">-1</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		a[i].l=<span class="hljs-built_in">lower_bound</span>(b+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>+tot,a[i].l)-b;<br>		a[i].r=<span class="hljs-built_in">lower_bound</span>(b+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>+tot,a[i].r)-b;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(ll i,ll l,ll r)</span></span>&#123;<br>	tree[i].l=l,tree[i].r=r,tree[i].col=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">if</span>(l==r)&#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	ll mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>	<span class="hljs-built_in">build</span>(i&lt;&lt;<span class="hljs-number">1</span>,l,mid);<br>	<span class="hljs-built_in">build</span>(i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br>	<span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(ll i)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(tree[i].col==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>	tree[i&lt;&lt;<span class="hljs-number">1</span>].col=tree[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].col=tree[i].col;<br>	tree[i].col=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(ll i,ll l,ll r,ll col)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(tree[i].l&gt;=l&amp;&amp;tree[i].r&lt;=r)&#123;<br>		tree[i].col=col;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-built_in">push_down</span>(i);<br>	<span class="hljs-keyword">if</span>(tree[i&lt;&lt;<span class="hljs-number">1</span>].r&gt;=l) <span class="hljs-built_in">update</span>(i&lt;&lt;<span class="hljs-number">1</span>,l,r,col);<br>	<span class="hljs-keyword">if</span>(tree[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].l&lt;=r) <span class="hljs-built_in">update</span>(i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r,col);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">search</span><span class="hljs-params">(ll i,ll l,ll r,ll &amp;ans)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(tree[i].col)&#123;<br>		<span class="hljs-keyword">if</span>(!vis[tree[i].col])&#123;<br>			vis[tree[i].col]=<span class="hljs-number">1</span>;<br>			ans++;<br>		&#125;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-built_in">search</span>(i&lt;&lt;<span class="hljs-number">1</span>,l,r,ans);<br>	<span class="hljs-built_in">search</span>(i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r,ans);<br>	<span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">ask</span><span class="hljs-params">(ll l,ll r)</span></span>&#123;<br>	ll ans=<span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">search</span>(<span class="hljs-number">1</span>,l,r,ans);<br>	<span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;t);<br>    <span class="hljs-keyword">while</span>(t--)&#123;<br>    	<span class="hljs-built_in">init</span>();<br>	    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,tot);<br>	    ll col=<span class="hljs-number">0</span>;<br>	    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>	    	<span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>,a[i].l,a[i].r,++col);<br>		&#125;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">ask</span>(<span class="hljs-number">1</span>,tot));<br>	&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h2 id="权值线段树"><a href="#权值线段树" class="headerlink" title="权值线段树"></a>权值线段树</h2><p>例题：<a href="https://www.luogu.com.cn/problem/P1801">洛谷 P1801 黑匣子</a>（离散化+权值线段树）</p>
<p>与一般的线段树有一点区别：权值线段树的每个叶子节点就<strong>代表了数列中一个具体的值</strong>（我们称之为<strong>权值</strong>），而每个叶子节点<strong>维护的是这个具体的值在整个数列中出现的次数</strong>，每一个父亲节点<strong>维护了一段区间的值出现的总次数</strong>，这样一来，权值线段树的意义就很明朗了</p>
<p>权值线段树的一个重要应用：<strong>求整个数列中第k大（第k小）的数</strong>（注意是整个数列）</p>
<p>算法：权值线段树的基本操作和普通线段树几乎相同，需要注意的是以下几点：</p>
<ul>
<li><p>每个节点维护的不再是权值or区间和，而是<strong>该节点代表数字出现的次数</strong></p>
<p>比如我们可以开一个结构体存储</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Stree</span>&#123;<br>    <span class="hljs-type">int</span> l,r;<span class="hljs-comment">//维护该子树对应的左右区间端点</span><br>    <span class="hljs-type">int</span> v;<span class="hljs-comment">//维护数的出现次数</span><br>&#125;tr[N&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-comment">//照样开4倍大</span><br></code></pre></div></td></tr></table></figure>
</li>
<li><p>更新操作（比如插入了一个数），就是递归找到该数对应的叶子节点，给节点维护的次数+1</p>
</li>
<li><p>询问操作（以询问第k小为例），递归地找，如果左子树内有大于等于k个数字，那么就递归进入左子树找第k小，否则就递归进入右子树找第<code>k-tr[rs].v</code>小</p>
</li>
</ul>
<p>例题代码：</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ls (i&lt;&lt;1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs (i&lt;&lt;1|1)</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n,m,b[N],c[N],cnt=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>	<span class="hljs-type">int</span> val,id;<br>&#125;a[N];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node x1,node x2)</span></span>&#123;<br>	<span class="hljs-keyword">return</span> x1.val&lt;x2.val;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Stree</span>&#123;<br>	<span class="hljs-type">int</span> l,r,v;<br>&#125;tr[N&lt;&lt;<span class="hljs-number">2</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<span class="hljs-comment">//建树</span><br>	tr[i].l=l,tr[i].r=r;<br>	<span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span>;<br>	<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>	<span class="hljs-built_in">build</span>(ls,l,mid);<br>	<span class="hljs-built_in">build</span>(rs,mid+<span class="hljs-number">1</span>,r);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">//插入并更新</span><br>	<span class="hljs-keyword">if</span>(tr[i].l==tr[i].r)&#123;<br>		tr[i].v++;<span class="hljs-comment">//次数+1</span><br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-keyword">if</span>(tr[ls].r&gt;=x) <span class="hljs-built_in">update</span>(ls,x);<span class="hljs-comment">//找到位置</span><br>	<span class="hljs-keyword">else</span> <span class="hljs-built_in">update</span>(rs,x);<br>	tr[i].v=tr[ls].v+tr[rs].v;<span class="hljs-comment">//push_up</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getval</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> k)</span></span>&#123;<span class="hljs-comment">//获得对应权值</span><br>	<span class="hljs-keyword">if</span>(tr[i].l==tr[i].r)&#123;<br>		<span class="hljs-keyword">return</span> tr[i].l;<br>	&#125;<br>	<span class="hljs-keyword">if</span>(tr[ls].v&gt;=k) <span class="hljs-keyword">return</span> <span class="hljs-built_in">getval</span>(ls,k);<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">getval</span>(rs,k-tr[ls].v);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i].val),a[i].id=i;<br>    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">1</span>+n,cmp);<span class="hljs-comment">//离散化排序</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) c[a[i].id]=i;<span class="hljs-comment">//找出每个点的相对大小位置</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;b[i]);<br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    	<span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>,c[i]);<span class="hljs-comment">//插入操作</span><br>    	<span class="hljs-keyword">while</span>(b[cnt]==i)&#123;<br>    		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,a[<span class="hljs-built_in">getval</span>(<span class="hljs-number">1</span>,cnt)].val); <br>    		cnt++;<br>		&#125;<br>	&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h2 id="动态开点线段树"><a href="#动态开点线段树" class="headerlink" title="动态开点线段树"></a>动态开点线段树</h2><p>参考blog：</p>
<ul>
<li><p><a href="https://www.cnblogs.com/light-house/p/11756048.html">[线段树系列]动态开点线段树</a></p>
</li>
<li><p><a href="http://doc.okbase.net/GuZhenYin/archive/259026.html">动态开点线段树</a></p>
</li>
</ul>
<p>这东西就比较神了，它是线段树的<del>（阉割）</del>简化版，原理就是：我们不会在询问出现之前就利用build函数建立一颗完整的<strong>满二叉树</strong>结构的线段树（因为这样可能会有很多节点的空间没有用上，浪费了空间），而是采用<strong>边询问边建树</strong>的方式<strong>动态开点</strong>，这样以来，不用的节点我们不开，用的节点我们用的时候再开，可以很高效地处理<strong>值域较大（1e9），但是操作次数较少（1e5）</strong>的操作，或是需要<strong>建立多棵独立的线段树</strong>的时候</p>
<p>通常情况下，我们为动态开点线段树开<strong>（修改次数*40）</strong>的空间（类似主席树），然后根据RE和MLE来修改空间，其余特征和普通线段树无差异（pushdown下放，pushup更新）</p>
<p>注意事项：</p>
<ul>
<li>我们不再开结构体（可以但没必要）存树，因为它不再满足儿子节点为根节点编号的两倍和两倍加一原则（不是满二叉树），而是利用一个<strong>时间戳编号</strong>来存储节点编号</li>
<li>也不需要存储每个节点所对应的区间左右端点值（其实普通线段树也没必要存）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> ls[N*<span class="hljs-number">40</span>],rs[N*<span class="hljs-number">40</span>],tg[N*<span class="hljs-number">40</span>],rt,ncnt;<br>ll sum[N*<span class="hljs-number">40</span>];<br><span class="hljs-comment">//rt为根节点编号，ncnt为节点数（时间戳），动态开点时用到</span><br></code></pre></div></td></tr></table></figure>
<p>下面放<a href="https://www.luogu.com.cn/problem/P3372">线段树1</a>的动态开点形式：</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n,m,op,x,y,k,ls[N*<span class="hljs-number">40</span>],rs[N*<span class="hljs-number">40</span>],tg[N*<span class="hljs-number">40</span>],rt,ncnt;<br>ll sum[N*<span class="hljs-number">40</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> o)</span></span>&#123;<br>	sum[o]=sum[ls[o]]+sum[rs[o]];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;o,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> k)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(!o) o=++ncnt;<br>	<span class="hljs-keyword">if</span>(l==r)&#123;<br>		sum[o]+=<span class="hljs-number">1ll</span>*k;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span>(mid&gt;=x) <span class="hljs-built_in">init</span>(ls[o],l,mid,x,k);<br>	<span class="hljs-keyword">else</span> <span class="hljs-built_in">init</span>(rs[o],mid+<span class="hljs-number">1</span>,r,x,k);<br>	<span class="hljs-built_in">pushup</span>(o);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-type">int</span> o,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(!tg[o]) <span class="hljs-keyword">return</span>;<br>	<span class="hljs-keyword">if</span>(!ls[o]) ls[o]=++ncnt;<br>	<span class="hljs-keyword">if</span>(!rs[o]) rs[o]=++ncnt;<br>	<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>	sum[ls[o]]+=tg[o]*(mid-l+<span class="hljs-number">1</span>);<br>	sum[rs[o]]+=tg[o]*(r-mid);<br>	tg[ls[o]]+=tg[o];<br>	tg[rs[o]]+=tg[o];<br>	tg[o]=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;o,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> k)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(!o) o=++ncnt;<br>	<span class="hljs-keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;<br>		sum[o]+=<span class="hljs-number">1ll</span>*k*(r-l+<span class="hljs-number">1</span>);<br>		tg[o]+=k;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-built_in">push_down</span>(o,l,r);<br>	<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span>(mid&gt;=L) <span class="hljs-built_in">update</span>(ls[o],l,mid,L,R,k);<br>	<span class="hljs-keyword">if</span>(mid+<span class="hljs-number">1</span>&lt;=R) <span class="hljs-built_in">update</span>(rs[o],mid+<span class="hljs-number">1</span>,r,L,R,k);<br>	<span class="hljs-built_in">pushup</span>(o);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;o,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(!o) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R) <span class="hljs-keyword">return</span> sum[o];<br>	<span class="hljs-built_in">push_down</span>(o,l,r);<br>	ll res=<span class="hljs-number">0</span>;<br>	<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span>(mid&gt;=L) res+=<span class="hljs-built_in">getsum</span>(ls[o],l,mid,L,R);<br>	<span class="hljs-keyword">if</span>(mid+<span class="hljs-number">1</span>&lt;=R) res+=<span class="hljs-built_in">getsum</span>(rs[o],mid+<span class="hljs-number">1</span>,r,L,R);<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>    	<span class="hljs-built_in">init</span>(rt,<span class="hljs-number">1</span>,n,i,x);<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;op,&amp;x,&amp;y);<br>		<span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)&#123;<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;k);<br>			<span class="hljs-built_in">update</span>(rt,<span class="hljs-number">1</span>,n,x,y,k);<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">getsum</span>(rt,<span class="hljs-number">1</span>,n,x,y));<br>		&#125;<br>	&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h2 id="可持久化线段树（主席树）"><a href="#可持久化线段树（主席树）" class="headerlink" title="可持久化线段树（主席树）"></a>可持久化线段树（主席树）</h2><p>题目链接：<a href="https://www.luogu.com.cn/problem/P3834">P3834 【模板】可持久化线段树 1（主席树）</a></p>
<p>参考blog：</p>
<ul>
<li><a href="https://blog.csdn.net/ModestCoder_/article/details/90107874">【学习笔记】主席树</a></li>
</ul>
<p>题意：给定$n$个整数构成的序列，将对于指定的闭区间查询其区间内的第$k$小值</p>
<p>经典得不能再经典的区间$Kth$问题，即（强制在线的）询问若干区间内的 $k$大/$k$小 值，对于这类问题，当然可以使用暴力$O(nq)$，但是你会T得很惨，于是便又出现了一种神仙数据结构——<strong>可持久化线段树</strong>（或 主席树，据说是因为发明人的名字缩写叫hjt）</p>
<p>其实<strong>主席树</strong>并不是什么新的数据结构，本质上它其实是<strong>权值线段树+前缀和思想</strong>应用的结合，原理描述起来也十分简单，即：开$n$棵权值线段树，第$i$棵维护序列的前$i$个数的出现次数，对于每一次$[l,r]$的询问，用第$r$棵线段树减去第$l-1$棵线段树，得出的新线段树就是维护了$[l,r]$区间的每个数的出现次数的权值线段树，然后在这棵树上二分求解$Kth$就行了，但是，仅仅这样做会使得空间特别大导致RE，因此需要优化，优化过后的这些树就是主席树啦，那么如何进行空间优化呢？</p>
<p>我们发现，对于每一次插入新的序列中的值时，都构建出一颗完整的权值线段树是不值得的，因为有很多的点早就已经在之前构建的权值线段树中出现过了，且没有发生改变，这些点没必要再重新新建，直接利用之前构建好的点就行了，因此，<strong>单次的更新只需要新建$log(n)$个新节点即可</strong>，空间大大缩减</p>
<p>举个栗子：4 3 2 3 6 1</p>
<p>初始时，只有一棵空的线段树，所有节点对应的出现次数为0，当加入区间$[1,1]$时，即 将4的出现次数+1，此时，只需要将与4节点有关的节点维护的次数值+1即可，剩余的节点不需要改变，直接连回去即可</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/20190511125552180.png" alt="在这里插入图片描述"></p>
<p>插入$[1,3]$区间后得到的线段树如下图所示：</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/20190511130727560.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>时间复杂度：建树$O(nlogn)$，单次询问$O(logn)$</p>
</li>
<li><p>空间复杂度：通常情况$O(nlog^2n)$</p>
</li>
</ul>
<p>接下来是代码实现</p>
<h3 id="一些变量"><a href="#一些变量" class="headerlink" title="一些变量"></a>一些变量</h3><p><code>T[maxn*50]</code>：存储每棵线段树的根节点</p>
<p><code>ls[maxn*50]</code>：存储左儿子编号</p>
<p><code>rs[maxn*50]</code>：存储右儿子编号</p>
<p><code>ci[maxn*50]</code>：记录节点对应权值（出现次数）</p>
<p><code>tcnt</code>：节点个数</p>
<h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p>通常情况下，如果要求$Kth$，给出的数值一般都比$n$大很多，所以需要离散化，否者会炸空间RE哦</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">read</span>(a[i]),b[i]=a[i];<br><span class="hljs-built_in">sort</span>(b+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>+n);<br><span class="hljs-type">int</span> len=<span class="hljs-built_in">unique</span>(b+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>+n)-b<span class="hljs-number">-1</span>;<br></code></pre></div></td></tr></table></figure>
<h3 id="Build建树函数"><a href="#Build建树函数" class="headerlink" title="Build建树函数"></a>Build建树函数</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;rt,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    rt=++tcnt,ci[rt]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(ls[rt],<span class="hljs-number">1</span>,mid);<br>    <span class="hljs-built_in">build</span>(rs[rt],mid+<span class="hljs-number">1</span>,r);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="Update更新函数"><a href="#Update更新函数" class="headerlink" title="Update更新函数"></a>Update更新函数</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> o,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> val)</span></span>&#123;<br>    <span class="hljs-type">int</span> oo=++tcnt;<br>    <span class="hljs-comment">//新节点的左右儿子与原节点相同</span><br>    ls[oo]=ls[o],rs[oo]=rs[o],ci[oo]=ci[o]+<span class="hljs-number">1</span>;<span class="hljs-comment">//在之前的节点基础上+1</span><br>    <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> oo;<span class="hljs-comment">//如果到叶子了，返回新节点标号</span><br>    <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(mid&gt;=val) ls[oo]=<span class="hljs-built_in">update</span>(ls[oo],l,mid,val);<span class="hljs-comment">//递归求左右节点新标号</span><br>    <span class="hljs-keyword">else</span> rs[oo]=<span class="hljs-built_in">update</span>(rs[oo],mid+<span class="hljs-number">1</span>,r);<br>    <span class="hljs-keyword">return</span> oo;<span class="hljs-comment">//返回新节点序号</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="Query询问函数"><a href="#Query询问函数" class="headerlink" title="Query询问函数"></a>Query询问函数</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<br>    <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> x=ci[ls[R]]-ci[ls[L]];<span class="hljs-comment">//x为区间[l,r]中数的出现次数之和</span><br>    <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> l;<br>    <span class="hljs-keyword">if</span>(x&gt;=k) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(ls[L],ls[R],l,mid,k);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(rs[L],rs[R],mid+<span class="hljs-number">1</span>,r,k-x);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="完整模板题代码"><a href="#完整模板题代码" class="headerlink" title="完整模板题代码"></a>完整模板题代码</h3><p>通常情况下，主席树的空间需要开32~50倍的序列长度大小，总之，能开多大开多大吧</p>
<p><details><br>    <summary>code</summary></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,a,b) for(register int i=a;i&lt;=b;i++)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> All(x) (x).begin(),(x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mp make_pair</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">double</span> db;<br><span class="hljs-keyword">typedef</span> vector&lt;<span class="hljs-type">int</span>&gt; VI;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI=<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps=<span class="hljs-number">1e-6</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">0x7fffffff</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">200005</span>;<br><span class="hljs-function">ll <span class="hljs-title">qpow</span><span class="hljs-params">(ll x,ll y,ll Mod)</span> </span>&#123;ll ans=<span class="hljs-number">1</span>,base=x%Mod; <span class="hljs-keyword">while</span>(y)&#123;<span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>)ans=(ans*base)%Mod;base=(base*base)%Mod;y&gt;&gt;=<span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">return</span> ans;&#125;<br><span class="hljs-function">ll <span class="hljs-title">gcd</span><span class="hljs-params">(ll a,ll b)</span> </span>&#123;<span class="hljs-keyword">return</span> b?<span class="hljs-built_in">gcd</span>(b,a%b):a;&#125;<br><br><span class="hljs-comment">// fast read</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(T &amp;x)</span> </span>&#123;<br>	x=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> f=<span class="hljs-number">0</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br>	<span class="hljs-keyword">while</span>(ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;f|=(ch==<span class="hljs-string">&#x27;-&#x27;</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<br>	<span class="hljs-keyword">while</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<br>	x=f?-x:x;<br>	<span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">int</span> n,m,type,a[maxn],b[maxn],ans;<br><span class="hljs-type">int</span> T[maxn*<span class="hljs-number">40</span>],ls[maxn*<span class="hljs-number">40</span>],rs[maxn*<span class="hljs-number">40</span>],ci[maxn*<span class="hljs-number">40</span>],tcnt;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;rt,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>	rt=++tcnt,ci[rt]=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span>;<br>	<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>	<span class="hljs-built_in">build</span>(ls[rt],l,mid);<br>	<span class="hljs-built_in">build</span>(rs[rt],mid+<span class="hljs-number">1</span>,r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> ort,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> val)</span></span>&#123;<br>	<span class="hljs-type">int</span> nrt=++tcnt;<br>	ls[nrt]=ls[ort],rs[nrt]=rs[ort],ci[nrt]=ci[ort]+<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> nrt;<br>	<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span>(mid&gt;=val) ls[nrt]=<span class="hljs-built_in">update</span>(ls[nrt],l,mid,val);<br>	<span class="hljs-keyword">else</span> rs[nrt]=<span class="hljs-built_in">update</span>(rs[nrt],mid+<span class="hljs-number">1</span>,r,val);<br>	<span class="hljs-keyword">return</span> nrt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> lt,<span class="hljs-type">int</span> rt,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> l;<br>	<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>,x=ci[ls[rt]]-ci[ls[lt]];<br>	<span class="hljs-keyword">if</span>(x&gt;=k) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(ls[lt],ls[rt],l,mid,k);<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(rs[lt],rs[rt],mid+<span class="hljs-number">1</span>,r,k-x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">read</span>(n),<span class="hljs-built_in">read</span>(m);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">read</span>(a[i]),b[i]=a[i];<br>	<span class="hljs-built_in">sort</span>(b+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>+n);<br>	<span class="hljs-type">int</span> len=<span class="hljs-built_in">unique</span>(b+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>+n)-b<span class="hljs-number">-1</span>;<br>	<span class="hljs-built_in">build</span>(T[<span class="hljs-number">0</span>],<span class="hljs-number">1</span>,len);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n)&#123;<br>		<span class="hljs-type">int</span> x=<span class="hljs-built_in">lower_bound</span>(b+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>+len,a[i])-b;<br>		T[i]=<span class="hljs-built_in">update</span>(T[i<span class="hljs-number">-1</span>],<span class="hljs-number">1</span>,len,x);<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,x,y,k;i&lt;m;i++)&#123;<br>		<span class="hljs-built_in">read</span>(x),<span class="hljs-built_in">read</span>(y),<span class="hljs-built_in">read</span>(k);<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,b[<span class="hljs-built_in">query</span>(T[x<span class="hljs-number">-1</span>],T[y],<span class="hljs-number">1</span>,len,k)]);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p><a href="https://www.luogu.com.cn/problem/P3834">P3834 【模板】可持久化线段树 1（主席树）</a></p>
<p><a href="https://www.luogu.com.cn/problem/P3567">P3567 [POI2014]KUR-Couriers</a>（动态询问区间是否存在出现次数大于一半的数）</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>分块</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>组合数学基础</title>
    <url>/2020/03/01/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="程序设计中的组合数学基础"><a href="#程序设计中的组合数学基础" class="headerlink" title="程序设计中的组合数学基础"></a><center>程序设计中的组合数学基础</center></h2><span id="more"></span>
<h1 id="组合数学"><a href="#组合数学" class="headerlink" title="组合数学"></a>组合数学</h1><h2 id="乘法原理-amp-加法原理"><a href="#乘法原理-amp-加法原理" class="headerlink" title="乘法原理&amp;加法原理"></a>乘法原理&amp;加法原理</h2><p>乘法原理：做一件事，完成它需要分成$n$个步骤，做第一步有$m_1$种不同的方法，做第二步有$m_2$种不同的方法，…，做第$n$步有$m_n$种不同的方法，那么完成这件事共有$N=m_1*m_2*m_3*…*m_n$种不同的方法（前提：任意两个步骤间互相独立）</p>
<p>加法原理：做一件事，完成它有$n$类方式，第一类方式有$M_1$种方法，第二类方式有$M_2$种方法，…，第$n$类方式有$M_n$种方法，那么完成这件事情共有$M_1+M_2+…+M_n$种方法</p>
<h2 id="排列-amp-组合"><a href="#排列-amp-组合" class="headerlink" title="排列&amp;组合"></a>排列&amp;组合</h2><script type="math/tex; mode=display">
A_n^m=n(n-1)(n-2)...(n-m+1)=\frac{n!}{(n-m)!}\\
全排列：A_n^n=n!\\
特别的：0!=1\\
C_n^m=\frac{n!}{m!(n-m)!}</script><p>常用恒等式</p>
<script type="math/tex; mode=display">
C_n^m=C_{n-1}^m+C_{n-1}^{m-1}\\C_n^m=C_n^{n-m}\\</script><p>二项式定理</p>
<script type="math/tex; mode=display">
(x+y)^n=\sum_{i=0}^nC_n^{n-i}x^iy^{n-i}</script><h3 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h3><p>Q：有$k$种物品共$n$个，其中第$i$种物品有$a_i$，问最后一共多少种排列？</p>
<p>A：先全当成一种，然后去重</p>
<script type="math/tex; mode=display">
ans=\frac{n!}{a_1!a_2!a_3!...a_k!}</script><p>Q：$n$个元素排成一排，分成$m$个<strong>非空</strong>的段的方案数</p>
<p>A：隔板法，在$n-1$个空位里插入$m-1$个隔板的方案数</p>
<script type="math/tex; mode=display">
ans=C_{n-1}^{m-1}</script><p>Q：$n$个元素排成一排，分成$m$个<strong>可空</strong>的段的方案数</p>
<p>A：假想$n$个元素中加入$m$个元素，然后对这$n+m$个元素应用上一题的方法，最后再考虑把每一段减去一个元素，就是答案</p>
<script type="math/tex; mode=display">
ans=C_{n+m-1}^{m-1}</script><p>Q：$\sum_{i=0}^{n}(C_n^i)^2=?$</p>
<p>A：</p>
<script type="math/tex; mode=display">
\sum_{i=0}^{n}(C_n^i)^2=\sum_{i=0}^nC_n^iC_n^{n-i}</script><p>上式其实就是从$2n$个元素里取$n$个元素的取法总数，所以</p>
<script type="math/tex; mode=display">
ans=C_{2n}^n</script><p>Q：计算<strong>模意义下</strong>的$C_n^m=\frac{n!}{m!(n-m)!}$</p>
<ul>
<li><p>定义计算法</p>
<p>只需要计算模意义下的阶乘和阶乘的逆元就可以了</p>
</li>
<li><p>杨辉三角递推法</p>
<p>考虑$C<em>n^m=C\</em>{n-1}^m+C_{n-1}^{m-1}$，开一个二维数组，初始化$C_i^0=1$，递推即可</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> C[N+<span class="hljs-number">5</span>][N+<span class="hljs-number">5</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>    C[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)&#123;<br>        C[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>            C[i][j]=(C[i<span class="hljs-number">-1</span>][j]+C[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])%mod;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流专题浅析</title>
    <url>/2020/06/07/%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<h2 id="网络最大流"><a href="#网络最大流" class="headerlink" title="网络最大流"></a>网络最大流</h2><p>参考blog：</p>
<ul>
<li><p><a href="https://www.cnblogs.com/linzhengmin/p/9313216.html">[算法]网络最大流Dinic</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/122375531">Pecco 算法学习笔记(28): 网络流</a></p>
</li>
</ul>
<p>关于具体的概念知识点，上面两篇博客已经写得十分清楚了，这里主要写一下$Ford-Fulkerson(FF)$算法、$Edmonds-Karp(EK)$算法、$Dinic$算法 这三种算法的代码实现和注意事项以及重难点</p>
<p><a href="https://loj.ac/problem/101">LOJ模板题 最大流</a>（需要开<code>long long</code>）</p>
<p><a href="https://www.luogu.com.cn/problem/P3376">洛谷P3376 【模板】网络最大流</a>（<code>int</code>即可）</p>
<h3 id="FF算法"><a href="#FF算法" class="headerlink" title="FF算法"></a>FF算法</h3><p>核心思想：FF算法就是通过<strong>DFS的方式不断从源点出发寻找到达汇点的增广路</strong>，图中需要取整条路径上的容量的<strong>最小值</strong>作为这条链（增广路）实际的流量，只要找到了一条到达汇点的增广路，就将这条增广路经过的所有的<strong>前向弧减去实际流量值</strong>，再将<strong>反向弧加上实际流量值</strong>，最后返回这条增广路的实际流量即可，如果找不到增广路了，就返回-1（即找不到能加流量了，最大流已经求完）。</p>
<p>时间复杂度上界：$O(mf)$，$f$为最大流，真实情况复杂度 $O(玄学)$</p>
<p>注意事项：</p>
<ul>
<li>每次DFS需要重置标记数组<code>vis[]=0</code></li>
<li>边从0开始计数，则若正向边为<code>i</code>，反向边即为<code>i^1</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n,m,s,t;<br><span class="hljs-type">bool</span> vis[maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ff</span><span class="hljs-params">(<span class="hljs-type">int</span> u=s,<span class="hljs-type">int</span> flow=inf)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(u==t) <span class="hljs-keyword">return</span> flow;<span class="hljs-comment">// 到达汇点，返回流量</span><br>	vis[u]=<span class="hljs-number">1</span>;<span class="hljs-comment">// 标记到达该点</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v,w=e[i].w,c;<br>        <span class="hljs-comment">// 递归寻找下一点的流量</span><br>		<span class="hljs-keyword">if</span>(!vis[v]&amp;&amp;w&gt;<span class="hljs-number">0</span>&amp;&amp;(c=<span class="hljs-built_in">ff</span>(v,<span class="hljs-built_in">min</span>(flow,w)))!=<span class="hljs-number">-1</span>)&#123;<br>			e[i].w-=c;<span class="hljs-comment">// 前向弧 -</span><br>			e[i^<span class="hljs-number">1</span>].w+=c; <span class="hljs-comment">// 反向弧 +</span><br>			<span class="hljs-keyword">return</span> c;<span class="hljs-comment">// 返回流量</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">// 到不了汇点</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">FF</span><span class="hljs-params">()</span></span>&#123;<br>	ll c,maxflow=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>((c=<span class="hljs-built_in">ff</span>())!=<span class="hljs-number">-1</span>)&#123;<br>		<span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<br>		maxflow+=(ll)c;<br>	&#125;<br>	<span class="hljs-keyword">return</span> maxflow;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="EK算法"><a href="#EK算法" class="headerlink" title="EK算法"></a>EK算法</h3><p>核心思想：EK算法其实就是用BFS实现的FF算法，但通常会比FF算法更优，因为BFS本身就是一个寻找最短路的算法，能够保证每次找到的增广路是最短路，而FF本身是DFS，可能会出现“绕远路”的情况</p>
<p>注意事项：</p>
<ul>
<li><code>flow[]</code>数组保存到达每个点的流量值</li>
<li><code>last[]</code>数组保存每次寻找增广路时，到达该点的边的序号，如果为<code>-1</code>则未到达该点</li>
<li>每次找到增广路后，借助<code>last[]</code>数组从汇点倒推到源点，过程中执行前向弧减，反向弧加的操作</li>
</ul>
<p>时间复杂度上界：$O(nm^2)$</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n,m,s,t,flow[maxn],last[maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ek</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">memset</span>(last,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(last));<span class="hljs-comment">// 每次需要重置last[]</span><br>	queue&lt;<span class="hljs-type">int</span>&gt; q;<br>	q.<span class="hljs-built_in">push</span>(s);<br>	flow[s]=inf;<span class="hljs-comment">// 源点流量无限大</span><br>	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>		<span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>();<br>		q.<span class="hljs-built_in">pop</span>();<br>		<span class="hljs-keyword">if</span>(u==t) <span class="hljs-keyword">break</span>;<span class="hljs-comment">// 如果到达了汇点，退出循环</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>			<span class="hljs-type">int</span> v=e[i].v,w=e[i].w;<br>			<span class="hljs-keyword">if</span>(w&gt;<span class="hljs-number">0</span>&amp;&amp;last[v]==<span class="hljs-number">-1</span>)&#123;<br>				last[v]=i;<span class="hljs-comment">// 记录到达v点的边</span><br>				flow[v]=<span class="hljs-built_in">min</span>(flow[u],w);<span class="hljs-comment">// 取增广路最小流量</span><br>				q.<span class="hljs-built_in">push</span>(v);<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> last[t]!=<span class="hljs-number">-1</span>;<span class="hljs-comment">// 如果last[t]为-1，则未到达汇点，gg</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">EK</span><span class="hljs-params">()</span></span>&#123;<br>	ll maxflow=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">ek</span>())&#123;<br>		maxflow+=(ll)flow[t];<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=t;i!=s;i=e[last[i]^<span class="hljs-number">1</span>].v)&#123;<span class="hljs-comment">// 倒推增广路上的边</span><br>			e[last[i]].w-=flow[t];<br>			e[last[i]^<span class="hljs-number">1</span>].w+=flow[t];<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> maxflow;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="Dinic算法"><a href="#Dinic算法" class="headerlink" title="Dinic算法"></a>Dinic算法</h3><p>算法核心：其实是FF和EK算法两者的结合 + 一些骚操作，具体过程是，首先使用BFS对网络图进行<strong>分层</strong>（其实就是预处理出从源点到达每个其他点的深度，这样可以保证在DFS求增广路时不绕圈、不走回头路），然后通过DFS进行增广，增广过程中只往深度更深的地方增广，此外，还有两个优化过程</p>
<ol>
<li><strong>多路增广</strong>：在DFS找到一条增广路后，如果还有剩下的流量，就尝试在该点继续DFS找更多的增广路，即：<strong>可以达到一遍DFS找到多条增广路的效果</strong></li>
<li><strong>当前弧优化</strong>（这个我理解了老半天才搞懂它的作用）：就是在DFS增广时，对于一个节点，它如果有多条出边，则处理完这些边后，在后续的DFS过程中如果再次经过了这一个节点（如下图中，4点就有可能经过2次）则直接跳过增广过的边（一条边在一次增广过程中只会增广一次），具体实现为：每次增广时，复制一份<code>head[]</code>数组（命名为<code>cur[]</code>），利用<code>cur[]</code>数组进行图的遍历操作，并不断更新每个点对应的增广的起点</li>
</ol>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200607223852198.png" alt="image-20200607223852198" style="zoom:50%;" /></p>
<p>时间复杂度上界：$O(n^2m)$</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n,m,s,t,deep[maxn],cur[maxn];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> s,<span class="hljs-type">int</span> t)</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>		cur[i]=head[i],deep[i]=<span class="hljs-number">0</span>;<br>	deep[s]=<span class="hljs-number">1</span>;<br>	queue&lt;<span class="hljs-type">int</span>&gt; q;<br>	q.<span class="hljs-built_in">push</span>(s);<br>	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>		<span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>();<br>		q.<span class="hljs-built_in">pop</span>();<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>			<span class="hljs-type">int</span> v=e[i].v,w=e[i].w;<br>			<span class="hljs-keyword">if</span>(w&gt;<span class="hljs-number">0</span>&amp;&amp;!deep[v])&#123;<br>				deep[v]=deep[u]+<span class="hljs-number">1</span>;<br>				q.<span class="hljs-built_in">push</span>(v);<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> deep[t];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> t,<span class="hljs-type">int</span> flow)</span></span>&#123;<span class="hljs-comment">// s点流量无穷大</span><br>	<span class="hljs-keyword">if</span>(u==t) <span class="hljs-keyword">return</span> flow;<span class="hljs-comment">// 到达源点，返回流量</span><br>	<span class="hljs-type">int</span> left=flow;<br>    <span class="hljs-comment">// 使用引用，保证cur随着i改变而改变</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> &amp;i=cur[u];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v,w=e[i].w;<br>		<span class="hljs-keyword">if</span>(w&gt;<span class="hljs-number">0</span>&amp;&amp;deep[v]==deep[u]+<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">// 只往深了增广</span><br>			<span class="hljs-type">int</span> c=<span class="hljs-built_in">dfs</span>(v,t,<span class="hljs-built_in">min</span>(w,left));<span class="hljs-comment">// c = 从v这个点流出多少流量</span><br>			left-=c,e[i].w-=c,e[i^<span class="hljs-number">1</span>].w+=c;<br>			<span class="hljs-keyword">if</span>(!left) <span class="hljs-keyword">break</span>;<span class="hljs-comment">// 如果剩余流量为0，退出循环</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> flow-left;<span class="hljs-comment">// 返回从该点流出多少流量</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">Dinic</span><span class="hljs-params">()</span></span>&#123;<br>	ll maxflow=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>(s,t))&#123;<br>		maxflow+=(ll)<span class="hljs-built_in">dfs</span>(s,t,inf);<br>	&#125;<br>	<span class="hljs-keyword">return</span> maxflow;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="二分图最大匹配的网络流算法"><a href="#二分图最大匹配的网络流算法" class="headerlink" title="二分图最大匹配的网络流算法"></a>二分图最大匹配的网络流算法</h3><p>核心思想：构建出一个虚拟源点和虚拟汇点，从源点向二分图的左部所有点连边，容量为1，从二分图右部所有点向汇点连边，容量为1，对于二分图两部之间的连边，左部连向右部，容量为1，上述连边的同时都需要加一条反向弧，容量为0，最后跑 从源点到汇点的$Dinic$算法即可</p>
<p>证明：略 </p>
<p>时间复杂度上界：$O(n\sqrt m)$，优于匈牙利算法的$O(nm)$</p>
<p><a href="https://www.luogu.com.cn/problem/P3386">模板题</a>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">Dinic</span><span class="hljs-params">()</span></span>&#123;<br>	ll maxflow=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>(<span class="hljs-number">1</span>,n+m+<span class="hljs-number">2</span>))&#123;<br>		maxflow+=(ll)<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,n+m+<span class="hljs-number">2</span>,inf);<br>		<span class="hljs-comment">// cout&lt;&lt;&quot;head&quot;&lt;&lt;endl;</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> maxflow;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">read</span>(n),<span class="hljs-built_in">read</span>(m),<span class="hljs-built_in">read</span>(ee);<br>	<span class="hljs-built_in">init_graph</span>();<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,u,v;i&lt;=ee;i++)&#123;<br>		<span class="hljs-built_in">read</span>(u),<span class="hljs-built_in">read</span>(v);<br>		<span class="hljs-built_in">addedge</span>(u+<span class="hljs-number">1</span>,n+v+<span class="hljs-number">1</span>,<span class="hljs-number">1</span>),<br>		<span class="hljs-built_in">addedge</span>(n+v+<span class="hljs-number">1</span>,u+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n+<span class="hljs-number">1</span>;i++) <span class="hljs-built_in">addedge</span>(<span class="hljs-number">1</span>,i,<span class="hljs-number">1</span>),<span class="hljs-built_in">addedge</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=m+<span class="hljs-number">1</span>;i++) <span class="hljs-built_in">addedge</span>(n+i,n+m+<span class="hljs-number">2</span>,<span class="hljs-number">1</span>),<span class="hljs-built_in">addedge</span>(n+m+<span class="hljs-number">2</span>,n+i,<span class="hljs-number">0</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">Dinic</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h2>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title> “联想杯”程序设计竞赛划水赛后 </title>
    <url>/2020/05/30/%E8%81%94%E6%83%B3%E6%9D%AF%E2%80%9C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E5%88%92%E6%B0%B4%E8%B5%9B%E5%90%8E/</url>
    <content><![CDATA[<h2 id="暨第三届上理程序设计竞赛赛后反思"><a href="#暨第三届上理程序设计竞赛赛后反思" class="headerlink" title="暨第三届上理程序设计竞赛赛后反思"></a><center>暨第三届上理程序设计竞赛赛后反思</center></h2><span id="more"></span>
<p>给能动丢脸了，给能动丢脸了，给能动丢脸了。</p>
<hr>
<h4 id="A-Archmage"><a href="#A-Archmage" class="headerlink" title="A. Archmage"></a><a href="">A. Archmage</a></h4><p>签到题，我居然没做出来，原因是：没看到 $x+y\le n$这个条件，我枯了，导致怎么想也想不出来，答案就是$\min(m,\lfloor \frac{n+(m-1)\cdot y}{x} \rfloor)$，我菜死了。</p>
<h4 id="B-Bamboo-Leaf-Rhapsody"><a href="#B-Bamboo-Leaf-Rhapsody" class="headerlink" title="B. Bamboo Leaf Rhapsody"></a><a href="https://acm.ecnu.edu.cn/contest/270/problem/B/">B. Bamboo Leaf Rhapsody</a></h4><p>签到题，C语言课后习题难度</p>
<h4 id="C-Cheat-Sheet"><a href="#C-Cheat-Sheet" class="headerlink" title="C. Cheat Sheet"></a><a href="https://acm.ecnu.edu.cn/contest/270/problem/C/">C. Cheat Sheet</a></h4><p>签到题，C语言课后习题难度</p>
<h4 id="D-Disaster-Recovery"><a href="#D-Disaster-Recovery" class="headerlink" title="D. Disaster Recovery"></a><a href="https://acm.ecnu.edu.cn/contest/270/problem/D/">D. Disaster Recovery</a></h4><p>并査集写成<code>fa[x]==find(fa[x])</code>了，我人傻了</p>
<p>另外，边权按照<code>pair&lt;max(x,y),min(x,y)&gt;</code>排序，我菜死了</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200530215431137.png" alt="image-20200530215431137"></p>
<h4 id="H-Hay-Mower"><a href="#H-Hay-Mower" class="headerlink" title="H. Hay Mower"></a><a href="https://acm.ecnu.edu.cn/contest/270/problem/H/">H. Hay Mower</a></h4><p>赛时A掉了，不过是用的简单的模拟，也属于签到题范围吧</p>
<p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200530215633591.png" alt="image-20200530215633591"></p>
<h4 id="L-Lottery-Tickets"><a href="#L-Lottery-Tickets" class="headerlink" title="L. Lottery Tickets"></a><a href="https://acm.ecnu.edu.cn/contest/270/problem/L/">L. Lottery Tickets</a></h4><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/image-20200530215802161.png" alt="image-20200530215802161"></p>
<p>首先只需要判断最后两位数即可，按照<code>00,20,12,32,40,24,44,52,60,16,36,64,56,72,76,80,28,84,48,68,88,92,96</code>这样排列最后两位，选前面的数一定比选后面的数更优，因此只需要挨个判断有没有这些数就行了，除此之外，还需要特判 只含有0、只有一个4、只有一个8 的情况，细节比较多，我菜死了</p>
<details>
    <summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> _,a[<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> biao[<span class="hljs-number">23</span>]=&#123;<span class="hljs-number">00</span>,<span class="hljs-number">20</span>,<span class="hljs-number">12</span>,<span class="hljs-number">32</span>,<span class="hljs-number">40</span>,<span class="hljs-number">24</span>,<span class="hljs-number">44</span>,<span class="hljs-number">52</span>,<span class="hljs-number">60</span>,<span class="hljs-number">16</span>,<span class="hljs-number">36</span>,<span class="hljs-number">64</span>,<span class="hljs-number">56</span>,<span class="hljs-number">72</span>,<span class="hljs-number">76</span>,<span class="hljs-number">80</span>,<span class="hljs-number">28</span>,<span class="hljs-number">84</span>,<span class="hljs-number">48</span>,<span class="hljs-number">68</span>,<span class="hljs-number">88</span>,<span class="hljs-number">92</span>,<span class="hljs-number">96</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">9</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=a[i];j++)&#123;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,i);<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-comment">//freopen(&quot;test.in&quot;,&quot;r&quot;,stdin);</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;_);_;_--)&#123;<br>		<span class="hljs-type">int</span> tot=<span class="hljs-number">0</span>;<br>		<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,<span class="hljs-number">9</span>)&#123;<br>			<span class="hljs-built_in">read</span>(a[i]);<br>			tot+=a[i];<br>		&#125;<br>		<span class="hljs-keyword">if</span>(tot==<span class="hljs-number">0</span>)&#123;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br>			<span class="hljs-keyword">continue</span>;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(tot&gt;<span class="hljs-number">0</span>&amp;&amp;tot==a[<span class="hljs-number">0</span>])&#123;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0\n&quot;</span>);<br>			<span class="hljs-keyword">continue</span>;<br>		&#125;<br>		<span class="hljs-type">bool</span> f=<span class="hljs-literal">false</span>;<br>		<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,<span class="hljs-number">22</span>)&#123;<br>			<span class="hljs-type">int</span> t1=biao[i]/<span class="hljs-number">10</span>,t2=biao[i]%<span class="hljs-number">10</span>;<br>			<span class="hljs-keyword">if</span>(t1==t2)&#123;<br>				<span class="hljs-keyword">if</span>(a[t1]&gt;<span class="hljs-number">1</span>)&#123;<br>					f=<span class="hljs-literal">true</span>;<br>					a[t1]-=<span class="hljs-number">2</span>;<br>					<span class="hljs-built_in">print</span>();<br>					<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d%d\n&quot;</span>,t1,t2);<br>					<span class="hljs-keyword">break</span>;<br>				&#125;<br>			&#125;<span class="hljs-keyword">else</span>&#123;<br>				<span class="hljs-keyword">if</span>(a[t1]&amp;&amp;a[t2])&#123;<br>					f=<span class="hljs-literal">true</span>;<br>					a[t1]--,a[t2]--;<br>					<span class="hljs-built_in">print</span>();<br>					<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d%d\n&quot;</span>,t1,t2);<br>					<span class="hljs-keyword">break</span>;<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(!f)&#123;<br>			<span class="hljs-keyword">if</span>(a[<span class="hljs-number">8</span>]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;8\n&quot;</span>);<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[<span class="hljs-number">4</span>]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;4\n&quot;</span>);<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0\n&quot;</span>);<br>			<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>背包九讲（转载）</title>
    <url>/2020/01/16/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/</url>
    <content><![CDATA[<ul>
<li>转自一个把背包问题写得非常透彻简明的博客<blockquote>
<p><a href="https://www.kancloud.cn/kancloud/pack/70124">（转）背包九讲</a></p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>背包问题</tag>
        <tag>动态规划</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>莫队算法</title>
    <url>/2020/04/25/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="优雅的暴力：分块应用の莫队算法"><a href="#优雅的暴力：分块应用の莫队算法" class="headerlink" title="优雅的暴力：分块应用の莫队算法"></a><center>优雅的暴力：分块应用の莫队算法</center></h2><p><img src="https://blog-1301883815.cos.ap-nanjing.myqcloud.com/imag/u=1800100450,703015408&amp;fm=26&amp;gp=0.jpg" alt="mechanism" style="zoom:67%;" /></p>
<span id="more"></span>
<p>参考blog：</p>
<ul>
<li><a href="https://www.cnblogs.com/WAMonster/p/10118934.html">莫队算法——从入门到黑题</a>（可以说是十分详细了）</li>
</ul>
<p><strong>莫队算法</strong>，众所周知，它是由莫涛大神提出的，一种<del>玄学毒瘤暴力的</del>区间操作算法，它的应用结合了分块的特点，以及排序的优化<del>玄学</del>，最终达到根号级别的复杂度，十分可观</p>
<p><strong>前置姿势：</strong></p>
<ol>
<li>分块的基本思想</li>
<li>STL的排序（自定义排序）</li>
<li>基础卡常技巧</li>
<li>倍增/树剖 求LCA</li>
<li>数值离散化</li>
</ol>
<h2 id="普通莫队"><a href="#普通莫队" class="headerlink" title="普通莫队"></a>普通莫队</h2><p>先看下这题：<a href="https://www.luogu.com.cn/problem/SP3267">D-query</a>，当然<a href="https://www.luogu.com.cn/problem/P1972">HH的项链</a>这题也可，但是它SB居然卡莫队</p>
<p><img src="https://i.loli.net/2020/04/25/XI5bEh2GFY6lnCV.png" alt="image.png"></p>
<p>每次询问区间内不同数字的个数，这是普通莫队最简单的模板题，其算法思路大概是这样的：（下面是莫队的基本思想）</p>
<p>应用<strong>双指针</strong>方法，每次询问的时候将指针<strong>一步一步地</strong>移动至对应的左右端点，移动时同步更新区间内的值出现的次数（开一个数组存储即可），具体实现如下</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m)&#123;<br>    <span class="hljs-type">int</span> tl=q[i].l,tr=q[i].r;<br>    <span class="hljs-keyword">while</span>(l&lt;tl) <span class="hljs-built_in">del</span>(l++);<br>    <span class="hljs-keyword">while</span>(l&gt;tl) <span class="hljs-built_in">add</span>(--l);<br>    <span class="hljs-keyword">while</span>(r&lt;tr) <span class="hljs-built_in">add</span>(++r);<br>    <span class="hljs-keyword">while</span>(r&gt;tr) <span class="hljs-built_in">del</span>(r--);<br>    ans[q[i].id]=now;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>而其中的add函数和del函数如下，也就是说：对于每次转移区间，我们要对应地将之前一次询问的左右端点移至当前询问的左右端点，期间如果是删除元素，则执行删除操作，如果出现了删完之后该值的出现次数为0，则对应区间的元素总个数-1，同理，如果是添加元素，则执行添加操作，如果添加之前该元素的出现次数为0，则对应区间的元素总个数要+1（因为把这个新元素添加进来了）</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span></span>&#123;<br>	--cnt[a[pos]];<br>	<span class="hljs-keyword">if</span>(!cnt[a[pos]]) --now;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(!cnt[a[pos]]) ++now;<br>	++cnt[a[pos]];<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>然而，仅仅这么做还不够，因为如果我们的询问区间长这样：</p>
<p><img src="https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181214145508773-749403260.jpg" alt=""></p>
<p>那么这两个指针将<strong>会在整个区间两头反复横跳</strong>，这样的算法就会比暴力还慢（多了个常数），所以我们要考虑优化这个算法，</p>
<p>接下来就是莫队算法的<del>玄学</del><strong>核心思想</strong>：对序列分块（此题分成$\sqrt{n}$最优），并将询问的区间排序（将询问存到结构体里，<strong>第一关键字为左端点所在块，第二关键字为右端点</strong>），也就是说，左端点所在块小的优先处理，左端点同在一块中则右端点小的优先处理，这样一来，复杂度大大下降了（但是是离线的操作），可以简单证明如下：</p>
<p>对于每一个块内询问，其右端点可能的最大跳动范围为整个序列（n），而总共有$\sqrt{n}$个块，因此总复杂度为$O(n\sqrt{n})$</p>
<p>排序操作如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Q x1,Q x2)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(bel[x1.l]==bel[x2.l]) <span class="hljs-keyword">return</span> x1.r&lt;x2.r;<br>	<span class="hljs-keyword">return</span> bel[x1.l]&lt;bel[x2.l];<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>至此，这题就被我们完美地解决了（最后记得要按照题目输入的顺序输出答案）</p>
<p>但是，实际上还可以在常数上做一些改进（快读之类的我就不说了）：<strong>奇偶性排序</strong></p>
<p>对于上面的排序函数，我们将其改写成如下形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Q x1,Q x2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> bel[x1.l]^bel[x2.l]?bel[x1.l&lt;bel[x2.l]:((bel[x1.l]&amp;<span class="hljs-number">1</span>)?x1.r&lt;x2.r:x1.r&gt;x2.r)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>翻译过来就是：<strong>对于左端点所在块相同的询问，当左端点所在块为奇数块则按照右端点升序排序，否则按照右端点降序排序</strong></p>
<p>而其优化的原理大概还是<strong>尽量减少了指针跳动的幅度</strong>：当我们处理完了奇数块时，此时右端点指针在最右断，下一块轮到偶数块了，我们就不需要把右端点从最右端挪到最左端来重新从左往右跳动了，而是直接从右往左跳动，使得每个来回跳动的操作都是尽量有效的操作</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//略去头文件</span><br><span class="hljs-comment">//D-query</span><br><span class="hljs-type">int</span> n,m,a[<span class="hljs-number">30005</span>],blk,st[<span class="hljs-number">30005</span>],en[<span class="hljs-number">30005</span>],bel[<span class="hljs-number">30005</span>],now;<br><span class="hljs-type">int</span> ans[<span class="hljs-number">200005</span>],cnt[<span class="hljs-number">1000005</span>];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Q</span>&#123;<span class="hljs-comment">//询问结构体</span><br>	<span class="hljs-type">int</span> l,r,id;<br>&#125;q[<span class="hljs-number">200005</span>];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Q x1,Q x2)</span></span>&#123;<span class="hljs-comment">//自定义排序</span><br>	<span class="hljs-keyword">if</span>(bel[x1.l]==bel[x2.l]) <span class="hljs-keyword">return</span> bel[x1.r]&lt;bel[x2.r];<br>	<span class="hljs-keyword">return</span> bel[x1.l]&lt;bel[x2.l];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init_blk</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<span class="hljs-comment">//分块基本操作</span><br>	blk=<span class="hljs-built_in">sqrt</span>(n);<span class="hljs-comment">//根号n个块</span><br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,blk)&#123;<br>		st[i]=n/blk*(i<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>;<br>		en[i]=n/blk*i;<br>	&#125;<br>	en[blk]=n;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,blk)&#123;<br>		<span class="hljs-built_in">rep</span>(j,st[i],en[i])&#123;<br>			bel[j]=i;<br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span></span>&#123; <span class="hljs-comment">//删除元素</span><br>	--cnt[a[pos]];<br>	<span class="hljs-keyword">if</span>(!cnt[a[pos]]) --now;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span></span>&#123; <span class="hljs-comment">//添加元素</span><br>	<span class="hljs-keyword">if</span>(!cnt[a[pos]]) ++now;<br>	++cnt[a[pos]];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>	<span class="hljs-built_in">init_blk</span>(n);<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;m);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;q[i].l,&amp;q[i].r);<br>		q[i].id=i;<span class="hljs-comment">//记得要存原题的查询顺序</span><br>	&#125;<br>	<span class="hljs-built_in">sort</span>(q+<span class="hljs-number">1</span>,q+<span class="hljs-number">1</span>+m,cmp);<span class="hljs-comment">//排序</span><br>	<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,r=<span class="hljs-number">0</span>;<span class="hljs-comment">//初始化双指针的左右端点</span><br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m)&#123;<br>		<span class="hljs-type">int</span> tl=q[i].l,tr=q[i].r;<br>		<span class="hljs-keyword">while</span>(l&lt;tl) <span class="hljs-built_in">del</span>(l++);<br>		<span class="hljs-keyword">while</span>(l&gt;tl) <span class="hljs-built_in">add</span>(--l);<br>		<span class="hljs-keyword">while</span>(r&lt;tr) <span class="hljs-built_in">add</span>(++r);<br>		<span class="hljs-keyword">while</span>(r&gt;tr) <span class="hljs-built_in">del</span>(r--);<span class="hljs-comment">//莫队基本操作</span><br>		ans[q[i].id]=now;<span class="hljs-comment">//记录答案</span><br>	&#125;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans[i]);<span class="hljs-comment">//按原题顺序输出答案</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<p>莫队算法的注意事项和重点：</p>
<ul>
<li>莫队算法优秀的根号复杂度是<strong>建立在每次修改操作（对应上题就是del和add操作）的复杂度是非常小的（O(1)）基础上</strong>的，因此，如果对应的修改操作复杂度非常大的话，莫队还是很慢的QAQ</li>
<li>莫队算法是一个<strong>离线算法</strong>（因为他要排序），如果题目要强制在线了，那就可以和莫队说拜拜了</li>
</ul>
<h3 id="普通莫队习题："><a href="#普通莫队习题：" class="headerlink" title="普通莫队习题："></a>普通莫队习题：</h3><p><a href="https://www.luogu.com.cn/problem/SP3267">D-query</a>（普通莫队，询问区间不同的数的个数）</p>
<p><a href="https://www.luogu.com.cn/problem/P2709">小B的询问</a>（普通莫队，询问区间每个数出现次数的平方和）</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 略去头文件</span><br><span class="hljs-comment">//每次询问区间每个数出现次数的平方和</span><br><span class="hljs-comment">//普通莫队算法，如果一个数出现次数+1，则对应总次数可以通过完全平方公式作差计算得出，出现次数-1同理，然后统计就行了</span><br><span class="hljs-type">int</span> n,m,k,blk,a[maxn],cnt[maxn],st[maxn],en[maxn],bel[maxn];<br>ll Ans[maxn];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Q</span><br>&#123;<br>	<span class="hljs-type">int</span> l,r,id;<br>&#125;q[maxn];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Q x1,Q x2)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(bel[x1.l]==bel[x2.l]) <span class="hljs-keyword">return</span> bel[x1.r]&lt;bel[x2.r];<br>	<span class="hljs-keyword">return</span> bel[x1.l]&lt;bel[x2.l];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init_blk</span><span class="hljs-params">()</span></span>&#123;<br>	blk=<span class="hljs-built_in">sqrt</span>(n);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,blk)<br>		st[i]=n/blk*(i<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>,en[i]=n/blk*i;<br>	en[blk]=n;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,blk)&#123;<br>		<span class="hljs-built_in">rep</span>(j,st[i],en[i])&#123;<br>			bel[j]=i;<br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>	<span class="hljs-built_in">init_blk</span>();<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;q[i].l,&amp;q[i].r),q[i].id=i;<br>	<span class="hljs-built_in">sort</span>(q+<span class="hljs-number">1</span>,q+<span class="hljs-number">1</span>+m,cmp);<br>	<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,r=<span class="hljs-number">0</span>;<br>	ll ans=<span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m)&#123;<br>		<span class="hljs-type">int</span> tl=q[i].l,tr=q[i].r;<br>		<span class="hljs-keyword">while</span>(l&lt;tl) --cnt[a[l]],ans-=<span class="hljs-number">2</span>*cnt[a[l]]+<span class="hljs-number">1</span>,l++;<br>		<span class="hljs-keyword">while</span>(l&gt;tl) l--,++cnt[a[l]],ans+=<span class="hljs-number">2</span>*cnt[a[l]]<span class="hljs-number">-1</span>;<br>		<span class="hljs-keyword">while</span>(r&lt;tr) r++,++cnt[a[r]],ans+=<span class="hljs-number">2</span>*cnt[a[r]]<span class="hljs-number">-1</span>;<br>		<span class="hljs-keyword">while</span>(r&gt;tr) --cnt[a[r]],ans-=<span class="hljs-number">2</span>*cnt[a[r]]+<span class="hljs-number">1</span>,r--;<br>		Ans[q[i].id]=ans;<br>	&#125;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,Ans[i]);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<p><a href="https://www.luogu.com.cn/problem/P3709">大爷的字符串题</a>（普通莫队，询问区间众数的出现次数）</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//略去头文件</span><br><span class="hljs-comment">//语文题：询问区间内众数的出现次数</span><br><span class="hljs-comment">//此题考查普通莫队的进阶应用</span><br><span class="hljs-comment">//我们发现只开一个cnt[i]数组是不够的，因为他没法同时记录多个数是众数</span><br><span class="hljs-comment">//因此我们考虑再开一个数组ge[i]来记录出现i次的数的个数</span><br><span class="hljs-comment">//当要删除一个数时，如果它是众数，并且只有它是众数（ge[cnt[a[pos]]]==1），那么删掉这个数时众数的出现次数-1，因为它就是众数，所以只减一就够了</span><br><span class="hljs-type">int</span> n,m,blk,a[maxn],b[maxn],st[maxn],en[maxn],bel[maxn],cnt[maxn],ge[maxn];<br>ll Ans[maxn],ans;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Q</span><br>&#123;<br>	<span class="hljs-type">int</span> l,r,id;<br>&#125;q[maxn];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Q x1,Q x2)</span></span>&#123;<br>	<span class="hljs-keyword">return</span> bel[x1.l]^bel[x2.l]?bel[x1.l]&lt;bel[x2.l]:((bel[x1.l]&amp;<span class="hljs-number">1</span>)?x1.r&lt;x2.r:x1.r&gt;x2.r);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init_blk</span><span class="hljs-params">()</span></span>&#123;<br>	blk=<span class="hljs-built_in">sqrt</span>(n);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,blk) st[i]=n/blk*(i<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>,en[i]=n/blk*i;<br>	en[blk]=n;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,blk)&#123;<br>		<span class="hljs-built_in">rep</span>(j,st[i],en[i]) bel[j]=i;<br>	&#125;<br>	<span class="hljs-comment">// 离散化</span><br>	<span class="hljs-built_in">sort</span>(b+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>+n);<br>	<span class="hljs-type">int</span> len=<span class="hljs-built_in">unique</span>(b+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>+n)-b<span class="hljs-number">-1</span>;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n)&#123;<br>		a[i]=<span class="hljs-built_in">lower_bound</span>(b+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>+len,a[i])-b;<br>		<span class="hljs-comment">// printf(&quot;%d &quot;,a[i]);</span><br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span></span>&#123;<br>	--ge[cnt[a[pos]]];<br>	++cnt[a[pos]];<br>	++ge[cnt[a[pos]]];<br>	ans=<span class="hljs-built_in">max</span>(ans,<span class="hljs-number">1ll</span>*cnt[a[pos]]);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(cnt[a[pos]]==ans&amp;&amp;ge[cnt[a[pos]]]==<span class="hljs-number">1</span>) ans--;<br>	--ge[cnt[a[pos]]];<br>	--cnt[a[pos]];<br>	++ge[cnt[a[pos]]];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-comment">// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]),b[i]=a[i];<br>	<span class="hljs-built_in">init_blk</span>();<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;q[i].l,&amp;q[i].r),q[i].id=i;<br>	<span class="hljs-built_in">sort</span>(q+<span class="hljs-number">1</span>,q+<span class="hljs-number">1</span>+m,cmp);<br>	<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,r=<span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m)&#123;<br>		<span class="hljs-type">int</span> tl=q[i].l,tr=q[i].r;<br>		<span class="hljs-keyword">while</span>(l&lt;tl) <span class="hljs-built_in">del</span>(l++);<br>		<span class="hljs-keyword">while</span>(l&gt;tl) <span class="hljs-built_in">add</span>(--l);<br>		<span class="hljs-keyword">while</span>(r&lt;tr) <span class="hljs-built_in">add</span>(++r);<br>		<span class="hljs-keyword">while</span>(r&gt;tr) <span class="hljs-built_in">del</span>(r--);<br>		Ans[q[i].id]=-ans;<br>	&#125;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,Ans[i]);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<p><a href="https://www.luogu.com.cn/problem/P1997">faebdc的烦恼</a>（同上）</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//忽略头文件</span><br><span class="hljs-comment">//是上一题的非语文版，重题</span><br><span class="hljs-type">int</span> n,m,st[maxn],en[maxn],bel[maxn],blk,cnt[maxn],ge[maxn],a[maxn],ans[maxn],now;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">que</span><br>&#123;<br>	<span class="hljs-type">int</span> l,r,id;<br>&#125;q[maxn];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(que x1,que x2)</span></span>&#123;<br>	<span class="hljs-keyword">return</span> bel[x1.l]==bel[x2.l]?bel[x1.r]&lt;bel[x2.r]:bel[x1.l]&lt;bel[x2.l];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init_blk</span><span class="hljs-params">()</span></span>&#123;<br>	blk=<span class="hljs-built_in">sqrt</span>(n);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,blk) st[i]=n/blk*(i<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>,en[i]=n/blk*i;<br>	en[blk]=n;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,blk)<br>		<span class="hljs-built_in">rep</span>(j,st[i],en[i])<br>			bel[j]=i;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span></span>&#123;<br>	--ge[cnt[a[pos]]];<br>	++cnt[a[pos]];<br>	++ge[cnt[a[pos]]];<br>	now=<span class="hljs-built_in">max</span>(now,cnt[a[pos]]);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>((now==cnt[a[pos]])&amp;&amp;(ge[cnt[a[pos]]]==<span class="hljs-number">1</span>)) now--;<br>	--ge[cnt[a[pos]]];<br>	--cnt[a[pos]];<br>	++ge[cnt[a[pos]]];<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>	<span class="hljs-built_in">init_blk</span>();<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;q[i].l,&amp;q[i].r),q[i].id=i;<br>	<span class="hljs-built_in">sort</span>(q+<span class="hljs-number">1</span>,q+<span class="hljs-number">1</span>+m,cmp);<br>	<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,r=<span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m)&#123;<br>		<span class="hljs-type">int</span> tl=q[i].l,tr=q[i].r;<br>		<span class="hljs-keyword">while</span>(l&lt;tl) <span class="hljs-built_in">del</span>(l++);<br>		<span class="hljs-keyword">while</span>(l&gt;tl) <span class="hljs-built_in">add</span>(--l);<br>		<span class="hljs-keyword">while</span>(r&lt;tr) <span class="hljs-built_in">add</span>(++r);<br>		<span class="hljs-keyword">while</span>(r&gt;tr) <span class="hljs-built_in">del</span>(r--);<br>		ans[q[i].id]=now; <br>	&#125;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans[i]);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h2 id="带修莫队"><a href="#带修莫队" class="headerlink" title="带修莫队"></a>带修莫队</h2><p>那么就不得不提到带修改莫队的模板题了：<a href="https://www.luogu.com.cn/problem/P1903">国家集训队 数颜色/维护队列</a></p>
<p>这道题其实就是加入了单点修改的上一道题，因此看上去这道题是一个在线的题，而且莫队不支持在线操作，那么如何实现带修改的莫队呢？</p>
<p>我们可以在普通莫队的基础上，将查询操作和修改操作分开记录，并使用一个<strong>时间戳</strong>变量来记录<strong>每次查询操作所对应的最近的前一次修改操作</strong>，具体实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Q</span>&#123;<br>    <span class="hljs-type">int</span> l,r,time;<span class="hljs-comment">//time为时间戳</span><br>&#125;q[maxn];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">mo</span>&#123;<br>    <span class="hljs-type">int</span> pos,val;<br>&#125;mo[maxn];<br></code></pre></div></td></tr></table></figure>
<p>对于排序操作，由于多加了一个时间戳变量（而这恰恰又是最耗时间的操作），我们这么安排排序规则：<strong>第一关键字为左端点所在块，第二关键字为右端点所在块，第三关键字为时间戳</strong>，都设置为升序排序，这样一来，复杂度又得到了优化</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(que x1,que x2)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(bel[x1.l]==bel[x2.l]&amp;&amp;bel[x1.r]==bel[x2.r]) <span class="hljs-keyword">return</span> x1.tim&lt;x2.tim;<br>	<span class="hljs-keyword">if</span>(bel[x1.l]==bel[x2.l]) <span class="hljs-keyword">return</span> bel[x1.r]&lt;bel[x2.r];<br>	<span class="hljs-keyword">return</span> bel[x1.l]&lt;bel[x2.l];<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>另外，这道题经过大佬的证明，可以得出当块的大小为$n^{frac{2}{3}}$时（即共有$n^{frac{1}{3}}$个块）可以达到$O(n^{frac{5}{3}})$的复杂度，要优于块大小为$\sqrt{n}$时候的复杂度$O(n^2)$</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init_blk</span><span class="hljs-params">()</span></span>&#123;<br>	blk=<span class="hljs-built_in">pow</span>(n,<span class="hljs-number">1.0</span>/<span class="hljs-number">3.0</span>);<span class="hljs-comment">//分为n^(1/3)块</span><br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,blk) st[i]=n/blk*(i<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>,en[i]=n/blk*i;<br>	en[blk]=n;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,blk)<br>		<span class="hljs-built_in">rep</span>(j,st[i],en[i])<br>			bel[j]=i;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>对于询问操作，和普通莫队没有区别，但对于带有时间戳的修改操作，我们需要将这一次查询操作的时间戳和当前的时间戳作比较，如果当前时间戳早了，那么就要一直执行这次查询操作之前的修改操作直到达到这一次操作的时间戳，然后记录答案；如果当前时间戳晚了，那么就要一直撤销修改操作直到到达这一次操作的时间戳，而对于执行和撤销的操作，有一个很聪明的方法：<strong>直接swap</strong>，因为如果我们这一次查询操作用到了很多次修改，那么如果下一次查询没有用到修改，我们就是把原来的值交换回来，因为时间永远是连续变化的，不可能存在时间间隔几个时间点跳跃的现象</p>
<p>至此，带修改（单点修改）的莫队的原理就结束了（区间修改的莫队似乎还不存在）</p>
<details>
<summary>code</summary>

<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//略去头文件和快读快写</span><br><span class="hljs-comment">//带修改莫队板子</span><br><span class="hljs-type">int</span> n,m,st[maxn],en[maxn],blk,bel[maxn],cnt[maxn*<span class="hljs-number">8</span>],a[maxn];<br><span class="hljs-type">int</span> qcnt,mcnt;<br><span class="hljs-type">int</span> l,r,tim,ans,Ans[maxn];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">que</span><br>&#123;<br>	<span class="hljs-type">int</span> l,r,id,tim;<br>&#125;q[maxn];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">modi</span><br>&#123;<br>	<span class="hljs-type">int</span> pos,val;<br>&#125;md[maxn];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(que x1,que x2)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(bel[x1.l]==bel[x2.l]&amp;&amp;bel[x1.r]==bel[x2.r]) <span class="hljs-keyword">return</span> x1.tim&lt;x2.tim;<br>	<span class="hljs-keyword">if</span>(bel[x1.l]==bel[x2.l]) <span class="hljs-keyword">return</span> bel[x1.r]&lt;bel[x2.r];<br>	<span class="hljs-keyword">return</span> bel[x1.l]&lt;bel[x2.l];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init_blk</span><span class="hljs-params">()</span></span>&#123;<br>	blk=<span class="hljs-built_in">pow</span>(n,<span class="hljs-number">1.0</span>/<span class="hljs-number">3.0</span>);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,blk) st[i]=n/blk*(i<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>,en[i]=n/blk*i;<br>	en[blk]=n;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,blk)<br>		<span class="hljs-built_in">rep</span>(j,st[i],en[i])<br>			bel[j]=i;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(!cnt[a[pos]]) ++ans;<br>	++cnt[a[pos]];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span></span>&#123;<br>	--cnt[a[pos]];<br>	<span class="hljs-keyword">if</span>(!cnt[a[pos]]) --ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>();<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>();<br>	<span class="hljs-built_in">init_blk</span>();<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m)&#123;<br>		<span class="hljs-type">char</span> c[<span class="hljs-number">2</span>];<br>		<span class="hljs-type">int</span> l,r;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,c);<br>		l=<span class="hljs-built_in">read</span>(),r=<span class="hljs-built_in">read</span>();<br>		<span class="hljs-keyword">if</span>(c[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;Q&#x27;</span>)&#123;<br>			q[++qcnt].l=l;<br>			q[qcnt].r=r;<br>			q[qcnt].id=qcnt;<br>			q[qcnt].tim=mcnt;<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>			md[++mcnt].pos=l;<br>			md[mcnt].val=r;<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">sort</span>(q+<span class="hljs-number">1</span>,q+<span class="hljs-number">1</span>+qcnt,cmp);<br><br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m)&#123;<br>		<span class="hljs-type">int</span> tl=q[i].l,tr=q[i].r,tt=q[i].tim;<br>		<span class="hljs-keyword">while</span>(l&lt;tl) <span class="hljs-built_in">del</span>(l++);<br>		<span class="hljs-keyword">while</span>(l&gt;tl) <span class="hljs-built_in">add</span>(--l);<br>		<span class="hljs-keyword">while</span>(r&lt;tr) <span class="hljs-built_in">add</span>(++r);<br>		<span class="hljs-keyword">while</span>(r&gt;tr) <span class="hljs-built_in">del</span>(r--);<br>		<span class="hljs-keyword">while</span>(tt&gt;tim)&#123;<br>			++tim;<br>			<span class="hljs-keyword">if</span>(md[tim].pos&gt;=tl&amp;&amp;md[tim].pos&lt;=tr)&#123;<br>				<span class="hljs-keyword">if</span>(!cnt[md[tim].val]) ans++;<br>				++cnt[md[tim].val];<br>				--cnt[a[md[tim].pos]];<br>				<span class="hljs-keyword">if</span>(!cnt[a[md[tim].pos]]) ans--;<br>			&#125;<br>			<span class="hljs-built_in">swap</span>(a[md[tim].pos],md[tim].val);<br>		&#125;<br>		<span class="hljs-keyword">while</span>(tt&lt;tim)&#123;<br>			<span class="hljs-keyword">if</span>(md[tim].pos&gt;=tl&amp;&amp;md[tim].pos&lt;=tr)&#123;<br>				<span class="hljs-keyword">if</span>(!cnt[md[tim].val]) ans++;<br>				++cnt[md[tim].val];<br>				--cnt[a[md[tim].pos]];<br>				<span class="hljs-keyword">if</span>(!cnt[a[md[tim].pos]]) ans--;<br>			&#125;<br>			<span class="hljs-built_in">swap</span>(a[md[tim].pos],md[tim].val);<br>			--tim;<br>		&#125;<br>		Ans[q[i].id]=ans;<br>	&#125;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,qcnt) <span class="hljs-built_in">write</span>(Ans[i]),<span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<h2 id="树上莫队"><a href="#树上莫队" class="headerlink" title="树上莫队"></a>树上莫队</h2>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>补题-2020USST算法竞赛练习场1</title>
    <url>/2020/02/22/%E8%A1%A5%E9%A2%98-2020USST%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E7%BB%83%E4%B9%A0%E5%9C%BA1/</url>
    <content><![CDATA[<h2 id="【补题系列】2020USST算法竞赛练习场1"><a href="#【补题系列】2020USST算法竞赛练习场1" class="headerlink" title="【补题系列】2020USST算法竞赛练习场1"></a><center>【补题系列】2020USST算法竞赛练习场1</center></h2><span id="more"></span>
<h3 id="HDU1018-Big-Number"><a href="#HDU1018-Big-Number" class="headerlink" title="HDU1018 Big Number"></a><a href="https://vjudge.net/problem/HDU-1018">HDU1018 Big Number</a></h3><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>题意：给你一个数$n$，要求输出$n!$的位数</p>
<p>算法：由数学知识可知，一个数$x$的位数是$[lgx]+1$，所以有</p>
<script type="math/tex; mode=display">
ans=\left[\sum_{i=1}^{n}lgx\right]+1</script><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> n;<br>	cin&gt;&gt;n;<br>	<span class="hljs-keyword">while</span>(n--)&#123;<br>		<span class="hljs-type">int</span> x;<br>		cin&gt;&gt;x;<br>		<span class="hljs-type">long</span> <span class="hljs-type">double</span> ans=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=x;i++)&#123;<br>			ans+=<span class="hljs-built_in">log10</span>(i);<br>		&#125;<br>		ans=<span class="hljs-built_in">floor</span>(ans)+<span class="hljs-number">1</span>;<br>		cout&lt;&lt;fixed&lt;&lt;<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">0</span>)&lt;&lt;ans&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="HDU1576-A-B"><a href="#HDU1576-A-B" class="headerlink" title="HDU1576 A/B"></a><a href="https://vjudge.net/problem/HDU-1576">HDU1576 A/B</a></h3><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>题意：要求$(A/B)\%9973$，给出$n(n=A\%9973)$和$B$，且$gcd(B,9973)=1$</p>
<p>算法：</p>
<ol>
<li>扩展欧几里得</li>
<li>答案就是$n*(b对9973的逆元)\%9973$，然后用快速幂算这个逆元，即$b^{9973-2}\%9973$</li>
</ol>
<h4 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h4><p>扩展欧几里得</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">9973</span>;<br><span class="hljs-type">int</span> x,y;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>	<span class="hljs-type">int</span> t;<br>	<span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)&#123;<br>		x=<span class="hljs-number">1</span>;<br>		y=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<span class="hljs-keyword">else</span>&#123;<br>		<span class="hljs-built_in">exgcd</span>(b,a%b);<br>		t=x;<br>		x=y;<br>		y=t-(a/b)*y;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> t;<br>	cin&gt;&gt;t;<br>	<span class="hljs-keyword">while</span>(t--)&#123;<br>		<span class="hljs-type">int</span> n,b;<br>		cin&gt;&gt;n&gt;&gt;b;<br>		<span class="hljs-built_in">exgcd</span>(b,mod);<br>		<span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) x+=mod;<br>		x*=n;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,x%mod);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>快速幂求逆元</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll; <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">9973</span>; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <br>    ll k,x,ans; <br>    <span class="hljs-type">int</span> t,n,b; <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t); <br>    <span class="hljs-keyword">while</span> (t--) &#123; <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;b); <br>        k=b; x=mod<span class="hljs-number">-2</span>; ans=<span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">while</span> (x) &#123; <span class="hljs-comment">//快速幂 </span><br>            <span class="hljs-keyword">if</span> (x&amp;<span class="hljs-number">1</span>) ans=ans*k%mod; <br>            k=k*k%mod; <br>            x&gt;&gt;=<span class="hljs-number">1</span>; &#125;<br>        ans=ans*n%mod; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans); <br>    &#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="HDU1712-ACboy-needs-your-help"><a href="#HDU1712-ACboy-needs-your-help" class="headerlink" title="HDU1712 ACboy needs your help"></a><a href="https://vjudge.net/problem/HDU-1712">HDU1712 ACboy needs your help</a></h3><h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>题意：不说了，算是裸的分组背包（见<a href="https://www.luogu.com.cn/problem/P1757">分组背包模板题</a>）</p>
<p>算法套路：依次枚举 数据组数、背包容量、每组数据内的单位数据（包括体积和价值）动态规划求解</p>
<h4 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> a[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">100005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> n,m;<br>	<span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)&#123;<br>		<span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a));<br>		<span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dp));<br>		<span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>&amp;&amp;m==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>				cin&gt;&gt;a[i][j];<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br>				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=j;k++)&#123;<br>					dp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j-k]+a[i][k]);<br>				&#125;<br>			&#125;<br>		&#125;<br>		cout&lt;&lt;dp[m]&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></div></td></tr></table></figure>
<h3 id="HDU6441-Find-Integer"><a href="#HDU6441-Find-Integer" class="headerlink" title="HDU6441 Find Integer"></a><a href="https://vjudge.net/problem/HDU-6441">HDU6441 Find Integer</a></h3><h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><p>题意：给出$n,a$，要求你求出满足$a^n+b^n=c^n$中的$b$和$c$</p>
<p>算法：根据费马大定理，$n=0或n&gt;2$都是无解的，对于$n=1$时，随便枚举；对于$n=2$时，有勾股奇偶构造公式如下</p>
<script type="math/tex; mode=display">
\begin{aligned}若a为奇数：&令x=\frac{a-1}{2}\\&b=x^2+(x+1)^2-1\\&c=x^2+(x+1)^2\\若a为偶数：&令x=\frac{a}{2}\\&b=x^2-1\\&c=x^2+1\\\end{aligned}</script><h4 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> t;<br>	cin&gt;&gt;t;<br>	<span class="hljs-keyword">while</span>(t--)&#123;<br>		<span class="hljs-type">int</span> n,a;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;n,&amp;a);<br>		<span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">2</span>||n==<span class="hljs-number">0</span>)&#123;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1 -1\n&quot;</span>);<br>		&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1 %d\n&quot;</span>,a+<span class="hljs-number">1</span>);<br>		&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==<span class="hljs-number">2</span>)&#123;<br>			<span class="hljs-keyword">if</span>(a&amp;<span class="hljs-number">1</span>)&#123;<br>				<span class="hljs-type">int</span> n=(a<span class="hljs-number">-1</span>)&gt;&gt;<span class="hljs-number">1</span>;<br>				<span class="hljs-type">int</span> b=n*n+(n+<span class="hljs-number">1</span>)*(n+<span class="hljs-number">1</span>)<span class="hljs-number">-1</span>;<br>				<span class="hljs-type">int</span> c=b+<span class="hljs-number">1</span>;<br>				<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,b,c);<br>				<span class="hljs-keyword">continue</span>;<br>			&#125;<span class="hljs-keyword">else</span>&#123;<br>				<span class="hljs-type">int</span> n=a&gt;&gt;<span class="hljs-number">1</span>;<br>				<span class="hljs-type">int</span> b=n*n<span class="hljs-number">-1</span>;<br>				<span class="hljs-type">int</span> c=b+<span class="hljs-number">2</span>;<br>				<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,b,c);<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="HDU1711-Number-Sequence"><a href="#HDU1711-Number-Sequence" class="headerlink" title="HDU1711 Number Sequence"></a><a href="https://vjudge.net/problem/HDU-1711">HDU1711 Number Sequence</a></h3><h4 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h4><p>题意：裸的<a href="https://www.luogu.com.cn/problem/P3375">KMP算法模板</a>，因为昨天刚学，所以记录一下</p>
<p>算法套路：模式串自己匹配自己构造出kmp数组，文本串用kmp数组去匹配</p>
<h4 id="AC代码-4"><a href="#AC代码-4" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> a[<span class="hljs-number">1000015</span>],b[<span class="hljs-number">1000015</span>];<br><span class="hljs-type">int</span> kmp[<span class="hljs-number">1000015</span>];<br><span class="hljs-type">bool</span> f=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> t;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<br>	<span class="hljs-keyword">while</span>(t--)&#123;<br>		f=<span class="hljs-number">0</span>;<br>		<span class="hljs-type">int</span> n,m;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;b[j]);<br>		&#125;<br>		<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=m;i++)&#123;<br>			<span class="hljs-keyword">while</span>(j&amp;&amp;b[i]!=b[j+<span class="hljs-number">1</span>]) j=kmp[j];<br>			<span class="hljs-keyword">if</span>(b[j+<span class="hljs-number">1</span>]==b[i]) j++;<br>			kmp[i]=j;<br>		&#125;<br>		j=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-keyword">while</span>(j&amp;&amp;b[j+<span class="hljs-number">1</span>]!=a[i]) j=kmp[j];<br>			<span class="hljs-keyword">if</span>(b[j+<span class="hljs-number">1</span>]==a[i]) j++;<br>			<span class="hljs-keyword">if</span>(j==m)&#123;<br>				<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,i-m+<span class="hljs-number">1</span>);<br>				f=<span class="hljs-number">1</span>;<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(!f) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="HDU5952-Counting-Cliques"><a href="#HDU5952-Counting-Cliques" class="headerlink" title="HDU5952 Counting Cliques"></a><a href="https://vjudge.net/problem/HDU-5952">HDU5952 Counting Cliques</a></h3><h4 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h4><p>题意：给一个无向无权图，求出其中节点数为$k$个的<strong>完全图</strong>的个数</p>
<p>完全图：$k$个定点的完全图定义为任意一个节点都与其余$k-1$个节点相连</p>
<p>算法：暴力DFS搜索，前向星存边，注意两点</p>
<ol>
<li>存单向边（小 指向 大），满足枚举时递增枚举，防止重复计算</li>
<li>每次枚举邻接点，减少枚举数</li>
</ol>
<h4 id="AC代码-5"><a href="#AC代码-5" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> v,next;<br>&#125;e[<span class="hljs-number">2005</span>];<br><span class="hljs-type">int</span> t,n,m,head[<span class="hljs-number">10005</span>],cnt,s,ans,size;<br><span class="hljs-type">bool</span> mm[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>];<br><span class="hljs-type">int</span> a[<span class="hljs-number">1005</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;<br>	e[++cnt].v=v;<br>	e[cnt].next=head[u];<br>	head[u]=cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123; <span class="hljs-comment">//判断是不是完全图</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=size;i++)&#123;<br>		<span class="hljs-keyword">if</span>(!mm[a[i]][u]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(size==s)&#123;<br>		ans++;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(v))&#123; <span class="hljs-comment">//如果这个点满足连上之后是完全图</span><br>			a[++size]=v; <span class="hljs-comment">//就给完全图加上这个点</span><br>			<span class="hljs-built_in">dfs</span>(v); <span class="hljs-comment">//继续搜索</span><br>			--size; <span class="hljs-comment">//回溯</span><br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<br>	<span class="hljs-keyword">while</span>(t--)&#123;<br>		cnt=<span class="hljs-number">0</span>;<br>		<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(head));<br>		<span class="hljs-built_in">memset</span>(e,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(e));<br>		<span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a));<br>		<span class="hljs-built_in">memset</span>(mm,<span class="hljs-literal">false</span>,<span class="hljs-built_in">sizeof</span>(mm));<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s);<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>			<span class="hljs-type">int</span> u,v;<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);<br>			<span class="hljs-keyword">if</span>(u&gt;v) <span class="hljs-built_in">swap</span>(u,v); <span class="hljs-comment">//存单向边</span><br>			<span class="hljs-built_in">addedge</span>(u,v);<br>			mm[u][v]=<span class="hljs-number">1</span>;<br>			mm[v][u]=<span class="hljs-number">1</span>;<br>		&#125;<br>		size=<span class="hljs-number">1</span>;<br>		ans=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123; <span class="hljs-comment">//从每一个点开始暴力枚举</span><br>			size=<span class="hljs-number">0</span>; <span class="hljs-comment">//每次枚举需要重置第一个完全图的点数为0</span><br>			a[++size]=i; <span class="hljs-comment">//将当前枚举的点加入完全图中</span><br>			<span class="hljs-built_in">dfs</span>(i); <span class="hljs-comment">//搜索</span><br>		&#125;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="HDU4336-Card-Collector"><a href="#HDU4336-Card-Collector" class="headerlink" title="HDU4336 Card Collector"></a><a href="https://vjudge.net/problem/HDU-4336">HDU4336 Card Collector</a></h3><h4 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h4><p>题意：分别给出$n$种卡片在一包零食中出现的概率，求集齐这$n$种卡片需要买的零食数量的期望</p>
<p>算法：概率论知识，举个例子，有两种卡片，出现概率分别为$P_1,P_2$，那么买到第1种卡片所需零食包数期望为$\frac{1}{P_1}$，同理，买到第2种卡片所需零食包数期望为$\frac{1}{P_2}$，而买到第1种或第2种卡片所需零食包数期望为$\frac{1}{P_1+P_2}$，</p>
<p>那么集齐这两种卡片所需的零食数量（根据<strong>容斥原理</strong>）为：</p>
<script type="math/tex; mode=display">
ans=\frac{1}{P_1}+\frac{1}{P_2}-\frac{1}{P_1+P_2}</script><p>同理三种情况的结果如下：</p>
<script type="math/tex; mode=display">
ans=\frac{1}{P_1}+\frac{1}{P_2}+\frac{1}{P_3}-\frac{1}{P_1+P_2}-\frac{1}{P_1+P_3}-\frac{1}{P_2+P_3}+\frac{1}{P_1+P_2+P_3}</script><p>以此类推，这就是容斥原理，于是考虑可以利用二进制枚举$n$的所有状态（共$2^n-1$种），然后枚举$P_i$（利用位运算和&amp;运算符）计算出上方公式中的每一项，分母中有奇数个P就加上这个项，偶数个P就减去这个项</p>
<h4 id="AC代码-6"><a href="#AC代码-6" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">double</span> p[<span class="hljs-number">25</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> n;<br>	<span class="hljs-keyword">while</span>(cin&gt;&gt;n)&#123;<br>		<span class="hljs-built_in">memset</span>(p,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(p));<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,&amp;p[i]);<br>		&#125;<br>		<span class="hljs-type">double</span> ans=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);i++)&#123; <span class="hljs-comment">//二进制枚举所有状态</span><br>			<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>			<span class="hljs-type">double</span> sum=<span class="hljs-number">0</span>;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>				<span class="hljs-keyword">if</span>(i&amp;(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>)))&#123; <span class="hljs-comment">//把对应状态下的P算上</span><br>					cnt++;<br>					sum+=p[j];<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">if</span>(cnt&amp;<span class="hljs-number">1</span>) ans+=<span class="hljs-number">1</span>/sum; <span class="hljs-comment">//若有奇数个P，则相加</span><br>			<span class="hljs-keyword">else</span> ans-=<span class="hljs-number">1</span>/sum; <span class="hljs-comment">//若有偶数个P，则相减</span><br>		&#125;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.4lf\n&quot;</span>,ans); <span class="hljs-comment">//注意精度</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<hr>
<p>以上几题让我学到了新姿势！</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>补题-2020USST算法竞赛练习场2</title>
    <url>/2020/02/26/%E8%A1%A5%E9%A2%98-2020USST%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E7%BB%83%E4%B9%A0%E5%9C%BA2/</url>
    <content><![CDATA[<h2 id="【补题系列】2020USST算法竞赛练习场2"><a href="#【补题系列】2020USST算法竞赛练习场2" class="headerlink" title="【补题系列】2020USST算法竞赛练习场2"></a><center>【补题系列】2020USST算法竞赛练习场2</center></h2><span id="more"></span>
<h3 id="HDU-3527-SPY"><a href="#HDU-3527-SPY" class="headerlink" title="HDU 3527 SPY"></a><a href="https://vjudge.net/problem/HDU-3527">HDU 3527 SPY</a></h3><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>题意：第一行输入三个数，分别代表乘客数、Y国间谍数、XY双重间谍数，然后依次每行输入对应的名字，要求找出乘客中不是双重间谍的Y国间谍并输出</p>
<p>很简单，当时没太看懂题QAQ，用vector实现即可</p>
<h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>string ss[<span class="hljs-number">1005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> n,m,k;<br>	<span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;m&gt;&gt;k)&#123;<br>		vector&lt;string&gt; aa,bb,cc,dd;<br>		string s;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>			cin&gt;&gt;s;<br>			aa.<span class="hljs-built_in">push_back</span>(s);<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>			cin&gt;&gt;s;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>				<span class="hljs-keyword">if</span>(aa[j]==s)&#123;<br>					bb.<span class="hljs-built_in">push_back</span>(s);<br>					<span class="hljs-keyword">break</span>;<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>			cin&gt;&gt;s;<br>			cc.<span class="hljs-built_in">push_back</span>(s);<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;bb.<span class="hljs-built_in">size</span>();i++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cc.<span class="hljs-built_in">size</span>();j++)&#123;<br>				<span class="hljs-keyword">if</span>(bb[i]==cc[j]) <span class="hljs-keyword">break</span>;<br>				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j==cc.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)&#123;<br>					dd.<span class="hljs-built_in">push_back</span>(bb[i]);<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(dd.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)&#123;<br>			cout&lt;&lt;<span class="hljs-string">&quot;No enemy spy&quot;</span>&lt;&lt;endl;<br>			<span class="hljs-keyword">continue</span>;<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;dd.<span class="hljs-built_in">size</span>();i++)&#123;<br>			<span class="hljs-keyword">if</span>(i!=dd.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)cout&lt;&lt;dd[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>			<span class="hljs-keyword">else</span> cout&lt;&lt;dd[i];<br>		&#125;<br>		cout&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="HDU-1690-Bus-System"><a href="#HDU-1690-Bus-System" class="headerlink" title="HDU 1690 Bus System"></a><a href="https://vjudge.net/problem/HDU-1690">HDU 1690 Bus System</a></h3><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>题意：给定若干站点，并给出一个表，表明某些距离段内的票价，有若干次询问，要求输出询问中两站点之间的最小票价</p>
<p>算法：floyd</p>
<p>首先预处理出任意两个点间的距离对应的票价，然后用一遍floyd求出每两个点间的最小票价，最后输出即可，（注意英文单词别打错！Orz）</p>
<h4 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1ll</span>&lt;&lt;<span class="hljs-number">60</span>;<br><span class="hljs-type">int</span> l[<span class="hljs-number">105</span>],c[<span class="hljs-number">105</span>],n,m;<br>ll dis[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>];<br><span class="hljs-type">int</span> pos[<span class="hljs-number">105</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> t;<br>	cin&gt;&gt;t;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> o=<span class="hljs-number">1</span>;o&lt;=t;o++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">4</span>;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,l+i);<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">4</span>;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,c+i);<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,pos+i);<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>				<span class="hljs-keyword">if</span>(i==j) dis[i][j]=<span class="hljs-number">0</span>;<br>				<span class="hljs-keyword">else</span> dis[i][j]=inf;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>				<span class="hljs-type">int</span> distance=<span class="hljs-built_in">abs</span>(pos[i]-pos[j]);<br>				ll w=inf;<br>				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">4</span>;k++)&#123;<br>					<span class="hljs-keyword">if</span>(distance&lt;=l[k])&#123;<br>						w=c[k];<br>						<span class="hljs-keyword">break</span>;<br>					&#125;<br>				&#125;<br>				dis[i][j]=dis[j][i]=<span class="hljs-built_in">min</span>(dis[i][j],w);<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>					dis[i][j]=<span class="hljs-built_in">min</span>(dis[i][j],dis[i][k]+dis[k][j]);<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case %d:\n&quot;</span>,o);<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>			<span class="hljs-type">int</span> x,y;<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<br>			<span class="hljs-keyword">if</span>(dis[x][y]==inf)&#123;<br>				<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Station %d and station %d are not attainable.\n&quot;</span>,x,y);<br>			&#125;<span class="hljs-keyword">else</span>&#123;<br>				<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The minimum cost between station %d and station %d is %lld.\n&quot;</span>,x,y,dis[x][y]);<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="HDU-4970-Killing-Monsters"><a href="#HDU-4970-Killing-Monsters" class="headerlink" title="HDU 4970 Killing Monsters"></a><a href="https://vjudge.net/problem/HDU-4970">HDU 4970 Killing Monsters</a></h3><h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>题意：给定一行格子、若干炮塔、若干敌人，炮塔固定一个坐标，拥有一个范围的攻击力，一次能对该范围内敌人造成攻击力的伤害，敌人在固定坐标内出现并朝着终点走，一次走一格，求最后还剩几个敌人活着</p>
<p>算法：差分+前缀和（倒前缀和）</p>
<p>很简单的前缀和题，由于敌人是朝着终点走，于是可以从终点向起点过两遍前缀和，就能求出每个点的累计伤害，然后把他跟每个敌人的生命值比较即可</p>
<h4 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">int</span> n,m,k,cor[<span class="hljs-number">100005</span>];<br>ll hp[<span class="hljs-number">100005</span>],gg[<span class="hljs-number">100005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)!=EOF&amp;&amp;n!=<span class="hljs-number">0</span>)&#123;<br>		<span class="hljs-built_in">memset</span>(gg,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(gg));<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;m);<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>			<span class="hljs-type">int</span> l,r,d;<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;d);<br>			gg[r]+=d;<br>			gg[l<span class="hljs-number">-1</span>]-=d;<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>			gg[i]=gg[i]+gg[i+<span class="hljs-number">1</span>];<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>			gg[i]=gg[i]+gg[i+<span class="hljs-number">1</span>];<br>		&#125;<br>	<span class="hljs-comment">//	for(int i=1;i&lt;=n;i++) cout&lt;&lt;gg[i]&lt;&lt;&quot; &quot;;</span><br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;k);<br>		<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;i++)&#123;<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%d&quot;</span>,&amp;hp[i],&amp;cor[i]);<br>			<span class="hljs-keyword">if</span>(hp[i]&lt;=gg[cor[i]]) ans++;<br>		&#125;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,n-ans);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="HDU-1789-Doing-Homework-again"><a href="#HDU-1789-Doing-Homework-again" class="headerlink" title="HDU 1789 Doing Homework again"></a><a href="https://vjudge.net/problem/HDU-1789">HDU 1789 Doing Homework again</a></h3><h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><p>这题比赛时AC了，但是感觉是个比较好的贪心题，记录一下</p>
<p>题意：给定若干作业的DDL，以及如果交不了的话对应的惩罚分数，求最小惩罚分数</p>
<p>算法：贪心</p>
<p>让所有作业按照惩罚降序排序，惩罚相同则按DDL升序排序，然后从第一个作业开始遍历，把他放到对应的DDL做，如果这一天已经被占用了，则往前挪即可，如果挪到了第0天都没做成，则ans+对应惩罚分数</p>
<h4 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>	<span class="hljs-type">int</span> x,y;<br>&#125;a[<span class="hljs-number">10005</span>];<br><span class="hljs-type">bool</span> vis[<span class="hljs-number">10005</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node x1,node x2)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(x1.y==x2.y) <span class="hljs-keyword">return</span> x1.x&lt;x2.x;<br>	<span class="hljs-keyword">return</span> x1.y&gt;x2.y;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> t;<br>	cin&gt;&gt;t;<br>	<span class="hljs-keyword">while</span>(t--)&#123;<br>		<span class="hljs-type">int</span> n;<br>		cin&gt;&gt;n;<br>		<span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			cin&gt;&gt;a[i].x;<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			cin&gt;&gt;a[i].y;<br>		&#125;<br>		<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">1</span>+n,cmp);<br>		<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-type">int</span> td=a[i].x;<br>			<span class="hljs-keyword">while</span>(td&gt;<span class="hljs-number">0</span>&amp;&amp;vis[td]==<span class="hljs-number">1</span>) td--;<br>			<span class="hljs-keyword">if</span>(td==<span class="hljs-number">0</span>)&#123;<br>				ans+=a[i].y;<br>			&#125;<span class="hljs-keyword">else</span>&#123;<br>				vis[td]=<span class="hljs-number">1</span>;<br>			&#125;<br>		&#125;<br>		cout&lt;&lt;ans&lt;&lt;endl;<br>	&#125;		<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="HDU-4143-A-Simple-Problem"><a href="#HDU-4143-A-Simple-Problem" class="headerlink" title="HDU 4143 A Simple Problem"></a><a href="https://vjudge.net/problem/HDU-4143">HDU 4143 A Simple Problem</a></h3><h4 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h4><p>也AC了，但是是自己做的不多的数学题，记录一下</p>
<p>题意：给定$n$，求满足$y^2=n+x^2$的最小的正整数$x$</p>
<p>算法：数学</p>
<p>把题目式子变形成$(y-x)(y+x)=n$，令$i=y-x,\frac{n}{i}=y+x$，求得$x=\frac{\frac{n}{i}-i}{2},y=\frac{\frac{n}{i}+i}{2}$，由于要求最小的<code>x</code>，所以<code>i</code>可以从<code>sqrt(n)</code>开始遍历，满足<code>n%i==0&amp;&amp;(n/i+1)%2==0&amp;&amp;(n/i-1)%2==0&amp;&amp;n/i-i!=0</code>的第一个<code>i</code>即得答案</p>
<h4 id="AC代码-4"><a href="#AC代码-4" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> t;<br>	cin&gt;&gt;t;<br>	<span class="hljs-keyword">while</span>(t--)&#123;<br>		<span class="hljs-type">int</span> n;<br>		cin&gt;&gt;n;<br>		<span class="hljs-type">bool</span> f=<span class="hljs-literal">true</span>;<br>		<span class="hljs-type">int</span> i=(<span class="hljs-type">int</span>)<span class="hljs-built_in">sqrt</span>(n);<br>		<span class="hljs-keyword">for</span>(;i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>			<span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>&amp;&amp;(n/i+i)%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>&amp;&amp;(n/i-i)%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>&amp;&amp;n/i-i!=<span class="hljs-number">0</span>)&#123;<br>				cout&lt;&lt;(n/i-i)/<span class="hljs-number">2</span>&lt;&lt;endl;<br>				f=<span class="hljs-literal">false</span>;<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(f) cout&lt;&lt;<span class="hljs-string">&quot;-1&quot;</span>&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>补题-2020USST算法竞赛练习场4</title>
    <url>/2020/02/28/%E8%A1%A5%E9%A2%98-2020USST%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E7%BB%83%E4%B9%A0%E5%9C%BA4/</url>
    <content><![CDATA[<h2 id="【补题系列】2020USST算法竞赛练习场4"><a href="#【补题系列】2020USST算法竞赛练习场4" class="headerlink" title="【补题系列】2020USST算法竞赛练习场4"></a><center>【补题系列】2020USST算法竞赛练习场4</center></h2><span id="more"></span>
<h2 id="CF-1294D-MEX-maximizing"><a href="#CF-1294D-MEX-maximizing" class="headerlink" title="CF 1294D MEX maximizing"></a><a href="https://vjudge.net/problem/CodeForces-1294D">CF 1294D MEX maximizing</a></h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题意：定义MEX为一个集合中未出现的最小非负整数，现在有q次询问，每次添加一个数进入集合中，每次操作都可以让集合中任意一个值+x或-x若干次，求每次询问后的最大MEX值</p>
<p>算法：贪心</p>
<p>由于+x和-x的操作是任意次的，因此每次询问时只需存储<code>新加的数%x</code>的值，按照题意需要从0开始尽可能填满之后的数，因此一开始假设答案为0，之后只要<code>ans%x</code>存在就可以使<code>ans++</code>，然后每次输出答案即可</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> giao[<span class="hljs-number">1000005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> n,x;<br>	cin&gt;&gt;n&gt;&gt;x;<br>	<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-type">int</span> y;<br>		cin&gt;&gt;y;<br>		giao[y%x]++;<br>		<span class="hljs-keyword">while</span>(giao[ans%x]&gt;=<span class="hljs-number">1</span>)&#123;<br>			giao[ans%x]--;<br>			ans++;<br>		&#125;<br>		cout&lt;&lt;ans&lt;&lt;endl;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="CF-1301C-Ayoub’s-function"><a href="#CF-1301C-Ayoub’s-function" class="headerlink" title="CF 1301C Ayoub’s function"></a><a href="https://vjudge.net/problem/CodeForces-1301C">CF 1301C Ayoub’s function</a></h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>题意：给出n位由0或1构成数，再给出其中包含的1的个数m（其余n-m位全是0），要求求出其中包含至少一个1的子串的种类数</p>
<p>算法：数学 + 逆向思维</p>
<p>题目要求找包含至少一个1的种类数，一看就很多，所以可以逆向思维，最多可以有<code>n*(n+1)/2</code>种，然后再减去全是0的种类数就可以了，可以分类讨论一下</p>
<ol>
<li>当全是1时：<code>ans=(n+1)*n/2</code></li>
<li><p>全是0时：<code>ans=0</code></p>
</li>
<li><p>当1的个数大于0的个数时：很容易想到用1把所有0都分隔开，比如5位数有3个1，则最佳情况应该是10101，因此答案很容易想到：<code>ans=n*(n+1)/2-(n-m)</code></p>
</li>
<li><p>当1的个数小于0的个数时：此时也应该尽量用1把所有0都分隔开，而且要尽量均摊，比如00100100是最佳的，m个1可以把(n-m)个0分隔成(m+1)份，每一份的0的数量是<code>mf=(n-m)/(m+1)</code>，此时还余下<code>duo=(n-m)%(m+1)</code>个0没有被分配，那么久把它丢进去继续分配，因此答案为<code>ans=(n+1)*n/2-(m+1-duo)*mf(mf+1)/2-duo*(mf+1)*(mf+2)/2</code></p>
</li>
</ol>
<h3 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> n;<br>	cin&gt;&gt;n;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		ll x,y;<br>		cin&gt;&gt;x&gt;&gt;y;<br>		<span class="hljs-keyword">if</span>(y==<span class="hljs-number">0</span>)&#123;<br>			cout&lt;&lt;<span class="hljs-string">&quot;0&quot;</span>&lt;&lt;endl;<br>			<span class="hljs-keyword">continue</span>;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(x==y)&#123;<br>			cout&lt;&lt;x*(x+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>&lt;&lt;endl;<br>			<span class="hljs-keyword">continue</span>;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(y&gt;=x-y)&#123;<br>			cout&lt;&lt;(x+<span class="hljs-number">1</span>)*x/<span class="hljs-number">2</span>-(x-y)&lt;&lt;endl;<br>			<span class="hljs-keyword">continue</span>;<br>		&#125;<br>		ll ling=x-y;<br>		ll mf=ling/(y+<span class="hljs-number">1</span>);<br>		ll duo=ling%(y+<span class="hljs-number">1</span>);<br>		ll ans=(x+<span class="hljs-number">1</span>)*x/<span class="hljs-number">2</span>;<br>		ans-=(y+<span class="hljs-number">1</span>-duo)*mf*(mf+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>		ans-=duo*(mf+<span class="hljs-number">1</span>)*(mf+<span class="hljs-number">2</span>)/<span class="hljs-number">2</span>;<br>		cout&lt;&lt;ans&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="HDU-5015-233Matrix"><a href="#HDU-5015-233Matrix" class="headerlink" title="HDU 5015 233Matrix"></a><a href="https://vjudge.net/problem/HDU-5015">HDU 5015 233Matrix</a></h2><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>个人觉得比较好的矩阵加速题，记录一下</p>
<p>题意：给出一个n行m列矩阵的第一列2~n行的数值，该矩阵第一行从第2列到第m列分别为233、2333、23333。。。其余位置$a<em> {i,j}=a</em> {i-1,j}+a_{i,j-1}$，现在要求你求出第n行m列的数的值（mod 10000007）的答案</p>
<p>算法：矩阵加速（矩阵快速幂）</p>
<p>容易发现题目的矩阵长这样</p>
<script type="math/tex; mode=display">
\begin{pmatrix} 0&233&... \\a_1&233+a_1&...\\a_2&233+a_1+a_2&...\\...&...&...\\a_n&233+a_1+a_2+...+a_n&...\end{pmatrix}</script><p>由于n很小但m特别大，直接递推肯定T，所以联想到矩阵加速，我们把第一列提取出来，想办法构造一个矩阵，让第一列乘完这个矩阵之后变成第二列，然后套矩阵快速幂</p>
<p>但是发现这个233不好构造，考虑到左上角第一个数没用，所以我们可以令它为23，然后给这个矩阵多加一行3，就可以构造成如下的矩阵啦</p>
<script type="math/tex; mode=display">
\begin{pmatrix}23&a_1&a_2&...&a_n&3\end{pmatrix}\begin{pmatrix}10&10&10&...&10&0\\0&1&1&...&1&0\\0&0&1&...&1&0\\...&...&...&...&...&...\\0&0&0&...&1&0\\1&1&1&...&1&1\end{pmatrix}\\=\begin{pmatrix}233&233+a_1&233+a_1+a_2&...&233+a_1+a_2+...a_n&3\end{pmatrix}</script><p>出于习惯原因，我把第一列写成了行向量，总共<code>n+2</code>行，矩阵是<code>(n+2)*(n+2)</code>的方阵，接下来套矩阵快速幂即可</p>
<h3 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">1e7</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">M</span>&#123;<br>	ll mat[<span class="hljs-number">15</span>][<span class="hljs-number">15</span>];<br>&#125;ans;<br><br>M <span class="hljs-keyword">operator</span> *(M x1,M x2)&#123;<br>	M res;<br>	<span class="hljs-built_in">memset</span>(res.mat,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(res.mat));<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+<span class="hljs-number">2</span>;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n+<span class="hljs-number">2</span>;j++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n+<span class="hljs-number">2</span>;k++)&#123;<br>				res.mat[i][j]+=(x1.mat[i][k]%mod*x2.mat[k][j]%mod)%mod;<br>				res.mat[i][j]%=mod;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> M <span class="hljs-title">qpow</span><span class="hljs-params">(M a,ll k,M ans)</span></span>&#123;<br>	M base=a;<br>	<span class="hljs-keyword">while</span>(k&gt;<span class="hljs-number">0</span>)&#123;<br>		<span class="hljs-keyword">if</span>(k&amp;<span class="hljs-number">1</span>) ans=ans*base;<br>		base=base*base;<br>		k&gt;&gt;=<span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)!=EOF)&#123;<br>		<span class="hljs-built_in">memset</span>(ans.mat,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(ans));<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n+<span class="hljs-number">1</span>;i++)&#123;<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;ans.mat[<span class="hljs-number">1</span>][i]);<br>		&#125;<br>		ans.mat[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">23</span>;<br>		ans.mat[<span class="hljs-number">1</span>][n+<span class="hljs-number">2</span>]=<span class="hljs-number">3</span>;<br>		M a;<br>		<span class="hljs-built_in">memset</span>(a.mat,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a.mat));<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n+<span class="hljs-number">1</span>;i++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;=n+<span class="hljs-number">1</span>;j++)&#123;<br>				a.mat[i][j]=<span class="hljs-number">1</span>;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+<span class="hljs-number">1</span>;i++)&#123;<br>			a.mat[<span class="hljs-number">1</span>][i]=<span class="hljs-number">10</span>;<br>			a.mat[n+<span class="hljs-number">2</span>][i]=<span class="hljs-number">1</span>;<br>		&#125;<br>		a.mat[n+<span class="hljs-number">2</span>][n+<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;<br>		M anss=<span class="hljs-built_in">qpow</span>(a,m,ans);<br>		cout&lt;&lt;anss.mat[<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>]%mod&lt;&lt;endl; <br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></div></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>补题-2020USST算法竞赛练习场3</title>
    <url>/2020/02/27/%E8%A1%A5%E9%A2%98-2020USST%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E7%BB%83%E4%B9%A0%E5%9C%BA3/</url>
    <content><![CDATA[<h2 id="【补题系列】2020USST算法竞赛练习场3"><a href="#【补题系列】2020USST算法竞赛练习场3" class="headerlink" title="【补题系列】2020USST算法竞赛练习场3"></a><center>【补题系列】2020USST算法竞赛练习场3</center></h2><span id="more"></span>
<h3 id="HDU-2369-Broken-Keyboard"><a href="#HDU-2369-Broken-Keyboard" class="headerlink" title="HDU 2369 Broken Keyboard"></a><a href="https://vjudge.net/problem/HDU-2369">HDU 2369 Broken Keyboard</a></h3><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>比较典型的双指针题，比赛时AC了，但还是记录一下</p>
<p>题意：给定n和字符串s，要求求出s中字母种类数不超过n的最长子串的长度</p>
<p>算法：双指针</p>
<p>题目也就是要求维护一个特殊的队列，不断往队头加元素，当队列中字符种类数大于n时，队尾元素出队，循环直到队头指针到达字符串末尾</p>
<h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> m[<span class="hljs-number">500</span>]; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <br>    <span class="hljs-type">int</span> n; <br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n&amp;&amp;n) &#123; <br>        <span class="hljs-type">int</span> fr,en,len,cur=<span class="hljs-number">0</span>,asd=<span class="hljs-number">0</span>; <br>        string ss;<span class="hljs-built_in">getline</span>(cin,ss); <br>        fr=en=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">memset</span>(m,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(m));<br>        len=ss.<span class="hljs-built_in">length</span>(); <br>        <span class="hljs-keyword">while</span>(en&lt;len) &#123; <br>            <span class="hljs-keyword">if</span>(m[ss[en]]==<span class="hljs-number">0</span>)<span class="hljs-comment">//首次出现 </span><br>            &#123; <br>                m[ss[en]]=<span class="hljs-number">1</span>;<br>                cur++;<span class="hljs-comment">//种类增加 </span><br>            &#125;<span class="hljs-keyword">else</span> m[ss[en]]++; <br>            <span class="hljs-keyword">while</span>(cur&gt;n)<span class="hljs-comment">//出列pop </span><br>            &#123; <br>                m[ss[fr]]--; <br>                <span class="hljs-keyword">if</span>(m[ss[fr]]==<span class="hljs-number">0</span>)cur--;<span class="hljs-comment">//更新种类 </span><br>                fr++; <br>            &#125;<br>            asd=<span class="hljs-built_in">max</span>(asd,en-fr+<span class="hljs-number">1</span>);<span class="hljs-comment">//记录最大 </span><br>            en++; <br>        &#125;<br>        cout&lt;&lt;asd&lt;&lt;endl; <br>    &#125; <br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="HDU-5707-Combine-String"><a href="#HDU-5707-Combine-String" class="headerlink" title="HDU 5707 Combine String"></a><a href="https://vjudge.net/problem/HDU-5707">HDU 5707 Combine String</a></h3><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>题意：给定三个字符串，判断是否存在一种拆分方案使得a、b分别组成c的子串</p>
<p>算法：dp</p>
<p>用<code>dp[i][j]</code>表示c的前<code>i+j</code>个字符创能否由a的前<code>i</code>个字符和b的前<code>j</code>个字符组成，状态转移方程为<code>dp[i][j]=dp[i-1][j]&amp;&amp;a[i]==c[i+j]||dp[i][j-1]&amp;&amp;b[j]==c[i+j]</code></p>
<p>PS：代码中的<code>|=</code>代表两个状态满足其一即可，因为dp只有0和1两种状态</p>
<h4 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">2005</span>][<span class="hljs-number">2005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	string a,b,c;<br>	<span class="hljs-keyword">while</span>(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c)&#123;<br>		<span class="hljs-type">int</span> len1=a.<span class="hljs-built_in">length</span>(),len2=b.<span class="hljs-built_in">length</span>(),len3=c.<span class="hljs-built_in">length</span>();<br>		<span class="hljs-keyword">if</span>(len1+len2!=len3)&#123;<br>			cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>			<span class="hljs-keyword">continue</span>;<br>		&#125;<br>		<span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dp));<br>		dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=len1;i++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=len2;j++)&#123;<br>				<span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;a[i<span class="hljs-number">-1</span>]==c[i+j<span class="hljs-number">-1</span>]) dp[i][j]|=dp[i<span class="hljs-number">-1</span>][j];<br>				<span class="hljs-keyword">if</span>(j&gt;<span class="hljs-number">0</span>&amp;&amp;b[j<span class="hljs-number">-1</span>]==c[i+j<span class="hljs-number">-1</span>]) dp[i][j]|=dp[i][j<span class="hljs-number">-1</span>];<br>			&#125;<br>		&#125;<br>		cout&lt;&lt;(dp[len1][len2]?<span class="hljs-string">&quot;Yes&quot;</span>:<span class="hljs-string">&quot;No&quot;</span>)&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>补题-2020USST算法竞赛练习场7</title>
    <url>/2020/03/07/%E8%A1%A5%E9%A2%98-2020USST%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E7%BB%83%E4%B9%A0%E5%9C%BA7/</url>
    <content><![CDATA[<h2 id="【补题系列】2020USST算法竞赛练习场7"><a href="#【补题系列】2020USST算法竞赛练习场7" class="headerlink" title="【补题系列】2020USST算法竞赛练习场7"></a><center>【补题系列】2020USST算法竞赛练习场7</center></h2><span id="more"></span>
<h2 id="ZOJ-3212-Nice"><a href="#ZOJ-3212-Nice" class="headerlink" title="ZOJ-3212 Nice"></a><a href="https://vjudge.net/problem/ZOJ-3212">ZOJ-3212 Nice</a></h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题意：构造出一个n行m列的矩阵，其中有k个元素是‘’nice‘’的，一个元素是“nice”的当且仅当这个元素等于上下左右四个元素的和</p>
<p>算法：想象力</p>
<p>可以想象，一开始矩阵全是0，则nice的元素个数为<code>(n-2)*(m-2)</code>，我们从第一行第二列开始一次往后填1（或别的数），就会使得nice数减少1</p>
<p>需要特判一下从第二行往后的第二列的数为1而第三列不为1的情况（是nice的），因此需要把这一行的第一列置为1</p>
<p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">int</span> a[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> t;cin&gt;&gt;t;<br>	<span class="hljs-keyword">while</span>(t--)&#123;<br>		<span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a));<br>		<span class="hljs-type">int</span> n,m,k;<br>		cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>		<span class="hljs-type">int</span> tot=(n<span class="hljs-number">-2</span>)*(m<span class="hljs-number">-2</span>)-k;<br>		a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>;j&lt;m;j++)&#123;<br>			<span class="hljs-keyword">if</span>(tot&gt;<span class="hljs-number">0</span>)&#123;<br>				a[<span class="hljs-number">1</span>][j]=<span class="hljs-number">1</span>;<br>				tot--;<br>			&#125;<span class="hljs-keyword">else</span>&#123;<br>				a[<span class="hljs-number">1</span>][j]=<span class="hljs-number">0</span>;<br>			&#125;<br>		&#125;<br>		a[<span class="hljs-number">1</span>][m]=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>;j&lt;m;j++)&#123;<br>				<span class="hljs-keyword">if</span>(tot&gt;<span class="hljs-number">0</span>)&#123;<br>					a[i][j]=<span class="hljs-number">1</span>;<br>					tot--;<br>				&#125;<span class="hljs-keyword">else</span>&#123;<br>					a[i][j]=<span class="hljs-number">0</span>;<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-keyword">if</span>(a[i][<span class="hljs-number">2</span>]==<span class="hljs-number">1</span>&amp;&amp;a[i][<span class="hljs-number">3</span>]==<span class="hljs-number">0</span>)&#123;<br>				a[i][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>				<span class="hljs-keyword">if</span>(j!=m) cout&lt;&lt;a[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>				<span class="hljs-keyword">else</span> cout&lt;&lt;a[i][j]&lt;&lt;endl;<br>			&#125;<br>		&#125;<br>		<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="计蒜客-A1251-Half-consecutive-Numbers"><a href="#计蒜客-A1251-Half-consecutive-Numbers" class="headerlink" title="计蒜客-A1251 Half-consecutive Numbers"></a><a href="https://vjudge.net/problem/计蒜客-A1251">计蒜客-A1251 Half-consecutive Numbers</a></h3><p>题意：定义一个数列$t<em>i=\frac{1}{2}i(i+1)$，给定N，求满足$t</em>{\tau}$为完全平方数且$\tau \geq N$的最小的$\tau$</p>
<p>算法：打表</p>
<p>首先暴力打表观察一下规律</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">i</th>
<th style="text-align:center">t_i</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">36</td>
</tr>
<tr>
<td style="text-align:center">49</td>
<td style="text-align:center">1225</td>
</tr>
<tr>
<td style="text-align:center">288</td>
<td style="text-align:center">41616</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
</div>
<script type="math/tex; mode=display">
\begin{aligned}1&\to 1\\8&=3^2-1&\to 36&=2^2\cdot3^2\\49&=7^2&\to 1225&=5^2\cdot 7^2\\288&=17^2-1&\to 41616&=12^2\cdot 17^2\\...\end{aligned}</script><p>发现每个$t_i$可以拆分成两个数的平方数，且第一个数等于上一个$t_i$的两个数之和，第二个数根据奇偶性来判断，然后就有了如下打表程序</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;biao.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout);<br>	ll a=<span class="hljs-number">1</span>,b=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">50</span>;i++)&#123;<br>		<span class="hljs-keyword">if</span>(i&amp;<span class="hljs-number">1</span>)&#123;<br>			ll giao=(a+b)*(a+b)*<span class="hljs-number">2</span>;<br>			b=giao+<span class="hljs-number">1</span>;<br>			a=giao/<span class="hljs-number">2</span>;<br>			cout&lt;&lt;b<span class="hljs-number">-1</span>&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;endl;<br>			b=<span class="hljs-built_in">sqrt</span>(b);<br>			a=<span class="hljs-built_in">sqrt</span>(a);<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>			ll giao=(a+b)*(a+b)*<span class="hljs-number">2</span>;<br>			b=giao<span class="hljs-number">-1</span>;<br>			a=giao/<span class="hljs-number">2</span>;<br>			cout&lt;&lt;b&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;endl;<br>			b=<span class="hljs-built_in">sqrt</span>(b);<br>			a=<span class="hljs-built_in">sqrt</span>(a);<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>然后就可以AC了</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll a[<span class="hljs-number">21</span>]=&#123;<br><span class="hljs-number">1</span>,<br><span class="hljs-number">8</span>,<br><span class="hljs-number">49</span>,<br><span class="hljs-number">288</span>,<br><span class="hljs-number">1681</span>,<br><span class="hljs-number">9800</span>,<br><span class="hljs-number">57121</span>,<br><span class="hljs-number">332928</span>,<br><span class="hljs-number">1940449</span>,<br><span class="hljs-number">11309768</span>,<br><span class="hljs-number">65918161</span>,<br><span class="hljs-number">384199200</span>,<br><span class="hljs-number">2239277041</span>,<br><span class="hljs-number">13051463048</span>,<br><span class="hljs-number">76069501249</span>,<br><span class="hljs-number">443365544448</span>,<br><span class="hljs-number">2584123765441</span>,<br><span class="hljs-number">15061377048200</span>,<br><span class="hljs-number">87784138523761</span>,<br><span class="hljs-number">511643454094368</span>,<br><span class="hljs-number">2982076586042449</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> t ;<br>	cin&gt;&gt;t;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> o=<span class="hljs-number">1</span>;o&lt;=t;o++)&#123;<br>		ll n;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;n);<br>		<span class="hljs-keyword">if</span>(n&gt;a[<span class="hljs-number">20</span>])&#123;<br>			cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl;<br>			<span class="hljs-keyword">continue</span>;<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">21</span>;i++)&#123;<br>			<span class="hljs-keyword">if</span>(a[i]&gt;=n)&#123;<br>				<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case #%d: %lld\n&quot;</span>,o,a[i]);<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>		&#125;<br>	&#125; <br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>补题-2020USST算法竞赛练习场9</title>
    <url>/2020/03/12/%E8%A1%A5%E9%A2%98-2020USST%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E7%BB%83%E4%B9%A0%E5%9C%BA9/</url>
    <content><![CDATA[<h2 id="【补题系列】2020USST算法竞赛练习场9"><a href="#【补题系列】2020USST算法竞赛练习场9" class="headerlink" title="【补题系列】2020USST算法竞赛练习场9"></a><center>【补题系列】2020USST算法竞赛练习场9</center></h2><span id="more"></span>
<ul>
<li>先记录一下两道好题</li>
</ul>
<h2 id="Minimun-Spanning-Tree"><a href="#Minimun-Spanning-Tree" class="headerlink" title="Minimun Spanning Tree"></a><a href="https://vjudge.net/problem/Gym-102220E">Minimun Spanning Tree</a></h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题意：</p>
<p>给出有n个节点和n-1条边的无向带权图（树），把边视为节点，节点视为边，构造一个新图，新图的边只存在于构成该边所连的两原图的边存在公共节点，边权为该边所连的原图的两边的边权之和，求这个新图的最小生成树（MST）</p>
<p>题解：</p>
<p>首先可以无脑想到，不就是求最小生成树嘛，建图然后prim或者kruskal走起呗<br>但问题是这个图怎么建？<del>想破头皮没想出来于是逐渐开始放弃</del><br>因此我开始返璞归真，从最简单的情况看起，如下图（圆圈为原图）</p>
<p><img src="https://i.loli.net/2020/03/12/Fj5ZYLhfutGsypH.png" alt="image-20200311163621370.png" style="zoom:50%;" /></p>
<p>我们发现这时新图的MST就是一条单边，而且这两个节点是由原图的2节点的两条出边构成的，因此显然如果原图中一个节点只有一条出边，那么它肯定不能组成新图的一条边</p>
<p>再稍微复杂一点，看下图</p>
<p><img src="https://i.loli.net/2020/03/12/PbEIcuzFfgLaens.png" alt="image-20200311163932991.png" style="zoom:50%;" /></p>
<p>我们发现此时，2节点有三条出边，因此它代表了新图中的三条边，这个时候的MST就要取舍了，根据题意，新图的边权是原图对应两边权之和，那么显然我们只需要贪心地把原图该节点的最小出边设置为新图的“主节点”，然后把所有别的出边往主节点上连边就可以了，最后的边权和一定是最小的（因为我们反复往边权和里加的是原图最小的出边的边权）比如上图中如果<code>dis[2][1]=1,dis[2][3]=2,dis[2][4]=3</code>，那么<code>21</code>这条边就是对饮新图的主节点，对应的MST为<code>dis[2][1]+dis[2][3]</code>+<code>dis[2][1]+dis[2][4]</code>，也就是<code>所有出边求和 + (出边个数-2)*最小出边边权</code></p>
<p>因此，对于原图的每一个度不小于2的节点都重复上述操作就可以啦（不信可以自己建个图验证一下）</p>
<p>然而，此题还是有坑点（它似乎会卡常），以及请使用<font size=3 color=red>邻接表</font>存图（用别的东西存可能会一直TLE）</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1ll</span>&lt;&lt;<span class="hljs-number">60</span>;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//scanf也可</span><br>	ll kk=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>; <br>	<span class="hljs-type">char</span> cc=<span class="hljs-built_in">getchar</span>(); <br>	<span class="hljs-keyword">while</span>(cc&lt;<span class="hljs-string">&#x27;0&#x27;</span>||cc&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>		<span class="hljs-keyword">if</span>(cc==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;<br>		cc=<span class="hljs-built_in">getchar</span>();<br>	&#125; <br>	<span class="hljs-keyword">while</span>(cc&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;cc&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>		kk=(kk&lt;&lt;<span class="hljs-number">1</span>)+(kk&lt;&lt;<span class="hljs-number">3</span>)+cc-<span class="hljs-string">&#x27;0&#x27;</span>;<br>		cc=<span class="hljs-built_in">getchar</span>();<br>	&#125; <br>	<span class="hljs-keyword">return</span> kk*f; <br>&#125;<br>ll n;<br>vector&lt;ll&gt; gg[<span class="hljs-number">200005</span>]; <span class="hljs-comment">//邻接表</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> t;t=<span class="hljs-built_in">read</span>();<br>	<span class="hljs-keyword">while</span>(t--)&#123;<br>		ll u,v,w;<br>		n=<span class="hljs-built_in">read</span>();<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) gg[i].<span class="hljs-built_in">clear</span>();<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>			u=<span class="hljs-built_in">read</span>(),v=<span class="hljs-built_in">read</span>(),w=<span class="hljs-built_in">read</span>();<br>			gg[u].<span class="hljs-built_in">push_back</span>(w);gg[v].<span class="hljs-built_in">push_back</span>(w);<br>		&#125;<br>		ll ans=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123; <span class="hljs-comment">//遍历原图每个顶点</span><br>			ll temp=<span class="hljs-number">0</span>,minh=inf,len=gg[i].<span class="hljs-built_in">size</span>();<br>			<span class="hljs-keyword">if</span>(len&lt;<span class="hljs-number">2</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//出边&lt;2就pass</span><br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;len;j++)&#123;<span class="hljs-comment">//遍历出边</span><br>				temp+=gg[i][j]; <span class="hljs-comment">//加权值</span><br>				minh=<span class="hljs-built_in">min</span>(minh,gg[i][j]); <span class="hljs-comment">//找到最小的边权</span><br>			&#125;<br>			ans+=minh*(len<span class="hljs-number">-2</span>)+temp; <span class="hljs-comment">//加到MST里</span><br>		&#125;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="Radar-Scanner"><a href="#Radar-Scanner" class="headerlink" title="Radar Scanner"></a><a href="https://vjudge.net/problem/Gym-102220G">Radar Scanner</a></h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>题意：</p>
<p>有若干正方形（以给出左下和右上的单位正方形的坐标形式给出），每次可以使任意一个正方形移动一步（上下左右），求满足使所有正方形都重合到一个单位正方形的最小步数</p>
<p>题解：</p>
<p>可以先考虑一维的情况，对于若干线段（左端点命名为<code>l</code>，右端点为<code>r</code>），现在需要找到一个点<code>x</code>，将所有线段平移到这个点上最小总步数就是下式</p>
<script type="math/tex; mode=display">
min\left(\sum_{i=1}^nmin(|x-l_i|,|x-r_i|)\right)</script><p>但这么写好像不太好找x，考虑换一种写法如下</p>
<script type="math/tex; mode=display">
min\left(\sum_{i=1}^n{\frac{|l_i-x|+|r_i-x|-|r_i-l_i|}{2}}\right)</script><p>去掉常数<code>l-r</code>和分母，在考虑简化一下，把<code>l,r</code>视为一个东西<code>k</code>，方程变为</p>
<script type="math/tex; mode=display">
min\left(\sum_{i=1}^n{\left(|k_i-x|\right)}\right)</script><p>也就是下面这个式子</p>
<script type="math/tex; mode=display">
min\left(|k_1-x|+|k_2-x|+...+|k_n-x|\right)</script><p>这个<code>x</code>看起来像平均数or中位数，那么一个个试，ok确认过了是中位数</p>
<h4 id="一个不严谨的证明："><a href="#一个不严谨的证明：" class="headerlink" title="一个不严谨的证明："></a>一个不严谨的证明：</h4><p>我随便想了一个，先对<code>k</code>这个序列排序<code>k1最小,kn最大</code>，那么<code>x</code>理论上应该是处于<code>k1~kn</code>之间的一个数（这个太太太显然了，就不证了）那么</p>
<script type="math/tex; mode=display">
一定存在1\leq h<h+1\leq n\\
使得k_h\leq x且k_{h+1}\geq x\\
且对于所有i\leq h满足k_i\leq x\\
对于所有i\geq h 满足k_i\geq x\\
因此原式=min(x-k_1+x-k_2+...+x-k_h+k_{h+1}-x+...+k_n-x)\\
对x求导令导数为0即可得出最小值所对应的的x</script><p>此时，直观上来看<code>x</code>为<code>+1</code>和为<code>-1</code>的次数应该相同（此时导数才得0），所以x取<code>k[n/2]</code>的时候是最好的，也就是中位数啦</p>
<p>因此这题只需要分别对横坐标和纵坐标排个序然后找到中位数所对应的坐标就是这题的<code>x</code>点了，剩下的就是模拟移过去的操作了</p>
<h3 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1ll</span>&lt;&lt;<span class="hljs-number">60</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>	ll x1,y1,x2,y2;<br>&#125;a[<span class="hljs-number">2000005</span>];<br><br>ll x[<span class="hljs-number">500005</span>],y[<span class="hljs-number">500005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> t;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<br>	<span class="hljs-keyword">while</span>(t--)&#123;<br>		<span class="hljs-type">int</span> n;cin&gt;&gt;n;<br>		<span class="hljs-type">int</span> cnt1=<span class="hljs-number">0</span>,cnt2=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld%lld&quot;</span>,&amp;a[i].x1,&amp;a[i].y1,&amp;a[i].x2,&amp;a[i].y2);<br>			x[++cnt1]=a[i].x1;<br>			x[++cnt1]=a[i].x2;<br>			y[++cnt2]=a[i].y1;<br>			y[++cnt2]=a[i].y2;<br>		&#125;<br>		<span class="hljs-built_in">sort</span>(x+<span class="hljs-number">1</span>,x+<span class="hljs-number">1</span>+cnt1);<br>		<span class="hljs-built_in">sort</span>(y+<span class="hljs-number">1</span>,y+<span class="hljs-number">1</span>+cnt2);<br>		ll ans=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-keyword">if</span>(a[i].x1&gt;x[n]||a[i].x2&lt;x[n])<br>				ans+=<span class="hljs-built_in">min</span>(<span class="hljs-built_in">abs</span>(x[n]-a[i].x1),<span class="hljs-built_in">abs</span>(a[i].x2-x[n]));<br>			<span class="hljs-keyword">if</span>(a[i].y1&gt;y[n]||a[i].y2&lt;y[n])<br>				ans+=<span class="hljs-built_in">min</span>(<span class="hljs-built_in">abs</span>(y[n]-a[i].y1),<span class="hljs-built_in">abs</span>(a[i].y2-y[n]));<br>		&#125;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<hr>
<ul>
<li>下面是补的题</li>
</ul>
<h2 id="Eventual-…-Journey"><a href="#Eventual-…-Journey" class="headerlink" title="Eventual … Journey"></a><a href="https://vjudge.net/problem/Gym-102056L">Eventual … Journey</a></h2><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>题意：</p>
<p>给n个01的点，0之间连通，1之间连通，再给m条10之间连通的路，求从所有点到达每个点所走的最少步数和</p>
<p>题解：</p>
<p>分类讨论，总共有4种路线：</p>
<p>0到0或1到1，1步到位</p>
<p>0到1或1到0有公共路线，1步到位</p>
<p>0到1或1到0没有公共路线，但可以通过2步（先到有公共路线的地方，再走公共路线）到位；</p>
<p>0到1或1到0没有公共路线，只能通过3步（先到有公共路线的地方，再走公共路线，再走内部路线）</p>
<h3 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123; <br>	ll kk=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>; <br>	<span class="hljs-type">char</span> cc=<span class="hljs-built_in">getchar</span>(); <br>	<span class="hljs-keyword">while</span>(cc&lt;<span class="hljs-string">&#x27;0&#x27;</span>||cc&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<span class="hljs-keyword">if</span>(cc==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;cc=<span class="hljs-built_in">getchar</span>();&#125; <br>	<span class="hljs-keyword">while</span>(cc&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;cc&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;kk=(kk&lt;&lt;<span class="hljs-number">1</span>)+(kk&lt;&lt;<span class="hljs-number">3</span>)+cc-<span class="hljs-string">&#x27;0&#x27;</span>;cc=<span class="hljs-built_in">getchar</span>();&#125; <br>	<span class="hljs-keyword">return</span> kk*f; <br>&#125;<br>vector&lt;ll&gt; gg[<span class="hljs-number">10000005</span>];<br>ll n,m,a[<span class="hljs-number">10000005</span>];<br>ll zero,one,cnmd;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	n=<span class="hljs-built_in">read</span>();<br>	m=<span class="hljs-built_in">read</span>();<br>	<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		a[i]=<span class="hljs-built_in">read</span>();<br>		<span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">0</span>) zero++;<br>		<span class="hljs-keyword">else</span> one++;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>		ll aa,bb;<br>		aa=<span class="hljs-built_in">read</span>();bb=<span class="hljs-built_in">read</span>();<br>		<span class="hljs-keyword">if</span>(a[aa]!=a[bb])&#123;<br>			gg[aa].<span class="hljs-built_in">push_back</span>(bb);<br>			gg[bb].<span class="hljs-built_in">push_back</span>(aa);<br>		&#125;<br>	&#125;<br>	ll og=<span class="hljs-number">0</span>,zg=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">if</span>(gg[i].<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>&amp;&amp;a[i]==<span class="hljs-number">0</span>) zg++;<br>		<span class="hljs-keyword">if</span>(gg[i].<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>&amp;&amp;a[i]==<span class="hljs-number">1</span>) og++; <br>	&#125;<br>	<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		ll ans=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">0</span>)&#123;<br>			ans+=zero<span class="hljs-number">-1</span>+gg[i].<span class="hljs-built_in">size</span>()+(n-zero-gg[i].<span class="hljs-built_in">size</span>())*<span class="hljs-number">2</span>;<br>		&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">1</span>)&#123;<br>			ans+=one<span class="hljs-number">-1</span>+gg[i].<span class="hljs-built_in">size</span>()+(n-one-gg[i].<span class="hljs-built_in">size</span>())*<span class="hljs-number">2</span>;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(gg[i].<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>&amp;&amp;a[i]==<span class="hljs-number">0</span>) ans+=og;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(gg[i].<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>&amp;&amp;a[i]==<span class="hljs-number">1</span>) ans+=zg;<br>		<span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,ans);<br>		<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %lld&quot;</span>,ans);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="Line-line-Intersection"><a href="#Line-line-Intersection" class="headerlink" title="Line-line Intersection"></a><a href="https://vjudge.net/problem/Gym-102220C">Line-line Intersection</a></h2><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>题意：</p>
<p>求n条直线中有多少对直线至少有一个交点（重合也算有交点）</p>
<p>题解：</p>
<p>每条直线最多可以和前<code>i-1</code>条直线相交，然后减去斜率相同的直线个数，再加上斜率相同截距也相同的直线个数即可</p>
<h5 id="Mark一下（第一道计算几何题）"><a href="#Mark一下（第一道计算几何题）" class="headerlink" title="Mark一下（第一道计算几何题）"></a>Mark一下（第一道计算几何题）</h5><ul>
<li>此题为了避免精度问题，存的是斜率和截距的最简分数的形式</li>
</ul>
<h3 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">typedef</span> pair&lt;ll,ll&gt; pa;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123; <br>	ll kk=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>; <br>	<span class="hljs-type">char</span> cc=<span class="hljs-built_in">getchar</span>(); <br>	<span class="hljs-keyword">while</span>(cc&lt;<span class="hljs-string">&#x27;0&#x27;</span>||cc&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<span class="hljs-keyword">if</span>(cc==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;cc=<span class="hljs-built_in">getchar</span>();&#125; <br>	<span class="hljs-keyword">while</span>(cc&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;cc&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;kk=(kk&lt;&lt;<span class="hljs-number">1</span>)+(kk&lt;&lt;<span class="hljs-number">3</span>)+cc-<span class="hljs-string">&#x27;0&#x27;</span>;cc=<span class="hljs-built_in">getchar</span>();&#125; <br>	<span class="hljs-keyword">return</span> kk*f; <br>&#125;<br><br>map&lt;pair&lt;pa,pa&gt;,<span class="hljs-type">int</span>&gt; M;<br>map&lt;pa,<span class="hljs-type">int</span>&gt; Mk;<br>ll n,t;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>	t=<span class="hljs-built_in">read</span>();<br>	<span class="hljs-keyword">while</span>(t--)&#123;<br>		M.<span class="hljs-built_in">clear</span>();<br>		Mk.<span class="hljs-built_in">clear</span>();<br>		n=<span class="hljs-built_in">read</span>();<br>		ll i;<br>		ll ans=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			ll x1,y1,x2,y2;<br>			x1=<span class="hljs-built_in">read</span>(),y1=<span class="hljs-built_in">read</span>(),x2=<span class="hljs-built_in">read</span>(),y2=<span class="hljs-built_in">read</span>();<br>			ll ka=y1-y2,kb=x1-x2;<br>			ll ba=x2*y1-x1*y2,bb=x2-x1;<br>			ll gcdk=__gcd(<span class="hljs-built_in">abs</span>(ka),<span class="hljs-built_in">abs</span>(kb));<br>			ll gcdb=__gcd(<span class="hljs-built_in">abs</span>(ba),<span class="hljs-built_in">abs</span>(bb));<br>			pa k;<br>			<span class="hljs-keyword">if</span>(ka==<span class="hljs-number">0</span>) <br>			k=<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(kb==<span class="hljs-number">0</span>) <br>			k=<span class="hljs-built_in">make_pair</span>(inf,inf);<br>			<span class="hljs-keyword">else</span>&#123;<br>				ka/=gcdk,kb/=gcdk;<br>				<span class="hljs-keyword">if</span>(ka*kb&gt;<span class="hljs-number">0</span>) <br>				k=<span class="hljs-built_in">make_pair</span>(<span class="hljs-built_in">abs</span>(ka),<span class="hljs-built_in">abs</span>(kb));<br>				<span class="hljs-keyword">else</span> <br>				k=<span class="hljs-built_in">make_pair</span>(-<span class="hljs-built_in">abs</span>(ka),<span class="hljs-built_in">abs</span>(kb));<br>			&#125;<br>			pa b;<br>			<span class="hljs-keyword">if</span>(ba==<span class="hljs-number">0</span>) <br>			b=<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bb==<span class="hljs-number">0</span>) <br>			b=<span class="hljs-built_in">make_pair</span>(x1,x1);<br>			<span class="hljs-keyword">else</span>&#123;<br>				ba/=gcdb,bb/=gcdb;<br>				<span class="hljs-keyword">if</span>(ba*bb&gt;<span class="hljs-number">0</span>) <br>				b=<span class="hljs-built_in">make_pair</span>(<span class="hljs-built_in">abs</span>(ba),<span class="hljs-built_in">abs</span>(bb));<br>				<span class="hljs-keyword">else</span> <br>				b=<span class="hljs-built_in">make_pair</span>(-<span class="hljs-built_in">abs</span>(ba),<span class="hljs-built_in">abs</span>(bb));<br>			&#125;<br>			ans+=(i<span class="hljs-number">-1</span>-Mk[k]+M[<span class="hljs-built_in">make_pair</span>(k,b)]);<br>			Mk[k]++;<br>			M[<span class="hljs-built_in">make_pair</span>(k,b)]++;<br>		&#125;<br>		cout&lt;&lt;ans&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="Balanced-Diet"><a href="#Balanced-Diet" class="headerlink" title="Balanced Diet"></a><a href="https://vjudge.net/problem/Gym-102220B">Balanced Diet</a></h2><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>题意：</p>
<p>有m个种类的糖果共n颗，每颗对应一个价值k，每种糖起购件数c（要么不买，要买就至少c个）求下式</p>
<script type="math/tex; mode=display">
max(\frac{所有买的糖果的\sum k_i}{max(单件购买个数)})</script><p>题解：</p>
<p>本蒟蒻不太会，题解也看不太懂，先搁着</p>
<h3 id="AC代码-4"><a href="#AC代码-4" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123; <br>	ll kk=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>; <br>	<span class="hljs-type">char</span> cc=<span class="hljs-built_in">getchar</span>(); <br>	<span class="hljs-keyword">while</span>(cc&lt;<span class="hljs-string">&#x27;0&#x27;</span>||cc&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<span class="hljs-keyword">if</span>(cc==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;cc=<span class="hljs-built_in">getchar</span>();&#125; <br>	<span class="hljs-keyword">while</span>(cc&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;cc&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;kk=(kk&lt;&lt;<span class="hljs-number">1</span>)+(kk&lt;&lt;<span class="hljs-number">3</span>)+cc-<span class="hljs-string">&#x27;0&#x27;</span>;cc=<span class="hljs-built_in">getchar</span>();&#125; <br>	<span class="hljs-keyword">return</span> kk*f; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(ll x,ll y)</span></span>&#123;<br>	<span class="hljs-keyword">return</span> x&gt;y;<br>&#125;<br><br>vector&lt;ll&gt; cnmd[<span class="hljs-number">1000005</span>],xbzz[<span class="hljs-number">1000005</span>];<br>ll n,m,a[<span class="hljs-number">1000005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> t=<span class="hljs-built_in">read</span>();<br>	<span class="hljs-keyword">while</span>(t--)&#123;<br>		<span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a));<br>		n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>();<br>		<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=m;i++) a[i]=<span class="hljs-built_in">read</span>();<br>		<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>			ll x,y;<br>			x=<span class="hljs-built_in">read</span>(),y=<span class="hljs-built_in">read</span>();<br>			cnmd[y].<span class="hljs-built_in">push_back</span>(x);<br>		&#125;<br>		<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>			<span class="hljs-built_in">sort</span>(cnmd[i].<span class="hljs-built_in">begin</span>(),cnmd[i].<span class="hljs-built_in">end</span>(),cmp);<br>			<span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">0</span>;j&lt;cnmd[i].<span class="hljs-built_in">size</span>();j++)&#123;<br>				xbzz[<span class="hljs-built_in">max</span>(j+<span class="hljs-number">1</span>,a[i])].<span class="hljs-built_in">push_back</span>(cnmd[i][j]);<br>			&#125;<br>			cnmd[i].<span class="hljs-built_in">clear</span>();<br>		&#125;<br>		ll giao=<span class="hljs-number">0</span>,giaogiao=<span class="hljs-number">1</span>,giaogiaogiao=<span class="hljs-number">0</span>,giaogiaogiaogiao=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			giaogiaogiaogiao=i;<br>			<span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">0</span>;j&lt;xbzz[i].<span class="hljs-built_in">size</span>();j++)&#123;<br>				giaogiaogiao+=xbzz[i][j];<br>			&#125;<br>			<span class="hljs-keyword">if</span>(giaogiao*giaogiaogiao&gt;giao*giaogiaogiaogiao)<br>				giaogiao=giaogiaogiaogiao,giao=giaogiaogiao;<br>			xbzz[i].<span class="hljs-built_in">clear</span>();<br>		&#125;<br>		ll huohua=__gcd(giaogiao,giao);<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld/%lld\n&quot;</span>,giao/huohua,giaogiao/huohua);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></div></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>补题：AtCoder ABC245</title>
    <url>/2022/03/28/%E8%A1%A5%E9%A2%98%EF%BC%9AABC245/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<h2 id="C-Choose-Elements"><a href="#C-Choose-Elements" class="headerlink" title="C - Choose Elements"></a><a href="https://atcoder.jp/contests/abc245/tasks/abc245_c">C - Choose Elements</a></h2><p>题意：给出两个长度为$n$的数组$A$和$B$和一个整数$K$，构造一个长度为$n$的数组，满足第$i$位是$A_i$或$B_i$且相邻两数绝对值差不超过$K$</p>
<p>解法：考虑$dp$，定义$dpa[i]$：$A$的第$i$位数字能否作为构造数组的第$i$位，能为1，否为0，同理定义$dpb[i]$，则转移方程为：</p>
<script type="math/tex; mode=display">
dpa[i] = dpa[i-1]\ if (|{A[i]-A[i-1]}|\le K)\\
dpa[i] = dpb[i-1]\ if (|{A[i]-B[i-1]}|\le K)\\
dpb[i] = dpa[i-1]\ if (|{B[i]-A[i-1]}|\le K)\\
dpb[i] = dpb[i-1]\ if (|{B[i]-B[i-1]}|\le K)</script><p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x7fffffff</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;<br> <br><span class="hljs-type">int</span> n,k,a[maxn],b[maxn];<br><span class="hljs-type">bool</span> dpa[maxn],dpb[maxn];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>	cin&gt;&gt;n&gt;&gt;k;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>		cin&gt;&gt;a[i];<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>		cin&gt;&gt;b[i];<br>	&#125;<br>	dpa[<span class="hljs-number">1</span>] = dpb[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>; <br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>		<span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(a[i]-a[i<span class="hljs-number">-1</span>])&lt;=k) dpa[i] |= dpa[i<span class="hljs-number">-1</span>];<br>		<span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(a[i]-b[i<span class="hljs-number">-1</span>])&lt;=k) dpa[i] |= dpb[i<span class="hljs-number">-1</span>];<br>		<span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(b[i]-a[i<span class="hljs-number">-1</span>])&lt;=k) dpb[i] |= dpa[i<span class="hljs-number">-1</span>];<br>		<span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(b[i]-b[i<span class="hljs-number">-1</span>])&lt;=k) dpb[i] |= dpb[i<span class="hljs-number">-1</span>];<br>	&#125;<br>	<span class="hljs-keyword">if</span>(dpa[n]||dpb[n]) cout&lt;&lt;<span class="hljs-string">&quot;Yes\n&quot;</span>;<br>	<span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;No\n&quot;</span>;<br> <br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<hr>
<h2 id="D-Polynomial-division"><a href="#D-Polynomial-division" class="headerlink" title="D - Polynomial division"></a><a href="https://atcoder.jp/contests/abc245/tasks/abc245_d">D - Polynomial division</a></h2><p>题意：对于多项式乘法$A(i)*B(i)=C(i)$，给出$A(i), C(i)$的每一项系数（不为0），求$B(i)$的每一项系数</p>
<p>解法：模拟长除法即可</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x7fffffff</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;<br><br><span class="hljs-type">int</span> n,m;<br>ll a[<span class="hljs-number">1005</span>],b[<span class="hljs-number">1005</span>],c[<span class="hljs-number">1005</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>	cin&gt;&gt;n&gt;&gt;m;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i)&#123;<br>		cin&gt;&gt;a[i];<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m+n;++i)&#123;<br>		cin&gt;&gt;c[i];<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m;i&gt;=<span class="hljs-number">0</span>;--i)&#123;<br>		ll d = c[i+n]/a[n];<br>		b[i] = d;<br>		<span class="hljs-type">int</span> cnt = n;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+n;j&gt;=<span class="hljs-number">0</span>;--j)&#123;<br>			c[j] -= d * a[cnt--];<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;++i)&#123;<br>		cout&lt;&lt;b[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>	&#125;<br>	cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<hr>
<h2 id="E-Wrapping-Chocolate"><a href="#E-Wrapping-Chocolate" class="headerlink" title="E - Wrapping Chocolate"></a><a href="https://atcoder.jp/contests/abc245/tasks/abc245_e">E - Wrapping Chocolate</a></h2><p>题意：给出N个巧克力和M个盒子的长宽，每个盒子最多只能装一个巧克力，问能否将N个巧克力全部装入盒子里（能装入盒子的条件是巧克力的长$\le$盒子的长，且巧克力的宽$\le$盒子的宽）</p>
<p>解法：将巧克力和盒子合并在一起考虑，以宽度降序排序，宽度相同的盒子在前。开一个multiset，遍历整个序列，如果是盒子则将盒子的长加入multiset，否则在multiset中二分找到第一个不小于该巧克力长的盒子长，删去它，如果找不到，则No，如果能完成全部遍历则Yes</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x7fffffff</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;<br> <br><span class="hljs-type">int</span> n,m;<br>pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; ab[maxn],cd[maxn];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>	<span class="hljs-type">int</span> x,y,id; <span class="hljs-comment">// 0:box; 1:chocolate</span><br>&#125;a[maxn&lt;&lt;<span class="hljs-number">1</span>];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node &amp;x1,node &amp;x2)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(x1.x!=x2.x) <span class="hljs-keyword">return</span> x1.x &gt; x2.x;<br>	<span class="hljs-keyword">if</span>(x1.y!=x2.y) <span class="hljs-keyword">return</span> x1.y &gt; x2.y;<br>	<span class="hljs-keyword">return</span> x1.id &lt; x2.id;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>	cin&gt;&gt;n&gt;&gt;m;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin&gt;&gt;ab[i].first;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin&gt;&gt;ab[i].second;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) cin&gt;&gt;cd[i].first;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) cin&gt;&gt;cd[i].second;<br> <br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>		a[i].id = <span class="hljs-number">1</span>;<br>		a[i].x = ab[i].first;<br>		a[i].y = ab[i].second;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)&#123;<br>		a[i+n].id = <span class="hljs-number">0</span>;<br>		a[i+n].x = cd[i].first;<br>		a[i+n].y = cd[i].second;<br>	&#125;<br>	<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">1</span>+n+m,cmp);<br>	multiset&lt;<span class="hljs-type">int</span>&gt; se;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+m;++i)&#123;<br>		<span class="hljs-keyword">if</span>(a[i].id==<span class="hljs-number">0</span>)&#123;<br>			se.<span class="hljs-built_in">insert</span>(a[i].y);<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>			<span class="hljs-keyword">auto</span> it = se.<span class="hljs-built_in">lower_bound</span>(a[i].y);<br>			<span class="hljs-keyword">if</span>(it==se.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> cout&lt;&lt;<span class="hljs-string">&quot;No\n&quot;</span>,<span class="hljs-number">0</span>;<br>			se.<span class="hljs-built_in">erase</span>(it);<br>		&#125;<br>	&#125;<br>	cout&lt;&lt;<span class="hljs-string">&quot;Yes\n&quot;</span>;<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<hr>
<h2 id="F-Endless-Walk"><a href="#F-Endless-Walk" class="headerlink" title="F - Endless Walk"></a><a href="https://atcoder.jp/contests/abc245/tasks/abc245_f">F - Endless Walk</a></h2><p>题意：给出一个N个点M条边的有向图，问满足以下条件的节点的个数：从该点出发能够进入无限循环</p>
<p>解法：显然所有SCC里的点都满足要求，除此之外，所有能到达一个[节点数大于1的SCC]的节点也满足要求，因此考虑Tarjan缩点后反向建边然后从所有[节点数大于1的SCC]开始dfs即可</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x7fffffff</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;<br> <br><span class="hljs-type">int</span> n,m;<br> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> u,v,next;<br>&#125;e[maxn];<br>std::vector&lt;<span class="hljs-type">int</span>&gt; ee[maxn];<br><span class="hljs-type">int</span> gcnt,head[maxn];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init_graph</span><span class="hljs-params">()</span></span>&#123;<br>	gcnt=<span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;<br>	e[gcnt]=Edge&#123;u,v,head[u]&#125;;<br>	head[u]=gcnt++;<br>&#125;<br> <br><span class="hljs-type">int</span> low[maxn],dfn[maxn],sta[maxn],color[maxn],vis[maxn],top,scc,deep;<br><span class="hljs-type">int</span> cnt[maxn];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>	vis[sta[++top]=u]=<span class="hljs-number">1</span>;<br>	low[u]=dfn[u]=++deep;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(!dfn[v])&#123;<br>			<span class="hljs-built_in">tarjan</span>(v);<br>			low[u]=<span class="hljs-built_in">min</span>(low[u],low[v]);<br>		&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(vis[v]) low[u]=<span class="hljs-built_in">min</span>(low[u],dfn[v]);<br>	&#125;<br>	<span class="hljs-keyword">if</span>(low[u]==dfn[u])&#123;<br>		vis[u]=<span class="hljs-number">0</span>;<br>		color[u]=++scc;<br>		<span class="hljs-keyword">while</span>(sta[top]!=u)&#123;<br>			color[sta[top]]=scc;<br>			vis[sta[top--]]=<span class="hljs-number">0</span>;<br>		&#125;<br>		top--;<br>	&#125;<br>&#125;<br> <br><span class="hljs-type">bool</span> ma[maxn];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;v:ee[u])&#123;<br>		<span class="hljs-keyword">if</span>(!ma[v])&#123;<br>			ma[v] = <span class="hljs-number">1</span>;<br>			<span class="hljs-built_in">dfs</span>(v);<br>		&#125;<br>	&#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">init_graph</span>();<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,u,v;i&lt;=m;++i)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);<br>		<span class="hljs-built_in">addedge</span>(u,v);<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>		<span class="hljs-keyword">if</span>(!dfn[i]) <span class="hljs-built_in">tarjan</span>(i);<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cnt[color[i]]++;<br>    <br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u,v,i=<span class="hljs-number">0</span>;i&lt;m;++i)&#123;<br>		u = color[e[i].u];<br>		v = color[e[i].v];<br>		<span class="hljs-keyword">if</span>(u!=v)&#123;<br>			ee[v].<span class="hljs-built_in">emplace_back</span>(u);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=scc;++i)&#123;<br>		<span class="hljs-keyword">if</span>(!ma[i] &amp;&amp; cnt[i]&gt;<span class="hljs-number">1</span>) ma[i]=<span class="hljs-number">1</span>, <span class="hljs-built_in">dfs</span>(i);<br>	&#125;<br>	<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=scc;++i)&#123;<br>		<span class="hljs-keyword">if</span>(ma[i]) ans += cnt[i];<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>补题：AtCoder ABC246</title>
    <url>/2022/04/05/%E8%A1%A5%E9%A2%98%EF%BC%9AABC246/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<h2 id="C-Coupon"><a href="#C-Coupon" class="headerlink" title="C - Coupon"></a><a href="https://atcoder.jp/contests/abc246/tasks/abc246_c">C - Coupon</a></h2><p>题意：有N个物品，每个物品有一个价格，有K个优惠券，每个优惠券能抵消X元，当物品剩余价格低于X时，可以用掉抵用券把免费兑换物品，问最低花多少钱买走全部物品</p>
<p>解法：商品按价格从大到小排序，然后，在保证剩余价格大于零的情况下尽可能用掉优惠券，最后，如果优惠券有剩余，则按照从剩余价格大到小排序花掉优惠券</p>
<details>
    <summary>code</summary>

<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x7fffffff</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> int ll</span><br>    <span class="hljs-type">int</span> n,k,x;<br>    cin&gt;&gt;n&gt;&gt;k&gt;&gt;x;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]/x &lt;= k)&#123;<br>            k -= a[i]/x;<br>            a[i] %= x;<br>            <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            a[i] -= k*x;<br>            k = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>(k&gt;<span class="hljs-number">0</span>)&#123;<br>            k--;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            res += a[i];<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;res&lt;&lt;endl;<br> <br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</details>

<hr>
<h2 id="D-2-variable-Function"><a href="#D-2-variable-Function" class="headerlink" title="D - 2-variable Function"></a><a href="https://atcoder.jp/contests/abc246/tasks/abc246_d">D - 2-variable Function</a></h2><p>题意：给出N，求一个最小的大于等于N的数X，满足存在非负整数$a,b$使得$X = a^3+a^2b+ab^2+b^3$</p>
<p>解法：可以看出，$N\le X=(a+b)(a^2+b^2)$，因此从数据范围推断出$\max{a,b}\le 1e6$，因此可以枚举$a$，然后二分查找满足条件的最小的$b$</p>
<details>
    <summary>code</summary>

<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x7fffffff</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ll n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">auto</span> f = [&amp;](ll a,ll b)&#123;<br>        <span class="hljs-built_in">return</span> (a+b)*(a*a+b*b);<br>    &#125;;<br>    ll ans = <span class="hljs-number">1e18</span>;<br>    <span class="hljs-keyword">for</span>(ll a=<span class="hljs-number">0</span>;a&lt;=<span class="hljs-number">1e6</span>;++a)&#123;<br>        ll l = <span class="hljs-number">0</span>, r = <span class="hljs-number">1e6</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            ll mid = (l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">f</span>(a,mid)&lt;n) l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> r = mid;<br>        &#125;<br>        ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">f</span>(a,l));<br>    &#125;<br>    <br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h2 id="E-Bishop-2"><a href="#E-Bishop-2" class="headerlink" title="E - Bishop 2"></a><a href="https://atcoder.jp/contests/abc246/tasks/abc246_e">E - Bishop 2</a></h2><p>题意：给出一个国际象棋棋盘，有一些格子不能走，给出一个<strong>象</strong>，一步可以朝斜着的四个方位走任意格子，给出起点和终点，问最少多少步能完成，如果完不成，返回<code>-1</code></p>
<p>解法：BFS，需要注意的是，定义<code>vis[x][y][dir]</code>数组用来存储位置<code>x,y</code>和此时的方向<code>dir</code>（一定要有方向）是否被访问过，在遍历的时候，外层枚举方位，内层枚举长度，一旦 走出去 or 不能走 or vis标记过 都直接break，用于剪枝</p>
<details>
    <summary>code</summary>

<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x7fffffff</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1500</span> + <span class="hljs-number">5</span>;<br> <br><span class="hljs-type">int</span> n,ax,ay,bx,by;<br><span class="hljs-type">char</span> mm[maxn][maxn];<br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br>    <span class="hljs-type">int</span> x,y,step;<br>&#125;;<br><span class="hljs-type">bool</span> vis[maxn][maxn][<span class="hljs-number">4</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;ax&gt;&gt;ay&gt;&gt;bx&gt;&gt;by;<br>    <span class="hljs-keyword">if</span>(((ax+ay)%<span class="hljs-number">2</span>==<span class="hljs-number">0</span> &amp;&amp; (bx+by)%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>) <span class="hljs-built_in">or</span> ((bx+by)%<span class="hljs-number">2</span>==<span class="hljs-number">0</span> &amp;&amp; (ax+ay)%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>))&#123;<br>        <span class="hljs-keyword">return</span> cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl,<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)&#123;<br>            cin&gt;&gt;mm[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">auto</span> in = [&amp;](<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)&#123;<br>        <span class="hljs-keyword">return</span> x&gt;=<span class="hljs-number">1</span> &amp;&amp; x&lt;=n &amp;&amp; y&gt;=<span class="hljs-number">1</span> &amp;&amp; y&lt;=n;<br>    &#125;;<br>    queue&lt;node&gt; q;<br>    q.<span class="hljs-built_in">push</span>(node&#123;ax,ay,<span class="hljs-number">0</span>&#125;);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        node q1 = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> x = q1.x, y = q1.y, step = q1.step;<br>        <span class="hljs-keyword">if</span>(x==bx &amp;&amp; y==by)&#123;<br>            <span class="hljs-keyword">return</span> cout&lt;&lt;step&lt;&lt;endl,<span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;++k)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>                <span class="hljs-type">int</span> dx = x + dir[k][<span class="hljs-number">0</span>] * i;<br>                <span class="hljs-type">int</span> dy = y + dir[k][<span class="hljs-number">1</span>] * i;<br>                <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">in</span>(dx,dy) <span class="hljs-keyword">or</span> mm[dx][dy]==<span class="hljs-string">&#x27;#&#x27;</span> <span class="hljs-keyword">or</span> vis[dx][dy][k]) <span class="hljs-keyword">break</span>;<br>                vis[dx][dy][k] = <span class="hljs-number">1</span>;<br>                q.<span class="hljs-built_in">push</span>(node&#123;dx,dy,step+<span class="hljs-number">1</span>&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl;<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h2 id="F-typewriter"><a href="#F-typewriter" class="headerlink" title="F - typewriter"></a><a href="https://atcoder.jp/contests/abc246/tasks/abc246_f">F - typewriter</a></h2><p>题意：给出$N(\le 18)$个字符串（都是<code>abcdefghijklmnopqrstuvwxyz</code>的子序列），每次从其中一个里挑任意字符组成一个长度为$L$的字符串，问可以组成多少种不同的字符串</p>
<p>解法：状态压缩+组合数学+容斥原理</p>
<p>一个长度为A的字符串能组成$A^L$个字符串，但是会发现重复枚举了，于是挑出两两字符串公共的字符（假设有B个），则减去$B^L$个，再挑出三个三个的字符串公共字符（假设有C个），则加上$C^L$个，以此类推（奇数加，偶数减）。</p>
<details>
    <summary>code</summary>

<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> mod = <span class="hljs-number">998244353</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x7fffffff</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br> <br><span class="hljs-type">int</span> n,L;<br>vector&lt;string&gt; s;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">auto</span> qpow = [&amp;](ll x,ll y)&#123;<br>        ll res = <span class="hljs-number">1</span>, base = x;<br>        <span class="hljs-keyword">while</span>(y)&#123;<br>            <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) res = (res * base)%mod;<br>            base = (base * base) % mod;<br>            y &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;;<br>    cin&gt;&gt;n&gt;&gt;L;<br>    s.<span class="hljs-built_in">resize</span>(n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) cin&gt;&gt;s[i];<br>    ll ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);++i)&#123;<br>        <span class="hljs-type">int</span> cnt = __builtin_popcount(i);<br>        <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-type">char</span>,ll&gt; ma;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)&#123;<br>            <span class="hljs-keyword">if</span>((i&gt;&gt;j)&amp;<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> &amp;c:s[j])&#123;<br>                    <span class="hljs-keyword">if</span>(++ma[c]==cnt) tot++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        ll tp = <span class="hljs-built_in">qpow</span>(tot, L);<br>        <span class="hljs-keyword">if</span>(cnt&amp;<span class="hljs-number">1</span>) ans = (ans + tp) % mod;<br>        <span class="hljs-keyword">else</span> ans = (ans - tp + mod) % mod;<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>

<hr>
<h2 id="G-Game-on-Tree-3"><a href="#G-Game-on-Tree-3" class="headerlink" title="G - Game on Tree 3"></a><a href="https://atcoder.jp/contests/abc246/tasks/abc246_g">G - Game on Tree 3</a></h2><p>PS：想不出来，看的题解</p>
<p>题意：有一棵树，除根节点外每个节点有个权值，A和B玩树上游戏，初始时树根有一个小人，B先开始。</p>
<p>B的行为：可以将任意非根节点权值变为0</p>
<p>A的行为：可以将小人移动到所在节点的任意儿子处</p>
<p>问：最终A的得分为小人所在处的权值</p>
<p>A想让得分尽可能大，B想让得分尽可能小，问两者在最优操作下，A最大得分</p>
<p>解法：博弈+二分+树形dp</p>
<ul>
<li>参考：<a href="https://atcoder.jp/contests/abc246/editorial/3716">[G - Game on Tree 3] Editorial</a></li>
</ul>
<p>大概就是，考虑给定一个X，令权值大于X的为黑点($color=1$)，其余为白点($color=0$)，玩一个等价的新游戏（B先行动）：</p>
<p>A赢定义为：A此刻在黑色节点</p>
<p>B赢定义为：A此刻在叶子节点</p>
<p>B的行为：将任意非根节点变为白色</p>
<p>A的行为：将小人移动到任意一个儿子节点</p>
<p>定义<code>dp[u]</code>表示u为根的树，B想要获胜的话需要在游戏开始之前将其变成白色的最少节点数</p>
<p>则显然有：<code>dp[1] = 0</code>时B必胜，否则必败</p>
<p>转移方程：$dp[u] = \max { \sum_{v\in C_u} dp[v] - 1,0 } + color[u]$</p>
<p>最后，二分得到最大的X即可</p>
<details>
    <summary>code</summary>

<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x7fffffff</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br> <br><span class="hljs-type">int</span> n;<br>vector&lt;<span class="hljs-type">int</span>&gt; a,color,dp;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; e;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;v:e[u])&#123;<br>        <span class="hljs-keyword">if</span>(v!=fa)&#123;<br>            <span class="hljs-built_in">dfs</span>(v,u);<br>            dp[u] += dp[v];<br>        &#125;<br>    &#125;<br>    dp[u] = <span class="hljs-built_in">max</span>(dp[u]<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>) + color[u];<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>        color[i] = (a[i]&gt;x);<br>    &#125;<br>    dp.<span class="hljs-built_in">assign</span>(n,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    a.<span class="hljs-built_in">resize</span>(n);<br>    e.<span class="hljs-built_in">resize</span>(n);<br>    color.<span class="hljs-built_in">resize</span>(n);<br>    dp.<span class="hljs-built_in">resize</span>(n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u,v,i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;++i)&#123;<br>        cin&gt;&gt;u&gt;&gt;v;<br>        --v,--u;<br>        e[u].<span class="hljs-built_in">emplace_back</span>(v);<br>        e[v].<span class="hljs-built_in">emplace_back</span>(u);<br>    &#125;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">1e9</span>;<br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>        <span class="hljs-type">int</span> mid = (l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid))&#123;<br>            l = mid + <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            r = mid;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;l&lt;&lt;endl;<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>计算元素贡献 专题</title>
    <url>/2022/05/22/%E8%AE%A1%E7%AE%97%E5%85%83%E7%B4%A0%E8%B4%A1%E7%8C%AE%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<p>本专题尝试用比较容易理解的方式，去解释一系列<strong>计算元素贡献</strong>的一类题的通用解法与思考方式</p>
<span id="more"></span>
<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>2022.5.22 上午的周赛T4 <a href="https://leetcode.cn/problems/sum-of-total-strength-of-wizards/">6077. 巫师的总力量和 - 力扣（LeetCode）</a>就是这一类典型的题型，对于这类 <strong>统计序列中所有子数组的某个性质/值的总和</strong> 的问法，暴力枚举是一个显然的做法，但是通常它的复杂度会达到$O(n^2)$或者$O(n^3)$的级别，如果题目数据量在$10^4$以上，绝对会超时。那么，对于这一类问题，我们关注如何用简单的思路去实现一个$O(n)$的解法。</p>
<p>这个思路，用一句话来说就是：<strong>统计序列中 每个数/每种长度 产生的贡献</strong>。我们遍历序列，对于当前元素，如果我们能在$O(1)$的时间内计算出当前 元素/长度 对于答案产生的贡献值，我们就能够将时间复杂度控制在$O(n)$。</p>
<p>对于这样一个方法论，实际上有很多种类型的题目都可以应用，接下来由浅入深，结合例题进行解释。</p>
<h2 id="较直接的问题"><a href="#较直接的问题" class="headerlink" title="较直接的问题"></a>较直接的问题</h2><h3 id="问题1：求所有子数组的和"><a href="#问题1：求所有子数组的和" class="headerlink" title="问题1：求所有子数组的和"></a>问题1：求所有子数组的和</h3><p>抛砖引玉，先从最直接的一道题出发：<a href="https://www.lintcode.com/problem/1814/description">1814 · 所有子数组之和 - LintCode</a> 题目的意思是：</p>
<blockquote>
<p>给出一个长度为 $n$ 的序列$[a_1,a_2,…,a_n]$（<u>如无特殊说明，此后所有序列定义都由下标1开始</u>），求这个序列的所有子数组的和，例如，序列$[1,2,3]$的所有子数组为$[1],[2],[3],[1,2],[2,3],[1,2,3]$，它们的和为$1+2+3+1+2+2+3+1+2+3=20$。</p>
</blockquote>
<p>乍一看这题，有一个显然的解法，就是我们可以枚举每一个子数组，即 一层循环枚举左端点，一层枚举右端点，然后暴力求这个子数组的和（这个可以通过前缀和优化成$O(1)$求），因此复杂度为$O(n^2)$。</p>
<p>如果用<strong>统计贡献</strong>的思路，那么对于这样一个问题，通常有两种思考方式：</p>
<ol>
<li>考虑计算每个元素对答案的贡献</li>
<li>采用<strong>动态规划</strong>的思路，考虑在遍历这个数组的时候，加入一个新的数对答案的贡献</li>
</ol>
<h4 id="思路1-考虑计算每个元素对答案的贡献"><a href="#思路1-考虑计算每个元素对答案的贡献" class="headerlink" title="思路1. 考虑计算每个元素对答案的贡献"></a>思路1. 考虑计算每个元素对答案的贡献</h4><p>我们先思考第1种思路（也是本问题最简单的思路），举个栗子，观察这样一个长度为4的序列$[1,3,5,2]$，思考对于$3$这个元素，它会出现在哪些子数组中？答案是$6$个子数组：$[3],[3,5],[3,5,2],[1,3],[1,3,5],[1,3,5,2]$，因此，它会对答案产生$6$次贡献，则它的贡献为$3\times 6=18$。</p>
<p>进一步地，仔细观察这些子数组的左右端点，我们能发现这样一个规律：左端点一定是小于等于当前数的位置，右端点一定大于等于当前数的位置（因为必须包含这个数），我们发现，$3$这个数处在的位置为$2$，因此它出现在$2\times (4-2+1)=6$个子数组中。更一般地，利用乘法原理我们知道，对于一个下标为$i$的数$a[i]$，它一定会出现在$i\times(n-i+1)$个子数组中（即 左侧选$i$个，右侧选$n-i+1$个，乘法原理），因此它对答案的贡献为$a[i]\times i\times (n-i+1)$。</p>
<p>遍历整个数组，对每个元素直接$O(1)$求出这个值累加到答案中，就完成了$O(n)$的解法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    ans += a[i] * i * (n-i+<span class="hljs-number">1</span>);<br></code></pre></div></td></tr></table></figure>
<p>这里我们来模拟一下计算流程，以 $[1,3,5,2]$为例。</p>
<ul>
<li>考虑$a_1 = 1$计算对答案的贡献为$1\times 1\times 4 = 4$，加入至答案 $ans = 4$</li>
<li>考虑$a_2 = 3$计算对答案的贡献为$3\times 2\times 3 = 18$，加入至答案 $ans=4+18=22$</li>
<li>考虑$a_3 = 5$计算对答案的贡献为$5\times 3\times 2 = 30$，加入至答案 $ans=22+30=52$</li>
<li>考虑$a_4 = 2$计算对答案的贡献为$2\times 4\times 1 = 8$，加入至答案 $ans=52+8=60$</li>
</ul>
<h4 id="思路2-动态规划，考虑加入一个新数对答案的贡献"><a href="#思路2-动态规划，考虑加入一个新数对答案的贡献" class="headerlink" title="思路2. 动态规划，考虑加入一个新数对答案的贡献"></a>思路2. 动态规划，考虑加入一个新数对答案的贡献</h4><p>接下来考虑动态规划的思路，我们定义一个状态$f(i)$表示处理完前$i$个数后的答案值。那么，对于$f(i-1)$已经求出的情况下，考虑新加入元素$a[i]$对答案的贡献。</p>
<p>此时，我们还是需要考虑元素$a[i]$的加入相比于前$i-1$个元素产生的贡献，多出了哪些贡献，这个贡献实际上就是 <strong>多出来的子数组的和</strong>，进一步地，我们发现这些多出来的子数组实际上都是以$a[i]$为结尾的子数组，而这些子数组，显然可以把它拼到以$a[i-1]$为结尾的子数组后面，这样以来，就相当于多出了$(i-1)$个（包含了$a[i]$的）子数组，此外，$a[i]$本身也可以自己作为一个新的子数组，所以总共产生了$(i-1+1=i)$个新的子数组，因此这里产生了一个值为$(i\times a[i])$的贡献，这里要特别注意，这个贡献实际上代表的是：<strong>添加$a[i]$后，相较于以$a[i-1]$为结尾的所有子数组的和</strong> 多出来的部分，因此我们需要再维护一个状态$g(i)$代表以$a[i]$为结尾的所有子数组的和，那么就有状态转移方程：$g(i) = g(i-1) + i\times a[i]$。对于$f(i)$的状态转移，就是把$g(i)$这部分加上就行了：$f(i) = f(i-1) + g(i)$。</p>
<p>更进一步思考，实际上$g(i)$维护了一个类似前缀和的东西：$\sum_\limits{i=1}^n i\times a[i]$</p>
<p> 代码实现方面，由于状态$i$仅与$i-1$有关，因此可以滚动数组将空间优化为$O(1)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> f = <span class="hljs-number">0</span>; <span class="hljs-comment">// 答案</span><br><span class="hljs-type">int</span> g = <span class="hljs-number">0</span>; <span class="hljs-comment">// 以a_i为结尾的所有子数组的和</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>    g += i * a[i];<br>    f += g;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>这里我们来模拟一下计算流程，还是刚刚的例子 $[1,3,5,2]$。</p>
<ul>
<li><p>考虑第1个数$1$，以$a_1 = 1$为结尾的所有子数组和为：$1\times 1 = 1$（即$[1]$这一个子数组），此后计算对答案的贡献，$f = 1$；</p>
</li>
<li><p>考虑第2个数$3$，以$a_2 = 3$为结尾的所有子数组和为：$1+2\times 3 = 7$（即$[1,3],[3]$这两个子数组），此后计算对答案的贡献，$f = 1+7 = 8$；</p>
</li>
<li><p>考虑第3个数$5$，以$a_3 = 5$为结尾的所有子数组和为：$7+3\times 5 = 22$（即$[1,3,5],[3,5],[5]$这三个子数组），此后计算对答案的贡献，$f = 8+22 =30$；</p>
</li>
<li><p>考虑第4个数$2$，以$a_4 = 2$为结尾的所有子数组和为：$22+4\times 2 = 30$（即$[1,3,5,2],[3,5,2],[5,2],[2]$这四个子数组），此后计算对答案的贡献，$f = 30+30 = 60$</p>
</li>
</ul>
<p>因此最终答案为$f=60$。</p>
<hr>
<p>这样一个直接的问题，我们从两种完全不同的思路出发，得到了相同的结果。因此，对于此类计算贡献的问题，我们通常从这两种思路出发去寻找问题的解法，当然，其他很多问题并没有此题这么直接，通常情况下，他们会结合 <strong>数学、单调栈/单调队列、动态规划</strong> 等知识点综合考察。</p>
<h3 id="问题1变式：求序列所有子集和"><a href="#问题1变式：求序列所有子集和" class="headerlink" title="问题1变式：求序列所有子集和"></a>问题1变式：求序列所有子集和</h3><p>如果将问题1种的 <strong>子数组</strong> 改为 <strong>子集</strong> ，则如何求解呢？</p>
<p>这个问题并不难，可以从思路1的角度出发，还是乘法原理，但左侧端点和右侧端点的选择变多了，对于$a[i]$来说，左侧能够选$2^{i-1}$个子集，右侧能够选$2^{n-i}$个子集，因此对答案的贡献为$a[i] \times 2^{i-1}\times 2^{n-i}$.</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    ans += a[i] * (<span class="hljs-number">1</span>&lt;&lt;i<span class="hljs-number">-1</span>) * (<span class="hljs-number">1</span>&lt;&lt;n-i);<br></code></pre></div></td></tr></table></figure>
<h3 id="问题1进阶：求所有子数组平均数的和"><a href="#问题1进阶：求所有子数组平均数的和" class="headerlink" title="问题1进阶：求所有子数组平均数的和"></a>问题1进阶：求所有子数组平均数的和</h3><p>问题1的进阶版本：</p>
<blockquote>
<p>给出一个长度为 $n$ 的序列$[a_1,a_2,…,a_n]$，求这个序列的所有子数组的平均数，例如，序列$[1,3,5]$的所有子数组为$[1],[3],[5],[1,3],[3,5],[1,3,5]$，它们的平均数的和为$1+3+5+\frac{1+3}{2}+\frac{3+5}{2}+\frac{1+3+5}{3}=18$。</p>
</blockquote>
<p>由于最终答案可能出现浮点数，因此最终输出结果有两种方式：</p>
<ol>
<li>输出浮点数</li>
<li>输出模$10^9+7$意义下的答案</li>
</ol>
<p>我们先考虑<strong>输出浮点数</strong>的情况，对于这样一个问题，我们同样考虑如何计算每个元素产生的贡献。我们发现，对于不同的子数组的长度，每个元素产生的贡献的权重是不一样的，比如说对于$[1,3,5]$这个序列来说，元素$1,3,5$对答案产生的贡献如下：</p>
<script type="math/tex; mode=display">
\left\{\begin{matrix}
 1: & \frac{1}{1} + \frac{1}{2} + \frac{1}{3}\\
 3: & \frac{1}{1} + \frac{2}{2} + \frac{1}{3}\\
 5: & \frac{1}{1} + \frac{1}{2} + \frac{1}{3}
\end{matrix}\right.</script><p>似乎可以看出有一种规律，我们把元素数写多一些，例如$[a_1,a_2,a_3,a_4,a_5]$种每个元素对答案的贡献分别为：</p>
<script type="math/tex; mode=display">
\left\{\begin{matrix}
 a_1: & \frac{1}{1} + \frac{1}{2} + \frac{1}{3} + \frac{1}{4} +\frac{1}{5}\\
 a_2: & \frac{1}{1} + \frac{2}{2} + \frac{2}{3} + \frac{2}{4} + \frac{1}{5}\\
 a_3: & \frac{1}{1} + \frac{2}{2} + \frac{3}{3} + \frac{2}{4} + \frac{1}{5}\\
 a_4: & \frac{1}{1} + \frac{2}{2} + \frac{2}{3} + \frac{2}{4} + \frac{1}{5}\\
 a_5: & \frac{1}{1} + \frac{1}{2} + \frac{1}{3} + \frac{1}{4} +\frac{1}{5}
\end{matrix}\right.</script><p>可以看出，右侧的值实际上是序列的$1+\frac12 + \frac13+…+\frac1n$某种加权和，而这个权重的规律符合<strong>三角波</strong>的规律，即：</p>
<p>对于$a1$来说，就是$\sum \limits_{i=1}^{n} \frac{1}{i}$；</p>
<p>对于$a2$来说，就是加上了$\sum \limits_{i=2}^{n-1} \frac{1}{i}$；</p>
<p>对于$a3$来说，就是再加上$\sum\limits_{i=3}^{n-2} \frac{1}{i}$，以此类推。</p>
<p>而对于过半之后的元素，也是经过类似的操作，只不过变成了减法。</p>
<p>因此，我们可以通过$O(n)$预处理出$\sum\limits_{i=1}^n \frac{1}{i}$这样一个前缀和，然后在遍历序列的时候$O(1)$处理变化值就行了，总复杂度$O(n)$。</p>
<p>对于<strong>输出模$10^9+7$意义下的答案</strong>这样的要求，只需$O(n)$预处理出$[1,2,,…,n]$这些元素的乘法逆元即可，复杂度依然是$O(n)$。</p>
<p>解法来源于我在StackExchange上问的相同的问题：<a href="https://cs.stackexchange.com/questions/152039/sum-of-average-of-all-subarrays#comment319709_152040">algorithms - Sum of average of all subarrays - Computer Science Stack Exchange</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inv</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin&gt;&gt;a[i];<br>    inv[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) <span class="hljs-comment">// linearly calculate mod inverse of [1,2,...,n]</span><br>        inv[i] = <span class="hljs-number">1LL</span> * (mod-mod/i)*inv[mod%i]%mod;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) <span class="hljs-comment">// prefix of mod inverse of [1,2,...,n]</span><br>        inv[i] = (<span class="hljs-number">1LL</span> * inv[i] + inv[i<span class="hljs-number">-1</span>])%mod;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> r = n, l = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=(n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;++i)&#123;<br>        tot = (<span class="hljs-number">1LL</span> * tot + inv[r--] - inv[l++] + mod) % mod;<br>        ans = (<span class="hljs-number">1LL</span> * ans + <span class="hljs-number">1LL</span> * a[i] * tot ) % mod;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) ans = (<span class="hljs-number">1LL</span> * ans + <span class="hljs-number">1LL</span> * a[n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] * tot) % mod;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=(n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>+(n%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>);i&lt;=n;++i)&#123;<br>        tot = (<span class="hljs-number">1LL</span> * tot - inv[++r] + inv[--l] + mod) % mod;<br>        ans = (<span class="hljs-number">1LL</span> * ans + <span class="hljs-number">1LL</span> * a[i] * tot) % mod;<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<hr>
<p>同类题：</p>
<ul>
<li><p><a href="https://leetcode.cn/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/">1498. 满足条件的子序列数目 - 力扣（LeetCode）</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/">828. 统计子串中的唯一字符 - 力扣（LeetCode）</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/total-appeal-of-a-string/">2262. 字符串的总引力 - 力扣（LeetCode）</a></p>
</li>
</ul>
<h2 id="结合数论分块"><a href="#结合数论分块" class="headerlink" title="结合数论分块"></a>结合数论分块</h2><p><a href="https://vjudge.net/problem/LightOJ-1098">LightOJ 1098. A New Function</a></p>
<p>同类题：</p>
<p><a href="https://www.dotcpp.com/oj/problem2683.html">蓝桥杯2022年第十三届省赛真题-因数平方和</a></p>
<h2 id="结合单调栈"><a href="#结合单调栈" class="headerlink" title="结合单调栈"></a>结合单调栈</h2><p> <a href="https://leetcode.cn/problems/sum-of-total-strength-of-wizards/">6077. 巫师的总力量和 - 力扣（LeetCode）</a></p>
<p>同类题：</p>
<ul>
<li><a href="https://leetcode.cn/problems/maximum-subarray-min-product/solution/">1856. 子数组最小乘积的最大值 题解 - 力扣（LeetCode）</a></li>
<li><a href="https://leetcode.cn/problems/sum-of-subarray-minimums/">907. 子数组的最小值之和 - 力扣（LeetCode）</a></li>
<li><a href="https://leetcode.cn/problems/sum-of-subarray-ranges/">2104. 子数组范围和 - 力扣（LeetCode）</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>计算几何 专题</title>
    <url>/2022/04/23/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h2 id="计算几何专题（待更……）"><a href="#计算几何专题（待更……）" class="headerlink" title="计算几何专题（待更……）"></a><center>计算几何专题（待更……）</center></h2><span id="more"></span>
<h2 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h2><h3 id="二维凸包"><a href="#二维凸包" class="headerlink" title="二维凸包"></a>二维凸包</h3><p>模板题: <a class="btn" href="https://www.luogu.com.cn/problem/P2742"  target="_blank">P2742 圈奶牛Fencing the Cows /【模板】二维凸包 - 洛谷</a><br>leetcode模板题: <a class="btn" href="https://leetcode-cn.com/problems/erect-the-fence/"  target="_blank">587. 安装栅栏 - 力扣</a></p>
<ul>
<li>Graham算法</li>
</ul>
<details>
    <summary>code</summary>

<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> ull = <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    vector&lt;pair&lt;<span class="hljs-type">double</span>, <span class="hljs-type">double</span>&gt;&gt; <span class="hljs-built_in">point</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; point[i].first &gt;&gt; point[i].second;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(point.<span class="hljs-built_in">begin</span>(), point.<span class="hljs-built_in">end</span>(), [&amp;](pair&lt;<span class="hljs-type">double</span>, <span class="hljs-type">double</span>&gt; a, pair&lt;<span class="hljs-type">double</span>, <span class="hljs-type">double</span>&gt; b) &#123;<br>        <span class="hljs-built_in">return</span> (a.second == b.second) ? (a.first &lt; b.first) : (a.second &lt; b.second);<br>    &#125;);<br>    <span class="hljs-keyword">auto</span> judge = [&amp;](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c) &#123;<br>        <span class="hljs-built_in">return</span> (point[a].second - point[b].second) * (point[b].first - point[c].first) &gt; (point[a].first - point[b].first) * (point[b].second - point[c].second);<br>    &#125;;<br>    <span class="hljs-keyword">auto</span> dis = [&amp;](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((point[a].first - point[b].first) * (point[a].first - point[b].first) + (point[a].second - point[b].second) * (point[a].second - point[b].second));<br>    &#125;;<br>    <span class="hljs-type">double</span> ans = <span class="hljs-number">0</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; sta;<br>    sta.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>), sta.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">while</span> (sta.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; !<span class="hljs-built_in">judge</span>(i, sta[sta.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>], sta[sta.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>]))<br>            sta.<span class="hljs-built_in">pop_back</span>();<br>        sta.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-type">int</span>)sta.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++)<br>        ans += <span class="hljs-built_in">dis</span>(sta[i], sta[i + <span class="hljs-number">1</span>]);<br>    sta.<span class="hljs-built_in">clear</span>();<br>    sta.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>), sta.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">while</span> (sta.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">judge</span>(i, sta[sta.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>], sta[sta.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>]))<br>            sta.<span class="hljs-built_in">pop_back</span>();<br>        sta.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-type">int</span>)sta.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++)<br>        ans += <span class="hljs-built_in">dis</span>(sta[i], sta[i + <span class="hljs-number">1</span>]);<br>    cout&lt;&lt;fixed&lt;&lt;<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>)&lt;&lt;ans&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>负环&amp;分层图</title>
    <url>/2020/02/11/%E8%B4%9F%E7%8E%AF%E5%92%8C%E5%88%86%E5%B1%82%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="关于最短路算法的特殊应用"><a href="#关于最短路算法的特殊应用" class="headerlink" title="关于最短路算法的特殊应用"></a><center>关于最短路算法的特殊应用</center></h2><span id="more"></span>
<h2 id="负环"><a href="#负环" class="headerlink" title="负环"></a>负环</h2><p><a href="https://www.luogu.com.cn/problem/P3385">洛谷 P3385【模板】负环</a></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给一个含有<strong>负权边</strong>的有向图，判断是否有<strong>负环</strong>存在</p>
<ul>
<li>负环：一个边权之和为负的环</li>
</ul>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>都说$SPFA$已死，其实拿来做这题还是很管用的</p>
<p>我们很容易想到：如果存在负环，那么环内所有点的最短路将会被无限次更新，$bfs$过程将会进入一个死循环，因此这里提供一个最好理解的思路：</p>
<ul>
<li>如果$SPFA$进行过程中同一个点被访问过超过$n$（$n$为节点个数）次，那么就一定存在负环（因为最坏情况下同一个点最多被访问$n$次）</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">2147483647</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> u,v,w,next;<br>&#125;e[<span class="hljs-number">3005</span>];<br><br><span class="hljs-type">int</span> n,m,cnt,vis[<span class="hljs-number">2005</span>],head[<span class="hljs-number">200005</span>],ring[<span class="hljs-number">2005</span>]; <br><span class="hljs-comment">//ring数组记录每个点访问了几次</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w)</span></span>&#123;<br>	e[++cnt].u=u;<br>	e[cnt].v=v;<br>	e[cnt].w=w;<br>	e[cnt].next=head[u];<br>	head[u]=cnt;<br>&#125;<br><span class="hljs-type">int</span> dis[<span class="hljs-number">2005</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">SPFA</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//裸spfa</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		dis[i]=inf;<br>	&#125;<br>	queue&lt;<span class="hljs-type">int</span>&gt; q;<br>	q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>	dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>	vis[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>	ring[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>; <span class="hljs-comment">//起点初始为1次</span><br>	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>		<span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>();<br>		q.<span class="hljs-built_in">pop</span>();<br>		vis[u]=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];i;i=e[i].next)&#123;<br>			<span class="hljs-type">int</span> v=e[i].v,w=e[i].w;<br>			<span class="hljs-keyword">if</span>(dis[v]&gt;dis[u]+w)&#123;<br>				dis[v]=dis[u]+w;<br>				<span class="hljs-keyword">if</span>(vis[v]==<span class="hljs-number">0</span>)&#123;<br>					ring[v]=ring[u]+<span class="hljs-number">1</span>; <span class="hljs-comment">//更新访问次数</span><br>					<span class="hljs-keyword">if</span>(ring[v]&gt;n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//如果超过n了，则有负环</span><br>					vis[v]=<span class="hljs-number">1</span>;<br>					q.<span class="hljs-built_in">push</span>(v);<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> t;<br>	cin&gt;&gt;t;<br>	<span class="hljs-keyword">while</span>(t--)&#123;<br>		cnt=<span class="hljs-number">0</span>;<br>		<span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<br>		<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(head));<br>		<span class="hljs-built_in">memset</span>(ring,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(ring));<br>		<span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dis));<br>		cin&gt;&gt;n&gt;&gt;m;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>			<span class="hljs-type">int</span> u,v,w;<br>			cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br>			<span class="hljs-built_in">addedge</span>(u,v,w);<br>			<span class="hljs-keyword">if</span>(w&gt;=<span class="hljs-number">0</span>) <span class="hljs-built_in">addedge</span>(v,u,w);<br>		&#125;<br>		<span class="hljs-keyword">if</span>(<span class="hljs-built_in">SPFA</span>()) cout&lt;&lt;<span class="hljs-string">&quot;YE5&quot;</span>&lt;&lt;endl;<br>		<span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;N0&quot;</span>&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="2020-3-20-更新"><a href="#2020-3-20-更新" class="headerlink" title="2020.3.20 更新"></a>2020.3.20 更新</h3><p>桥豆麻袋，请看一下<a href="https://vjudge.net/problem/HDU-3666">HDU 3666 THE MATRIX PROBLEM</a></p>
<p>这道题成功更新了我对于负环更新的理解（甚至让我加强了代码，玄学加强？）</p>
<p>于是查到有两种方案（玄学剪枝法）：</p>
<ol>
<li><p>一个节点更新次数大于$\sqrt{n}$就判定位负环（无法证明？有什么办法，这题只能这么胡搞）</p>
</li>
<li><p>所有节点更新总次数大于$k*n$就判定为负环（一般k取2，然并卵，也是个玄学方法）</p>
</li>
</ol>
<p>除此之外，我还发现我一直使用的判负环方法会WA？？</p>
<p>因此我得出结论：</p>
<p><strong>对于此类题，先用我自己的判负环方法，如果WA了，改为更强的方法，如果还TLE，那么就用上面的玄学剪枝法</strong></p>
<p>加强方法（SPFA内部）</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>		ll u=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>		vis[u]=<span class="hljs-number">0</span>;<br>		ring[u]++; <span class="hljs-comment">//新判法</span><br>	<span class="hljs-comment">//if(ring[u]&gt;sqrt(n)) return true; //超级玄学搞法</span><br>    <span class="hljs-comment">//上面那个比较扯了，一般用下面这个就不会错了</span><br>    	<span class="hljs-keyword">if</span>(ring[u]&gt;n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></div></td></tr></table></figure>
<h2 id="分层图"><a href="#分层图" class="headerlink" title="分层图"></a>分层图</h2><p><del>蒟蒻在洛谷的第一道紫题orz</del><br><a href="https://www.luogu.com.cn/problem/P4568">洛谷 P4568 飞行路线</a></p>
<h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>在<strong>单源最短路问题</strong>的基础上，加上以下条件：</p>
<ul>
<li>可以使得最多$k$条边的权值为$0$</li>
</ul>
<h3 id="算法一（动态规划）"><a href="#算法一（动态规划）" class="headerlink" title="算法一（动态规划）"></a>算法一（动态规划）</h3><p>由于$Dijkstra$算法的本质是<strong>动态规划</strong>，因此本题可以利用二维的动态规划求解</p>
<p>定义状态$dp[i][j]$：到达第$i$个节点使$j$条边权为零时的最短路</p>
<p>状态转移：两种状态</p>
<ol>
<li>不使用免费机票：$dp[i][j]=dp[u][j]+w$，w为这条边的权值</li>
<li>使用免费机票：$dp[i][j]=dp[u][j-1]$，且$j&gt;0$</li>
</ol>
<p>注意：</p>
<ul>
<li>记得把对$k$的循环放在最外层</li>
<li>此题是从0开始读入每条边的</li>
</ul>
<h4 id="代码（动态规划）"><a href="#代码（动态规划）" class="headerlink" title="代码（动态规划）"></a>代码（动态规划）</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> u,v,w,next;<br>&#125;e[<span class="hljs-number">500005</span>];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>	<span class="hljs-type">int</span> u,w;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> node&amp;rhs)<span class="hljs-type">const</span>&#123;<br>		<span class="hljs-keyword">return</span> w&gt;rhs.w;<br>	&#125;<br>&#125;;<br><br><span class="hljs-type">int</span> n,m,k,s,t,cnt,head[<span class="hljs-number">1000005</span>],dis[<span class="hljs-number">1000005</span>][<span class="hljs-number">25</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w)</span></span>&#123;<br>	e[++cnt].u=u;<br>	e[cnt].v=v;<br>	e[cnt].w=w;<br>	e[cnt].next=head[u];<br>	head[u]=cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=k;j++)&#123;<br>			dis[i][j]=inf;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=k;i++) dis[s][i]=<span class="hljs-number">0</span>;<br>	<br>	priority_queue&lt;node&gt; q;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=k;i++)&#123; <span class="hljs-comment">//最外层</span><br>		q.<span class="hljs-built_in">push</span>((node)&#123;s,<span class="hljs-number">0</span>&#125;);<br>		<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>			node q1=q.<span class="hljs-built_in">top</span>();<br>			q.<span class="hljs-built_in">pop</span>();<br>			<span class="hljs-type">int</span> u=q1.u;<br>			<span class="hljs-keyword">if</span>(q1.w&gt;dis[u][i])<span class="hljs-keyword">continue</span>;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p=head[u];p;p=e[p].next)&#123;<br>				<span class="hljs-type">int</span> v=e[p].v,w=e[p].w;<br>				<span class="hljs-type">bool</span> f=<span class="hljs-literal">false</span>;<br>				<span class="hljs-keyword">if</span>(dis[v][i]&gt;dis[u][i]+w)&#123; <span class="hljs-comment">//不使用免费机票</span><br>					dis[v][i]=dis[u][i]+w;<br>					f=<span class="hljs-literal">true</span>;<br>				&#125;<br>				<span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;dis[v][i]&gt;dis[u][i<span class="hljs-number">-1</span>])&#123; <span class="hljs-comment">//使用免费机票</span><br>					dis[v][i]=dis[u][i<span class="hljs-number">-1</span>];<br>					f=<span class="hljs-literal">true</span>;<br>				&#125;<br>				<span class="hljs-keyword">if</span>(f)&#123;<br>					q.<span class="hljs-built_in">push</span>((node)&#123;v,dis[v][i]&#125;);<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;s&gt;&gt;t;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>		<span class="hljs-type">int</span> u,v,w;<br>		cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br>		<span class="hljs-built_in">addedge</span>(u,v,w);<br>		<span class="hljs-built_in">addedge</span>(v,u,w);<br>	&#125; <br>	<span class="hljs-built_in">dijkstra</span>();<br>	cout&lt;&lt;dis[t][k]&lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></div></td></tr></table></figure>
<hr>
<ul>
<li>2020.3.13 补</li>
</ul>
<h3 id="算法二（分层建图）"><a href="#算法二（分层建图）" class="headerlink" title="算法二（分层建图）"></a>算法二（分层建图）</h3><p>看这题之前，我们先看另一道容易一点的</p>
<p><a href="https://vjudge.net/problem/HDU-4725">HDU 4724 The Shortest Path in Nya Graph</a></p>
<p>题意：</p>
<p>求一个无向带权图的单源最短路</p>
<p>附加条件：每个节点都处在一个“层”中，可以花费<code>c</code>的代价在相邻两层的任意节点间移动</p>
<p>题解：</p>
<p>首先，毋庸置疑我们肯定得建图+求最短路，但这个附加条件就十分棘手了</p>
<p>因此，出现了<strong>分层建图</strong>这么一个概念：</p>
<p>我们将层与层之间的关系建立在原始的n个节点的图之后（虚图，也可以说是<strong>把每一层也视为一个节点</strong>），比方说，如果<code>i</code>号点在第<code>k</code>层，那么我们就建一个<strong>从点<code>i</code>指向第<code>k</code>层的单向边（边权为0）</strong>，而这个<strong>第<code>k</code>层</strong>可以表示为<code>n+k</code>（就像<a href="https://www.luogu.com.cn/problem/P2024">食物链</a>这道并査集一样，单独剥离一块区域用来存点和层的关系）因而这个就呈现出了点<code>i</code>在第<code>k</code>层的一个概念，而由于每相邻层之间的点能任意穿梭，我们还必须建立起<strong>相邻的层中点与层中点的关系</strong>，因此还需要存一次点<code>i</code>到前一层（如果<code>i</code>不在最后一层）和后一层（如果<code>i</code>不在第一层）的关系（依题意存双向边，边权为<code>c</code>），这样这个图就建好了，接下来跑一遍最短路就行了（当然这题似乎需要堆优化的dijkstra才能过）</p>
<h4 id="代码（HDU-4724-分层图）"><a href="#代码（HDU-4724-分层图）" class="headerlink" title="代码（HDU 4724 分层图）"></a>代码（HDU 4724 分层图）</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1ll</span>&lt;&lt;<span class="hljs-number">60</span>;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>	ll kk=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>; <br>	<span class="hljs-type">char</span> cc=<span class="hljs-built_in">getchar</span>(); <br>	<span class="hljs-keyword">while</span>(cc&lt;<span class="hljs-string">&#x27;0&#x27;</span>||cc&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<span class="hljs-keyword">if</span>(cc==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;cc=<span class="hljs-built_in">getchar</span>();&#125; <br>	<span class="hljs-keyword">while</span>(cc&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;cc&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;kk=(kk&lt;&lt;<span class="hljs-number">1</span>)+(kk&lt;&lt;<span class="hljs-number">3</span>)+cc-<span class="hljs-string">&#x27;0&#x27;</span>;cc=<span class="hljs-built_in">getchar</span>();&#125; <br>	<span class="hljs-keyword">return</span> kk*f; <br>&#125;<br><span class="hljs-type">int</span> cnt,head[<span class="hljs-number">800005</span>];<br>ll dis[<span class="hljs-number">800005</span>];<br><span class="hljs-type">int</span> n,m,c;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> u,v,w,next;<br>&#125;e[<span class="hljs-number">800005</span>]; <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>	<span class="hljs-type">int</span> u,dis;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> node&amp;rhs)<span class="hljs-type">const</span> &#123;<br>		<span class="hljs-keyword">return</span> dis&gt;rhs.dis;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w)</span></span>&#123;<br>	e[++cnt]=Edge&#123;u,v,w,head[u]&#125;;<br>	head[u]=cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">dij</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//dijkstra最短路堆优化</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=(n+n);i++) dis[i]=inf;<br>	dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>	priority_queue&lt;node&gt; q;<br>	q.<span class="hljs-built_in">push</span>(node&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;);<br>	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>		node q1=q.<span class="hljs-built_in">top</span>();q.<span class="hljs-built_in">pop</span>();<br>		ll u=q1.u,d=q1.dis;<br>		<span class="hljs-keyword">if</span>(d&gt;dis[u]) <span class="hljs-keyword">continue</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];i;i=e[i].next)&#123;<br>			ll v=e[i].v,w=e[i].w;<br>			<span class="hljs-keyword">if</span>(dis[v]&gt;dis[u]+w)&#123;<br>				dis[v]=dis[u]+w;<br>				q.<span class="hljs-built_in">push</span>(node&#123;v,dis[v]&#125;);<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> t=<span class="hljs-built_in">read</span>();<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> o=<span class="hljs-number">1</span>;o&lt;=t;o++)&#123;<br>		cnt=<span class="hljs-number">0</span>;<br>		<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(head));<br>		<span class="hljs-built_in">memset</span>(e,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(e)); <br>		n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>(),c=<span class="hljs-built_in">read</span>();<br>		<span class="hljs-type">int</span> x,y,z;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			x=<span class="hljs-built_in">read</span>();<br>			<span class="hljs-built_in">addedge</span>(i,n+x,<span class="hljs-number">0</span>); <span class="hljs-comment">//记得是单向边，否则WA</span><br>			<span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">1</span>)&#123; <span class="hljs-comment">//如果不在第一层，把连上前一层</span><br>				<span class="hljs-built_in">addedge</span>(i,n+x<span class="hljs-number">-1</span>,c);<br>				<span class="hljs-built_in">addedge</span>(n+x<span class="hljs-number">-1</span>,i,c);<br>			&#125;<br>			<span class="hljs-keyword">if</span>(x&lt;n)&#123; <span class="hljs-comment">//如果不在最后一层，就连上下一层</span><br>				<span class="hljs-built_in">addedge</span>(i,n+x+<span class="hljs-number">1</span>,c);<br>				<span class="hljs-built_in">addedge</span>(n+x+<span class="hljs-number">1</span>,i,c);<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123; <span class="hljs-comment">//正常加边操作</span><br>			x=<span class="hljs-built_in">read</span>(),y=<span class="hljs-built_in">read</span>(),z=<span class="hljs-built_in">read</span>();<br>			<span class="hljs-built_in">addedge</span>(x,y,z);<br>			<span class="hljs-built_in">addedge</span>(y,x,z);<br>		&#125;<br>		<span class="hljs-built_in">dij</span>();<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case #%d: %lld\n&quot;</span>,o,dis[n]==inf?<span class="hljs-number">-1</span>:dis[n]);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>接下来我们再看这道 [飞行路线]</p>
<p>我们同样考虑<strong>分层建图</strong>，由于存在<code>k</code>次免费，因此我们建一个<code>k+1</code>层图，第一层是正常的不使用任何免费机票的图，从第二层往后，每加一层就视为使用了一次免费机票，因此最后只需要跑一遍<code>从st到en+k*n</code>的最短路即可</p>
<p>那么在建图的时候，我们在每一层都要正常建图，同时要把当前层往前一层的对应节点连一个边权为0的边，表示使用免费机票下的路线</p>
<h4 id="代码（飞行路线-分层图）"><a href="#代码（飞行路线-分层图）" class="headerlink" title="代码（飞行路线 分层图）"></a>代码（飞行路线 分层图）</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1ll</span>&lt;&lt;<span class="hljs-number">60</span>;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>	ll kk=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>; <br>	<span class="hljs-type">char</span> cc=<span class="hljs-built_in">getchar</span>(); <br>	<span class="hljs-keyword">while</span>(cc&lt;<span class="hljs-string">&#x27;0&#x27;</span>||cc&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<span class="hljs-keyword">if</span>(cc==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;cc=<span class="hljs-built_in">getchar</span>();&#125; <br>	<span class="hljs-keyword">while</span>(cc&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;cc&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;kk=(kk&lt;&lt;<span class="hljs-number">1</span>)+(kk&lt;&lt;<span class="hljs-number">3</span>)+cc-<span class="hljs-string">&#x27;0&#x27;</span>;cc=<span class="hljs-built_in">getchar</span>();&#125; <br>	<span class="hljs-keyword">return</span> kk*f; <br>&#125;<br><span class="hljs-type">int</span> cnt,head[<span class="hljs-number">8000005</span>];<br>ll dis[<span class="hljs-number">8000005</span>];<br><span class="hljs-type">int</span> n,m,k,st,en;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> u,v,w,next;<br>&#125;e[<span class="hljs-number">8000005</span>]; <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>	<span class="hljs-type">int</span> u,dis;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> node&amp;rhs)<span class="hljs-type">const</span> &#123;<br>		<span class="hljs-keyword">return</span> dis&gt;rhs.dis;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w=<span class="hljs-number">0</span>)</span></span>&#123;<br>	e[++cnt]=Edge&#123;u,v,w,head[u]&#125;;<br>	head[u]=cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">dij</span><span class="hljs-params">(<span class="hljs-type">int</span> st)</span></span>&#123; <span class="hljs-comment">//常规dijkstra堆优化</span><br>	<span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f3f</span>,<span class="hljs-built_in">sizeof</span>(dis));<br>	dis[st]=<span class="hljs-number">0</span>;<br>	priority_queue&lt;node&gt; q;<br>	q.<span class="hljs-built_in">push</span>(node&#123;st,<span class="hljs-number">0</span>&#125;);<br>	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>		node q1=q.<span class="hljs-built_in">top</span>();q.<span class="hljs-built_in">pop</span>();<br>		ll u=q1.u,d=q1.dis;<br>		<span class="hljs-keyword">if</span>(d&gt;dis[u]) <span class="hljs-keyword">continue</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];i;i=e[i].next)&#123;<br>			ll v=e[i].v,w=e[i].w;<br>			<span class="hljs-keyword">if</span>(dis[v]&gt;dis[u]+w)&#123;<br>				dis[v]=dis[u]+w;<br>				q.<span class="hljs-built_in">push</span>(node&#123;v,dis[v]&#125;);<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>(),k=<span class="hljs-built_in">read</span>();<br>	st=<span class="hljs-built_in">read</span>(),en=<span class="hljs-built_in">read</span>();<br>	<span class="hljs-type">int</span> u,v,w;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>		u=<span class="hljs-built_in">read</span>(),v=<span class="hljs-built_in">read</span>(),w=<span class="hljs-built_in">read</span>();<br>		<span class="hljs-built_in">addedge</span>(u,v,w);<br>		<span class="hljs-built_in">addedge</span>(v,u,w);<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=k;j++)&#123; <span class="hljs-comment">//从第二层开始</span><br>			<span class="hljs-built_in">addedge</span>(u+(j<span class="hljs-number">-1</span>)*n,v+j*n); <span class="hljs-comment">//连免费的边</span><br>			<span class="hljs-built_in">addedge</span>(v+(j<span class="hljs-number">-1</span>)*n,u+j*n);<br>			<span class="hljs-built_in">addedge</span>(u+j*n,v+j*n,w); <span class="hljs-comment">//连该层的正常边</span><br>			<span class="hljs-built_in">addedge</span>(v+j*n,u+j*n,w);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;i++)&#123;<br>		<span class="hljs-built_in">addedge</span>(en+(i<span class="hljs-number">-1</span>)*n,en+i*n);<br>	&#125;<br>	<span class="hljs-built_in">dij</span>(st);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,dis[en+k*n]);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>数据结构</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>递归神经网络RNN(Recurrent Neural Network)</title>
    <url>/2020/02/16/%E9%80%92%E5%BD%92%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CRNN-Recurrent-Neural-Network/</url>
    <content><![CDATA[<h2 id="RNN简单介绍"><a href="#RNN简单介绍" class="headerlink" title="RNN简单介绍"></a><center>RNN简单介绍</center></h2><span id="more"></span>
<p>关于<strong>RNN递归（循环）神经网络</strong>的知识点</p>
<hr>
<p>以下内容用我自己理解的十分通俗的话描述出来，非常好理解</p>
<h2 id="递归神经网络"><a href="#递归神经网络" class="headerlink" title="递归神经网络"></a>递归神经网络</h2><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><ul>
<li><strong>人工神经网络</strong>和<strong>卷积神经网络</strong>成立的前提假设是：元素之间是相互独立的，输入与输出也是独立的，那么对于元素或输入输出之间不独立（比如写一篇作文或画一幅画）的情况就无法处理，因此出现了<strong>递归神经网络</strong>，他的本质是：像人一样拥有记忆的能力</li>
</ul>
<h3 id="RNN结构"><a href="#RNN结构" class="headerlink" title="RNN结构"></a>RNN结构</h3><p><img src="https://i.loli.net/2020/02/18/AIXUtVGTR4g5EBi.png" alt="image.png"></p>
<p>如上图所示，每个圆圈代表一个单元，$x、s、o$分别代表输入、记忆、输出，$U、V、W$代表权重，由于RNN具有记忆，因此在网络上的呈现就像多了一个时间的维度，并且RNN是一个$Sequence to Sequence$的模型，因此会出现</p>
<script type="math/tex; mode=display">
X_t:表示t时刻的输入，O_t:表示t时刻的输出，S_t:表示t时刻的记忆</script><p>当前时刻的输出$O<em>t$是由当前时刻的输入$X_t$和记忆$S</em>{t-1}$决定的</p>
<script type="math/tex; mode=display">
S_t=f(U*X_t+W*S_{t-1})</script><p>上式中的$f$为激活函数（RNN种常用的有$tanh$），用于过滤信息，因为有时候很久以前的记忆是没有作用的</p>
<p>于是最后一步就是预测了，如果是分类任务，那么通常情况下采用$softmax$函数来预测（不懂$softmax$的<a href="https://blog.csdn.net/bitcarmanlee/article/details/82320853">戳这里</a>），记得带上权重矩阵</p>
<script type="math/tex; mode=display">
O_t=softmax(V\cdot S_t)</script><p>RNN的注意点：</p>
<ol>
<li>$O_t$是由当前时间以及之前所有的记忆得到的</li>
<li>$S_t$捕捉之前时间点的信息，但不能捕捉之前所有时间点的信息</li>
<li>$O_t$在很多情况下并不存在，因为大多数任务并不关注过程，只关注结果</li>
</ol>
<h3 id="RNN改进1：双向RNN"><a href="#RNN改进1：双向RNN" class="headerlink" title="RNN改进1：双向RNN"></a>RNN改进1：双向RNN</h3><p>作用：能够同时利用过去和未来的信息</p>
<p>结构图：</p>
<p><img src="https://i.loli.net/2020/02/18/cOumMB81APV6nYs.png" alt="image.png"></p>
<p>就像算法里的双向bfs一样，双向RNN的每个记忆节点同时利用过去的记忆和来自未来的记忆，因此所需内存是单向RNN的两倍</p>
<script type="math/tex; mode=display">
从前往后：\overrightarrow{S_t^1}=f(\overrightarrow{U^1}*X_t+\overrightarrow{W^1}*S_{t-1}+\overrightarrow{b^1})\\从后往前：\overleftarrow{S_t^2}=f(\overleftarrow{U^2}*X_t+\overleftarrow{W^2}*S_{t-1}+\overleftarrow{b^2})\\输出：O_t=softmas(V*[\overrightarrow{S^1_t};\overleftarrow{S_t^2}])</script><h3 id="RNN改进2：深层双向RNN"><a href="#RNN改进2：深层双向RNN" class="headerlink" title="RNN改进2：深层双向RNN"></a>RNN改进2：深层双向RNN</h3><p>改进：拥有多个隐含层</p>
<p>结构图：</p>
<p><img src="https://i.loli.net/2020/02/18/Y7Ubli2Cy48ILaw.png" alt="image.png"></p>
<p>因此每个隐含层神经元的输入由两部分组成：</p>
<ol>
<li>前一时刻的同一隐含层传来的信息</li>
<li>同一时刻上一个隐含层传来的信息（包括前向和后向）</li>
</ol>
<script type="math/tex; mode=display">
\overrightarrow{h_t}^{(i)}=f(\overrightarrow{W}^{(i)}h_t^{(i-1)}+\overrightarrow{V}^{(i)}\overrightarrow{h}_{t-1}^{(i)}+\overrightarrow{b}^{(i)})\\\overleftarrow{h_t}^{(i)}=f(\overleftarrow{W}^{(i)}h_t^{(i-1)}+\overleftarrow{V}^{(i)}\overleftarrow{h}_{t-1}^{(i)}+\overleftarrow{b}^{(i)})</script><p>最后利用最后一层来分类：</p>
<script type="math/tex; mode=display">
\widehat{y}_t=g(Uh_t+c)=g(U[\overrightarrow{h}_t^{(L)}:\overleftarrow{h}_t^{(L)}]+c)</script><h3 id="RNN的训练方式：BPTT-Back-Propagation-Through-Time"><a href="#RNN的训练方式：BPTT-Back-Propagation-Through-Time" class="headerlink" title="RNN的训练方式：BPTT(Back Propagation Through Time)"></a>RNN的训练方式：BPTT(Back Propagation Through Time)</h3><p>由之前分析可知，当前时刻的记忆：</p>
<script type="math/tex; mode=display">
s_t=tanh(Ux_t+Ws_{t-1})</script><p>利用该记忆通过$softmax$分类器输出概率：</p>
<script type="math/tex; mode=display">
\widehat{y}_t=softmax(Vs_t)</script><p>接下来求出损失，这里使用交叉熵（crossentropy）损失函数：</p>
<script type="math/tex; mode=display">
t时刻的损失：E_t(y_t,\widehat{y}_t)=-y_tlog{\widehat{y}_t}</script><p>把所有时刻的损失都加起来：</p>
<script type="math/tex; mode=display">
E(y_t,\widehat{y}_t)=\sum_{t}{(y_t,\widehat{y}_t)}=-\sum_{t}{y_tlog\widehat{y}_t}</script><p><img src="https://i.loli.net/2020/02/18/56LoAzh9kmf1FBw.png" alt="image.png"></p>
<p>接下来就是根据损失函数利用SGD或者RMSprop之类的算法求解最优参数的过程了，在CNN和ANN里我们使用BP（反向传播）算法，利用链式求导法则完成这一过程的细节，但是对于RNN我们需要使用BPTT，区别也就是CNN和RNN的区别，它的输出不仅依赖于当前输入，还依赖于当前记忆，所以每个求导环节还要加上一个对前一时刻的的求导</p>
<p><img src="https://i.loli.net/2020/02/18/3FTZdxO298I1nkB.png" alt="image.png"></p>
<p>举个例子：让$E_3$对$W$求偏导，有如下公式</p>
<script type="math/tex; mode=display">
s_3=tanh(Ux_3+Ws_2)\\\frac{\partial E_3}{\partial W}=\frac{\partial E_3}{\partial \widehat{y}_3}\frac{\partial \widehat{y}_3}{\partial s_3}\frac{\partial s_3}{\partial W}</script><p>还没结束，我们发现</p>
<script type="math/tex; mode=display">
s_2=tanh(Ux_2+Ws_1)</script><p>因此真正的求导过程长这样</p>
<script type="math/tex; mode=display">
\frac{\partial E_3}{\partial W}=\sum_{k=0}^{3}\frac{\partial E_3}{\partial \widehat{y}_3}\frac{\partial \widehat{y}_3}{\partial s_3}\frac{\partial s_3}{\partial s_k}\frac{\partial s_k}{\partial W}</script><p>可以看出，我们需要把当前时刻造成的损失和以往每个时刻造成的损失加起来，因此RNN设立了参数共享机制，这是CNN和ANN所没有的</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>酷Q机器人部署过程记录</title>
    <url>/2020/04/22/%E9%85%B7Q%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%83%A8%E7%BD%B2%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="酷Q机器人部署过程记录"><a href="#酷Q机器人部署过程记录" class="headerlink" title="酷Q机器人部署过程记录"></a><center>酷Q机器人部署过程记录</center></h2><ul>
<li>终终终于快要完工了，AWSL，这里记录一下整个过程（以及所有踩过的坑）<span id="more"></span>
</li>
</ul>
<hr>
<p>源自于Comet OJ群一位大佬自制的群机器人，能自动查询各类算法竞赛平台的比赛时间，还能提醒你，于是产生了兴趣，前去求学。然后大佬二话不说 抛给我一个知乎链接：<a href="https://zhuanlan.zhihu.com/p/129086720">小明机器人来了</a>，于是踏上造机器人的征途。。。</p>
<p>这里我整理了一下，想自己搭一个这样的机器人，那么你需要掌握以下</p>
<p><strong>前置姿势：</strong></p>
<ul>
<li>Python基本语法+特性（闭包、装饰器、面向对象 等）</li>
<li>Python异步IO（协程的实现）</li>
<li>基本的Python爬虫知识（简单的单线程爬虫即可），包括requests库的使用，以及熟悉至少一种网页解析库（re、bs4、xpath 等）</li>
<li><p>最基础的code ability（一些简单计算和逻辑的实现）</p>
</li>
<li><p>会看官方文档的能力</p>
</li>
</ul>
<p>对，就这么简单（会一点点python+一点点爬虫就可以搞了）</p>
<hr>
<p>按照顺序来，第一部开始学<a href="https://nonebot.cqp.moe/">Nonebot</a>，打开官方文档，直接搞起：</p>
<p>可以看到他的原理（基于Python异步IO+酷Q+CQHTTP插件 反向WebSocket通信）</p>
<p><img src="https://nonebot.cqp.moe/assets/img/diagram.4194e005.png" alt="m1"></p>
<ul>
<li>第一步：安装NoneBot</li>
</ul>
<p>首先保证自己的python版本不低于3.7，然后<code>pip install nonebot</code>一步到位</p>
<p>然后你可能会崩掉（特别是在服务器上安装的时候），所以先提前把一些常用库安装好吧</p>
<ul>
<li>第二步 安装库Q和插件</li>
</ul>
<p><a href="https://cqp.cc/b/news">酷Q版本发布</a>，Air免费，Pro要捐钱给开发者<del>（还蛮贵的）</del>，Pro能发图片！（可惜我没有）</p>
<p>到这里，其实你完全可以去应用发布专栏找别人开发好的插件拿来直接用，但是这就违背了我学技术的初心，于是果断<del>（下载几个好玩的插件先玩起来）</del>去学技术</p>
<ul>
<li>第三步 下载CQHTTP插件</li>
</ul>
<p>到<a href="https://cqhttp.cc/docs/">这里</a>按照要求下载插件，然后就没了，万事俱备只欠东风了</p>
<p>PS：如果插件不能用了，可能是没更新，去看看新版本吧</p>
<hr>
<p>然后跟着教程来，我的github就有了mybot这个repo</p>
<p><a href="https://github.com/b4158813/mybot">github: b4158813/mybot</a></p>
<p>里面大部分配置都是我自己写的<strong>爬虫</strong>代码和<strong>异步交互</strong>代码，到现在，花了几天时间完成了以下功能：</p>
<p>返回学校VPN网址、爬取学校新闻、爬取教务处新闻、从用户获取搜索关键字并搜索B站视频、爬取B站日榜、爬取欧拉计划题目、爬取百度百科/维基百科词条内容、通知个人定时打卡（个人的信息存储在json格式文件中）</p>
<p>其实都是些不需要动脑子的活啦~，爬虫几乎都是用requests+XPath搞的（没有用到Selenium模仿电脑操作以及验证码识别这种稍微高级一点的实现，毕竟学校这种网站也没什么反爬虫措施QAQ，噢是我太菜了）</p>
<p>（目前已经得到辅导员认可，已经投入年级群使用，hiahiahia~~）</p>
<p>当然这里要感谢的还是那位神秘的大佬，给我提供了这么好的学习资源</p>
<hr>
<p>此后，我又尝试过购买阿里云的服务器（Windows 2012 server）来实现服务器部署机器人，因为这样就不需要我的电脑24小时都开着啦，然而我<strong>快要</strong>成功了，但是还是没成功，BUG很严重，机器人甚至不会理你，而且服务器<strong>太卡了</strong>，我不知道是不是我的问题，这几天在研究研究，争取搞定它，一劳永逸啊！</p>
<ul>
<li>2020.4.24 更新</li>
</ul>
<p>暂时不搞云服务器了（阿里云的windows服务器为什么这么卡），就把自己的TP X230 作为服务器吧，不想再折腾了。。。</p>
<ul>
<li>2020.4.25 更新</li>
</ul>
<p>今天上午出了点小bug，因为我发现大佬的repo提供的代码居然是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 这种垃圾代码拿出来误人子弟</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">for</span> it <span class="hljs-keyword">in</span> ID:<br>            <span class="hljs-keyword">await</span> bot.send_private_msg(user_id=it, message=text)<br>    <span class="hljs-keyword">except</span> CQHttpError: <br>   <span class="hljs-comment"># 您这么写？只要一个号码出错 后面的正确的号码不就也通知不到了吗？？？？</span><br>		<span class="hljs-keyword">pass</span><br></code></pre></div></td></tr></table></figure>
<p>于是果断改进为下面这种：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">for</span> it <span class="hljs-keyword">in</span> ID:<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">await</span> bot.send_private_msg(user_id=it, message=text)<br>    <span class="hljs-keyword">except</span>: <span class="hljs-comment"># 一个出错没事，下一个可以接着来</span><br>        <span class="hljs-keyword">pass</span><br></code></pre></div></td></tr></table></figure>
]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>Python项目</tag>
      </tags>
  </entry>
  <entry>
    <title>链式前向星解释</title>
    <url>/2020/02/04/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/</url>
    <content><![CDATA[<h2 id="存图方式：链式前向星-浅析"><a href="#存图方式：链式前向星-浅析" class="headerlink" title="存图方式：链式前向星 浅析"></a><center>存图方式：链式前向星 浅析</center></h2><span id="more"></span>
<ul>
<li>我们目前所知的存图方式有三种：<ol>
<li><strong>邻接矩阵</strong></li>
<li><strong>邻接表</strong></li>
<li><strong>链式前向星</strong></li>
</ol>
</li>
</ul>
<p>然而<strong>邻接矩阵</strong>空间复杂度太大，除了一些特定场合（$floyd$算法等）需要使用之外并不推荐；<strong>邻接表</strong>不太好建出来，因此大多是情况下我们使用<strong>链式前向星</strong>的方式来存储图结构，下面做一点解释。</p>
<hr>
<h2 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h2><ul>
<li>与<strong>邻接矩阵</strong> <u>存储<strong>一对节点</strong>和这对节点的权值</u> 的方式不同，链式前向星采用的方式是<strong>存储每一条边</strong>。</li>
<li><p>这一条边包含了以下信息：</p>
<ul>
<li>从哪来（起点）</li>
<li>到哪去（终点）</li>
<li>权值</li>
<li><strong>$next$值：与本条边相同起点的前一条边</strong></li>
</ul>
</li>
<li><p>个人理解：仿佛把每一个节点出发的所有边存储在了<strong>以该节点命名的<u>链表</u>内</strong>。</p>
</li>
</ul>
<h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><ul>
<li><p>首先是一条边（$Edge$）的结构定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br>	<span class="hljs-type">int</span> from,to,next,dis;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
</li>
<li><p>开辟一些变量（用来计数和用于遍历，<strong>很重要</strong>）</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> head[<span class="hljs-number">1000005</span>]; <span class="hljs-comment">//用来存从每个节点出发的最后一条边的序号</span><br><span class="hljs-type">int</span> cnt; <span class="hljs-comment">//用来记录边的序号</span><br></code></pre></div></td></tr></table></figure>
</li>
<li><p>$addedge$函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w)</span></span>&#123;<br>	cnt++;<br>    edge[cnt].from = u;<br>    edge[cnt].to = v;<br>    edge[cnt].dis = w;<br>    edge[cnt].next = head[u]; <span class="hljs-comment">//把这条边和同一起点的上一条边接上</span><br>    head[u] = cnt; <span class="hljs-comment">//更新当前起点所对应的最后一条边的序号</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
<li><p>示例：</p>
<p>Sample Input</p>
<figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span><br></code></pre></div></td></tr></table></figure>
<p>构建了如下的一个图：</p>
<p><img src="https://i.loli.net/2020/02/04/AdUB1zLFTYRDZPi.png" alt="graph.png"></p>
<p>每次$addedge$操作中，最后两行（带有注释的）代码所进行的过程如下：</p>
<p>举个例子，现在<strong>第1条边</strong>（1，2）已经连上，需要$addedge(1,3,2)$：</p>
<p><img src="https://i.loli.net/2020/02/04/OxsCV7rhDILgKdF.png" alt="1.png"></p>
<ol>
<li><p>将当前$edge$与<strong>同起点</strong>的上一条$edge$连上：</p>
<p><img src="https://i.loli.net/2020/02/04/1fbd9I2Gg6R4z8p.png" alt="image.png"></p>
</li>
<li><p>将$head$更新为指向当前同起点的最后一条$edge$，也就是现在这一条$edge$：</p>
<p><img src="https://i.loli.net/2020/02/04/CSQ41FdkEzWhwrj.png" alt="3.png"></p>
</li>
</ol>
<p>大功告成，接下来按照同样步骤把图存完即可，最终结果如下图所示：</p>
<p><img src="https://i.loli.net/2020/02/04/rsTm2kLjDwIRVPv.png" alt="模拟.png"></p>
<p>PS：如果是无向图的话，那么就$addedge(u,v,w)$再$addedge(v,u,w)$即可。</p>
</li>
</ul>
<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><ul>
<li><p><strong>链式前向星</strong>能够优化图的遍历过程，如$Dijkstra$、$DFS$、$BFS$等，其最简单的遍历方式如下：（枚举每一个点的所有的边（<strong>倒序</strong>））</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p=head[i];p;p=edge[p].next)&#123; <span class="hljs-comment">//i号节点</span><br>	...<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>题解-2020USST算法竞赛练习场11-IJK</title>
    <url>/2020/03/15/%E9%A2%98%E8%A7%A3-2020USST%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E7%BB%83%E4%B9%A0%E5%9C%BA11-IJK/</url>
    <content><![CDATA[<h2 id="题解系列"><a href="#题解系列" class="headerlink" title="题解系列"></a><center>题解系列</center></h2><span id="more"></span>
<ul>
<li>自己写的题解<h2 id="2020年上海理工大学算法竞赛训练场11-I-K"><a href="#2020年上海理工大学算法竞赛训练场11-I-K" class="headerlink" title="2020年上海理工大学算法竞赛训练场11 I~K"></a>2020年上海理工大学算法竞赛训练场11 I~K</h2></li>
</ul>
<h4 id="I-Count"><a href="#I-Count" class="headerlink" title="I. Count"></a>I. Count</h4><p>题意：</p>
<script type="math/tex; mode=display">
a_1=1,a_2=2\\n\geq 3时,a_n=2a_{n-2}+a_{n-1}+n^3\\求a_n\%123456789</script><p>题解：</p>
<p>由于数据范围很大，考虑矩阵加速，构造如下矩阵A</p>
<script type="math/tex; mode=display">
\begin{pmatrix}a_{n-2}&a_{n-1}&n^3&n^2&n&1\end{pmatrix}\begin{pmatrix} 0 & 2 & 0 & 0 & 0 & 0 \\ 1 & 1 & 0 & 0 & 0 & 0 \\ 0 & 1 & 1 & 0 & 0 & 0 \\ 0 & 0 & 3 & 1 & 0 & 0 \\ 0 & 0 & 3 & 2 & 1 & 0 \\ 0 & 0 & 1 & 1 & 1 & 1 \end{pmatrix}\\=\begin{pmatrix}a_{n-1}&a_{n}&(n+1)^3&(n+1)^2&(n+1)&1\end{pmatrix}\\</script><script type="math/tex; mode=display">
初始矩阵\begin{pmatrix}1&2&3^3&3^2&3&1\end{pmatrix}\\
则ans=初始矩阵*A^{n-1}的第一项</script><p>AC代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">123456789</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">M</span>&#123;<br>	ll mat[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<br>&#125;;<br><span class="hljs-type">int</span> t;<br>ll n;<br>M <span class="hljs-keyword">operator</span>*(M x1,M x2)&#123;<br>	M res;<br>	<span class="hljs-built_in">memset</span>(res.mat,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(res.mat));<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">6</span>;i++)&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">6</span>;j++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">6</span>;k++)&#123;<br>				res.mat[i][j]+=(x1.mat[i][k]%mod*x2.mat[k][j]%mod)%mod;<br>				res.mat[i][j]%=mod;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> M <span class="hljs-title">mqpow</span><span class="hljs-params">(M aa,ll y,M A)</span></span>&#123;<br>	<span class="hljs-keyword">while</span>(y&gt;<span class="hljs-number">0</span>)&#123;<br>		<span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) aa=aa*A;<br>		y&gt;&gt;=<span class="hljs-number">1</span>;<br>		A=A*A;<br>	&#125;<br>	<span class="hljs-keyword">return</span> aa;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<br>	M a,b;<br>	<span class="hljs-built_in">memset</span>(a.mat,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a.mat));<br>	<span class="hljs-built_in">memset</span>(b.mat,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(b.mat));<br>	a.mat[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>	a.mat[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>;<br>	a.mat[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>]=<span class="hljs-number">27</span>;<br>	a.mat[<span class="hljs-number">1</span>][<span class="hljs-number">4</span>]=<span class="hljs-number">9</span>;<br>	a.mat[<span class="hljs-number">1</span>][<span class="hljs-number">5</span>]=<span class="hljs-number">3</span>;<br>	a.mat[<span class="hljs-number">1</span>][<span class="hljs-number">6</span>]=<span class="hljs-number">1</span>;<br>	b.mat[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]=b.mat[<span class="hljs-number">5</span>][<span class="hljs-number">4</span>]=<span class="hljs-number">2</span>;<br>	b.mat[<span class="hljs-number">4</span>][<span class="hljs-number">3</span>]=b.mat[<span class="hljs-number">5</span>][<span class="hljs-number">3</span>]=<span class="hljs-number">3</span>;<br>	b.mat[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]=b.mat[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]=b.mat[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>]=b.mat[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>]=b.mat[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>]=b.mat[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>]=b.mat[<span class="hljs-number">6</span>][<span class="hljs-number">3</span>]=b.mat[<span class="hljs-number">6</span>][<span class="hljs-number">4</span>]=b.mat[<span class="hljs-number">6</span>][<span class="hljs-number">5</span>]=b.mat[<span class="hljs-number">6</span>][<span class="hljs-number">6</span>]=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">while</span>(t--)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;n);<br>		M ans=<span class="hljs-built_in">mqpow</span>(a,n<span class="hljs-number">-1</span>,b);<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans.mat[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="J-没有兄弟的舞会"><a href="#J-没有兄弟的舞会" class="headerlink" title="J. 没有兄弟的舞会"></a>J. 没有兄弟的舞会</h4><p>题意：</p>
<p>求一棵节点带权值的树的节点权值和的最大值和最小值，条件是所选节点中至多只有一对兄弟节点（父节点相同）</p>
<p>题解：</p>
<p>用vector（set好像也可，还省去了排序）存每个父节点的儿子节点，然后对每个节点都贪心地选最大和最小的儿子节点加到答案中，最后再遍历所有节点找到次大和次小的权值加上去就行了</p>
<p>注意：</p>
<ol>
<li>权值有正有负，因此大于零的节点都没必要加到最小值里面，同理小于零的节点也没必要加到最大值里面</li>
<li>此题似乎<strong>用快读会TLE</strong>（不知道是不是我的问题？）</li>
</ol>
<p>另外，此题很像树形dp，应该也可但我不会，如有大佬用树形dp写的希望能分享一波？</p>
<p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1ll</span>&lt;&lt;<span class="hljs-number">60</span>;<br><br>ll fa[<span class="hljs-number">100015</span>],t,n,x;<br>vector&lt;ll&gt; wdnmd[<span class="hljs-number">100015</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>	cin&gt;&gt;t;<br>	<span class="hljs-keyword">while</span>(t--)&#123;<br>		cin&gt;&gt;n;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) wdnmd[i].<span class="hljs-built_in">clear</span>();<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>			cin&gt;&gt;fa[i];<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			cin&gt;&gt;x;<br>			wdnmd[fa[i]].<span class="hljs-built_in">push_back</span>(x); <span class="hljs-comment">//存儿子节点</span><br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-keyword">if</span>(!wdnmd[i].<span class="hljs-built_in">empty</span>()) <span class="hljs-built_in">sort</span>(wdnmd[i].<span class="hljs-built_in">begin</span>(),wdnmd[i].<span class="hljs-built_in">end</span>());<br>		&#125; <span class="hljs-comment">//排序用于贪心</span><br>		ll ansmin=<span class="hljs-number">0</span>,ansmax=<span class="hljs-number">0</span>;<br>		ll minh=<span class="hljs-number">0</span>,maxh=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>			ll Size=wdnmd[i].<span class="hljs-built_in">size</span>();<br>			<span class="hljs-keyword">if</span>(Size!=<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">// 更新答案</span><br>				<span class="hljs-keyword">if</span>(wdnmd[i][<span class="hljs-number">0</span>]&lt;<span class="hljs-number">0</span>) ansmin+=wdnmd[i][<span class="hljs-number">0</span>];<br>				<span class="hljs-keyword">if</span>(wdnmd[i][Size<span class="hljs-number">-1</span>]&gt;<span class="hljs-number">0</span>) ansmax+=wdnmd[i][Size<span class="hljs-number">-1</span>];<br>				<span class="hljs-keyword">if</span>(wdnmd[i].<span class="hljs-built_in">size</span>()&gt;=<span class="hljs-number">2</span>)&#123;<span class="hljs-comment">// 更新次大次小</span><br>					minh=<span class="hljs-built_in">min</span>(minh,wdnmd[i][<span class="hljs-number">1</span>]);<br>					maxh=<span class="hljs-built_in">max</span>(maxh,wdnmd[i][Size<span class="hljs-number">-2</span>]);<br>				&#125;<br>			&#125;<br>		&#125;<br>		cout&lt;&lt;ansmax+maxh&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;ansmin+minh&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="K-代码派对"><a href="#K-代码派对" class="headerlink" title="K. 代码派对"></a>K. 代码派对</h4><p>题意：</p>
<p>在1000*1000的网格中给出若干矩形，若任意三个矩形重合到至少包含一个格子的区域中则算这三个矩形组成了一个答案，求共有多少个这样的答案</p>
<p>题解：</p>
<p>首先想到<strong>二维前缀和</strong>可以把1000*1000中的所有格子对应的矩形重合次数算出来，然后求一下</p>
<script type="math/tex; mode=display">
\sum{C_{f_{i,j}}^3}</script><p>但是会发现，好多格子都被重复算了，因为矩形和矩形可以重合到含有多个格子的矩形中（而这写都只能算一个答案），因此需要减掉这部分多出的答案</p>
<p>采用<strong>容斥原理</strong>，存前缀和的时候把到<code>i,j</code>,<code>i-1,j</code>,<code>i,j-1</code>,<code>i-1,j-1</code>的和都存一遍，然后像求二维前缀和一样容斥一下答案，即</p>
<script type="math/tex; mode=display">
Ans=ans_{i,j}-ans_{i-1,j}-ans_{i,j-1}+ans_{i-1,j-1}</script><p>这样就能把答案缩到一个小正方形中了</p>
<p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br>ll a[<span class="hljs-number">1005</span>][<span class="hljs-number">1005</span>],b[<span class="hljs-number">1005</span>][<span class="hljs-number">1005</span>],c[<span class="hljs-number">1005</span>][<span class="hljs-number">1005</span>],d[<span class="hljs-number">1005</span>][<span class="hljs-number">1005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> t;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<br>	<span class="hljs-keyword">while</span>(t--)&#123;<br>		ll n,x1,y1,x2,y2;<br>		<span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a));<br>		<span class="hljs-built_in">memset</span>(b,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(b));<br>		<span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(c));<br>		<span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(d));<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;n);<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld%lld&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);<br>			a[x1][y1]++,a[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>]++,a[x2+<span class="hljs-number">1</span>][y1]--,a[x1][y2+<span class="hljs-number">1</span>]--;<br>			b[x1][y1]++,b[x2+<span class="hljs-number">1</span>][y2]++,b[x2+<span class="hljs-number">1</span>][y1]--,b[x1][y2]--;<br>			c[x1][y1]++,c[x2][y2+<span class="hljs-number">1</span>]++,c[x2][y1]--,c[x1][y2+<span class="hljs-number">1</span>]--;<br>			d[x1][y1]++,d[x2][y2]++,d[x2][y1]--,d[x1][y2]--;<br>		&#125;<br>		ll ans1=<span class="hljs-number">0</span>,ans2=<span class="hljs-number">0</span>,ans3=<span class="hljs-number">0</span>,ans4=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">1000</span>;i++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">1000</span>;j++)&#123;<br>				a[i][j]+=a[i][j<span class="hljs-number">-1</span>]+a[i<span class="hljs-number">-1</span>][j]-a[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>				<span class="hljs-keyword">if</span>(a[i][j]&gt;=<span class="hljs-number">3</span>)&#123;<br>					ans1+=a[i][j]*(a[i][j]<span class="hljs-number">-1</span>)*(a[i][j]<span class="hljs-number">-2</span>)/<span class="hljs-number">6</span>;<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">1000</span>;i++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">1000</span>;j++)&#123;<br>				b[i][j]+=b[i][j<span class="hljs-number">-1</span>]+b[i<span class="hljs-number">-1</span>][j]-b[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>				<span class="hljs-keyword">if</span>(b[i][j]&gt;=<span class="hljs-number">3</span>)&#123;<br>					ans2+=b[i][j]*(b[i][j]<span class="hljs-number">-1</span>)*(b[i][j]<span class="hljs-number">-2</span>)/<span class="hljs-number">6</span>;<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">1000</span>;i++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">1000</span>;j++)&#123;<br>				c[i][j]+=c[i][j<span class="hljs-number">-1</span>]+c[i<span class="hljs-number">-1</span>][j]-c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>				<span class="hljs-keyword">if</span>(a[i][j]&gt;=<span class="hljs-number">3</span>)&#123;<br>					ans3+=c[i][j]*(c[i][j]<span class="hljs-number">-1</span>)*(c[i][j]<span class="hljs-number">-2</span>)/<span class="hljs-number">6</span>;<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">1000</span>;i++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">1000</span>;j++)&#123;<br>				d[i][j]+=d[i][j<span class="hljs-number">-1</span>]+d[i<span class="hljs-number">-1</span>][j]-d[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>				<span class="hljs-keyword">if</span>(d[i][j]&gt;=<span class="hljs-number">3</span>)&#123;<br>					ans4+=d[i][j]*(d[i][j]<span class="hljs-number">-1</span>)*(d[i][j]<span class="hljs-number">-2</span>)/<span class="hljs-number">6</span>;<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans1-ans2-ans3+ans4);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>题解-2020USST算法竞赛练习场5 ABC</title>
    <url>/2020/03/01/%E9%A2%98%E8%A7%A3-2020USST%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E7%BB%83%E4%B9%A0%E5%9C%BA5-ABC/</url>
    <content><![CDATA[<h2 id="题解系列"><a href="#题解系列" class="headerlink" title="题解系列"></a><center>题解系列</center></h2><span id="more"></span>
<ul>
<li>自己写的题解</li>
</ul>
<h2 id="2020年上海理工大学算法竞赛训练场5-A-C"><a href="#2020年上海理工大学算法竞赛训练场5-A-C" class="headerlink" title="2020年上海理工大学算法竞赛训练场5 A~C"></a>2020年上海理工大学算法竞赛训练场5 A~C</h2><h4 id="A-Ones"><a href="#A-Ones" class="headerlink" title="A. Ones"></a>A. <a href="https://vjudge.net/problem/Kattis-ones">Ones</a></h4><p>题意：给定一个不能被2和5整除的数n，求出它的一个 全由1组成的 最小倍数的位数</p>
<p>算法：暴力枚举</p>
<p>从1、11、111…这样枚举下去，但是这样下去会爆(long long)，因此考虑模运算的性质，如果没找到答案则只要用(上一次的答案%n)*10+1即可</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> n;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;<br>		<span class="hljs-type">int</span> giao=<span class="hljs-number">1</span>;<br>		<span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">while</span>(giao%=n)&#123;<br>			giao=giao*<span class="hljs-number">10</span>+<span class="hljs-number">1</span>;<br>			ans++;<br>		&#125;<br>		cout&lt;&lt;ans&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="B-Robotopia"><a href="#B-Robotopia" class="headerlink" title="B. Robotopia"></a>B. <a href="https://vjudge.net/problem/Kattis-robotopia">Robotopia</a></h4><p>题意：分别给出拼成一个A机器人和一个B机器人所需要的 手零件个数（l1、a1） 和 腿零件个数（l2、a2），再给出当前你所拥有的全部的 手零件个数（lt） 和 腿零件个数（at），问恰好用完这些零件能拼成几个A机器人和几个B机器人？如果不能拼成或者有多种方案，则输出”？”</p>
<p>算法：枚举</p>
<p>数据范围很小，真的只是枚举即可，一定要注意判断条件 以及 不要搞错边界</p>
<p>详细题解：</p>
<p>我们很容易可以想到，这就是解一个如下的方程组的<strong>正整数解</strong>（注意，题目要求输出正整数解（positive integers））：</p>
<script type="math/tex; mode=display">
l_1*x+l_2*y=lt\\
a_1*x+a_2*y=at</script><p>那么我们可以从1开始（0被pass掉）枚举x，遇到边界就停止，判断是否同时有</p>
<script type="math/tex; mode=display">
l_t-x*l_1能被l_2整除\\
a_t-x*a_1能被a_2整除\\
且 这两个整除的商相等</script><p>记录有效答案及其次数，如果枚举完之后有且仅有一种有效答案，则输出该答案，否则输出”?”</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span>  t;<br>	cin&gt;&gt;t;<br>	<span class="hljs-keyword">while</span>(t--)&#123;<br>		<span class="hljs-type">int</span> l1,a1,l2,a2,lt,at;<br>		cin&gt;&gt;l1&gt;&gt;a1&gt;&gt;l2&gt;&gt;a2&gt;&gt;lt&gt;&gt;at;<br>		<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>,ansx=<span class="hljs-number">0</span>,ansy=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i*l1&lt;lt&amp;&amp;i*a1&lt;at;i++)&#123;<br>			<span class="hljs-type">int</span> giaol=lt-i*l1;<br>			<span class="hljs-type">int</span> giaoa=at-i*a1;<br>			<span class="hljs-keyword">if</span>(giaol%l2==<span class="hljs-number">0</span>&amp;&amp;giaoa%a2==<span class="hljs-number">0</span>&amp;&amp;giaol/l2==giaoa/a2)&#123;<br>				ansx=i;<br>				ansy=giaol/l2;<br>				cnt++;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">1</span>)&#123;<br>			cout&lt;&lt;ansx&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;ansy&lt;&lt;endl;<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>			cout&lt;&lt;<span class="hljs-string">&quot;?&quot;</span>&lt;&lt;endl;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="C-What-does-the-fox-say"><a href="#C-What-does-the-fox-say" class="headerlink" title="C. What does the fox say?"></a>C. <a href="https://vjudge.net/problem/Kattis-whatdoesthefoxsay">What does the fox say?</a></h4><p>题意：给出t组测试数据，每组的第1行是需要判断的叫声字符串（每个叫声由空格隔开），接下来若干行以“xx goes xx”的形式呈现出“某动物 发出 某叫声”，最后以“what does the fox say?”结束，要求从第1行的叫声字符串中找出下面若干行没有出现过的叫声</p>
<p>算法：先用vector把需要判断的叫声存入，然后再用set标记每个出现了的叫声，最后一个个判断有没有出现即可，需要注意一下字符串处理</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> t;cin&gt;&gt;t;<span class="hljs-built_in">getchar</span>();<br>	<span class="hljs-keyword">while</span>(t--)&#123;<br>		vector&lt;string&gt; vec;<br>		set&lt;string&gt; se;<br>		string temp;<br>		<span class="hljs-keyword">while</span>(cin&gt;&gt;temp)&#123;<br>			<span class="hljs-keyword">if</span>(temp==<span class="hljs-string">&quot;goes&quot;</span>)&#123; <span class="hljs-comment">//如果出现了goes说明出现了第二行输入</span><br>				cin&gt;&gt;temp; <span class="hljs-comment">//goes后面肯定还有一个输入，这是出现的第一个叫声</span><br>				se.<span class="hljs-built_in">insert</span>(temp);<span class="hljs-comment">//存进set</span><br>				vec.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">//goes之前有个无用的字符串，删掉它</span><br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>			vec.<span class="hljs-built_in">push_back</span>(temp);<br>		&#125;<br>		string giao,giaogiao;<br>		<span class="hljs-keyword">while</span>(cin&gt;&gt;giao&gt;&gt;temp&gt;&gt;giaogiao)&#123;<span class="hljs-comment">//xx goes xx</span><br>			<span class="hljs-keyword">if</span>(temp!=<span class="hljs-string">&quot;goes&quot;</span>)&#123;<br>				cin&gt;&gt;temp&gt;&gt;giao; <span class="hljs-comment">//因为最后一次输入没用，但它有五个字符串，所以我都吃掉，然后break</span><br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>			se.<span class="hljs-built_in">insert</span>(giaogiao); <span class="hljs-comment">//存入set</span><br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;vec.<span class="hljs-built_in">size</span>();i++)&#123;<br>			<span class="hljs-keyword">if</span>(se.<span class="hljs-built_in">find</span>(vec[i])==se.<span class="hljs-built_in">end</span>())&#123;<br>				cout&lt;&lt;vec[i];<br>				<span class="hljs-keyword">if</span>(i==vec.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>) cout&lt;&lt;endl;<br>				<span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>麦克斯韦关系浅析</title>
    <url>/2020/01/16/%E9%BA%A6%E5%85%8B%E6%96%AF%E9%9F%A6%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h2 id="有关麦克斯韦关系的推导"><a href="#有关麦克斯韦关系的推导" class="headerlink" title="有关麦克斯韦关系的推导"></a><center>有关麦克斯韦关系的推导</center></h2><span id="more"></span>
<ul>
<li>搞热统，搞到最基础的麦克斯韦关系（Maxwell relationship），搜了一些资料，学习了一下推导过程。</li>
</ul>
<h2 id="麦克斯韦关系"><a href="#麦克斯韦关系" class="headerlink" title="麦克斯韦关系"></a>麦克斯韦关系</h2><h3 id="热力学基本方程式"><a href="#热力学基本方程式" class="headerlink" title="热力学基本方程式"></a>热力学基本方程式</h3><script type="math/tex; mode=display">
dU=TdS-pdV</script><script type="math/tex; mode=display">
dH=TdS+Vdp</script><script type="math/tex; mode=display">
dA=-SdT-pdV</script><script type="math/tex; mode=display">
dG=-SdT+Vdp</script><h3 id="全微分的关系"><a href="#全微分的关系" class="headerlink" title="全微分的关系"></a>全微分的关系</h3><script type="math/tex; mode=display">
df=a(x,y)dx+b(x,y)dy</script><script type="math/tex; mode=display">
df = \frac{\partial f}{\partial x}dx+\frac{\partial f}{\partial y}dy</script><ul>
<li>可以发现热力学基本方程式就是每个热力学势的全微分，因此，根据 <strong>二阶混合偏导数连续</strong> 的概念，对热力学基本方程式做一系列操作，就可以得到麦克斯韦关系了，具体操作如下：<br>例如：对于$dU=TdS-pdV$，对照全微分关系，再依据二阶连续偏导数相等的性质，得出：<script type="math/tex; mode=display">
\left(\frac{\partial T}{\partial V}\right)_S = -\left(\frac{\partial p}{\partial S}\right)_V</script>同理，可以得出如下关系式：<script type="math/tex; mode=display">
\left( \dfrac {\partial T}{\partial p}\right) _{S}=\left( \dfrac {\partial V}{\partial S}\right) _{p}</script><script type="math/tex; mode=display">
\left( \dfrac {\partial S}{\partial V}\right) _{T}=\left( \dfrac {\partial p}{\partial T}\right) _{V}</script><script type="math/tex; mode=display">
\left( \dfrac {\partial S}{\partial p}\right) _{T}=-\left( \dfrac {\partial V}{\partial T}\right) _{p}</script></li>
</ul>
<hr>
<h2 id="一些特殊恒等式"><a href="#一些特殊恒等式" class="headerlink" title="一些特殊恒等式"></a>一些特殊恒等式</h2><ul>
<li>比定容热容：<script type="math/tex; mode=display">
\left( \dfrac {\partial U}{\partial T}\right) _{V}=C _{V}</script></li>
<li>比定压热容：<script type="math/tex; mode=display">
\left( \dfrac {\partial H}{\partial T}\right) _{p}=C_{p}</script></li>
</ul>
<hr>
<center>剩下的就是一顿代换的事情了</center>]]></content>
      <categories>
        <category>物理</category>
      </categories>
      <tags>
        <tag>热力学</tag>
      </tags>
  </entry>
</search>
